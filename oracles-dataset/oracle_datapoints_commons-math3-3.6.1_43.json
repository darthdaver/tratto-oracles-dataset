[
    {
        "id": 15352,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "commons-math3-3.6.1",
        "packageName": "org.apache.commons.math3.complex",
        "className": "Complex",
        "javadocTag": "@param subtrahend value to be subtracted from this {@code Complex}.",
        "methodJavadoc": "    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this - subtrahend)}.\n     *\n     * @param  subtrahend value to be subtracted from this {@code Complex}.\n     * @return {@code this - subtrahend}.\n     * @see #subtract(Complex)\n     */",
        "methodSourceCode": "public Complex subtract(double subtrahend){\n    if (isNaN || Double.isNaN(subtrahend)) {\n        return NaN;\n    }\n    return createComplex(real - subtrahend, imaginary);\n}",
        "classJavadoc": "/**\n * Representation of a Complex number, i.e. a number which has both a\n * real and imaginary part.\n * <p>\n * Implementations of arithmetic operations handle {@code NaN} and\n * infinite values according to the rules for {@link java.lang.Double}, i.e.\n * {@link #equals} is an equivalence relation for all instances that have\n * a {@code NaN} in either real or imaginary part, e.g. the following are\n * considered equal:\n * <ul>\n *  <li>{@code 1 + NaNi}</li>\n *  <li>{@code NaN + i}</li>\n *  <li>{@code NaN + NaNi}</li>\n * </ul><p>\n * Note that this contradicts the IEEE-754 standard for floating\n * point numbers (according to which the test {@code x == x} must fail if\n * {@code x} is {@code NaN}). The method\n * {@link org.apache.commons.math3.util.Precision#equals(double,double,int)\n * equals for primitive double} in {@link org.apache.commons.math3.util.Precision}\n * conforms with IEEE-754 while this class conforms with the standard behavior\n * for Java object types.</p>\n *\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.complex;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.FieldElement;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.Precision;\n\n/**\n * Representation of a Complex number, i.e. a number which has both a\n * real and imaginary part.\n * <p>\n * Implementations of arithmetic operations handle {@code NaN} and\n * infinite values according to the rules for {@link java.lang.Double}, i.e.\n * {@link #equals} is an equivalence relation for all instances that have\n * a {@code NaN} in either real or imaginary part, e.g. the following are\n * considered equal:\n * <ul>\n *  <li>{@code 1 + NaNi}</li>\n *  <li>{@code NaN + i}</li>\n *  <li>{@code NaN + NaNi}</li>\n * </ul><p>\n * Note that this contradicts the IEEE-754 standard for floating\n * point numbers (according to which the test {@code x == x} must fail if\n * {@code x} is {@code NaN}). The method\n * {@link org.apache.commons.math3.util.Precision#equals(double,double,int)\n * equals for primitive double} in {@link org.apache.commons.math3.util.Precision}\n * conforms with IEEE-754 while this class conforms with the standard behavior\n * for Java object types.</p>\n *\n */\npublic class Complex implements FieldElement<Complex>, Serializable  {\n    /** The square root of -1. A number representing \"0.0 + 1.0i\" */\n    public static final Complex I = new Complex(0.0, 1.0);\n    // CHECKSTYLE: stop ConstantName\n    /** A complex number representing \"NaN + NaNi\" */\n    public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n    // CHECKSTYLE: resume ConstantName\n    /** A complex number representing \"+INF + INFi\" */\n    public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    /** A complex number representing \"1.0 + 0.0i\" */\n    public static final Complex ONE = new Complex(1.0, 0.0);\n    /** A complex number representing \"0.0 + 0.0i\" */\n    public static final Complex ZERO = new Complex(0.0, 0.0);\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6195664516687396620L;\n\n    /** The imaginary part. */\n    private final double imaginary;\n    /** The real part. */\n    private final double real;\n    /** Record whether this complex number is equal to NaN. */\n    private final transient boolean isNaN;\n    /** Record whether this complex number is infinite. */\n    private final transient boolean isInfinite;\n\n    /**\n     * Create a complex number given only the real part.\n     *\n     * @param real Real part.\n     */\n    public Complex(double real) {\n        this(real, 0.0);\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param real Real part.\n     * @param imaginary Imaginary part.\n     */\n    public Complex(double real, double imaginary) {\n        this.real = real;\n        this.imaginary = imaginary;\n\n        isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n        isInfinite = !isNaN &&\n            (Double.isInfinite(real) || Double.isInfinite(imaginary));\n    }\n\n    /**\n     * Return the absolute value of this complex number.\n     * Returns {@code NaN} if either real or imaginary part is {@code NaN}\n     * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},\n     * but at least one part is infinite.\n     *\n     * @return the absolute value.\n     */\n    public double abs() {\n        if (isNaN) {\n            return Double.NaN;\n        }\n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return FastMath.abs(real);\n            }\n            double q = real / imaginary;\n            return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n        } else {\n            if (real == 0.0) {\n                return FastMath.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n        }\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this + addend)}.\n     * Uses the definitional formula\n     * <p>\n     *   {@code (a + bi) + (c + di) = (a+c) + (b+d)i}\n     * </p>\n     * If either {@code this} or {@code addend} has a {@code NaN} value in\n     * either part, {@link #NaN} is returned; otherwise {@code Infinite}\n     * and {@code NaN} values are returned in the parts of the result\n     * according to the rules for {@link java.lang.Double} arithmetic.\n     *\n     * @param  addend Value to be added to this {@code Complex}.\n     * @return {@code this + addend}.\n     * @throws NullArgumentException if {@code addend} is {@code null}.\n     */\n    public Complex add(Complex addend) throws NullArgumentException {\n        MathUtils.checkNotNull(addend);\n        if (isNaN || addend.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real + addend.getReal(),\n                             imaginary + addend.getImaginary());\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code (this + addend)},\n     * with {@code addend} interpreted as a real number.\n     *\n     * @param addend Value to be added to this {@code Complex}.\n     * @return {@code this + addend}.\n     * @see #add(Complex)\n     */\n    public Complex add(double addend) {\n        if (isNaN || Double.isNaN(addend)) {\n            return NaN;\n        }\n\n        return createComplex(real + addend, imaginary);\n    }\n\n     /**\n     * Returns the conjugate of this complex number.\n     * The conjugate of {@code a + bi} is {@code a - bi}.\n     * <p>\n     * {@link #NaN} is returned if either the real or imaginary\n     * part of this Complex number equals {@code Double.NaN}.\n     * </p><p>\n     * If the imaginary part is infinite, and the real part is not\n     * {@code NaN}, the returned value has infinite imaginary part\n     * of the opposite sign, e.g. the conjugate of\n     * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.\n     * </p>\n     * @return the conjugate of this Complex object.\n     */\n    public Complex conjugate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real, -imaginary);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this / divisor)}.\n     * Implements the definitional formula\n     * <pre>\n     *  <code>\n     *    a + bi          ac + bd + (bc - ad)i\n     *    ----------- = -------------------------\n     *    c + di         c<sup>2</sup> + d<sup>2</sup>\n     *  </code>\n     * </pre>\n     * but uses\n     * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n     * prescaling of operands</a> to limit the effects of overflows and\n     * underflows in the computation.\n     * <p>\n     * {@code Infinite} and {@code NaN} values are handled according to the\n     * following rules, applied in the order presented:\n     * <ul>\n     *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n     *   in either part, {@link #NaN} is returned.\n     *  </li>\n     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n     *  </li>\n     *  <li>If {@code this} and {@code divisor} are both infinite,\n     *   {@link #NaN} is returned.\n     *  </li>\n     *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\n     *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\n     *   infinite), {@link #ZERO} is returned.\n     *  </li>\n     *  <li>If {@code this} is infinite and {@code divisor} is finite,\n     *   {@code NaN} values are returned in the parts of the result if the\n     *   {@link java.lang.Double} rules applied to the definitional formula\n     *   force {@code NaN} results.\n     *  </li>\n     * </ul>\n     *\n     * @param divisor Value by which this {@code Complex} is to be divided.\n     * @return {@code this / divisor}.\n     * @throws NullArgumentException if {@code divisor} is {@code null}.\n     */\n    public Complex divide(Complex divisor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(divisor);\n        if (isNaN || divisor.isNaN) {\n            return NaN;\n        }\n\n        final double c = divisor.getReal();\n        final double d = divisor.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n\n        if (divisor.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(c) < FastMath.abs(d)) {\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code (this / divisor)},\n     * with {@code divisor} interpreted as a real number.\n     *\n     * @param  divisor Value by which this {@code Complex} is to be divided.\n     * @return {@code this / divisor}.\n     * @see #divide(Complex)\n     */\n    public Complex divide(double divisor) {\n        if (isNaN || Double.isNaN(divisor)) {\n            return NaN;\n        }\n        if (divisor == 0d) {\n            return NaN;\n        }\n        if (Double.isInfinite(divisor)) {\n            return !isInfinite() ? ZERO : NaN;\n        }\n        return createComplex(real / divisor,\n                             imaginary  / divisor);\n    }\n\n    /** {@inheritDoc} */\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return INF;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }\n\n    /**\n     * Test for equality with another object.\n     * If both the real and imaginary parts of two complex numbers\n     * are exactly the same, and neither is {@code Double.NaN}, the two\n     * Complex objects are considered to be equal.\n     * The behavior is the same as for JDK's {@link Double#equals(Object)\n     * Double}:\n     * <ul>\n     *  <li>All {@code NaN} values are considered to be equal,\n     *   i.e, if either (or both) real and imaginary parts of the complex\n     *   number are equal to {@code Double.NaN}, the complex number is equal\n     *   to {@code NaN}.\n     *  </li>\n     *  <li>\n     *   Instances constructed with different representations of zero (i.e.\n     *   either \"0\" or \"-0\") are <em>not</em> considered to be equal.\n     *  </li>\n     * </ul>\n     *\n     * @param other Object to test for equality with this instance.\n     * @return {@code true} if the objects are equal, {@code false} if object\n     * is {@code null}, not an instance of {@code Complex}, or not equal to\n     * this instance.\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex c = (Complex) other;\n            if (c.isNaN) {\n                return isNaN;\n            } else {\n                return MathUtils.equals(real, c.real) &&\n                    MathUtils.equals(imaginary, c.imaginary);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Test for the floating-point equality between Complex objects.\n     * It returns {@code true} if both arguments are equal or within the\n     * range of allowed error (inclusive).\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between the real (resp. imaginary) parts of {@code x} and\n     * {@code y}.\n     * @return {@code true} if there are fewer than {@code maxUlps} floating\n     * point values between the real (resp. imaginary) parts of {@code x}\n     * and {@code y}.\n     *\n     * @see Precision#equals(double,double,int)\n     * @since 3.3\n     */\n    public static boolean equals(Complex x, Complex y, int maxUlps) {\n        return Precision.equals(x.real, y.real, maxUlps) &&\n            Precision.equals(x.imaginary, y.imaginary, maxUlps);\n    }\n\n    /**\n     * Returns {@code true} iff the values are equal as defined by\n     * {@link #equals(Complex,Complex,int) equals(x, y, 1)}.\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @return {@code true} if the values are equal.\n     *\n     * @since 3.3\n     */\n    public static boolean equals(Complex x, Complex y) {\n        return equals(x, y, 1);\n    }\n\n    /**\n     * Returns {@code true} if, both for the real part and for the imaginary\n     * part, there is no double value strictly between the arguments or the\n     * difference between them is within the range of allowed error\n     * (inclusive).  Returns {@code false} if either of the arguments is NaN.\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @param eps Amount of allowed absolute error.\n     * @return {@code true} if the values are two adjacent floating point\n     * numbers or they are within range of each other.\n     *\n     * @see Precision#equals(double,double,double)\n     * @since 3.3\n     */\n    public static boolean equals(Complex x, Complex y, double eps) {\n        return Precision.equals(x.real, y.real, eps) &&\n            Precision.equals(x.imaginary, y.imaginary, eps);\n    }\n\n    /**\n     * Returns {@code true} if, both for the real part and for the imaginary\n     * part, there is no double value strictly between the arguments or the\n     * relative difference between them is smaller or equal to the given\n     * tolerance. Returns {@code false} if either of the arguments is NaN.\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @param eps Amount of allowed relative error.\n     * @return {@code true} if the values are two adjacent floating point\n     * numbers or they are within range of each other.\n     *\n     * @see Precision#equalsWithRelativeTolerance(double,double,double)\n     * @since 3.3\n     */\n    public static boolean equalsWithRelativeTolerance(Complex x, Complex y,\n                                                      double eps) {\n        return Precision.equalsWithRelativeTolerance(x.real, y.real, eps) &&\n            Precision.equalsWithRelativeTolerance(x.imaginary, y.imaginary, eps);\n    }\n\n    /**\n     * Get a hashCode for the complex number.\n     * Any {@code Double.NaN} value in real or imaginary part produces\n     * the same hash code {@code 7}.\n     *\n     * @return a hash code value for this object.\n     */\n    @Override\n    public int hashCode() {\n        if (isNaN) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) +\n            MathUtils.hash(real));\n    }\n\n    /**\n     * Access the imaginary part.\n     *\n     * @return the imaginary part.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Access the real part.\n     *\n     * @return the real part.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Checks whether either or both parts of this complex number is\n     * {@code NaN}.\n     *\n     * @return true if either or both parts of this complex number is\n     * {@code NaN}; false otherwise.\n     */\n    public boolean isNaN() {\n        return isNaN;\n    }\n\n    /**\n     * Checks whether either the real or imaginary part of this complex number\n     * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or\n     * {@code Double.NEGATIVE_INFINITY}) and neither part\n     * is {@code NaN}.\n     *\n     * @return true if one or both parts of this complex number are infinite\n     * and neither part is {@code NaN}.\n     */\n    public boolean isInfinite() {\n        return isInfinite;\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <p>\n     *   {@code (a + bi)(c + di) = (ac - bd) + (ad + bc)i}\n     * </p>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <p>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * </p><p>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.</p>\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN || factor.isNaN) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n     * interpreted as a integer number.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @see #multiply(Complex)\n     */\n    public Complex multiply(final int factor) {\n        if (isNaN) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary)) {\n            return INF;\n        }\n        return createComplex(real * factor, imaginary * factor);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n     * interpreted as a real number.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @see #multiply(Complex)\n     */\n    public Complex multiply(double factor) {\n        if (isNaN || Double.isNaN(factor)) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor, imaginary * factor);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code (-this)}.\n     * Returns {@code NaN} if either real or imaginary\n     * part of this Complex number is {@code Double.NaN}.\n     *\n     * @return {@code -this}.\n     */\n    public Complex negate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(-real, -imaginary);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this - subtrahend)}.\n     * Uses the definitional formula\n     * <p>\n     *  {@code (a + bi) - (c + di) = (a-c) + (b-d)i}\n     * </p>\n     * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,\n     * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.\n     *\n     * @param  subtrahend value to be subtracted from this {@code Complex}.\n     * @return {@code this - subtrahend}.\n     * @throws NullArgumentException if {@code subtrahend} is {@code null}.\n     */\n    public Complex subtract(Complex subtrahend)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(subtrahend);\n        if (isNaN || subtrahend.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real - subtrahend.getReal(),\n                             imaginary - subtrahend.getImaginary());\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this - subtrahend)}.\n     *\n     * @param  subtrahend value to be subtracted from this {@code Complex}.\n     * @return {@code this - subtrahend}.\n     * @see #subtract(Complex)\n     */\n    public Complex subtract(double subtrahend) {\n        if (isNaN || Double.isNaN(subtrahend)) {\n            return NaN;\n        }\n        return createComplex(real - subtrahend, imaginary);\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n     * inverse cosine</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     *  {@code acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))}\n     * </p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite.\n     *\n     * @return the inverse cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex acos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n     * inverse sine</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     *  {@code asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))}\n     * </p><p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite.</p>\n     *\n     * @return the inverse sine of this complex number.\n     * @since 1.2\n     */\n    public Complex asin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n     * inverse tangent</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     * {@code atan(z) = (i/2) log((i + z)/(i - z))}\n     * </p><p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite.</p>\n     *\n     * @return the inverse tangent of this complex number\n     * @since 1.2\n     */\n    public Complex atan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(I).divide(I.subtract(this)).log()\n                .multiply(I.divide(createComplex(2.0, 0.0)));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n     * cosine</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     *  {@code cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i}\n     * </p><p>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * </p><p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p><p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.</p>\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   cos(1 &plusmn; INFINITY i) = 1 \\u2213 INFINITY i\n     *   cos(&plusmn;INFINITY + i) = NaN + NaN i\n     *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex cos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cos(real) * FastMath.cosh(imaginary),\n                             -FastMath.sin(real) * FastMath.sinh(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n     * hyperbolic cosine</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n     *   cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n     *   cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the hyperbolic cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex cosh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cosh(real) * FastMath.cos(imaginary),\n                             FastMath.sinh(real) * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n     * exponential function</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#exp}, {@link FastMath#cos}, and\n     * {@link FastMath#sin}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   exp(1 &plusmn; INFINITY i) = NaN + NaN i\n     *   exp(INFINITY + i) = INFINITY + INFINITY i\n     *   exp(-INFINITY + i) = 0 + 0i\n     *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return <code><i>e</i><sup>this</sup></code>.\n     * @since 1.2\n     */\n    public Complex exp() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double expReal = FastMath.exp(real);\n        return createComplex(expReal *  FastMath.cos(imaginary),\n                             expReal * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n     * natural logarithm</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i\n     *  </code>\n     * </pre>\n     * where ln on the right hand side is {@link FastMath#log},\n     * {@code |a + bi|} is the modulus, {@link Complex#abs},  and\n     * {@code arg(a + bi) = }{@link FastMath#atan2}(b, a).\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n     *   log(INFINITY + i) = INFINITY + 0i\n     *   log(-INFINITY + i) = INFINITY + &pi;i\n     *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n     *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n     *   log(0 + 0i) = -INFINITY + 0i\n     *  </code>\n     * </pre>\n     *\n     * @return the value <code>ln &nbsp; this</code>, the natural logarithm\n     * of {@code this}.\n     * @since 1.2\n     */\n    public Complex log() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.log(abs()),\n                             FastMath.atan2(imaginary, real));\n    }\n\n    /**\n     * Returns of value of this complex number raised to the power of {@code x}.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   y<sup>x</sup> = exp(x&middot;log(y))\n     *  </code>\n     * </pre>\n     * where {@code exp} and {@code log} are {@link #exp} and\n     * {@link #log}, respectively.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite, or if {@code y}\n     * equals {@link Complex#ZERO}.</p>\n     *\n     * @param  x exponent to which this {@code Complex} is to be raised.\n     * @return <code> this<sup>x</sup></code>.\n     * @throws NullArgumentException if x is {@code null}.\n     * @since 1.2\n     */\n    public Complex pow(Complex x)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(x);\n        return this.log().multiply(x).exp();\n    }\n\n    /**\n     * Returns of value of this complex number raised to the power of {@code x}.\n     *\n     * @param  x exponent to which this {@code Complex} is to be raised.\n     * @return <code>this<sup>x</sup></code>.\n     * @see #pow(Complex)\n     */\n     public Complex pow(double x) {\n        return this.log().multiply(x).exp();\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n     * sine</a>\n     * of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p><p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or {@code NaN} values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n     *   sin(&plusmn;INFINITY + i) = NaN + NaN i\n     *   sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the sine of this complex number.\n     * @since 1.2\n     */\n    public Complex sin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sin(real) * FastMath.cosh(imaginary),\n                             FastMath.cos(real) * FastMath.sinh(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n     * hyperbolic sine</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p><p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n     *   sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n     *   sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the hyperbolic sine of {@code this}.\n     * @since 1.2\n     */\n    public Complex sinh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary),\n            FastMath.cosh(real) * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of this complex number.\n     * Implements the following algorithm to compute {@code sqrt(a + bi)}:\n     * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>\n     * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}\n     *  else return {@code |b|/2t + sign(b)t i }</pre></li>\n     * </ol>\n     * where <ul>\n     * <li>{@code |a| = }{@link FastMath#abs}(a)</li>\n     * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>\n     * <li>{@code sign(b) =  }{@link FastMath#copySign(double,double) copySign(1d, b)}\n     * </ul>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n     *   sqrt(INFINITY + i) = INFINITY + 0i\n     *   sqrt(-INFINITY + i) = 0 + INFINITY i\n     *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n     *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n     *  </code>\n     * </pre>\n     *\n     * @return the square root of {@code this}.\n     * @since 1.2\n     */\n    public Complex sqrt() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n\n        double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n                                 FastMath.copySign(1d, imaginary) * t);\n        }\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of <code>1 - this<sup>2</sup></code> for this complex\n     * number.\n     * Computes the result directly as\n     * {@code sqrt(ONE.subtract(z.multiply(z)))}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     *\n     * @return the square root of <code>1 - this<sup>2</sup></code>.\n     * @since 1.2\n     */\n    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n     * tangent</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n     * {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\n     *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\n     *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the tangent of {@code this}.\n     * @since 1.2\n     */\n    public Complex tan() {\n        if (isNaN || Double.isInfinite(real)) {\n            return NaN;\n        }\n        if (imaginary > 20.0) {\n            return createComplex(0.0, 1.0);\n        }\n        if (imaginary < -20.0) {\n            return createComplex(0.0, -1.0);\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n\n        return createComplex(FastMath.sin(real2) / d,\n                             FastMath.sinh(imaginary2) / d);\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n     * hyperbolic tangent</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n     * {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\n     *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\n     *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i\n     *  </code>\n     * </pre>\n     *\n     * @return the hyperbolic tangent of {@code this}.\n     * @since 1.2\n     */\n    public Complex tanh() {\n        if (isNaN || Double.isInfinite(imaginary)) {\n            return NaN;\n        }\n        if (real > 20.0) {\n            return createComplex(1.0, 0.0);\n        }\n        if (real < -20.0) {\n            return createComplex(-1.0, 0.0);\n        }\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n\n        return createComplex(FastMath.sinh(real2) / d,\n                             FastMath.sin(imaginary2) / d);\n    }\n\n\n\n    /**\n     * Compute the argument of this complex number.\n     * The argument is the angle phi between the positive real axis and\n     * the point representing this number in the complex plane.\n     * The value returned is between -PI (not inclusive)\n     * and PI (inclusive), with negative values returned for numbers with\n     * negative imaginary parts.\n     * <p>\n     * If either real or imaginary part (or both) is NaN, NaN is returned.\n     * Infinite parts are handled as {@code Math.atan2} handles them,\n     * essentially treating finite parts as zero in the presence of an\n     * infinite coordinate and returning a multiple of pi/4 depending on\n     * the signs of the infinite parts.\n     * See the javadoc for {@code Math.atan2} for full details.\n     *\n     * @return the argument of {@code this}.\n     */\n    public double getArgument() {\n        return FastMath.atan2(getImaginary(), getReal());\n    }\n\n    /**\n     * Computes the n-th roots of this complex number.\n     * The nth roots are defined by the formula:\n     * <pre>\n     *  <code>\n     *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n     *  </code>\n     * </pre>\n     * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n     * are respectively the {@link #abs() modulus} and\n     * {@link #getArgument() argument} of this complex number.\n     * <p>\n     * If one or both parts of this complex number is NaN, a list with just\n     * one element, {@link #NaN} is returned.\n     * if neither part is NaN, but at least one part is infinite, the result\n     * is a one-element list containing {@link #INF}.\n     *\n     * @param n Degree of root.\n     * @return a List of all {@code n}-th roots of {@code this}.\n     * @throws NotPositiveException if {@code n <= 0}.\n     * @since 2.0\n     */\n    public List<Complex> nthRoot(int n) throws NotPositiveException {\n\n        if (n <= 0) {\n            throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                                           n);\n        }\n\n        final List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN) {\n            result.add(NaN);\n            return result;\n        }\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        // nth root of abs -- faster / more accurate to use a solver here?\n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\n        final double nthPhi = getArgument() / n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n            // inner part\n            final double realPart = nthRootOfAbs *  FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param realPart Real part.\n     * @param imaginaryPart Imaginary part.\n     * @return a new complex number instance.\n     * @since 1.2\n     * @see #valueOf(double, double)\n     */\n    protected Complex createComplex(double realPart,\n                                    double imaginaryPart) {\n        return new Complex(realPart, imaginaryPart);\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param realPart Real part.\n     * @param imaginaryPart Imaginary part.\n     * @return a Complex instance.\n     */\n    public static Complex valueOf(double realPart,\n                                  double imaginaryPart) {\n        if (Double.isNaN(realPart) ||\n            Double.isNaN(imaginaryPart)) {\n            return NaN;\n        }\n        return new Complex(realPart, imaginaryPart);\n    }\n\n    /**\n     * Create a complex number given only the real part.\n     *\n     * @param realPart Real part.\n     * @return a Complex instance.\n     */\n    public static Complex valueOf(double realPart) {\n        if (Double.isNaN(realPart)) {\n            return NaN;\n        }\n        return new Complex(realPart);\n    }\n\n    /**\n     * Resolve the transient fields in a deserialized Complex Object.\n     * Subclasses will need to override {@link #createComplex} to\n     * deserialize properly.\n     *\n     * @return A Complex instance with all fields resolved.\n     * @since 2.0\n     */\n    protected final Object readResolve() {\n        return createComplex(real, imaginary);\n    }\n\n    /** {@inheritDoc} */\n    public ComplexField getField() {\n        return ComplexField.getInstance();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String toString() {\n        return \"(\" + real + \", \" + imaginary + \")\";\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "RealFieldElement",
                "org.apache.commons.math3"
            ],
            [
                "Primes",
                "org.apache.commons.math3.primes"
            ],
            [
                "SmallPrimes",
                "org.apache.commons.math3.primes"
            ],
            [
                "PollardRho",
                "org.apache.commons.math3.primes"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "SimpleCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.fitting"
            ],
            [
                "ParameterValidator",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "EvaluationRmsChecker",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "OptimumImpl",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresAdapter",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "DenseWeightedEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "AbstractEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresFactory",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "ValueAndJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "MultivariateJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresBuilder",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresProblem",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "WeightedObservedPoints",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "AbstractCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "UnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "FunctionUtils",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "IterativeLegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "LegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "MidPointIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "RombergIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "SimpsonIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BaseRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "HermiteRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegratorFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreHighPrecisionRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "SymmetricGaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "BaseAbstractUnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "UnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "TrapezoidIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "AbstractDifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PegasusSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolverUtils",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "FieldBracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonRaphsonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseSecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "SecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "DifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver2",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractPolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseAbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "LaguerreSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "IllinoisSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RegulaFalsiSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AllowedSolution",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RiddersSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BisectionSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedRealFieldUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "Asin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Multiply",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Asinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Rint",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "StepFunction",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Add",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sqrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Inverse",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Gaussian",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Pow",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Exp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cbrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log1p",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Constant",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Identity",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Signum",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logit",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ceil",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Subtract",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Max",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Min",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Expm1",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Abs",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Divide",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ulp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log10",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Power",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Minus",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan2",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logistic",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Floor",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sigmoid",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinc",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "HarmonicOscillator",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "MultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TrivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "MultivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "ParametricUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableMatrixFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DSCompiler",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "SparseGradient",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateMatrixFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "JacobianFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "GradientFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DerivativeStructure",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateVectorFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "FiniteDifferencesDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "PolynomialFunctionNewtonForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunctionLagrangeForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialSplineFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialsUtils",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "RealFieldUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TricubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LoessInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "DividedDifferenceInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "HermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TrivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "NevilleInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereProjectionInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "AkimaSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MultivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "FieldHermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LinearInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariatePeriodicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SmoothingPolynomialBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere2D",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "Precision",
                "org.apache.commons.math3.util"
            ],
            [
                "MultidimensionalCounter",
                "org.apache.commons.math3.util"
            ],
            [
                "DoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "Incrementor",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToDoubleHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToFieldHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "MathArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "Pair",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathCalc",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMath",
                "org.apache.commons.math3.util"
            ],
            [
                "ResizableDoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "BigRealField",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64Field",
                "org.apache.commons.math3.util"
            ],
            [
                "Combinations",
                "org.apache.commons.math3.util"
            ],
            [
                "MathUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "NumberTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "ContinuedFraction",
                "org.apache.commons.math3.util"
            ],
            [
                "RandomPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationManager",
                "org.apache.commons.math3.util"
            ],
            [
                "CompositeFormat",
                "org.apache.commons.math3.util"
            ],
            [
                "KthSelector",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationEvent",
                "org.apache.commons.math3.util"
            ],
            [
                "TransformerMap",
                "org.apache.commons.math3.util"
            ],
            [
                "IntegerSequence",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathLiteralArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "CombinatoricsUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationListener",
                "org.apache.commons.math3.util"
            ],
            [
                "PivotingStrategyInterface",
                "org.apache.commons.math3.util"
            ],
            [
                "CentralPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64",
                "org.apache.commons.math3.util"
            ],
            [
                "DefaultTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "BigReal",
                "org.apache.commons.math3.util"
            ],
            [
                "ArithmeticUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "MedianOf3PivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "ComplexFormat",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexField",
                "org.apache.commons.math3.complex"
            ],
            [
                "RootsOfUnity",
                "org.apache.commons.math3.complex"
            ],
            [
                "Quaternion",
                "org.apache.commons.math3.complex"
            ],
            [
                "Complex",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexUtils",
                "org.apache.commons.math3.complex"
            ],
            [
                "DifferentiableMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractScalarDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "ConjugateGradientFormula",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "BaseMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "AbstractLinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseAbstractUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Target",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NonSymmetricMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "AnyMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularValueDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "EigenDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldLUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixUtils",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "TriDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixDimensionMismatchException",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "DecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "LUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "ConjugateGradient",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSelfAdjointOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BiDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "CholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldDecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "PreconditionedIterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "QRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "SymmLQ",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "IllConditionedOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultIterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DiagonalMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "HessenbergTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RectangularCholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "JacobiPreconditioner",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealLinearOperator",
                "org.apache.commons.math3.linear"
            ],
            [
                "RRQRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SchurTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "CauchyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LaplaceDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "HypergeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ChiSquaredDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TriangularDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalMixtureExpectationMaximization",
                "org.apache.commons.math3.distribution.fitting"
            ],
            [
                "BetaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "RealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "SaddlePointExpansion",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GumbelDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ZipfDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "BinomialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "IntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "WeibullDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NakagamiDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ConstantRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ExponentialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PascalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ParetoDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "FDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PoissonDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "KolmogorovSmirnovDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GammaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogisticDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LevyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxIter",
                "org.apache.commons.math3.optim"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraintSet",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "PivotSelectionRule",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SolutionCallback",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "NonNegativeConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "AbstractOptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optim"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseMultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "MultiStartUnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateObjectiveFunction",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SearchInterval",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxEval",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optim"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GradientMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "LineSearch",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunction",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunctionGradient",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ModelFunction",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "ModelFunctionJacobian",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "JacobianMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Target",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultiStartMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Erf",
                "org.apache.commons.math3.special"
            ],
            [
                "BesselJ",
                "org.apache.commons.math3.special"
            ],
            [
                "Gamma",
                "org.apache.commons.math3.special"
            ],
            [
                "Beta",
                "org.apache.commons.math3.special"
            ],
            [
                "FieldODEState",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldODEStateAndDerivative",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ODEIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterConfiguration",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputFieldModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderConverter",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ExpandableStatefulODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "Parameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "JacobianMatrices",
                "org.apache.commons.math3.ode"
            ],
            [
                "StepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "DummyStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractFieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldFixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerMode",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerBounds",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "NordsieckStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "RungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldButcherArrayProvider",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckFieldTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldSecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MainStateJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldEquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldExpandableODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterizedWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractParameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "UnknownParameterException",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "EquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "Transformer",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "Action",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventFilter",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FilterType",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "ParameterizedODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "NaNStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "NaturalRanking",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "TiesStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "RankingAlgorithm",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "StatUtils",
                "org.apache.commons.math3.stat"
            ],
            [
                "IntervalUtils",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "AgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "WilsonScoreInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "NormalApproximationInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "BinomialConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "StorelessCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "StorelessBivariateCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "KendallsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "Covariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "PearsonsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "SpearmansCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanIntegerPoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanDoublePoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "TestUtils",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "TTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "GTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AlternativeHypothesis",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "MannWhitneyUTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "WilcoxonSignedRankTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "OneWayAnova",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "ChiSquareTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "BinomialTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "KolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AbstractUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "DescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "MultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SecondMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Mean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FourthMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Variance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Kurtosis",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "GeometricMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StandardDeviation",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialCovariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "ThirdMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "SemiVariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FirstMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Skewness",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StatisticalSummaryValues",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalMultivariateSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "AggregateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "WeightedEvaluation",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "UnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "Percentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Max",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "PSquarePercentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Min",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Median",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "SynchronizedDescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedMultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SumOfSquares",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Product",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Sum",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "SumOfLogs",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "AbstractStorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SimpleRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "UpdatingMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "AbstractMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "GLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "ModelSpecificationException",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "RegressionResults",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MillerUpdatingRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "OLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "Frequency",
                "org.apache.commons.math3.stat"
            ],
            [
                "ChebyshevDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CanberraDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EuclideanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "ManhattanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EarthMoversDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "DistanceMeasure",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CentroidCluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "MultiKMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "FuzzyKMeansClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "SumOfClusterVariances",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "ClusterEvaluator",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "Clusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DoublePoint",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KohonenTrainingTask",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "KohonenUpdateAction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "QuasiSigmoidDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "ExponentialDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "NeighbourhoodSizeFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "NeighbourhoodSizeFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "MapUtils",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Network",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializerFactory",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Neuron",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializer",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "NeuronString",
                "org.apache.commons.math3.ml.neuralnet.oned"
            ],
            [
                "NeuronSquareMesh2D",
                "org.apache.commons.math3.ml.neuralnet.twod"
            ],
            [
                "SmoothedDataHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "UnifiedDistanceMatrix",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapDataVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "LocationFinder",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "HitHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "QuantizationError",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "TopographicErrorHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "SquareNeighbourhood",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "UpdateAction",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "BracketingNthOrderBrentSolverDFP",
                "org.apache.commons.math3.dfp"
            ],
            [
                "UnivariateDfpFunction",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpDec",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpMath",
                "org.apache.commons.math3.dfp"
            ],
            [
                "Dfp",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpField",
                "org.apache.commons.math3.dfp"
            ],
            [
                "GeneticAlgorithm",
                "org.apache.commons.math3.genetics"
            ],
            [
                "SelectionPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedGenerationCount",
                "org.apache.commons.math3.genetics"
            ],
            [
                "AbstractListChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OnePointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ElitisticListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Chromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OrderedCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "InvalidRepresentationException",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKey",
                "org.apache.commons.math3.genetics"
            ],
            [
                "StoppingCondition",
                "org.apache.commons.math3.genetics"
            ],
            [
                "PermutationChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ChromosomePair",
                "org.apache.commons.math3.genetics"
            ],
            [
                "TournamentSelection",
                "org.apache.commons.math3.genetics"
            ],
            [
                "NPointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "UniformCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "MutationPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedElapsedTime",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CycleCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Population",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKeyMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Fitness",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CrossoverPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Vector",
                "org.apache.commons.math3.geometry"
            ],
            [
                "VectorFormat",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Point",
                "org.apache.commons.math3.geometry"
            ],
            [
                "RotationConvention",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubPlane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3DFormat",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "OutlineExtractor",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "PolyhedronsSet",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "RotationOrder",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Rotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Euclidean3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphericalCoordinates",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "CardanEulerSingularityException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "NotARotationMatrixException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldRotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Plane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphereGenerator",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "IntervalsSet",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Interval",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "SubOrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "OrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Euclidean1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1DFormat",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "AbstractConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "AklToussaintHeuristic",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHull2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "MonotoneChain",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "Vector2DFormat",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "PolygonsSet",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "DiskGenerator",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Vector2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "NestedLoops",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Euclidean2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "ConvexHullGenerator",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ConvexHull",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ArcsSet",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "S1Point",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere1D",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Arc",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "LimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "SubLimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere2D",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SubCircle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Vertex",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Circle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "PropertiesComputer",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SphericalPolygonsSet",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Edge",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "EdgesBuilder",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "S2Point",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SupportBallGenerator",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "EnclosingBall",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "WelzlEncloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "Encloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "InsideFinder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjection",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjector",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Region",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Transform",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "NodesSet",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractRegion",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Characterization",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractSubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BSPTree",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "RegionFactory",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Side",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundarySizeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AVLTree",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "OrderedTuple",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "BSPTreeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Hyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Embedding",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryAttribute",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "SubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryBuilder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Space",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Field",
                "org.apache.commons.math3"
            ],
            [
                "ProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "MeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "KalmanFilter",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultMeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "NormalizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "GaussianRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "ISAACRandom",
                "org.apache.commons.math3.random"
            ],
            [
                "CorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937a",
                "org.apache.commons.math3.random"
            ],
            [
                "Well1024a",
                "org.apache.commons.math3.random"
            ],
            [
                "UniformRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497a",
                "org.apache.commons.math3.random"
            ],
            [
                "BitsStreamGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "SynchronizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "UncorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937c",
                "org.apache.commons.math3.random"
            ],
            [
                "ValueServer",
                "org.apache.commons.math3.random"
            ],
            [
                "HaltonSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497b",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomData",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well512a",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "JDKRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "StableRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomAdaptor",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGeneratorFactory",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractWell",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataImpl",
                "org.apache.commons.math3.random"
            ],
            [
                "EmpiricalDistribution",
                "org.apache.commons.math3.random"
            ],
            [
                "SobolSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "MersenneTwister",
                "org.apache.commons.math3.random"
            ],
            [
                "UnitSphereRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "FieldElement",
                "org.apache.commons.math3"
            ],
            [
                "BigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "Fraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "AbstractFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionConversionException",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperBigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "NotFiniteNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoBracketingException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathArithmeticException",
                "org.apache.commons.math3.exception"
            ],
            [
                "InsufficientDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyEvaluationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ExceptionContextProvider",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ExceptionContext",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ArgUtils",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "DummyLocalizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "Localizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "LocalizedFormats",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "NotANumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MultiDimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "OutOfRangeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyIterationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NullArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooLargeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalStateException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathUnsupportedOperationException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotStrictlyPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NonMonotonicSequenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ZeroException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "DimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathRuntimeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathParseException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MaxCountExceededException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooSmallException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ConvergenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathInternalError",
                "org.apache.commons.math3.exception"
            ],
            [
                "DftNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "RealTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastSineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "DctNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastFourierTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformType",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastCosineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformUtils",
                "org.apache.commons.math3.transform"
            ],
            [
                "DstNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastHadamardTransformer",
                "org.apache.commons.math3.transform"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "isPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Primality test: tells if the argument is a (provable) prime or not.\n * <p>\n * It uses the Miller-Rabin probabilistic test in such a way that a result is guaranteed:\n * it uses the firsts prime numbers as successive base (see Handbook of applied cryptography\n * by Menezes, table 4.1).\n *\n * @param n number to test.\n * @return true if n is prime. (All numbers &lt; 2 return false).\n */\npublic static boolean isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int p : SmallPrimes.PRIMES) {\n        if (0 == (n % p)) {\n            return n == p;\n        }\n    }\n    return SmallPrimes.millerRabinPrimeTest(n);\n}"
            ],
            [
                "nextPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Return the smallest prime greater than or equal to n.\n *\n * @param n a positive number.\n * @return the smallest prime greater than or equal to n.\n * @throws MathIllegalArgumentException if n &lt; 0.\n */\npublic static int nextPrime(int n) {\n    if (n < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL, n, 0);\n    }\n    if (n == 2) {\n        return 2;\n    }\n    //make sure n is odd\n    n |= 1;\n    if (n == 1) {\n        return 2;\n    }\n    if (isPrime(n)) {\n        return n;\n    }\n    // prepare entry in the +2, +4 loop:\n    // n should not be a multiple of 3\n    final int rem = n % 3;\n    if (0 == rem) {\n        // if n % 3 == 0\n        // n % 3 == 2\n        n += 2;\n    } else if (1 == rem) {\n        // if n % 3 == 1\n        // if (isPrime(n)) return n;\n        // n % 3 == 2\n        n += 4;\n    }\n    while (true) {\n        // this loop skips all multiple of 3\n        if (isPrime(n)) {\n            return n;\n        }\n        // n % 3 == 1\n        n += 2;\n        if (isPrime(n)) {\n            return n;\n        }\n        // n % 3 == 2\n        n += 4;\n    }\n}"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Prime factors decomposition\n *\n * @param n number to factorize: must be &ge; 2\n * @return list of prime factors of n\n * @throws MathIllegalArgumentException if n &lt; 2.\n */\npublic static List<Integer> primeFactors(int n) {\n    if (n < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL, n, 2);\n    }\n    // slower than trial div unless we do an awful lot of computation\n    // (then it finally gets JIT-compiled efficiently\n    // List<Integer> out = PollardRho.primeFactors(n);\n    return SmallPrimes.trialDivision(n);\n}"
            ],
            [
                "smallTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Extract small factors.\n * @param n the number to factor, must be &gt; 0.\n * @param factors the list where to add the factors.\n * @return the part of n which remains to be factored, it is either a prime or a semi-prime\n */\npublic static int smallTrialDivision(int n, final List<Integer> factors) {\n    for (int p : PRIMES) {\n        while (0 == n % p) {\n            n /= p;\n            factors.add(p);\n        }\n    }\n    return n;\n}"
            ],
            [
                "boundedTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Extract factors in the range <code>PRIME_LAST+2</code> to <code>maxFactors</code>.\n * @param n the number to factorize, must be >= PRIME_LAST+2 and must not contain any factor below PRIME_LAST+2\n * @param maxFactor the upper bound of trial division: if it is reached, the method gives up and returns n.\n * @param factors the list where to add the factors.\n * @return  n or 1 if factorization is completed.\n */\npublic static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors) {\n    int f = PRIMES_LAST + 2;\n    // no check is done about n >= f\n    while (f <= maxFactor) {\n        if (0 == n % f) {\n            n /= f;\n            factors.add(f);\n            break;\n        }\n        f += 4;\n        if (0 == n % f) {\n            n /= f;\n            factors.add(f);\n            break;\n        }\n        f += 2;\n    }\n    if (n != 1) {\n        factors.add(n);\n    }\n    return n;\n}"
            ],
            [
                "trialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Factorization by trial division.\n * @param n the number to factor\n * @return the list of prime factors of n\n */\npublic static List<Integer> trialDivision(int n) {\n    final List<Integer> factors = new ArrayList<Integer>(32);\n    n = smallTrialDivision(n, factors);\n    if (1 == n) {\n        return factors;\n    }\n    // here we are sure that n is either a prime or a semi prime\n    final int bound = (int) FastMath.sqrt(n);\n    boundedTrialDivision(n, bound, factors);\n    return factors;\n}"
            ],
            [
                "millerRabinPrimeTest",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Miller-Rabin probabilistic primality test for int type, used in such a way that a result is always guaranteed.\n * <p>\n * It uses the prime numbers as successive base therefore it is guaranteed to be always correct.\n * (see Handbook of applied cryptography by Menezes, table 4.1)\n *\n * @param n number to test: an odd integer &ge; 3\n * @return true if n is prime. false if n is definitely composite.\n */\npublic static boolean millerRabinPrimeTest(final int n) {\n    final int nMinus1 = n - 1;\n    final int s = Integer.numberOfTrailingZeros(nMinus1);\n    final int r = nMinus1 >> s;\n    //r must be odd, it is not checked here\n    int t = 1;\n    if (n >= 2047) {\n        t = 2;\n    }\n    if (n >= 1373653) {\n        t = 3;\n    }\n    if (n >= 25326001) {\n        t = 4;\n    }\n    // works up to 3.2 billion, int range stops at 2.7 so we are safe :-)\n    BigInteger br = BigInteger.valueOf(r);\n    BigInteger bn = BigInteger.valueOf(n);\n    for (int i = 0; i < t; i++) {\n        BigInteger a = BigInteger.valueOf(SmallPrimes.PRIMES[i]);\n        BigInteger bPow = a.modPow(br, bn);\n        int y = bPow.intValue();\n        if ((1 != y) && (y != nMinus1)) {\n            int j = 1;\n            while ((j <= s - 1) && (nMinus1 != y)) {\n                long square = ((long) y) * y;\n                y = (int) (square % n);\n                if (1 == y) {\n                    return false;\n                }\n                // definitely composite\n                j++;\n            }\n            if (nMinus1 != y) {\n                return false;\n            }\n            // definitely composite\n        }\n    }\n    // definitely prime\n    return true;\n}"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Factorization using Pollard's rho algorithm.\n * @param n number to factors, must be &gt; 0\n * @return the list of prime factors of n.\n */\npublic static List<Integer> primeFactors(int n) {\n    final List<Integer> factors = new ArrayList<Integer>();\n    n = SmallPrimes.smallTrialDivision(n, factors);\n    if (1 == n) {\n        return factors;\n    }\n    if (SmallPrimes.millerRabinPrimeTest(n)) {\n        factors.add(n);\n        return factors;\n    }\n    int divisor = rhoBrent(n);\n    factors.add(divisor);\n    factors.add(n / divisor);\n    return factors;\n}"
            ],
            [
                "rhoBrent",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Implementation of the Pollard's rho factorization algorithm.\n * <p>\n * This implementation follows the paper \"An improved Monte Carlo factorization algorithm\"\n * by Richard P. Brent. This avoids the triple computation of f(x) typically found in Pollard's\n * rho implementations. It also batches several gcd computation into 1.\n * <p>\n * The backtracking is not implemented as we deal only with semi-primes.\n *\n * @param n number to factor, must be semi-prime.\n * @return a prime factor of n.\n */\nstatic int rhoBrent(final int n) {\n    final int x0 = 2;\n    final int m = 25;\n    int cst = SmallPrimes.PRIMES_LAST;\n    int y = x0;\n    int r = 1;\n    do {\n        int x = y;\n        for (int i = 0; i < r; i++) {\n            final long y2 = ((long) y) * y;\n            y = (int) ((y2 + cst) % n);\n        }\n        int k = 0;\n        do {\n            final int bound = FastMath.min(m, r - k);\n            int q = 1;\n            for (int i = -3; i < bound; i++) {\n                //start at -3 to ensure we enter this loop at least 3 times\n                final long y2 = ((long) y) * y;\n                y = (int) ((y2 + cst) % n);\n                final long divisor = FastMath.abs(x - y);\n                if (0 == divisor) {\n                    cst += SmallPrimes.PRIMES_LAST;\n                    k = -m;\n                    y = x0;\n                    r = 1;\n                    break;\n                }\n                final long prod = divisor * q;\n                q = (int) (prod % n);\n                if (0 == q) {\n                    return gcdPositive(FastMath.abs((int) divisor), n);\n                }\n            }\n            final int out = gcdPositive(FastMath.abs(q), n);\n            if (1 != out) {\n                return out;\n            }\n            k += m;\n        } while (k < r);\n        r = 2 * r;\n    } while (true);\n}"
            ],
            [
                "gcdPositive",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Gcd between two positive numbers.\n * <p>\n * Gets the greatest common divisor of two numbers, using the \"binary gcd\" method,\n * which avoids division and modulo operations. See Knuth 4.5.2 algorithm B.\n * This algorithm is due to Josef Stein (1961).\n * </p>\n * Special cases:\n * <ul>\n * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and {@code gcd(x, 0)} is the value of {@code x}.</li>\n * <li>The invocation {@code gcd(0, 0)} is the only one which returns {@code 0}.</li>\n * </ul>\n *\n * @param a first number, must be &ge; 0\n * @param b second number, must be &ge; 0\n * @return gcd(a,b)\n */\nstatic int gcdPositive(int a, int b) {\n    // both a and b must be positive, it is not checked here\n    // gdc(a,0) = a\n    if (a == 0) {\n        return b;\n    } else if (b == 0) {\n        return a;\n    }\n    // make a and b odd, keep in mind the common power of twos\n    final int aTwos = Integer.numberOfTrailingZeros(a);\n    a >>= aTwos;\n    final int bTwos = Integer.numberOfTrailingZeros(b);\n    b >>= bTwos;\n    final int shift = FastMath.min(aTwos, bTwos);\n    // a and b >0\n    // if a > b then gdc(a,b) = gcd(a-b,b)\n    // if a < b then gcd(a,b) = gcd(b-a,a)\n    // so next a is the absolute difference and next b is the minimum of current values\n    while (a != b) {\n        final int delta = a - b;\n        b = FastMath.min(a, b);\n        a = FastMath.abs(delta);\n        // for speed optimization:\n        // remove any power of two in a as b is guaranteed to be odd throughout all iterations\n        a >>= Integer.numberOfTrailingZeros(a);\n    }\n    // gcd(a,a) = a, just \"add\" the common power of twos\n    return a << shift;\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "GaussianCurveFitter",
                "/**\n * Creates a default curve fitter.\n * The initial guess for the parameters will be {@link ParameterGuesser}\n * computed automatically, and the maximum number of iterations of the\n * optimization algorithm is set to {@link Integer#MAX_VALUE}.\n *\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static GaussianCurveFitter create() {\n    return new GaussianCurveFitter(null, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "SimpleCurveFitter",
                "/**\n * Creates a curve fitter.\n * The maximum number of iterations of the optimization algorithm is set\n * to {@link Integer#MAX_VALUE}.\n *\n * @param f Function to fit.\n * @param start Initial guess for the parameters.  Cannot be {@code null}.\n * Its length must be consistent with the number of parameters of the\n * function to fit.\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static SimpleCurveFitter create(ParametricUnivariateFunction f, double[] start) {\n    return new SimpleCurveFitter(f, start, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements. There will be no weights applied (unit weights).\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @param lazyEvaluation Whether the call to {@link Evaluation#evaluate(RealVector)}\n * will defer the evaluation until access to the value is requested.\n * @param paramValidator Model parameters validator.\n * @return the specified General Least Squares problem.\n *\n * @since 3.4\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations, final boolean lazyEvaluation, final ParameterValidator paramValidator) {\n    final LeastSquaresProblem p = new LocalLeastSquaresProblem(model, observed, start, checker, maxEvaluations, maxIterations, lazyEvaluation, paramValidator);\n    if (weight != null) {\n        return weightMatrix(p, weight);\n    } else {\n        return p;\n    }\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements. There will be no weights applied (unit weights).\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return create(model, observed, start, null, checker, maxEvaluations, maxIterations, false, null);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements.\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return weightMatrix(create(model, observed, start, checker, maxEvaluations, maxIterations), weight);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements.\n * <p>\n * This factory method is provided for continuity with previous interfaces. Newer\n * applications should use {@link #create(MultivariateJacobianFunction, RealVector,\n * RealVector, ConvergenceChecker, int, int)}, or {@link #create(MultivariateJacobianFunction,\n * RealVector, RealVector, RealMatrix, ConvergenceChecker, int, int)}.\n *\n * @param model          the model function. Produces the computed values.\n * @param jacobian       the jacobian of the model with respect to the parameters\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateVectorFunction model, final MultivariateMatrixFunction jacobian, final double[] observed, final double[] start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return create(model(model, jacobian), new ArrayRealVector(observed, false), new ArrayRealVector(start, false), weight, checker, maxEvaluations, maxIterations);\n}"
            ],
            [
                "weightMatrix",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Apply a dense weight matrix to the {@link LeastSquaresProblem}.\n *\n * @param problem the unweighted problem\n * @param weights the matrix of weights\n * @return a new {@link LeastSquaresProblem} with the weights applied. The original\n *         {@code problem} is not modified.\n */\npublic static LeastSquaresProblem weightMatrix(final LeastSquaresProblem problem, final RealMatrix weights) {\n    final RealMatrix weightSquareRoot = squareRoot(weights);\n    return new LeastSquaresAdapter(problem) {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Evaluation evaluate(final RealVector point) {\n            return new DenseWeightedEvaluation(super.evaluate(point), weightSquareRoot);\n        }\n    };\n}"
            ],
            [
                "weightDiagonal",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Apply a diagonal weight matrix to the {@link LeastSquaresProblem}.\n *\n * @param problem the unweighted problem\n * @param weights the diagonal of the weight matrix\n * @return a new {@link LeastSquaresProblem} with the weights applied. The original\n *         {@code problem} is not modified.\n */\npublic static LeastSquaresProblem weightDiagonal(final LeastSquaresProblem problem, final RealVector weights) {\n    // TODO more efficient implementation\n    return weightMatrix(problem, new DiagonalMatrix(weights.toArray()));\n}"
            ],
            [
                "countEvaluations",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Count the evaluations of a particular problem. The {@code counter} will be\n * incremented every time {@link LeastSquaresProblem#evaluate(RealVector)} is called on\n * the <em>returned</em> problem.\n *\n * @param problem the problem to track.\n * @param counter the counter to increment.\n * @return a least squares problem that tracks evaluations\n */\npublic static LeastSquaresProblem countEvaluations(final LeastSquaresProblem problem, final Incrementor counter) {\n    return new LeastSquaresAdapter(problem) {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Evaluation evaluate(final RealVector point) {\n            counter.incrementCount();\n            return super.evaluate(point);\n        }\n    };\n}"
            ],
            [
                "evaluationChecker",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * View a convergence checker specified for a {@link PointVectorValuePair} as one\n * specified for an {@link Evaluation}.\n *\n * @param checker the convergence checker to adapt.\n * @return a convergence checker that delegates to {@code checker}.\n */\npublic static ConvergenceChecker<Evaluation> evaluationChecker(final ConvergenceChecker<PointVectorValuePair> checker) {\n    return new ConvergenceChecker<Evaluation>() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean converged(final int iteration, final Evaluation previous, final Evaluation current) {\n            return checker.converged(iteration, new PointVectorValuePair(previous.getPoint().toArray(), previous.getResiduals().toArray(), false), new PointVectorValuePair(current.getPoint().toArray(), current.getResiduals().toArray(), false));\n        }\n    };\n}"
            ],
            [
                "model",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Combine a {@link MultivariateVectorFunction} with a {@link\n * MultivariateMatrixFunction} to produce a {@link MultivariateJacobianFunction}.\n *\n * @param value    the vector value function\n * @param jacobian the Jacobian function\n * @return a function that computes both at the same time\n */\npublic static MultivariateJacobianFunction model(final MultivariateVectorFunction value, final MultivariateMatrixFunction jacobian) {\n    return new LocalValueAndJacobianFunction(value, jacobian);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "HarmonicCurveFitter",
                "/**\n * Creates a default curve fitter.\n * The initial guess for the parameters will be {@link ParameterGuesser}\n * computed automatically, and the maximum number of iterations of the\n * optimization algorithm is set to {@link Integer#MAX_VALUE}.\n *\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static HarmonicCurveFitter create() {\n    return new HarmonicCurveFitter(null, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "PolynomialCurveFitter",
                "/**\n * Creates a default curve fitter.\n * Zero will be used as initial guess for the coefficients, and the maximum\n * number of iterations of the optimization algorithm is set to\n * {@link Integer#MAX_VALUE}.\n *\n * @param degree Degree of the polynomial to be fitted.\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static PolynomialCurveFitter create(int degree) {\n    return new PolynomialCurveFitter(new double[degree + 1], Integer.MAX_VALUE);\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n */\npublic static UnivariateFunction compose(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = x;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction compose(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = t;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public DerivativeStructure value(final DerivativeStructure t) {\n            DerivativeStructure r = t;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n * @deprecated as of 3.1 replaced by {@link #compose(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = x;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double p = 1;\n                    double r = x;\n                    for (int i = f.length - 1; i >= 0; i--) {\n                        p *= f[i].derivative().value(r);\n                        r = f[i].value(r);\n                    }\n                    return p;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n */\npublic static UnivariateFunction add(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(x);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction add(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(t);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         * @throws DimensionMismatchException if functions are not consistent with each other\n         */\n        public DerivativeStructure value(final DerivativeStructure t) throws DimensionMismatchException {\n            DerivativeStructure r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r = r.add(f[i].value(t));\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n * @deprecated as of 3.1 replaced by {@link #add(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(x);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double r = f[0].derivative().value(x);\n                    for (int i = 1; i < f.length; i++) {\n                        r += f[i].derivative().value(x);\n                    }\n                    return r;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n */\npublic static UnivariateFunction multiply(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(x);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction multiply(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(t);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public DerivativeStructure value(final DerivativeStructure t) {\n            DerivativeStructure r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r = r.multiply(f[i].value(t));\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n * @deprecated as of 3.1 replaced by {@link #multiply(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(x);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double sum = 0;\n                    for (int i = 0; i < f.length; i++) {\n                        double prod = f[i].derivative().value(x);\n                        for (int j = 0; j < f.length; j++) {\n                            if (i != j) {\n                                prod *= f[j].value(x);\n                            }\n                        }\n                        sum += prod;\n                    }\n                    return sum;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "combine",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns the univariate function\n * {@code h(x) = combiner(f(x), g(x)).}\n *\n * @param combiner Combiner function.\n * @param f Function.\n * @param g Function.\n * @return the composite function.\n */\npublic static UnivariateFunction combine(final BivariateFunction combiner, final UnivariateFunction f, final UnivariateFunction g) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return combiner.value(f.value(x), g.value(x));\n        }\n    };\n}"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns a MultivariateFunction h(x[]) defined by <pre> <code>\n * h(x[]) = combiner(...combiner(combiner(initialValue,f(x[0])),f(x[1]))...),f(x[x.length-1]))\n * </code></pre>\n *\n * @param combiner Combiner function.\n * @param f Function.\n * @param initialValue Initial value.\n * @return a collector function.\n */\npublic static MultivariateFunction collector(final BivariateFunction combiner, final UnivariateFunction f, final double initialValue) {\n    return new MultivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double[] point) {\n            double result = combiner.value(initialValue, f.value(point[0]));\n            for (int i = 1; i < point.length; i++) {\n                result = combiner.value(result, f.value(point[i]));\n            }\n            return result;\n        }\n    };\n}"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns a MultivariateFunction h(x[]) defined by <pre> <code>\n * h(x[]) = combiner(...combiner(combiner(initialValue,x[0]),x[1])...),x[x.length-1])\n * </code></pre>\n *\n * @param combiner Combiner function.\n * @param initialValue Initial value.\n * @return a collector function.\n */\npublic static MultivariateFunction collector(final BivariateFunction combiner, final double initialValue) {\n    return collector(combiner, new Identity(), initialValue);\n}"
            ],
            [
                "fix1stArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Creates a unary function by fixing the first argument of a binary function.\n *\n * @param f Binary function.\n * @param fixed value to which the first argument of {@code f} is set.\n * @return the unary function h(x) = f(fixed, x)\n */\npublic static UnivariateFunction fix1stArgument(final BivariateFunction f, final double fixed) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return f.value(fixed, x);\n        }\n    };\n}"
            ],
            [
                "fix2ndArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Creates a unary function by fixing the second argument of a binary function.\n *\n * @param f Binary function.\n * @param fixed value to which the second argument of {@code f} is set.\n * @return the unary function h(x) = f(x, fixed)\n */\npublic static UnivariateFunction fix2ndArgument(final BivariateFunction f, final double fixed) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return f.value(x, fixed);\n        }\n    };\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Samples the specified univariate real function on the specified interval.\n * <p>\n * The interval is divided equally into {@code n} sections and sample points\n * are taken from {@code min} to {@code max - (max - min) / n}; therefore\n * {@code f} is not sampled at the upper bound {@code max}.</p>\n *\n * @param f Function to be sampled\n * @param min Lower bound of the interval (included).\n * @param max Upper bound of the interval (excluded).\n * @param n Number of sample points.\n * @return the array of samples.\n * @throws NumberIsTooLargeException if the lower bound {@code min} is\n * greater than, or equal to the upper bound {@code max}.\n * @throws NotStrictlyPositiveException if the number of sample points\n * {@code n} is negative.\n */\npublic static double[] sample(UnivariateFunction f, double min, double max, int n) throws NumberIsTooLargeException, NotStrictlyPositiveException {\n    if (n <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES, Integer.valueOf(n));\n    }\n    if (min >= max) {\n        throw new NumberIsTooLargeException(min, max, false);\n    }\n    final double[] s = new double[n];\n    final double h = (max - min) / n;\n    for (int i = 0; i < n; i++) {\n        s[i] = f.value(min + i * h);\n    }\n    return s;\n}"
            ],
            [
                "toDifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link UnivariateDifferentiableFunction} into a {@link DifferentiableUnivariateFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableUnivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction toDifferentiableUnivariateFunction(final UnivariateDifferentiableFunction f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(final double x) {\n                    return f.value(new DerivativeStructure(1, 1, 0, x)).getPartialDerivative(1);\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toUnivariateDifferential",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableUnivariateFunction} into a {@link UnivariateDifferentiableFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} up to order one.\n * If the function is called with higher order, a {@link NumberIsTooLargeException} is thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableUnivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static UnivariateDifferentiableFunction toUnivariateDifferential(final DifferentiableUnivariateFunction f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is greater than 1\n         */\n        public DerivativeStructure value(final DerivativeStructure t) throws NumberIsTooLargeException {\n            switch(t.getOrder()) {\n                case 0:\n                    return new DerivativeStructure(t.getFreeParameters(), 0, f.value(t.getValue()));\n                case 1:\n                    {\n                        final int parameters = t.getFreeParameters();\n                        final double[] derivatives = new double[parameters + 1];\n                        derivatives[0] = f.value(t.getValue());\n                        final double fPrime = f.derivative().value(t.getValue());\n                        int[] orders = new int[parameters];\n                        for (int i = 0; i < parameters; ++i) {\n                            orders[i] = 1;\n                            derivatives[i + 1] = fPrime * t.getPartialDerivative(orders);\n                            orders[i] = 0;\n                        }\n                        return new DerivativeStructure(parameters, 1, derivatives);\n                    }\n                default:\n                    throw new NumberIsTooLargeException(t.getOrder(), 1, true);\n            }\n        }\n    };\n}"
            ],
            [
                "toDifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link MultivariateDifferentiableFunction} into a {@link DifferentiableMultivariateFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f) {\n    return new DifferentiableMultivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateFunction partialDerivative(final int k) {\n            return new MultivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        if (i == k) {\n                            dsX[i] = new DerivativeStructure(1, 1, 0, x[i]);\n                        } else {\n                            dsX[i] = new DerivativeStructure(1, 1, x[i]);\n                        }\n                    }\n                    final DerivativeStructure y = f.value(dsX);\n                    // extract partial derivative\n                    return y.getPartialDerivative(1);\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateVectorFunction gradient() {\n            return new MultivariateVectorFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double[] value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        dsX[i] = new DerivativeStructure(n, 1, i, x[i]);\n                    }\n                    final DerivativeStructure y = f.value(dsX);\n                    // extract gradient\n                    final double[] gradient = new double[n];\n                    final int[] orders = new int[n];\n                    for (int i = 0; i < n; ++i) {\n                        orders[i] = 1;\n                        gradient[i] = y.getPartialDerivative(orders);\n                        orders[i] = 0;\n                    }\n                    return gradient;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toMultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableMultivariateFunction} into a {@link MultivariateDifferentiableFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} elements\n * that all have the same number of free parameters and order, and with order at most 1.\n * If the function is called with inconsistent numbers of free parameters or higher order, a\n * {@link DimensionMismatchException} or a {@link NumberIsTooLargeException} will be thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f) {\n    return new MultivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is higher than 1\n         * @exception DimensionMismatchException if numbers of free parameters are inconsistent\n         */\n        public DerivativeStructure value(final DerivativeStructure[] t) throws DimensionMismatchException, NumberIsTooLargeException {\n            // check parameters and orders limits\n            final int parameters = t[0].getFreeParameters();\n            final int order = t[0].getOrder();\n            final int n = t.length;\n            if (order > 1) {\n                throw new NumberIsTooLargeException(order, 1, true);\n            }\n            // check all elements in the array are consistent\n            for (int i = 0; i < n; ++i) {\n                if (t[i].getFreeParameters() != parameters) {\n                    throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n                }\n                if (t[i].getOrder() != order) {\n                    throw new DimensionMismatchException(t[i].getOrder(), order);\n                }\n            }\n            // delegate computation to underlying function\n            final double[] point = new double[n];\n            for (int i = 0; i < n; ++i) {\n                point[i] = t[i].getValue();\n            }\n            final double value = f.value(point);\n            final double[] gradient = f.gradient().value(point);\n            // merge value and gradient into one DerivativeStructure\n            final double[] derivatives = new double[parameters + 1];\n            derivatives[0] = value;\n            final int[] orders = new int[parameters];\n            for (int i = 0; i < parameters; ++i) {\n                orders[i] = 1;\n                for (int j = 0; j < n; ++j) {\n                    derivatives[i + 1] += gradient[j] * t[j].getPartialDerivative(orders);\n                }\n                orders[i] = 0;\n            }\n            return new DerivativeStructure(parameters, order, derivatives);\n        }\n    };\n}"
            ],
            [
                "toDifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link MultivariateDifferentiableVectorFunction} into a {@link DifferentiableMultivariateVectorFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateVectorFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f) {\n    return new DifferentiableMultivariateVectorFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double[] value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateMatrixFunction jacobian() {\n            return new MultivariateMatrixFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double[][] value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        dsX[i] = new DerivativeStructure(n, 1, i, x[i]);\n                    }\n                    final DerivativeStructure[] y = f.value(dsX);\n                    // extract Jacobian\n                    final double[][] jacobian = new double[y.length][n];\n                    final int[] orders = new int[n];\n                    for (int i = 0; i < y.length; ++i) {\n                        for (int j = 0; j < n; ++j) {\n                            orders[j] = 1;\n                            jacobian[i][j] = y[i].getPartialDerivative(orders);\n                            orders[j] = 0;\n                        }\n                    }\n                    return jacobian;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toMultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableMultivariateVectorFunction} into a {@link MultivariateDifferentiableVectorFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} elements\n * that all have the same number of free parameters and order, and with order at most 1.\n * If the function is called with inconsistent numbers of free parameters or higher order, a\n * {@link DimensionMismatchException} or a {@link NumberIsTooLargeException} will be thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f) {\n    return new MultivariateDifferentiableVectorFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double[] value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is higher than 1\n         * @exception DimensionMismatchException if numbers of free parameters are inconsistent\n         */\n        public DerivativeStructure[] value(final DerivativeStructure[] t) throws DimensionMismatchException, NumberIsTooLargeException {\n            // check parameters and orders limits\n            final int parameters = t[0].getFreeParameters();\n            final int order = t[0].getOrder();\n            final int n = t.length;\n            if (order > 1) {\n                throw new NumberIsTooLargeException(order, 1, true);\n            }\n            // check all elements in the array are consistent\n            for (int i = 0; i < n; ++i) {\n                if (t[i].getFreeParameters() != parameters) {\n                    throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n                }\n                if (t[i].getOrder() != order) {\n                    throw new DimensionMismatchException(t[i].getOrder(), order);\n                }\n            }\n            // delegate computation to underlying function\n            final double[] point = new double[n];\n            for (int i = 0; i < n; ++i) {\n                point[i] = t[i].getValue();\n            }\n            final double[] value = f.value(point);\n            final double[][] jacobian = f.jacobian().value(point);\n            // merge value and Jacobian into a DerivativeStructure array\n            final DerivativeStructure[] merged = new DerivativeStructure[value.length];\n            for (int k = 0; k < merged.length; ++k) {\n                final double[] derivatives = new double[parameters + 1];\n                derivatives[0] = value[k];\n                final int[] orders = new int[parameters];\n                for (int i = 0; i < parameters; ++i) {\n                    orders[i] = 1;\n                    for (int j = 0; j < n; ++j) {\n                        derivatives[i + 1] += jacobian[k][j] * t[j].getPartialDerivative(orders);\n                    }\n                    orders[i] = 0;\n                }\n                merged[k] = new DerivativeStructure(parameters, order, derivatives);\n            }\n            return merged;\n        }\n    };\n}"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Convenience method to find a zero of a univariate real function.  A default\n * solver is used.\n *\n * @param function Function.\n * @param x0 Lower bound for the interval.\n * @param x1 Upper bound for the interval.\n * @return a value where the function is zero.\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double solve(UnivariateFunction function, double x0, double x1) throws NullArgumentException, NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final UnivariateSolver solver = new BrentSolver();\n    return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n}"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Convenience method to find a zero of a univariate real function.  A default\n * solver is used.\n *\n * @param function Function.\n * @param x0 Lower bound for the interval.\n * @param x1 Upper bound for the interval.\n * @param absoluteAccuracy Accuracy to be used by the solver.\n * @return a value where the function is zero.\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double solve(UnivariateFunction function, double x0, double x1, double absoluteAccuracy) throws NullArgumentException, NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final UnivariateSolver solver = new BrentSolver(absoluteAccuracy);\n    return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n}"
            ],
            [
                "forceSide",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Force a root found by a non-bracketing solver to lie on a specified side,\n * as if the solver were a bracketing one.\n *\n * @param maxEval maximal number of new evaluations of the function\n * (evaluations already done for finding the root should have already been subtracted\n * from this number)\n * @param f function to solve\n * @param bracketing bracketing solver to use for shifting the root\n * @param baseRoot original root found by a previous non-bracketing solver\n * @param min minimal bound of the search interval\n * @param max maximal bound of the search interval\n * @param allowedSolution the kind of solutions that the root-finding algorithm may\n * accept as solutions.\n * @return a root approximation, on the specified side of the exact root\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n */\npublic static double forceSide(final int maxEval, final UnivariateFunction f, final BracketedUnivariateSolver<UnivariateFunction> bracketing, final double baseRoot, final double min, final double max, final AllowedSolution allowedSolution) throws NoBracketingException {\n    if (allowedSolution == AllowedSolution.ANY_SIDE) {\n        // no further bracketing required\n        return baseRoot;\n    }\n    // find a very small interval bracketing the root\n    final double step = FastMath.max(bracketing.getAbsoluteAccuracy(), FastMath.abs(baseRoot * bracketing.getRelativeAccuracy()));\n    double xLo = FastMath.max(min, baseRoot - step);\n    double fLo = f.value(xLo);\n    double xHi = FastMath.min(max, baseRoot + step);\n    double fHi = f.value(xHi);\n    int remainingEval = maxEval - 2;\n    while (remainingEval > 0) {\n        if ((fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0)) {\n            // compute the root on the selected side\n            return bracketing.solve(remainingEval, f, xLo, xHi, baseRoot, allowedSolution);\n        }\n        // try increasing the interval\n        boolean changeLo = false;\n        boolean changeHi = false;\n        if (fLo < fHi) {\n            // increasing function\n            if (fLo >= 0) {\n                changeLo = true;\n            } else {\n                changeHi = true;\n            }\n        } else if (fLo > fHi) {\n            // decreasing function\n            if (fLo <= 0) {\n                changeLo = true;\n            } else {\n                changeHi = true;\n            }\n        } else {\n            // unknown variation\n            changeLo = true;\n            changeHi = true;\n        }\n        // update the lower bound\n        if (changeLo) {\n            xLo = FastMath.max(min, xLo - step);\n            fLo = f.value(xLo);\n            remainingEval--;\n        }\n        // update the higher bound\n        if (changeHi) {\n            xHi = FastMath.min(max, xHi + step);\n            fHi = f.value(xHi);\n            remainingEval--;\n        }\n    }\n    throw new NoBracketingException(LocalizedFormats.FAILED_BRACKETING, xLo, xHi, fLo, fHi, maxEval - remainingEval, maxEval, baseRoot, min, max);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method simply calls {@link #bracket(UnivariateFunction, double, double, double,\n * double, double, int) bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)}\n * with {@code q} and {@code r} set to 1.0 and {@code maximumIterations} set to {@code Integer.MAX_VALUE}.\n * <p>\n * <strong>Note: </strong> this method can take {@code Integer.MAX_VALUE}\n * iterations to throw a {@code ConvergenceException.}  Unless you are\n * confident that there is a root between {@code lowerBound} and\n * {@code upperBound} near {@code initial}, it is better to use\n * {@link #bracket(UnivariateFunction, double, double, double, double,double, int)\n * bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)},\n * explicitly specifying the maximum number of iterations.</p>\n *\n * @param function Function.\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value)\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @return a two-element array holding a and b.\n * @throws NoBracketingException if a root cannot be bracketted.\n * @throws NotStrictlyPositiveException if {@code maximumIterations <= 0}.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException {\n    return bracket(function, initial, lowerBound, upperBound, 1.0, 1.0, Integer.MAX_VALUE);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method simply calls {@link #bracket(UnivariateFunction, double, double, double,\n * double, double, int) bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)}\n * with {@code q} and {@code r} set to 1.0.\n * @param function Function.\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value).\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @param maximumIterations Maximum number of iterations to perform\n * @return a two element array holding a and b.\n * @throws NoBracketingException if the algorithm fails to find a and b\n * satisfying the desired conditions.\n * @throws NotStrictlyPositiveException if {@code maximumIterations <= 0}.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException {\n    return bracket(function, initial, lowerBound, upperBound, 1.0, 1.0, maximumIterations);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method attempts to find two values a and b satisfying <ul>\n * <li> {@code lowerBound <= a < initial < b <= upperBound} </li>\n * <li> {@code f(a) * f(b) <= 0} </li>\n * </ul>\n * If {@code f} is continuous on {@code [a,b]}, this means that {@code a}\n * and {@code b} bracket a root of {@code f}.\n * <p>\n * The algorithm checks the sign of \\( f(l_k) \\) and \\( f(u_k) \\) for increasing\n * values of k, where \\( l_k = max(lower, initial - \\delta_k) \\),\n * \\( u_k = min(upper, initial + \\delta_k) \\), using recurrence\n * \\( \\delta_{k+1} = r \\delta_k + q, \\delta_0 = 0\\) and starting search with \\( k=1 \\).\n * The algorithm stops when one of the following happens: <ul>\n * <li> at least one positive and one negative value have been found --  success!</li>\n * <li> both endpoints have reached their respective limits -- NoBracketingException </li>\n * <li> {@code maximumIterations} iterations elapse -- NoBracketingException </li></ul>\n * <p>\n * If different signs are found at first iteration ({@code k=1}), then the returned\n * interval will be \\( [a, b] = [l_1, u_1] \\). If different signs are found at a later\n * iteration {@code k>1}, then the returned interval will be either\n * \\( [a, b] = [l_{k+1}, l_{k}] \\) or \\( [a, b] = [u_{k}, u_{k+1}] \\). A root solver called\n * with these parameters will therefore start with the smallest bracketing interval known\n * at this step.\n * </p>\n * <p>\n * Interval expansion rate is tuned by changing the recurrence parameters {@code r} and\n * {@code q}. When the multiplicative factor {@code r} is set to 1, the sequence is a\n * simple arithmetic sequence with linear increase. When the multiplicative factor {@code r}\n * is larger than 1, the sequence has an asymptotically exponential rate. Note than the\n * additive parameter {@code q} should never be set to zero, otherwise the interval would\n * degenerate to the single initial point for all values of {@code k}.\n * </p>\n * <p>\n * As a rule of thumb, when the location of the root is expected to be approximately known\n * within some error margin, {@code r} should be set to 1 and {@code q} should be set to the\n * order of magnitude of the error margin. When the location of the root is really a wild guess,\n * then {@code r} should be set to a value larger than 1 (typically 2 to double the interval\n * length at each iteration) and {@code q} should be set according to half the initial\n * search interval length.\n * </p>\n * <p>\n * As an example, if we consider the trivial function {@code f(x) = 1 - x} and use\n * {@code initial = 4}, {@code r = 1}, {@code q = 2}, the algorithm will compute\n * {@code f(4-2) = f(2) = -1} and {@code f(4+2) = f(6) = -5} for {@code k = 1}, then\n * {@code f(4-4) = f(0) = +1} and {@code f(4+4) = f(8) = -7} for {@code k = 2}. Then it will\n * return the interval {@code [0, 2]} as the smallest one known to be bracketing the root.\n * As shown by this example, the initial value (here {@code 4}) may lie outside of the returned\n * bracketing interval.\n * </p>\n * @param function function to check\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value).\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @param q additive offset used to compute bounds sequence (must be strictly positive)\n * @param r multiplicative factor used to compute bounds sequence\n * @param maximumIterations Maximum number of iterations to perform\n * @return a two element array holding the bracketing values.\n * @exception NoBracketingException if function cannot be bracketed in the search interval\n */\npublic static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    if (q <= 0) {\n        throw new NotStrictlyPositiveException(q);\n    }\n    if (maximumIterations <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.INVALID_MAX_ITERATIONS, maximumIterations);\n    }\n    verifySequence(lowerBound, initial, upperBound);\n    // initialize the recurrence\n    double a = initial;\n    double b = initial;\n    double fa = Double.NaN;\n    double fb = Double.NaN;\n    double delta = 0;\n    for (int numIterations = 0; (numIterations < maximumIterations) && (a > lowerBound || b < upperBound); ++numIterations) {\n        final double previousA = a;\n        final double previousFa = fa;\n        final double previousB = b;\n        final double previousFb = fb;\n        delta = r * delta + q;\n        a = FastMath.max(initial - delta, lowerBound);\n        b = FastMath.min(initial + delta, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        if (numIterations == 0) {\n            // at first iteration, we don't have a previous interval\n            // we simply compare both sides of the initial interval\n            if (fa * fb <= 0) {\n                // the first interval already brackets a root\n                return new double[] { a, b };\n            }\n        } else {\n            // we have a previous interval with constant sign and expand it,\n            // we expect sign changes to occur at boundaries\n            if (fa * previousFa <= 0) {\n                // sign change detected at near lower bound\n                return new double[] { a, previousA };\n            } else if (fb * previousFb <= 0) {\n                // sign change detected at near upper bound\n                return new double[] { previousB, b };\n            }\n        }\n    }\n    // no bracketing found\n    throw new NoBracketingException(a, b, fa, fb);\n}"
            ],
            [
                "midpoint",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Compute the midpoint of two values.\n *\n * @param a first value.\n * @param b second value.\n * @return the midpoint.\n */\npublic static double midpoint(double a, double b) {\n    return (a + b) * 0.5;\n}"
            ],
            [
                "isBracketing",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Check whether the interval bounds bracket a root. That is, if the\n * values at the endpoints are not equal to zero, then the function takes\n * opposite signs at the endpoints.\n *\n * @param function Function.\n * @param lower Lower endpoint.\n * @param upper Upper endpoint.\n * @return {@code true} if the function values have opposite signs at the\n * given points.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static boolean isBracketing(UnivariateFunction function, final double lower, final double upper) throws NullArgumentException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final double fLo = function.value(lower);\n    final double fHi = function.value(upper);\n    return (fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0);\n}"
            ],
            [
                "isSequence",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Check whether the arguments form a (strictly) increasing sequence.\n *\n * @param start First number.\n * @param mid Second number.\n * @param end Third number.\n * @return {@code true} if the arguments form an increasing sequence.\n */\npublic static boolean isSequence(final double start, final double mid, final double end) {\n    return (start < mid) && (mid < end);\n}"
            ],
            [
                "getCompiler",
                "org.apache.commons.math3.analysis.differentiation",
                "DSCompiler",
                "/**\n * Get the compiler for number of free parameters and order.\n * @param parameters number of free parameters\n * @param order derivation order\n * @return cached rules set\n * @throws NumberIsTooLargeException if order is too large\n */\npublic static DSCompiler getCompiler(int parameters, int order) throws NumberIsTooLargeException {\n    // get the cached compilers\n    final DSCompiler[][] cache = compilers.get();\n    if (cache != null && cache.length > parameters && cache[parameters].length > order && cache[parameters][order] != null) {\n        // the compiler has already been created\n        return cache[parameters][order];\n    }\n    // we need to create more compilers\n    final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);\n    final int maxOrder = FastMath.max(order, cache == null ? 0 : cache[0].length);\n    final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];\n    if (cache != null) {\n        // preserve the already created compilers\n        for (int i = 0; i < cache.length; ++i) {\n            System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);\n        }\n    }\n    // create the array in increasing diagonal order\n    for (int diag = 0; diag <= parameters + order; ++diag) {\n        for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {\n            final int p = diag - o;\n            if (newCache[p][o] == null) {\n                final DSCompiler valueCompiler = (p == 0) ? null : newCache[p - 1][o];\n                final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];\n                newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);\n            }\n        }\n    }\n    // atomically reset the cached compilers array\n    compilers.compareAndSet(cache, newCache);\n    return newCache[parameters][order];\n}"
            ],
            [
                "createConstant",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Factory method creating a constant.\n * @param value value of the constant\n * @return a new instance\n */\npublic static SparseGradient createConstant(final double value) {\n    return new SparseGradient(value, Collections.<Integer, Double>emptyMap());\n}"
            ],
            [
                "createVariable",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Factory method creating an independent variable.\n * @param idx index of the variable\n * @param value value of the variable\n * @return a new instance\n */\npublic static SparseGradient createVariable(final int idx, final double value) {\n    return new SparseGradient(value, Collections.singletonMap(idx, 1.0));\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n */\npublic static SparseGradient hypot(final SparseGradient x, final SparseGradient y) {\n    return x.hypot(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Compute a<sup>x</sup> where a is a double and x a {@link SparseGradient}\n * @param a number to exponentiate\n * @param x power to apply\n * @return a<sup>x</sup>\n */\npublic static SparseGradient pow(final double a, final SparseGradient x) {\n    if (a == 0) {\n        if (x.value == 0) {\n            return x.compose(1.0, Double.NEGATIVE_INFINITY);\n        } else if (x.value < 0) {\n            return x.compose(Double.NaN, Double.NaN);\n        } else {\n            return x.getField().getZero();\n        }\n    } else {\n        final double ax = FastMath.pow(a, x.value);\n        return new SparseGradient(ax, ax * FastMath.log(a), x.derivatives);\n    }\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Two arguments arc tangent operation.\n * @param y first argument of the arc tangent\n * @param x second argument of the arc tangent\n * @return atan2(y, x)\n */\npublic static SparseGradient atan2(final SparseGradient y, final SparseGradient x) {\n    return y.atan2(x);\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * @exception DimensionMismatchException if number of free parameters\n * or orders do not match\n * @since 3.2\n */\npublic static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y) throws DimensionMismatchException {\n    return x.hypot(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Compute a<sup>x</sup> where a is a double and x a {@link DerivativeStructure}\n * @param a number to exponentiate\n * @param x power to apply\n * @return a<sup>x</sup>\n * @since 3.3\n */\npublic static DerivativeStructure pow(final double a, final DerivativeStructure x) {\n    final DerivativeStructure result = new DerivativeStructure(x.compiler);\n    x.compiler.pow(a, x.data, 0, result.data, 0);\n    return result;\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Two arguments arc tangent operation.\n * @param y first argument of the arc tangent\n * @param x second argument of the arc tangent\n * @return atan2(y, x)\n * @exception DimensionMismatchException if number of free parameters\n * or orders do not match\n * @since 3.2\n */\npublic static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException {\n    return y.atan2(x);\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionNewtonForm",
                "/**\n * Evaluate the Newton polynomial using nested multiplication. It is\n * also called <a href=\"http://mathworld.wolfram.com/HornersRule.html\">\n * Horner's Rule</a> and takes O(N) time.\n *\n * @param a Coefficients in Newton form formula.\n * @param c Centers.\n * @param z Point at which the function value is to be computed.\n * @return the function value.\n * @throws NullArgumentException if any argument is {@code null}.\n * @throws NoDataException if any array has zero length.\n * @throws DimensionMismatchException if the size difference between\n * {@code a} and {@code c} is not equal to 1.\n */\npublic static double evaluate(double[] a, double[] c, double z) throws NullArgumentException, DimensionMismatchException, NoDataException {\n    verifyInputArray(a, c);\n    final int n = c.length;\n    double value = a[n];\n    for (int i = n - 1; i >= 0; i--) {\n        value = a[i] + (z - c[i]) * value;\n    }\n    return value;\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "/**\n * Evaluate the Lagrange polynomial using\n * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n * Neville's Algorithm</a>. It takes O(n^2) time.\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @param z Point at which the function value is to be computed.\n * @return the function value.\n * @throws DimensionMismatchException if {@code x} and {@code y} have\n * different lengths.\n * @throws NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order.\n * @throws NumberIsTooSmallException if the size of {@code x} is less\n * than 2.\n */\npublic static double evaluate(double[] x, double[] y, double z) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    if (verifyInterpolationArray(x, y, false)) {\n        return evaluateInternal(x, y, z);\n    }\n    // Array is not sorted.\n    final double[] xNew = new double[x.length];\n    final double[] yNew = new double[y.length];\n    System.arraycopy(x, 0, xNew, 0, x.length);\n    System.arraycopy(y, 0, yNew, 0, y.length);\n    MathArrays.sortInPlace(xNew, yNew);\n    // Second check in case some abscissa is duplicated.\n    verifyInterpolationArray(xNew, yNew, true);\n    return evaluateInternal(xNew, yNew, z);\n}"
            ],
            [
                "verifyInterpolationArray",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "/**\n * Check that the interpolation arrays are valid.\n * The arrays features checked by this method are that both arrays have the\n * same length and this length is at least 2.\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @param abort Whether to throw an exception if {@code x} is not sorted.\n * @throws DimensionMismatchException if the array lengths are different.\n * @throws NumberIsTooSmallException if the number of points is less than 2.\n * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order and {@code abort}\n * is {@code true}.\n * @return {@code false} if the {@code x} is not sorted in increasing order,\n * {@code true} otherwise.\n * @see #evaluate(double[], double[], double)\n * @see #computeCoefficients()\n */\npublic static boolean verifyInterpolationArray(double[] x, double[] y, boolean abort) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    if (x.length != y.length) {\n        throw new DimensionMismatchException(x.length, y.length);\n    }\n    if (x.length < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.WRONG_NUMBER_OF_POINTS, 2, x.length, true);\n    }\n    return MathArrays.checkOrder(x, MathArrays.OrderDirection.INCREASING, true, abort);\n}"
            ],
            [
                "createChebyshevPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Chebyshev polynomial of the first kind.\n * <p><a href=\"https://en.wikipedia.org/wiki/Chebyshev_polynomials\">Chebyshev\n * polynomials of the first kind</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *    T_0(x) = 1 \\\\\n *    T_1(x) = x \\\\\n *    T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Chebyshev polynomial of specified degree\n */\npublic static PolynomialFunction createChebyshevPolynomial(final int degree) {\n    return buildPolynomial(degree, CHEBYSHEV_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * Fixed recurrence coefficients.\n         */\n        private final BigFraction[] coeffs = { BigFraction.ZERO, BigFraction.TWO, BigFraction.ONE };\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            return coeffs;\n        }\n    });\n}"
            ],
            [
                "createHermitePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Hermite polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/HermitePolynomial.html\">Hermite\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *  H_0(x) = 1 \\\\\n *  H_1(x) = 2x \\\\\n *  H_{k+1}(x) = 2x H_k(X) - 2k H_{k-1}(x)\n * \\)\n * </p>\n *\n * @param degree degree of the polynomial\n * @return Hermite polynomial of specified degree\n */\npublic static PolynomialFunction createHermitePolynomial(final int degree) {\n    return buildPolynomial(degree, HERMITE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            return new BigFraction[] { BigFraction.ZERO, BigFraction.TWO, new BigFraction(2 * k) };\n        }\n    });\n}"
            ],
            [
                "createLaguerrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Laguerre polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/LaguerrePolynomial.html\">Laguerre\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *   L_0(x) = 1 \\\\\n *   L_1(x) = 1 - x \\\\\n *   (k+1) L_{k+1}(x) = (2k + 1 - x) L_k(x) - k L_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Laguerre polynomial of specified degree\n */\npublic static PolynomialFunction createLaguerrePolynomial(final int degree) {\n    return buildPolynomial(degree, LAGUERRE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            final int kP1 = k + 1;\n            return new BigFraction[] { new BigFraction(2 * k + 1, kP1), new BigFraction(-1, kP1), new BigFraction(k, kP1) };\n        }\n    });\n}"
            ],
            [
                "createLegendrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Legendre polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/LegendrePolynomial.html\">Legendre\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *   P_0(x) = 1 \\\\\n *   P_1(x) = x \\\\\n *   (k+1) P_{k+1}(x) = (2k+1) x P_k(x) - k P_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Legendre polynomial of specified degree\n */\npublic static PolynomialFunction createLegendrePolynomial(final int degree) {\n    return buildPolynomial(degree, LEGENDRE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            final int kP1 = k + 1;\n            return new BigFraction[] { BigFraction.ZERO, new BigFraction(k + kP1, kP1), new BigFraction(k, kP1) };\n        }\n    });\n}"
            ],
            [
                "createJacobiPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Jacobi polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/JacobiPolynomial.html\">Jacobi\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *    P_0^{vw}(x) = 1 \\\\\n *    P_{-1}^{vw}(x) = 0 \\\\\n *    2k(k + v + w)(2k + v + w - 2) P_k^{vw}(x) = \\\\\n *    (2k + v + w - 1)[(2k + v + w)(2k + v + w - 2) x + v^2 - w^2] P_{k-1}^{vw}(x) \\\\\n *  - 2(k + v - 1)(k + w - 1)(2k + v + w) P_{k-2}^{vw}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @param v first exponent\n * @param w second exponent\n * @return Jacobi polynomial of specified degree\n */\npublic static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w) {\n    // select the appropriate list\n    final JacobiKey key = new JacobiKey(v, w);\n    if (!JACOBI_COEFFICIENTS.containsKey(key)) {\n        // allocate a new list for v, w\n        final List<BigFraction> list = new ArrayList<BigFraction>();\n        JACOBI_COEFFICIENTS.put(key, list);\n        // Pv,w,0(x) = 1;\n        list.add(BigFraction.ONE);\n        // P1(x) = (v - w) / 2 + (2 + v + w) * X / 2\n        list.add(new BigFraction(v - w, 2));\n        list.add(new BigFraction(2 + v + w, 2));\n    }\n    return buildPolynomial(degree, JACOBI_COEFFICIENTS.get(key), new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            k++;\n            final int kvw = k + v + w;\n            final int twoKvw = kvw + k;\n            final int twoKvwM1 = twoKvw - 1;\n            final int twoKvwM2 = twoKvw - 2;\n            final int den = 2 * k * kvw * twoKvwM2;\n            return new BigFraction[] { new BigFraction(twoKvwM1 * (v * v - w * w), den), new BigFraction(twoKvwM1 * twoKvw * twoKvwM2, den), new BigFraction(2 * (k + v - 1) * (k + w - 1) * twoKvw, den) };\n        }\n    });\n}"
            ],
            [
                "shift",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Compute the coefficients of the polynomial \\(P_s(x)\\)\n * whose values at point {@code x} will be the same as the those from the\n * original polynomial \\(P(x)\\) when computed at {@code x + shift}.\n * <p>\n * More precisely, let \\(\\Delta = \\) {@code shift} and let\n * \\(P_s(x) = P(x + \\Delta)\\).  The returned array\n * consists of the coefficients of \\(P_s\\).  So if \\(a_0, ..., a_{n-1}\\)\n * are the coefficients of \\(P\\), then the returned array\n * \\(b_0, ..., b_{n-1}\\) satisfies the identity\n * \\(\\sum_{i=0}^{n-1} b_i x^i = \\sum_{i=0}^{n-1} a_i (x + \\Delta)^i\\) for all \\(x\\).\n *\n * @param coefficients Coefficients of the original polynomial.\n * @param shift Shift value.\n * @return the coefficients \\(b_i\\) of the shifted\n * polynomial.\n */\npublic static double[] shift(final double[] coefficients, final double shift) {\n    final int dp1 = coefficients.length;\n    final double[] newCoefficients = new double[dp1];\n    // Pascal triangle.\n    final int[][] coeff = new int[dp1][dp1];\n    for (int i = 0; i < dp1; i++) {\n        for (int j = 0; j <= i; j++) {\n            coeff[i][j] = (int) CombinatoricsUtils.binomialCoefficient(i, j);\n        }\n    }\n    // First polynomial coefficient.\n    for (int i = 0; i < dp1; i++) {\n        newCoefficients[0] += coefficients[i] * FastMath.pow(shift, i);\n    }\n    // Superior order.\n    final int d = dp1 - 1;\n    for (int i = 0; i < d; i++) {\n        for (int j = i; j < d; j++) {\n            newCoefficients[i + 1] += coeff[j + 1][j - i] * coefficients[j + 1] * FastMath.pow(shift, j - i);\n        }\n    }\n    return newCoefficients;\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "/**\n * Uses Horner's Method to evaluate the polynomial with the given coefficients at\n * the argument.\n *\n * @param coefficients Coefficients of the polynomial to evaluate.\n * @param argument Input value.\n * @return the value of the polynomial.\n * @throws NoDataException if {@code coefficients} is empty.\n * @throws NullArgumentException if {@code coefficients} is {@code null}.\n */\nprotected static double evaluate(double[] coefficients, double argument) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(coefficients);\n    int n = coefficients.length;\n    if (n == 0) {\n        throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n    }\n    double result = coefficients[n - 1];\n    for (int j = n - 2; j >= 0; j--) {\n        result = argument * result + coefficients[j];\n    }\n    return result;\n}"
            ],
            [
                "differentiate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "/**\n * Returns the coefficients of the derivative of the polynomial with the given coefficients.\n *\n * @param coefficients Coefficients of the polynomial to differentiate.\n * @return the coefficients of the derivative or {@code null} if coefficients has length 1.\n * @throws NoDataException if {@code coefficients} is empty.\n * @throws NullArgumentException if {@code coefficients} is {@code null}.\n */\nprotected static double[] differentiate(double[] coefficients) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(coefficients);\n    int n = coefficients.length;\n    if (n == 0) {\n        throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n    }\n    if (n == 1) {\n        return new double[] { 0 };\n    }\n    double[] result = new double[n - 1];\n    for (int i = n - 1; i > 0; i--) {\n        result[i - 1] = i * coefficients[i];\n    }\n    return result;\n}"
            ],
            [
                "computeDividedDifference",
                "org.apache.commons.math3.analysis.interpolation",
                "DividedDifferenceInterpolator",
                "/**\n * Return a copy of the divided difference array.\n * <p>\n * The divided difference array is defined recursively by <pre>\n * f[x0] = f(x0)\n * f[x0,x1,...,xk] = (f[x1,...,xk] - f[x0,...,x[k-1]]) / (xk - x0)\n * </pre>\n * <p>\n * The computational complexity is \\(O(n^2)\\) where \\(n\\) is the common\n * length of {@code x} and {@code y}.</p>\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @return a fresh copy of the divided difference array.\n * @throws DimensionMismatchException if the array lengths are different.\n * @throws NumberIsTooSmallException if the number of points is less than 2.\n * @throws NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order.\n */\nprotected static double[] computeDividedDifference(final double[] x, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y, true);\n    // initialization\n    final double[] divdiff = y.clone();\n    final int n = x.length;\n    final double[] a = new double[n];\n    a[0] = divdiff[0];\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n - i; j++) {\n            final double denominator = x[j + i] - x[j];\n            divdiff[j] = (divdiff[j + 1] - divdiff[j]) / denominator;\n        }\n        a[i] = divdiff[0];\n    }\n    return a;\n}"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Compares two numbers given some amount of allowed error.\n *\n * @param x the first number\n * @param y the second number\n * @param eps the amount of error to allow when checking for equality\n * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y or\n *       either argument is NaN</li></ul>\n */\npublic static int compareTo(double x, double y, double eps) {\n    if (equals(x, y, eps)) {\n        return 0;\n    } else if (x < y) {\n        return -1;\n    }\n    return 1;\n}"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Compares two numbers given some amount of allowed error.\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>. Returns {@code false} if either of the arguments is NaN.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return <ul><li>0 if  {@link #equals(double, double, int) equals(x, y, maxUlps)}</li>\n *       <li>&lt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y</li>\n *       <li>&gt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x > y\n *       or either argument is NaN</li></ul>\n */\npublic static int compareTo(final double x, final double y, final int maxUlps) {\n    if (equals(x, y, maxUlps)) {\n        return 0;\n    } else if (x < y) {\n        return -1;\n    }\n    return 1;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true iff they are equal as defined by\n * {@link #equals(float,float,int) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\npublic static boolean equals(float x, float y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if both arguments are NaN or they are\n * equal as defined by {@link #equals(float,float) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).  Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other.\n * @since 2.2\n */\npublic static boolean equals(float x, float y, float eps) {\n    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN, are equal, or are within the range\n * of allowed error (inclusive).\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,\n * or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y, float eps) {\n    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>.  Returns {@code false} if either of the arguments is NaN.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equals(final float x, final float y, final int maxUlps) {\n    final int xInt = Float.floatToRawIntBits(x);\n    final int yInt = Float.floatToRawIntBits(y);\n    final boolean isEqual;\n    if (((xInt ^ yInt) & SGN_MASK_FLOAT) == 0) {\n        // number have same sign, there is no risk of overflow\n        isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    } else {\n        // number have opposite signs, take care of overflow\n        final int deltaPlus;\n        final int deltaMinus;\n        if (xInt < yInt) {\n            deltaPlus = yInt - POSITIVE_ZERO_FLOAT_BITS;\n            deltaMinus = xInt - NEGATIVE_ZERO_FLOAT_BITS;\n        } else {\n            deltaPlus = xInt - POSITIVE_ZERO_FLOAT_BITS;\n            deltaMinus = yInt - NEGATIVE_ZERO_FLOAT_BITS;\n        }\n        if (deltaPlus > maxUlps) {\n            isEqual = false;\n        } else {\n            isEqual = deltaMinus <= (maxUlps - deltaPlus);\n        }\n    }\n    return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN or if they are equal as defined\n * by {@link #equals(float,float,int) equals(x, y, maxUlps)}.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than\n * {@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, maxUlps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true iff they are equal as defined by\n * {@link #equals(double,double,int) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\npublic static boolean equals(double x, double y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN or they are\n * equal as defined by {@link #equals(double,double) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns {@code true} if there is no double value strictly between the\n * arguments or the difference between them is within the range of allowed\n * error (inclusive). Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed absolute error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n */\npublic static boolean equals(double x, double y, double eps) {\n    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n}"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns {@code true} if there is no double value strictly between the\n * arguments or the relative difference between them is less than or equal\n * to the given tolerance. Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed relative error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n * @since 3.1\n */\npublic static boolean equalsWithRelativeTolerance(double x, double y, double eps) {\n    if (equals(x, y, 1)) {\n        return true;\n    }\n    final double absoluteMax = FastMath.max(FastMath.abs(x), FastMath.abs(y));\n    final double relativeDifference = FastMath.abs((x - y) / absoluteMax);\n    return relativeDifference <= eps;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN, are equal or are within the range\n * of allowed error (inclusive).\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,\n * or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y, double eps) {\n    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).\n * <p>\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent\n * floating point numbers are considered equal.\n * </p>\n * <p>\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>. Returns {@code false} if either of the arguments is NaN.\n * </p>\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n */\npublic static boolean equals(final double x, final double y, final int maxUlps) {\n    final long xInt = Double.doubleToRawLongBits(x);\n    final long yInt = Double.doubleToRawLongBits(y);\n    final boolean isEqual;\n    if (((xInt ^ yInt) & SGN_MASK) == 0l) {\n        // number have same sign, there is no risk of overflow\n        isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    } else {\n        // number have opposite signs, take care of overflow\n        final long deltaPlus;\n        final long deltaMinus;\n        if (xInt < yInt) {\n            deltaPlus = yInt - POSITIVE_ZERO_DOUBLE_BITS;\n            deltaMinus = xInt - NEGATIVE_ZERO_DOUBLE_BITS;\n        } else {\n            deltaPlus = xInt - POSITIVE_ZERO_DOUBLE_BITS;\n            deltaMinus = yInt - NEGATIVE_ZERO_DOUBLE_BITS;\n        }\n        if (deltaPlus > maxUlps) {\n            isEqual = false;\n        } else {\n            isEqual = deltaMinus <= (maxUlps - deltaPlus);\n        }\n    }\n    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if both arguments are NaN or if they are equal as defined\n * by {@link #equals(double,double,int) equals(x, y, maxUlps)}.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than\n * {@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, maxUlps);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double round(double x, int scale) {\n    return round(x, scale, BigDecimal.ROUND_HALF_UP);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is\n * returned unchanged, regardless of the other parameters.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}\n * and the specified scaling operation would require rounding.\n * @throws IllegalArgumentException if {@code roundingMethod} does not\n * represent a valid rounding mode.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double round(double x, int scale, int roundingMethod) {\n    try {\n        final double rounded = (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\n        // MATH-1089: negative values rounded to zero should result in negative zero\n        return rounded == POSITIVE_ZERO ? POSITIVE_ZERO * x : rounded;\n    } catch (NumberFormatException ex) {\n        if (Double.isInfinite(x)) {\n            return x;\n        } else {\n            return Double.NaN;\n        }\n    }\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static float round(float x, int scale) {\n    return round(x, scale, BigDecimal.ROUND_HALF_UP);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n * @throws MathArithmeticException if an exact operation is required but result is not exact\n * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n */\npublic static float round(float x, int scale, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException {\n    final float sign = FastMath.copySign(1f, x);\n    final float factor = (float) FastMath.pow(10.0f, scale) * sign;\n    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;\n}"
            ],
            [
                "representableDelta",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Computes a number {@code delta} close to {@code originalDelta} with\n * the property that <pre><code>\n *   x + delta - x\n * </code></pre>\n * is exactly machine-representable.\n * This is useful when computing numerical derivatives, in order to reduce\n * roundoff errors.\n *\n * @param x Value.\n * @param originalDelta Offset value.\n * @return a number {@code delta} so that {@code x + delta} and {@code x}\n * differ by a representable floating number.\n */\npublic static double representableDelta(double x, double originalDelta) {\n    return x + originalDelta - x;\n}"
            ],
            [
                "wrap",
                "org.apache.commons.math3.util",
                "Incrementor",
                "/**\n * Create an instance that delegates everything to a {@link IntegerSequence.Incrementor}.\n * <p>\n * This factory method is intended only as a temporary hack for internal use in\n * Apache Commons Math 3.X series, when {@code Incrementor} is required in\n * interface (as a return value or in protected fields). It should <em>not</em>\n * be used in other cases. The {@link IntegerSequence.Incrementor} class should\n * be used instead of {@code Incrementor}.\n * </p>\n * <p>\n * All methods are mirrored to the underlying {@link IntegerSequence.Incrementor},\n * as long as neither {@link #setMaximalCount(int)} nor {@link #resetCount()} are called.\n * If one of these two methods is called, the created instance becomes independent\n * of the {@link IntegerSequence.Incrementor} used at creation. The rationale is that\n * {@link IntegerSequence.Incrementor} cannot change their maximal count and cannot be reset.\n * </p>\n * @param incrementor wrapped {@link IntegerSequence.Incrementor}\n * @return an incrementor wrapping an {@link IntegerSequence.Incrementor}\n * @since 3.6\n */\npublic static Incrementor wrap(final IntegerSequence.Incrementor incrementor) {\n    return new Incrementor() {\n\n        /**\n         * Underlying incrementor.\n         */\n        private IntegerSequence.Incrementor delegate;\n\n        {\n            // set up matching values at initialization\n            delegate = incrementor;\n            super.setMaximalCount(delegate.getMaximalCount());\n            super.incrementCount(delegate.getCount());\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void setMaximalCount(int max) {\n            super.setMaximalCount(max);\n            delegate = delegate.withMaximalCount(max);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void resetCount() {\n            super.resetCount();\n            delegate = delegate.withStart(0);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void incrementCount() {\n            super.incrementCount();\n            delegate.increment();\n        }\n    };\n}"
            ],
            [
                "scale",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Create a copy of an array scaled by a value.\n *\n * @param arr Array to scale.\n * @param val Scalar.\n * @return scaled copy of array with each entry multiplied by val.\n * @since 3.2\n */\npublic static double[] scale(double val, final double[] arr) {\n    double[] newArr = new double[arr.length];\n    for (int i = 0; i < arr.length; i++) {\n        newArr[i] = arr[i] * val;\n    }\n    return newArr;\n}"
            ],
            [
                "ebeAdd",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * addition of the arguments.\n *\n * @param a First term of the addition.\n * @param b Second term of the addition.\n * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] += b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeSubtract",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * subtraction of the second argument from the first.\n *\n * @param a First term.\n * @param b Element to be subtracted.\n * @return a new array {@code r} where {@code r[i] = a[i] - b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] -= b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeMultiply",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * multiplication of the arguments.\n *\n * @param a First factor of the multiplication.\n * @param b Second factor of the multiplication.\n * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] *= b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeDivide",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * division of the first argument by the second.\n *\n * @param a Numerator of the division.\n * @param b Denominator of the division.\n * @return a new array {@code r} where {@code r[i] = a[i] / b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] /= b[i];\n    }\n    return result;\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>1</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance1(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        sum += FastMath.abs(p1[i] - p2[i]);\n    }\n    return sum;\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>1</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static int distance1(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    int sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        sum += FastMath.abs(p1[i] - p2[i]);\n    }\n    return sum;\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>2</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final double dp = p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return FastMath.sqrt(sum);\n}"
            ],
            [
                "cosAngle",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the cosine of the angle between two vectors.\n *\n * @param v1 Cartesian coordinates of the first vector.\n * @param v2 Cartesian coordinates of the second vector.\n * @return the cosine of the angle between the vectors.\n * @since 3.6\n */\npublic static double cosAngle(double[] v1, double[] v2) {\n    return linearCombination(v1, v2) / (safeNorm(v1) * safeNorm(v2));\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>2</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final double dp = p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return FastMath.sqrt(sum);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>&infin;</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double max = 0;\n    for (int i = 0; i < p1.length; i++) {\n        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n    }\n    return max;\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>&infin;</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    int max = 0;\n    for (int i = 0; i < p1.length; i++) {\n        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n    }\n    return max;\n}"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that an array is monotonically increasing or decreasing.\n *\n * @param <T> the type of the elements in the specified array\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\npublic static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {\n    T previous = val[0];\n    final int max = val.length;\n    for (int i = 1; i < max; i++) {\n        final int comp;\n        switch(dir) {\n            case INCREASING:\n                comp = previous.compareTo(val[i]);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            case DECREASING:\n                comp = val[i].compareTo(previous);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n        }\n        previous = val[i];\n    }\n    return true;\n}"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that an array is monotonically increasing or decreasing.\n *\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\npublic static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {\n    return checkOrder(val, dir, strict, false);\n}"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that both arrays have the same length.\n *\n * @param a Array.\n * @param b Array.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the arrays have the same length.\n * @throws DimensionMismatchException if the lengths differ and\n * {@code abort} is {@code true}.\n * @since 3.6\n */\npublic static boolean checkEqualLength(double[] a, double[] b, boolean abort) {\n    if (a.length == b.length) {\n        return true;\n    } else {\n        if (abort) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n        return false;\n    }\n}"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that both arrays have the same length.\n *\n * @param a Array.\n * @param b Array.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the arrays have the same length.\n * @throws DimensionMismatchException if the lengths differ and\n * {@code abort} is {@code true}.\n * @since 3.6\n */\npublic static boolean checkEqualLength(int[] a, int[] b, boolean abort) {\n    if (a.length == b.length) {\n        return true;\n    } else {\n        if (abort) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n        return false;\n    }\n}"
            ],
            [
                "checkOrder",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that the given array is sorted.\n *\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the array is sorted.\n * @throws NonMonotonicSequenceException if the array is not sorted\n * and {@code abort} is {@code true}.\n */\npublic static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {\n    double previous = val[0];\n    final int max = val.length;\n    int index;\n    ITEM: for (index = 1; index < max; index++) {\n        switch(dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[index] <= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] < previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[index] >= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] > previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n        }\n        previous = val[index];\n    }\n    if (index == max) {\n        // Loop completed.\n        return true;\n    }\n    // Loop early exit means wrong ordering.\n    if (abort) {\n        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n    } else {\n        return false;\n    }\n}"
            ],
            [
                "safeNorm",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n * Translation of the minpack enorm subroutine.\n *\n * The redistribution policy for MINPACK is available\n * <a href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n * convenience, it is reproduced below.</p>\n *\n * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n * <tr><td>\n *    Minpack Copyright Notice (1999) University of Chicago.\n *    All rights reserved\n * </td></tr>\n * <tr><td>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * <ol>\n *  <li>Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.</li>\n * <li>Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.</li>\n * <li>The end-user documentation included with the redistribution, if any,\n *     must include the following acknowledgment:\n *     {@code This product includes software developed by the University of\n *           Chicago, as Operator of Argonne National Laboratory.}\n *     Alternately, this acknowledgment may appear in the software itself,\n *     if and wherever such third-party acknowledgments normally appear.</li>\n * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n *     BE CORRECTED.</strong></li>\n * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n * <ol></td></tr>\n * </table>\n *\n * @param v Vector of doubles.\n * @return the 2-norm of the vector.\n * @since 2.2\n */\npublic static double safeNorm(double[] v) {\n    double rdwarf = 3.834e-20;\n    double rgiant = 1.304e+19;\n    double s1 = 0;\n    double s2 = 0;\n    double s3 = 0;\n    double x1max = 0;\n    double x3max = 0;\n    double floatn = v.length;\n    double agiant = rgiant / floatn;\n    for (int i = 0; i < v.length; i++) {\n        double xabs = FastMath.abs(v[i]);\n        if (xabs < rdwarf || xabs > agiant) {\n            if (xabs > rdwarf) {\n                if (xabs > x1max) {\n                    double r = x1max / xabs;\n                    s1 = 1 + s1 * r * r;\n                    x1max = xabs;\n                } else {\n                    double r = xabs / x1max;\n                    s1 += r * r;\n                }\n            } else {\n                if (xabs > x3max) {\n                    double r = x3max / xabs;\n                    s3 = 1 + s3 * r * r;\n                    x3max = xabs;\n                } else {\n                    if (xabs != 0) {\n                        double r = xabs / x3max;\n                        s3 += r * r;\n                    }\n                }\n            }\n        } else {\n            s2 += xabs * xabs;\n        }\n    }\n    double norm;\n    if (s1 != 0) {\n        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n    } else {\n        if (s2 == 0) {\n            norm = x3max * Math.sqrt(s3);\n        } else {\n            if (s2 >= x3max) {\n                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n            } else {\n                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n            }\n        }\n    }\n    return norm;\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @return the copied array.\n */\npublic static int[] copyOf(int[] source) {\n    return copyOf(source, source.length);\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @return the copied array.\n */\npublic static double[] copyOf(double[] source) {\n    return copyOf(source, source.length);\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the source\n * length, the copy will be truncated, if larger it will padded with\n * zeroes.\n * @return the copied array.\n */\npublic static int[] copyOf(int[] source, int len) {\n    final int[] output = new int[len];\n    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n    return output;\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the source\n * length, the copy will be truncated, if larger it will padded with\n * zeroes.\n * @return the copied array.\n */\npublic static double[] copyOf(double[] source, int len) {\n    final double[] output = new double[len];\n    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n    return output;\n}"
            ],
            [
                "copyOfRange",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param from Initial index of the range to be copied, inclusive.\n * @param to Final index of the range to be copied, exclusive. (This index may lie outside the array.)\n * @return the copied array.\n */\npublic static double[] copyOfRange(double[] source, int from, int to) {\n    final int len = to - from;\n    final double[] output = new double[len];\n    System.arraycopy(source, from, output, 0, FastMath.min(len, source.length - from));\n    return output;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * This method computes the sum of the products\n * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n * It does so by using specific multiplication and addition algorithms to\n * preserve accuracy and reduce cancellation effects.\n * <br/>\n * It is based on the 2005 paper\n * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n *\n * @param a Factors.\n * @param b Factors.\n * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n * @throws DimensionMismatchException if arrays dimensions don't match\n */\npublic static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final int len = a.length;\n    if (len == 1) {\n        // Revert to scalar multiplication.\n        return a[0] * b[0];\n    }\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double aHigh = Double.longBitsToDouble(Double.doubleToRawLongBits(ai) & ((-1L) << 27));\n        final double aLow = ai - aHigh;\n        final double bi = b[i];\n        final double bHigh = Double.longBitsToDouble(Double.doubleToRawLongBits(bi) & ((-1L) << 27));\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n    final double prodHighCur = prodHigh[0];\n    double prodHighNext = prodHigh[1];\n    double sHighPrev = prodHighCur + prodHighNext;\n    double sPrime = sHighPrev - prodHighNext;\n    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n    final int lenMinusOne = len - 1;\n    for (int i = 1; i < lenMinusOne; i++) {\n        prodHighNext = prodHigh[i + 1];\n        final double sHighCur = sHighPrev + prodHighNext;\n        sPrime = sHighCur - prodHighNext;\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n        sHighPrev = sHighCur;\n    }\n    double result = sHighPrev + (prodLowSum + sLowSum);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\n * so by using specific multiplication and addition algorithms to\n * preserve accuracy and reduce cancellation effects. It is based\n * on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub>\n * @see #linearCombination(double, double, double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // use IEEE754 floating point arithmetic rounding properties.\n    // The variable naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // final rounding, s12 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s12High + (prod1Low + prod2Low + s12Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2;\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n * to high accuracy. It does so by using specific multiplication and\n * addition algorithms to preserve accuracy and reduce cancellation effects.\n * It is based on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n * @see #linearCombination(double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // do use IEEE754 floating point arithmetic rounding properties.\n    // The variables naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // split a3 and b3 as one 26 bits number and one 27 bits number\n    final double a3High = Double.longBitsToDouble(Double.doubleToRawLongBits(a3) & ((-1L) << 27));\n    final double a3Low = a3 - a3High;\n    final double b3High = Double.longBitsToDouble(Double.doubleToRawLongBits(b3) & ((-1L) << 27));\n    final double b3Low = b3 - b3High;\n    // accurate multiplication a3 * b3\n    final double prod3High = a3 * b3;\n    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n    final double s123High = s12High + prod3High;\n    final double s123Prime = s123High - prod3High;\n    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n    // final rounding, s123 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2 + a3 * b3;\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n * a<sub>4</sub>&times;b<sub>4</sub>\n * to high accuracy. It does so by using specific multiplication and\n * addition algorithms to preserve accuracy and reduce cancellation effects.\n * It is based on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @param a4 first factor of the third term\n * @param b4 second factor of the third term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n * a<sub>4</sub>&times;b<sub>4</sub>\n * @see #linearCombination(double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // do use IEEE754 floating point arithmetic rounding properties.\n    // The variables naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // split a3 and b3 as one 26 bits number and one 27 bits number\n    final double a3High = Double.longBitsToDouble(Double.doubleToRawLongBits(a3) & ((-1L) << 27));\n    final double a3Low = a3 - a3High;\n    final double b3High = Double.longBitsToDouble(Double.doubleToRawLongBits(b3) & ((-1L) << 27));\n    final double b3Low = b3 - b3High;\n    // accurate multiplication a3 * b3\n    final double prod3High = a3 * b3;\n    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n    // split a4 and b4 as one 26 bits number and one 27 bits number\n    final double a4High = Double.longBitsToDouble(Double.doubleToRawLongBits(a4) & ((-1L) << 27));\n    final double a4Low = a4 - a4High;\n    final double b4High = Double.longBitsToDouble(Double.doubleToRawLongBits(b4) & ((-1L) << 27));\n    final double b4Low = b4 - b4High;\n    // accurate multiplication a4 * b4\n    final double prod4High = a4 * b4;\n    final double prod4Low = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n    final double s123High = s12High + prod3High;\n    final double s123Prime = s123High - prod3High;\n    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4\n    final double s1234High = s123High + prod4High;\n    final double s1234Prime = s1234High - prod4High;\n    final double s1234Low = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n    // final rounding, s1234 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n    }\n    return result;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns true iff both arguments are null or have same dimensions and all\n * their elements are equal as defined by\n * {@link Precision#equals(float,float)}.\n *\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension\n * and equal elements.\n */\npublic static boolean equals(float[] x, float[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equals(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns true iff both arguments are null or have same dimensions and all\n * their elements are equal as defined by\n * {@link Precision#equalsIncludingNaN(double,double) this method}.\n *\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension and\n * equal elements\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float[] x, float[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns {@code true} iff both arguments are {@code null} or have same\n * dimensions and all their elements are equal as defined by\n * {@link Precision#equals(double,double)}.\n *\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have same\n * dimension and equal elements.\n */\npublic static boolean equals(double[] x, double[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equals(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns {@code true} iff both arguments are {@code null} or have same\n * dimensions and all their elements are equal as defined by\n * {@link Precision#equalsIncludingNaN(double,double) this method}.\n *\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have same\n * dimension and equal elements.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double[] x, double[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "normalizeArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Normalizes an array to make it sum to a specified value.\n * Returns the result of the transformation\n * <pre>\n *    x |-> x * normalizedSum / sum\n * </pre>\n * applied to each non-NaN element x of the input array, where sum is the\n * sum of the non-NaN entries in the input array.\n * <p>\n * Throws IllegalArgumentException if {@code normalizedSum} is infinite\n * or NaN and ArithmeticException if the input array contains any infinite elements\n * or sums to 0.\n * <p>\n * Ignores (i.e., copies unchanged to the output array) NaNs in the input array.\n *\n * @param values Input array to be normalized\n * @param normalizedSum Target sum for the normalized array\n * @return the normalized array.\n * @throws MathArithmeticException if the input array contains infinite\n * elements or sums to zero.\n * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.\n * @since 2.1\n */\npublic static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n    }\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n    }\n    double sum = 0d;\n    final int len = values.length;\n    double[] out = new double[len];\n    for (int i = 0; i < len; i++) {\n        if (Double.isInfinite(values[i])) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n        }\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n    }\n    for (int i = 0; i < len; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Build an array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n *\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param length of the array\n * @return a new array\n * @since 3.2\n */\npublic static <T> T[] buildArray(final Field<T> field, final int length) {\n    // OK because field must be correct class\n    @SuppressWarnings(\"unchecked\")\n    T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);\n    Arrays.fill(array, field.getZero());\n    return array;\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Build a double dimension  array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n *\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param rows number of rows in the array\n * @param columns number of columns (may be negative to build partial\n * arrays in the same way <code>new Field[rows][]</code> works)\n * @return a new array\n * @since 3.2\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n    final T[][] array;\n    if (columns < 0) {\n        T[] dummyRow = buildArray(field, 0);\n        array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n    } else {\n        array = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { rows, columns });\n        for (int i = 0; i < rows; ++i) {\n            Arrays.fill(array[i], field.getZero());\n        }\n    }\n    return array;\n}"
            ],
            [
                "convolve",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the <a href=\"http://en.wikipedia.org/wiki/Convolution\">\n * convolution</a> between two sequences.\n * <p>\n * The solution is obtained via straightforward computation of the\n * convolution sum (and not via FFT). Whenever the computation needs\n * an element that would be located at an index outside the input arrays,\n * the value is assumed to be zero.\n *\n * @param x First sequence.\n * Typically, this sequence will represent an input signal to a system.\n * @param h Second sequence.\n * Typically, this sequence will represent the impulse response of the system.\n * @return the convolution of {@code x} and {@code h}.\n * This array's length will be {@code x.length + h.length - 1}.\n * @throws NullArgumentException if either {@code x} or {@code h} is {@code null}.\n * @throws NoDataException if either {@code x} or {@code h} is empty.\n *\n * @since 3.3\n */\npublic static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(x);\n    MathUtils.checkNotNull(h);\n    final int xLen = x.length;\n    final int hLen = h.length;\n    if (xLen == 0 || hLen == 0) {\n        throw new NoDataException();\n    }\n    // initialize the output array\n    final int totalLength = xLen + hLen - 1;\n    final double[] y = new double[totalLength];\n    // straightforward implementation of the convolution sum\n    for (int n = 0; n < totalLength; n++) {\n        double yn = 0;\n        int k = FastMath.max(0, n + 1 - xLen);\n        int j = n - k;\n        while (k < hLen && j >= 0) {\n            yn += x[j--] * h[k++];\n        }\n        y[n] = yn;\n    }\n    return y;\n}"
            ],
            [
                "natural",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array representing the natural number {@code n}.\n *\n * @param n Natural number.\n * @return an array whose entries are the numbers 0, 1, ..., {@code n}-1.\n * If {@code n == 0}, the returned array is empty.\n */\npublic static int[] natural(int n) {\n    return sequence(n, 0, 1);\n}"
            ],
            [
                "sequence",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array of {@code size} integers starting at {@code start},\n * skipping {@code stride} numbers.\n *\n * @param size Natural number.\n * @param start Natural number.\n * @param stride Natural number.\n * @return an array whose entries are the numbers\n * {@code start, start + stride, ..., start + (size - 1) * stride}.\n * If {@code size == 0}, the returned array is empty.\n *\n * @since 3.4\n */\npublic static int[] sequence(int size, int start, int stride) {\n    final int[] a = new int[size];\n    for (int i = 0; i < size; i++) {\n        a[i] = start + i * stride;\n    }\n    return a;\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the input parameters designate a subarray of positive length.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * positive length</li>\n * <li>throws <code>MathIllegalArgumentException</code> if the array is null or\n * or the indices are invalid</li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0.\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return true if the parameters are valid and designate a subarray of positive length\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return verifyValues(values, begin, length, false);\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the input parameters designate a subarray of positive length.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * non-negative length</li>\n * <li>throws <code>IllegalArgumentException</code> if the array is null or\n * or the indices are invalid</li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @param allowEmpty if <code>true</code> then zero length arrays are allowed\n * @return true if the parameters are valid\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {\n    if (values == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    if (begin < 0) {\n        throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));\n    }\n    if (length < 0) {\n        throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));\n    }\n    if (begin + length > values.length) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END, Integer.valueOf(begin + length), Integer.valueOf(values.length), true);\n    }\n    if (length == 0 && !allowEmpty) {\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the begin and length parameters designate a subarray of positive length\n * and the weights are all non-negative, non-NaN, finite, and not all zero.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * positive length and the weights array contains legitimate values.</li>\n * <li>throws <code>IllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li></ul>\n * </li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0.\n * </ul></p>\n *\n * @param values the input array\n * @param weights the weights array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return true if the parameters are valid and designate a subarray of positive length\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException {\n    return verifyValues(values, weights, begin, length, false);\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the begin and length parameters designate a subarray of positive length\n * and the weights are all non-negative, non-NaN, finite, and not all zero.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * non-negative length and the weights array contains legitimate values.</li>\n * <li>throws <code>MathIllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li></ul>\n * </li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>.\n * </ul></p>\n *\n * @param values the input array.\n * @param weights the weights array.\n * @param begin index of the first array element to include.\n * @param length the number of elements to include.\n * @param allowEmpty if {@code true} than allow zero length arrays to pass.\n * @return {@code true} if the parameters are valid.\n * @throws NullArgumentException if either of the arrays are null\n * @throws MathIllegalArgumentException if the array indices are not valid,\n * the weights array contains NaN, infinite or negative elements, or there\n * are no positive weights.\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {\n    if (weights == null || values == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    checkEqualLength(weights, values);\n    boolean containsPositiveWeight = false;\n    for (int i = begin; i < begin + length; i++) {\n        final double weight = weights[i];\n        if (Double.isNaN(weight)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_ELEMENT_AT_INDEX, Integer.valueOf(i));\n        }\n        if (Double.isInfinite(weight)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, Double.valueOf(weight), Integer.valueOf(i));\n        }\n        if (weight < 0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX, Integer.valueOf(i), Double.valueOf(weight));\n        }\n        if (!containsPositiveWeight && weight > 0.0) {\n            containsPositiveWeight = true;\n        }\n    }\n    if (!containsPositiveWeight) {\n        throw new MathIllegalArgumentException(LocalizedFormats.WEIGHT_AT_LEAST_ONE_NON_ZERO);\n    }\n    return verifyValues(values, begin, length, allowEmpty);\n}"
            ],
            [
                "concatenate",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Concatenates a sequence of arrays. The return array consists of the\n * entries of the input arrays concatenated in the order they appear in\n * the argument list.  Null arrays cause NullPointerExceptions; zero\n * length arrays are allowed (contributing nothing to the output array).\n *\n * @param x list of double[] arrays to concatenate\n * @return a new array consisting of the entries of the argument arrays\n * @throws NullPointerException if any of the arrays are null\n * @since 3.6\n */\npublic static double[] concatenate(double[]... x) {\n    int combinedLength = 0;\n    for (double[] a : x) {\n        combinedLength += a.length;\n    }\n    int offset = 0;\n    int curLength = 0;\n    final double[] combined = new double[combinedLength];\n    for (int i = 0; i < x.length; i++) {\n        curLength = x[i].length;\n        System.arraycopy(x[i], 0, combined, offset, curLength);\n        offset += curLength;\n    }\n    return combined;\n}"
            ],
            [
                "unique",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array consisting of the unique values in {@code data}.\n * The return array is sorted in descending order.  Empty arrays\n * are allowed, but null arrays result in NullPointerException.\n * Infinities are allowed.  NaN values are allowed with maximum\n * sort order - i.e., if there are NaN values in {@code data},\n * {@code Double.NaN} will be the first element of the output array,\n * even if the array also contains {@code Double.POSITIVE_INFINITY}.\n *\n * @param data array to scan\n * @return descending list of values included in the input array\n * @throws NullPointerException if data is null\n * @since 3.6\n */\npublic static double[] unique(double[] data) {\n    TreeSet<Double> values = new TreeSet<Double>();\n    for (int i = 0; i < data.length; i++) {\n        values.add(data[i]);\n    }\n    final int count = values.size();\n    final double[] out = new double[count];\n    Iterator<Double> iterator = values.iterator();\n    int i = 0;\n    while (iterator.hasNext()) {\n        out[count - ++i] = iterator.next();\n    }\n    return out;\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Pair",
                "/**\n * Convenience factory method that calls the\n * {@link #Pair(Object, Object) constructor}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param k First element of the pair.\n * @param v Second element of the pair.\n * @return a new {@code Pair} containing {@code k} and {@code v}.\n * @since 3.3\n */\npublic static <K, V> Pair<K, V> create(K k, V v) {\n    return new Pair<K, V>(k, v);\n}"
            ],
            [
                "slowCos",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n *  For x between 0 and pi/4 compute cosine using Talor series\n *  cos(x) = 1 - x^2/2! + x^4/4! ...\n * @param x number from which cosine is requested\n * @param result placeholder where to put the result in extended precision\n * (may be null)\n * @return cos(x)\n */\nstatic double slowCos(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        if ((i & 1) != 0) {\n            // skip odd entries\n            continue;\n        }\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        if ((i & 2) != 0) {\n            // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowSin",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * For x between 0 and pi/4 compute sine using Taylor expansion:\n * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...\n * @param x number from which sine is requested\n * @param result placeholder where to put the result in extended precision\n * (may be null)\n * @return sin(x)\n */\nstatic double slowSin(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        if ((i & 1) == 0) {\n            // Ignore even numbers\n            continue;\n        }\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        if ((i & 2) != 0) {\n            // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowexp",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n *  For x between 0 and 1, returns exp(x), uses extended precision\n *  @param x argument of exponential\n *  @param result placeholder where to place exp(x) split in two terms\n *  for extra precision (i.e. exp(x) = result[0] + result[1]\n *  @return exp(x)\n */\nstatic double slowexp(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "expint",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * Compute exp(p) for a integer p in extended precision.\n * @param p integer whose exponential is requested\n * @param result placeholder where to put the result in extended precision\n * @return exp(p) in standard precision (equal to result[0] + result[1])\n */\nstatic double expint(int p, final double[] result) {\n    //double x = M_E;\n    final double[] xs = new double[2];\n    final double[] as = new double[2];\n    final double[] ys = new double[2];\n    //split(x, xs);\n    //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n    //xs[0] = 2.71827697753906250000;\n    //xs[1] = 4.85091998273542816811e-06;\n    //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n    //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n    /* E */\n    xs[0] = 2.718281828459045;\n    xs[1] = 1.4456468917292502E-16;\n    split(1.0, ys);\n    while (p > 0) {\n        if ((p & 1) != 0) {\n            quadMult(ys, xs, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n        quadMult(xs, xs, as);\n        xs[0] = as[0];\n        xs[1] = as[1];\n        p >>= 1;\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n        resplit(result);\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowLog",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * xi in the range of [1, 2].\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      1-x           \\          3        5        7          /\n *\n * So, compute a Remez approximation of the following function\n *\n *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n *\n * This will be an even function with only positive coefficents.\n * x is in the range [0 - 1/3].\n *\n * Transform xi for input to the above function by setting\n * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n * the result is multiplied by x.\n * @param xi number from which log is requested\n * @return log(xi)\n */\nstatic double[] slowLog(double xi) {\n    double[] x = new double[2];\n    double[] x2 = new double[2];\n    double[] y = new double[2];\n    double[] a = new double[2];\n    split(xi, x);\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a, y);\n    x[0] = y[0];\n    x[1] = y[1];\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n    //x[0] -= 1.0;\n    //resplit(x);\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][1];\n    for (int i = LN_SPLIT_COEF.length - 2; i >= 0; i--) {\n        splitMult(y, x2, a);\n        y[0] = a[0];\n        y[1] = a[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a);\n        y[0] = a[0];\n        y[1] = a[1];\n    }\n    splitMult(y, x, a);\n    y[0] = a[0];\n    y[1] = a[1];\n    return y;\n}"
            ],
            [
                "format",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * Format a double.\n * @param d double number to format\n * @return formatted number\n */\nstatic String format(double d) {\n    if (d != d) {\n        return \"Double.NaN,\";\n    } else {\n        return ((d >= 0) ? \"+\" : \"\") + Double.toString(d) + \"d,\";\n    }\n}"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the square root of a number.\n * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n * @param a number on which evaluation is done\n * @return square root of a\n */\npublic static double sqrt(final double a) {\n    return Math.sqrt(a);\n}"
            ],
            [
                "cosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic cosine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic cosine of x\n */\npublic static double cosh(double x) {\n    if (x != x) {\n        return x;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        if (x >= LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(x);\n        }\n    } else if (x < -20) {\n        if (x <= -LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(-0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(-x);\n        }\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}"
            ],
            [
                "sinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic sine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic sine of x\n */\npublic static double sinh(double x) {\n    boolean negate = false;\n    if (x != x) {\n        return x;\n    }\n    // sinh[z] = (exp(z) - exp(-z) / 2\n    // for values of z larger than about 20,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        if (x >= LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(x);\n        }\n    } else if (x < -20) {\n        if (x <= -LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(-0.5 * x);\n            return (-0.5 * t) * t;\n        } else {\n            return -0.5 * exp(-x);\n        }\n    }\n    if (x == 0) {\n        return x;\n    }\n    if (x < 0.0) {\n        x = -x;\n        negate = true;\n    }\n    double result;\n    if (x > 0.25) {\n        double[] hiPrec = new double[2];\n        exp(x, 0.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n        // recip = 1/y\n        double recip = 1.0 / ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n        // Correct for rounding in division\n        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n        // Account for yb\n        recipb += -yb * recip * recip;\n        recipa = -recipa;\n        recipb = -recipb;\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n        result = ya + yb;\n        result *= 0.5;\n    } else {\n        double[] hiPrec = new double[2];\n        expm1(x, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n        double denom = 1.0 + ya;\n        double denomr = 1.0 / denom;\n        double denomb = -(denom - 1.0 - ya) + yb;\n        double ratio = ya * denomr;\n        double temp = ratio * HEX_40000000;\n        double ra = ratio + temp - temp;\n        double rb = ratio - ra;\n        temp = denom * HEX_40000000;\n        double za = denom + temp - temp;\n        double zb = denom - za;\n        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n        // Adjust for yb\n        // numerator\n        rb += yb * denomr;\n        // denominator\n        rb += -ya * denomb * denomr * denomr;\n        // y = y - 1/y\n        temp = ya + ra;\n        yb += -(temp - ya - ra);\n        ya = temp;\n        temp = ya + rb;\n        yb += -(temp - ya - rb);\n        ya = temp;\n        result = ya + yb;\n        result *= 0.5;\n    }\n    if (negate) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "tanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic tangent of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic tangent of x\n */\npublic static double tanh(double x) {\n    boolean negate = false;\n    if (x != x) {\n        return x;\n    }\n    // tanh[z] = sinh[z] / cosh[z]\n    // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n    // = (exp(2x) - 1) / (exp(2x) + 1)\n    // for magnitude > 20, sinh[z] == cosh[z] in double precision\n    if (x > 20.0) {\n        return 1.0;\n    }\n    if (x < -20) {\n        return -1.0;\n    }\n    if (x == 0) {\n        return x;\n    }\n    if (x < 0.0) {\n        x = -x;\n        negate = true;\n    }\n    double result;\n    if (x >= 0.5) {\n        double[] hiPrec = new double[2];\n        // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n        exp(x * 2.0, 0.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Numerator */\n        double na = -1.0 + ya;\n        double nb = -(na + 1.0 - ya);\n        double temp = na + yb;\n        nb += -(temp - na - yb);\n        na = temp;\n        /* Denominator */\n        double da = 1.0 + ya;\n        double db = -(da - 1.0 - ya);\n        temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n        result = ratioa + ratiob;\n    } else {\n        double[] hiPrec = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x * 2.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n        result = ratioa + ratiob;\n    }\n    if (negate) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "acosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic cosine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic cosine of a\n */\npublic static double acosh(final double a) {\n    return FastMath.log(a + FastMath.sqrt(a * a - 1));\n}"
            ],
            [
                "asinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic sine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic sine of a\n */\npublic static double asinh(double a) {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAsinh;\n    if (a > 0.167) {\n        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);\n        }\n    }\n    return negative ? -absAsinh : absAsinh;\n}"
            ],
            [
                "atanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic tangent of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic tangent of a\n */\npublic static double atanh(double a) {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.15) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n    return negative ? -absAtanh : absAtanh;\n}"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the signum of a number.\n * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\npublic static double signum(final double a) {\n    // return +0.0/-0.0/NaN depending on a\n    return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a);\n}"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the signum of a number.\n * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\npublic static float signum(final float a) {\n    // return +0.0/-0.0/NaN depending on a\n    return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a);\n}"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\npublic static double nextUp(final double a) {\n    return nextAfter(a, Double.POSITIVE_INFINITY);\n}"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\npublic static float nextUp(final float a) {\n    return nextAfter(a, Float.POSITIVE_INFINITY);\n}"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards negative infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards negative infinity\n * @since 3.4\n */\npublic static double nextDown(final double a) {\n    return nextAfter(a, Double.NEGATIVE_INFINITY);\n}"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards negative infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards negative infinity\n * @since 3.4\n */\npublic static float nextDown(final float a) {\n    return nextAfter(a, Float.NEGATIVE_INFINITY);\n}"
            ],
            [
                "random",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns a pseudo-random number between 0.0 and 1.0.\n * <p><b>Note:</b> this implementation currently delegates to {@link Math#random}\n * @return a random number between 0.0 and 1.0\n */\npublic static double random() {\n    return Math.random();\n}"
            ],
            [
                "exp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Exponential function.\n *\n * Computes exp(x), function result is nearly rounded.   It will be correctly\n * rounded to the theoretical value for 99.9% of input values, otherwise it will\n * have a 1 ULP error.\n *\n * Method:\n *    Lookup intVal = exp(int(x))\n *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );\n *    Compute z as the exponential of the remaining bits by a polynomial minus one\n *    exp(x) = intVal * fracVal * (1 + z)\n *\n * Accuracy:\n *    Calculation is done with 63 bits of precision, so result should be correctly\n *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n *\n * @param x   a double\n * @return double e<sup>x</sup>\n */\npublic static double exp(double x) {\n    return exp(x, 0.0, null);\n}"
            ],
            [
                "expm1",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute exp(x) - 1\n * @param x number to compute shifted exponential\n * @return exp(x) - 1\n */\npublic static double expm1(double x) {\n    return expm1(x, null);\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Natural logarithm.\n *\n * @param x   a double\n * @return log(x)\n */\npublic static double log(final double x) {\n    return log(x, null);\n}"
            ],
            [
                "log1p",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes log(1 + x).\n *\n * @param x Number.\n * @return {@code log(1 + x)}.\n */\npublic static double log1p(final double x) {\n    if (x == -1) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (x == Double.POSITIVE_INFINITY) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (x > 1e-6 || x < -1e-6) {\n        final double xpa = 1 + x;\n        final double xpb = -(xpa - 1 - x);\n        final double[] hiPrec = new double[2];\n        final double lores = log(xpa, hiPrec);\n        if (Double.isInfinite(lores)) {\n            // Don't allow this to be converted to NaN\n            return lores;\n        }\n        // Do a taylor series expansion around xpa:\n        //   f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2\n        final double fx1 = xpb / xpa;\n        final double epsilon = 0.5 * fx1 + 1;\n        return epsilon * fx1 + hiPrec[1] + hiPrec[0];\n    } else {\n        // Value is small |x| < 1e6, do a Taylor series centered on 1.\n        final double y = (x * F_1_3 - F_1_2) * x + 1;\n        return y * x;\n    }\n}"
            ],
            [
                "log10",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the base 10 logarithm.\n * @param x a number\n * @return log10(x)\n */\npublic static double log10(final double x) {\n    final double[] hiPrec = new double[2];\n    final double lores = log(x, hiPrec);\n    if (Double.isInfinite(lores)) {\n        // don't allow this to be converted to NaN\n        return lores;\n    }\n    final double tmp = hiPrec[0] * HEX_40000000;\n    final double lna = hiPrec[0] + tmp - tmp;\n    final double lnb = hiPrec[0] - lna + hiPrec[1];\n    final double rln10a = 0.4342944622039795;\n    final double rln10b = 1.9699272335463627E-8;\n    return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes the <a href=\"http://mathworld.wolfram.com/Logarithm.html\">\n * logarithm</a> in a given base.\n *\n * Returns {@code NaN} if either argument is negative.\n * If {@code base} is 0 and {@code x} is positive, 0 is returned.\n * If {@code base} is positive and {@code x} is 0,\n * {@code Double.NEGATIVE_INFINITY} is returned.\n * If both arguments are 0, the result is {@code NaN}.\n *\n * @param base Base of the logarithm, must be greater than 0.\n * @param x Argument, must be greater than 0.\n * @return the value of the logarithm, i.e. the number {@code y} such that\n * <code>base<sup>y</sup> = x</code>.\n * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double log(double base, double x) {\n    return log(x) / log(base);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Power function.  Compute x^y.\n *\n * @param x   a double\n * @param y   a double\n * @return double\n */\npublic static double pow(final double x, final double y) {\n    if (y == 0) {\n        // y = -0 or y = +0\n        return 1.0;\n    } else {\n        final long yBits = Double.doubleToRawLongBits(y);\n        final int yRawExp = (int) ((yBits & MASK_DOUBLE_EXPONENT) >> 52);\n        final long yRawMantissa = yBits & MASK_DOUBLE_MANTISSA;\n        final long xBits = Double.doubleToRawLongBits(x);\n        final int xRawExp = (int) ((xBits & MASK_DOUBLE_EXPONENT) >> 52);\n        final long xRawMantissa = xBits & MASK_DOUBLE_MANTISSA;\n        if (yRawExp > 1085) {\n            // y is either a very large integral value that does not fit in a long or it is a special number\n            if ((yRawExp == 2047 && yRawMantissa != 0) || (xRawExp == 2047 && xRawMantissa != 0)) {\n                // NaN\n                return Double.NaN;\n            } else if (xRawExp == 1023 && xRawMantissa == 0) {\n                // x = -1.0 or x = +1.0\n                if (yRawExp == 2047) {\n                    // y is infinite\n                    return Double.NaN;\n                } else {\n                    // y is a large even integer\n                    return 1.0;\n                }\n            } else {\n                // the absolute value of x is either greater or smaller than 1.0\n                // if yRawExp == 2047 and mantissa is 0, y = -infinity or y = +infinity\n                // if 1085 < yRawExp < 2047, y is simply a large number, however, due to limited\n                // accuracy, at this magnitude it behaves just like infinity with regards to x\n                if ((y > 0) ^ (xRawExp < 1023)) {\n                    // either y = +infinity (or large engouh) and abs(x) > 1.0\n                    // or     y = -infinity (or large engouh) and abs(x) < 1.0\n                    return Double.POSITIVE_INFINITY;\n                } else {\n                    // either y = +infinity (or large engouh) and abs(x) < 1.0\n                    // or     y = -infinity (or large engouh) and abs(x) > 1.0\n                    return +0.0;\n                }\n            }\n        } else {\n            // y is a regular non-zero number\n            if (yRawExp >= 1023) {\n                // y may be an integral value, which should be handled specifically\n                final long yFullMantissa = IMPLICIT_HIGH_BIT | yRawMantissa;\n                if (yRawExp < 1075) {\n                    // normal number with negative shift that may have a fractional part\n                    final long integralMask = (-1L) << (1075 - yRawExp);\n                    if ((yFullMantissa & integralMask) == yFullMantissa) {\n                        // all fractional bits are 0, the number is really integral\n                        final long l = yFullMantissa >> (1075 - yRawExp);\n                        return FastMath.pow(x, (y < 0) ? -l : l);\n                    }\n                } else {\n                    // normal number with positive shift, always an integral value\n                    // we know it fits in a primitive long because yRawExp > 1085 has been handled above\n                    final long l = yFullMantissa << (yRawExp - 1075);\n                    return FastMath.pow(x, (y < 0) ? -l : l);\n                }\n            }\n            // y is a non-integral value\n            if (x == 0) {\n                // x = -0 or x = +0\n                // the integer powers have already been handled above\n                return y < 0 ? Double.POSITIVE_INFINITY : +0.0;\n            } else if (xRawExp == 2047) {\n                if (xRawMantissa == 0) {\n                    // x = -infinity or x = +infinity\n                    return (y < 0) ? +0.0 : Double.POSITIVE_INFINITY;\n                } else {\n                    // NaN\n                    return Double.NaN;\n                }\n            } else if (x < 0) {\n                // the integer powers have already been handled above\n                return Double.NaN;\n            } else {\n                // this is the general case, for regular fractional numbers x and y\n                // Split y into ya and yb such that y = ya+yb\n                final double tmp = y * HEX_40000000;\n                final double ya = (y + tmp) - tmp;\n                final double yb = y - ya;\n                /* Compute ln(x) */\n                final double[] lns = new double[2];\n                final double lores = log(x, lns);\n                if (Double.isInfinite(lores)) {\n                    // don't allow this to be converted to NaN\n                    return lores;\n                }\n                double lna = lns[0];\n                double lnb = lns[1];\n                /* resplit lns */\n                final double tmp1 = lna * HEX_40000000;\n                final double tmp2 = (lna + tmp1) - tmp1;\n                lnb += lna - tmp2;\n                lna = tmp2;\n                // y*ln(x) = (aa+ab)\n                final double aa = lna * ya;\n                final double ab = lna * yb + lnb * ya + lnb * yb;\n                lna = aa + ab;\n                lnb = -(lna - aa - ab);\n                double z = 1.0 / 120.0;\n                z = z * lnb + (1.0 / 24.0);\n                z = z * lnb + (1.0 / 6.0);\n                z = z * lnb + 0.5;\n                z = z * lnb + 1.0;\n                z *= lnb;\n                final double result = exp(lna, z, null);\n                //result = result + result * z;\n                return result;\n            }\n        }\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Raise a double to an int power.\n *\n * @param d Number to raise.\n * @param e Exponent.\n * @return d<sup>e</sup>\n * @since 3.1\n */\npublic static double pow(double d, int e) {\n    return pow(d, (long) e);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Raise a double to a long power.\n *\n * @param d Number to raise.\n * @param e Exponent.\n * @return d<sup>e</sup>\n * @since 3.6\n */\npublic static double pow(double d, long e) {\n    if (e == 0) {\n        return 1.0;\n    } else if (e > 0) {\n        return new Split(d).pow(e).full;\n    } else {\n        return new Split(d).reciprocal().pow(-e).full;\n    }\n}"
            ],
            [
                "sin",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Sine function.\n *\n * @param x Argument.\n * @return sin(x)\n */\npublic static double sin(double x) {\n    boolean negative = false;\n    int quadrant = 0;\n    double xa;\n    double xb = 0.0;\n    /* Take absolute value of the input */\n    xa = x;\n    if (x < 0) {\n        negative = true;\n        xa = -xa;\n    }\n    /* Check for zero and negative zero */\n    if (xa == 0.0) {\n        long bits = Double.doubleToRawLongBits(x);\n        if (bits < 0) {\n            return -0.0;\n        }\n        return 0.0;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    if (negative) {\n        // Flip bit 1\n        quadrant ^= 2;\n    }\n    switch(quadrant) {\n        case 0:\n            return sinQ(xa, xb);\n        case 1:\n            return cosQ(xa, xb);\n        case 2:\n            return -sinQ(xa, xb);\n        case 3:\n            return -cosQ(xa, xb);\n        default:\n            return Double.NaN;\n    }\n}"
            ],
            [
                "cos",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Cosine function.\n *\n * @param x Argument.\n * @return cos(x)\n */\npublic static double cos(double x) {\n    int quadrant = 0;\n    /* Take absolute value of the input */\n    double xa = x;\n    if (x < 0) {\n        xa = -xa;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    double xb = 0;\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    //if (negative)\n    //  quadrant = (quadrant + 2) % 4;\n    switch(quadrant) {\n        case 0:\n            return cosQ(xa, xb);\n        case 1:\n            return -sinQ(xa, xb);\n        case 2:\n            return -cosQ(xa, xb);\n        case 3:\n            return sinQ(xa, xb);\n        default:\n            return Double.NaN;\n    }\n}"
            ],
            [
                "tan",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Tangent function.\n *\n * @param x Argument.\n * @return tan(x)\n */\npublic static double tan(double x) {\n    boolean negative = false;\n    int quadrant = 0;\n    /* Take absolute value of the input */\n    double xa = x;\n    if (x < 0) {\n        negative = true;\n        xa = -xa;\n    }\n    /* Check for zero and negative zero */\n    if (xa == 0.0) {\n        long bits = Double.doubleToRawLongBits(x);\n        if (bits < 0) {\n            return -0.0;\n        }\n        return 0.0;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    double xb = 0;\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    if (xa > 1.5) {\n        // Accuracy suffers between 1.5 and PI/2\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n        xa = a + b;\n        xb = -(xa - a - b);\n        quadrant ^= 1;\n        negative ^= true;\n    }\n    double result;\n    if ((quadrant & 1) == 0) {\n        result = tanQ(xa, xb, false);\n    } else {\n        result = -tanQ(xa, xb, true);\n    }\n    if (negative) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "atan",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Arctangent function\n *  @param x a number\n *  @return atan(x)\n */\npublic static double atan(double x) {\n    return atan(x, 0.0, false);\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Two arguments arctangent function\n * @param y ordinate\n * @param x abscissa\n * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\n */\npublic static double atan2(double y, double x) {\n    if (x != x || y != y) {\n        return Double.NaN;\n    }\n    if (y == 0) {\n        final double result = x * y;\n        final double invx = 1d / x;\n        final double invy = 1d / y;\n        if (invx == 0) {\n            // X is infinite\n            if (x > 0) {\n                // return +/- 0.0\n                return y;\n            } else {\n                return copySign(Math.PI, y);\n            }\n        }\n        if (x < 0 || invx < 0) {\n            if (y < 0 || invy < 0) {\n                return -Math.PI;\n            } else {\n                return Math.PI;\n            }\n        } else {\n            return result;\n        }\n    }\n    // y cannot now be zero\n    if (y == Double.POSITIVE_INFINITY) {\n        if (x == Double.POSITIVE_INFINITY) {\n            return Math.PI * F_1_4;\n        }\n        if (x == Double.NEGATIVE_INFINITY) {\n            return Math.PI * F_3_4;\n        }\n        return Math.PI * F_1_2;\n    }\n    if (y == Double.NEGATIVE_INFINITY) {\n        if (x == Double.POSITIVE_INFINITY) {\n            return -Math.PI * F_1_4;\n        }\n        if (x == Double.NEGATIVE_INFINITY) {\n            return -Math.PI * F_3_4;\n        }\n        return -Math.PI * F_1_2;\n    }\n    if (x == Double.POSITIVE_INFINITY) {\n        if (y > 0 || 1 / y > 0) {\n            return 0d;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -0d;\n        }\n    }\n    if (x == Double.NEGATIVE_INFINITY) {\n        if (y > 0.0 || 1 / y > 0.0) {\n            return Math.PI;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -Math.PI;\n        }\n    }\n    // Neither y nor x can be infinite or NAN here\n    if (x == 0) {\n        if (y > 0 || 1 / y > 0) {\n            return Math.PI * F_1_2;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -Math.PI * F_1_2;\n        }\n    }\n    // Compute ratio r = y/x\n    final double r = y / x;\n    if (Double.isInfinite(r)) {\n        // bypass calculations that can create NaN\n        return atan(r, 0, x < 0);\n    }\n    double ra = doubleHighPart(r);\n    double rb = r - ra;\n    // Split x\n    final double xa = doubleHighPart(x);\n    final double xb = x - xa;\n    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n    final double temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    if (ra == 0) {\n        // Fix up the sign so atan works correctly\n        ra = copySign(0d, y);\n    }\n    // Call atan\n    final double result = atan(ra, rb, x < 0);\n    return result;\n}"
            ],
            [
                "asin",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the arc sine of a number.\n * @param x number on which evaluation is done\n * @return arc sine of x\n */\npublic static double asin(double x) {\n    if (x != x) {\n        return Double.NaN;\n    }\n    if (x > 1.0 || x < -1.0) {\n        return Double.NaN;\n    }\n    if (x == 1.0) {\n        return Math.PI / 2.0;\n    }\n    if (x == -1.0) {\n        return -Math.PI / 2.0;\n    }\n    if (x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n    /* Split x */\n    double temp = x * HEX_40000000;\n    final double xa = x + temp - temp;\n    final double xb = x - xa;\n    /* Square it */\n    double ya = xa * xa;\n    double yb = xa * xb * 2.0 + xb * xb;\n    /* Subtract from 1 */\n    ya = -ya;\n    yb = -yb;\n    double za = 1.0 + ya;\n    double zb = -(za - 1.0 - ya);\n    temp = za + yb;\n    zb += -(temp - za - yb);\n    za = temp;\n    /* Square root */\n    double y;\n    y = sqrt(za);\n    temp = y * HEX_40000000;\n    ya = y + temp - temp;\n    yb = y - ya;\n    /* Extend precision of sqrt */\n    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);\n    /* Contribution of zb to sqrt */\n    double dx = zb / (2.0 * y);\n    // Compute ratio r = x/y\n    double r = x / y;\n    temp = r * HEX_40000000;\n    double ra = r + temp - temp;\n    double rb = r - ra;\n    // Correct for rounding in division\n    rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y;\n    // Add in effect additional bits of sqrt.\n    rb += -x * dx / y / y;\n    temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    return atan(ra, rb, false);\n}"
            ],
            [
                "acos",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the arc cosine of a number.\n * @param x number on which evaluation is done\n * @return arc cosine of x\n */\npublic static double acos(double x) {\n    if (x != x) {\n        return Double.NaN;\n    }\n    if (x > 1.0 || x < -1.0) {\n        return Double.NaN;\n    }\n    if (x == -1.0) {\n        return Math.PI;\n    }\n    if (x == 1.0) {\n        return 0.0;\n    }\n    if (x == 0) {\n        return Math.PI / 2.0;\n    }\n    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n    /* Split x */\n    double temp = x * HEX_40000000;\n    final double xa = x + temp - temp;\n    final double xb = x - xa;\n    /* Square it */\n    double ya = xa * xa;\n    double yb = xa * xb * 2.0 + xb * xb;\n    /* Subtract from 1 */\n    ya = -ya;\n    yb = -yb;\n    double za = 1.0 + ya;\n    double zb = -(za - 1.0 - ya);\n    temp = za + yb;\n    zb += -(temp - za - yb);\n    za = temp;\n    /* Square root */\n    double y = sqrt(za);\n    temp = y * HEX_40000000;\n    ya = y + temp - temp;\n    yb = y - ya;\n    /* Extend precision of sqrt */\n    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);\n    /* Contribution of zb to sqrt */\n    yb += zb / (2.0 * y);\n    y = ya + yb;\n    yb = -(y - ya - yb);\n    // Compute ratio r = y/x\n    double r = y / x;\n    // Did r overflow?\n    if (Double.isInfinite(r)) {\n        // x is effectively zero\n        // so return the appropriate value\n        return Math.PI / 2;\n    }\n    double ra = doubleHighPart(r);\n    double rb = r - ra;\n    // Correct for rounding in division\n    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n    // Add in effect additional bits of sqrt.\n    rb += yb / x;\n    temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    return atan(ra, rb, x < 0);\n}"
            ],
            [
                "cbrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the cubic root of a number.\n * @param x number on which evaluation is done\n * @return cubic root of x\n */\npublic static double cbrt(double x) {\n    /* Convert input double to bits */\n    long inbits = Double.doubleToRawLongBits(x);\n    int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n    boolean subnormal = false;\n    if (exponent == -1023) {\n        if (x == 0) {\n            return x;\n        }\n        /* Subnormal, so normalize */\n        subnormal = true;\n        // 2^54\n        x *= 1.8014398509481984E16;\n        inbits = Double.doubleToRawLongBits(x);\n        exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n    }\n    if (exponent == 1024) {\n        // Nan or infinity.  Don't care which.\n        return x;\n    }\n    /* Divide the exponent by 3 */\n    int exp3 = exponent / 3;\n    /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\n    double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long) (((exp3 + 1023) & 0x7ff)) << 52);\n    /* This will be a number between 1 and 2 */\n    final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n    /* Estimate the cube root of mant by polynomial */\n    double est = -0.010714690733195933;\n    est = est * mant + 0.0875862700108075;\n    est = est * mant + -0.3058015757857271;\n    est = est * mant + 0.7249995199969751;\n    est = est * mant + 0.5039018405998233;\n    est *= CBRTTWO[exponent % 3 + 2];\n    // est should now be good to about 15 bits of precision.   Do 2 rounds of\n    // Newton's method to get closer,  this should get us full double precision\n    // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n    final double xs = x / (p2 * p2 * p2);\n    est += (xs - est * est * est) / (3 * est * est);\n    est += (xs - est * est * est) / (3 * est * est);\n    // Do one round of Newton's method in extended precision to get the last bit right.\n    double temp = est * HEX_40000000;\n    double ya = est + temp - temp;\n    double yb = est - ya;\n    double za = ya * ya;\n    double zb = ya * yb * 2.0 + yb * yb;\n    temp = za * HEX_40000000;\n    double temp2 = za + temp - temp;\n    zb += za - temp2;\n    za = temp2;\n    zb = za * yb + ya * zb + zb * yb;\n    za *= ya;\n    double na = xs - za;\n    double nb = -(na - xs + za);\n    nb -= zb;\n    est += (na + nb) / (3 * est * est);\n    /* Scale by a power of two, so this is exact. */\n    est *= p2;\n    if (subnormal) {\n        // 2^-18\n        est *= 3.814697265625E-6;\n    }\n    return est;\n}"
            ],
            [
                "toRadians",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n *  Convert degrees to radians, with error of less than 0.5 ULP\n *  @param x angle in degrees\n *  @return x converted into radians\n */\npublic static double toRadians(double x) {\n    if (Double.isInfinite(x) || x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    // These are PI/180 split into high and low order bits\n    final double facta = 0.01745329052209854;\n    final double factb = 1.997844754509471E-9;\n    double xa = doubleHighPart(x);\n    double xb = x - xa;\n    double result = xb * factb + xb * facta + xa * factb + xa * facta;\n    if (result == 0) {\n        // ensure correct sign if calculation underflows\n        result *= x;\n    }\n    return result;\n}"
            ],
            [
                "toDegrees",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n *  Convert radians to degrees, with error of less than 0.5 ULP\n *  @param x angle in radians\n *  @return x converted into degrees\n */\npublic static double toDegrees(double x) {\n    if (Double.isInfinite(x) || x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    // These are 180/PI split into high and low order bits\n    final double facta = 57.2957763671875;\n    final double factb = 3.145894820876798E-6;\n    double xa = doubleHighPart(x);\n    double xb = x - xa;\n    return xb * factb + xb * facta + xa * factb + xa * facta;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static int abs(final int x) {\n    final int i = x >>> 31;\n    return (x ^ (~i + 1)) + i;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static long abs(final long x) {\n    final long l = x >>> 63;\n    // l is one if x negative zero else\n    // ~l+1 is zero if x is positive, -1 if x is negative\n    // x^(~l+1) is x is x is positive, ~x if x is negative\n    // add around\n    return (x ^ (~l + 1)) + l;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static float abs(final float x) {\n    return Float.intBitsToFloat(MASK_NON_SIGN_INT & Float.floatToRawIntBits(x));\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static double abs(double x) {\n    return Double.longBitsToDouble(MASK_NON_SIGN_LONG & Double.doubleToRawLongBits(x));\n}"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\npublic static double ulp(double x) {\n    if (Double.isInfinite(x)) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1));\n}"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\npublic static float ulp(float x) {\n    if (Float.isInfinite(x)) {\n        return Float.POSITIVE_INFINITY;\n    }\n    return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));\n}"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply a double number by a power of 2.\n * @param d number to multiply\n * @param n power of 2\n * @return d &times; 2<sup>n</sup>\n */\npublic static double scalb(final double d, final int n) {\n    // first simple and fast handling when 2^n can be represented using normal numbers\n    if ((n > -1023) && (n < 1024)) {\n        return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n    }\n    // handle special cases\n    if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n        return d;\n    }\n    if (n < -2098) {\n        return (d > 0) ? 0.0 : -0.0;\n    }\n    if (n > 2097) {\n        return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n    }\n    // decompose d\n    final long bits = Double.doubleToRawLongBits(d);\n    final long sign = bits & 0x8000000000000000L;\n    int exponent = ((int) (bits >>> 52)) & 0x7ff;\n    long mantissa = bits & 0x000fffffffffffffL;\n    // compute scaled exponent\n    int scaledExponent = exponent + n;\n    if (n < 0) {\n        // we are really in the case n <= -1023\n        if (scaledExponent > 0) {\n            // both the input and the result are normal numbers, we only adjust the exponent\n            return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n        } else if (scaledExponent > -53) {\n            // the input is a normal number and the result is a subnormal number\n            // recover the hidden mantissa bit\n            mantissa |= 1L << 52;\n            // scales down complete mantissa, hence losing least significant bits\n            final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n            mantissa >>>= 1 - scaledExponent;\n            if (mostSignificantLostBit != 0) {\n                // we need to add 1 bit to round up the result\n                mantissa++;\n            }\n            return Double.longBitsToDouble(sign | mantissa);\n        } else {\n            // no need to compute the mantissa, the number scales down to 0\n            return (sign == 0L) ? 0.0 : -0.0;\n        }\n    } else {\n        // we are really in the case n >= 1024\n        if (exponent == 0) {\n            // the input number is subnormal, normalize it\n            while ((mantissa >>> 52) != 1) {\n                mantissa <<= 1;\n                --scaledExponent;\n            }\n            ++scaledExponent;\n            mantissa &= 0x000fffffffffffffL;\n            if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        } else if (scaledExponent < 2047) {\n            return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n        } else {\n            return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n    }\n}"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply a float number by a power of 2.\n * @param f number to multiply\n * @param n power of 2\n * @return f &times; 2<sup>n</sup>\n */\npublic static float scalb(final float f, final int n) {\n    // first simple and fast handling when 2^n can be represented using normal numbers\n    if ((n > -127) && (n < 128)) {\n        return f * Float.intBitsToFloat((n + 127) << 23);\n    }\n    // handle special cases\n    if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n        return f;\n    }\n    if (n < -277) {\n        return (f > 0) ? 0.0f : -0.0f;\n    }\n    if (n > 276) {\n        return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n    }\n    // decompose f\n    final int bits = Float.floatToIntBits(f);\n    final int sign = bits & 0x80000000;\n    int exponent = (bits >>> 23) & 0xff;\n    int mantissa = bits & 0x007fffff;\n    // compute scaled exponent\n    int scaledExponent = exponent + n;\n    if (n < 0) {\n        // we are really in the case n <= -127\n        if (scaledExponent > 0) {\n            // both the input and the result are normal numbers, we only adjust the exponent\n            return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n        } else if (scaledExponent > -24) {\n            // the input is a normal number and the result is a subnormal number\n            // recover the hidden mantissa bit\n            mantissa |= 1 << 23;\n            // scales down complete mantissa, hence losing least significant bits\n            final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n            mantissa >>>= 1 - scaledExponent;\n            if (mostSignificantLostBit != 0) {\n                // we need to add 1 bit to round up the result\n                mantissa++;\n            }\n            return Float.intBitsToFloat(sign | mantissa);\n        } else {\n            // no need to compute the mantissa, the number scales down to 0\n            return (sign == 0) ? 0.0f : -0.0f;\n        }\n    } else {\n        // we are really in the case n >= 128\n        if (exponent == 0) {\n            // the input number is subnormal, normalize it\n            while ((mantissa >>> 23) != 1) {\n                mantissa <<= 1;\n                --scaledExponent;\n            }\n            ++scaledExponent;\n            mantissa &= 0x007fffff;\n            if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        } else if (scaledExponent < 255) {\n            return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n        } else {\n            return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n    }\n}"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the next machine representable number after a number, moving\n * in the direction of another number.\n * <p>\n * The ordering is as follows (increasing):\n * <ul>\n * <li>-INFINITY</li>\n * <li>-MAX_VALUE</li>\n * <li>-MIN_VALUE</li>\n * <li>-0.0</li>\n * <li>+0.0</li>\n * <li>+MIN_VALUE</li>\n * <li>+MAX_VALUE</li>\n * <li>+INFINITY</li>\n * <li></li>\n * <p>\n * If arguments compare equal, then the second argument is returned.\n * <p>\n * If {@code direction} is greater than {@code d},\n * the smallest machine representable number strictly greater than\n * {@code d} is returned; if less, then the largest representable number\n * strictly less than {@code d} is returned.</p>\n * <p>\n * If {@code d} is infinite and direction does not\n * bring it back to finite numbers, it is returned unchanged.</p>\n *\n * @param d base number\n * @param direction (the only important thing is whether\n * {@code direction} is greater or smaller than {@code d})\n * @return the next machine representable number in the specified direction\n */\npublic static double nextAfter(double d, double direction) {\n    // handling of some important special cases\n    if (Double.isNaN(d) || Double.isNaN(direction)) {\n        return Double.NaN;\n    } else if (d == direction) {\n        return direction;\n    } else if (Double.isInfinite(d)) {\n        return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n    } else if (d == 0) {\n        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n    }\n    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n    // are handled just as normal numbers\n    // can use raw bits since already dealt with infinity and NaN\n    final long bits = Double.doubleToRawLongBits(d);\n    final long sign = bits & 0x8000000000000000L;\n    if ((direction < d) ^ (sign == 0L)) {\n        return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n    } else {\n        return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n    }\n}"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the next machine representable number after a number, moving\n * in the direction of another number.\n * <p>\n * The ordering is as follows (increasing):\n * <ul>\n * <li>-INFINITY</li>\n * <li>-MAX_VALUE</li>\n * <li>-MIN_VALUE</li>\n * <li>-0.0</li>\n * <li>+0.0</li>\n * <li>+MIN_VALUE</li>\n * <li>+MAX_VALUE</li>\n * <li>+INFINITY</li>\n * <li></li>\n * <p>\n * If arguments compare equal, then the second argument is returned.\n * <p>\n * If {@code direction} is greater than {@code f},\n * the smallest machine representable number strictly greater than\n * {@code f} is returned; if less, then the largest representable number\n * strictly less than {@code f} is returned.</p>\n * <p>\n * If {@code f} is infinite and direction does not\n * bring it back to finite numbers, it is returned unchanged.</p>\n *\n * @param f base number\n * @param direction (the only important thing is whether\n * {@code direction} is greater or smaller than {@code f})\n * @return the next machine representable number in the specified direction\n */\npublic static float nextAfter(final float f, final double direction) {\n    // handling of some important special cases\n    if (Double.isNaN(f) || Double.isNaN(direction)) {\n        return Float.NaN;\n    } else if (f == direction) {\n        return (float) direction;\n    } else if (Float.isInfinite(f)) {\n        return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n    } else if (f == 0f) {\n        return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n    }\n    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n    // are handled just as normal numbers\n    final int bits = Float.floatToIntBits(f);\n    final int sign = bits & 0x80000000;\n    if ((direction < f) ^ (sign == 0)) {\n        return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n    } else {\n        return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1));\n    }\n}"
            ],
            [
                "floor",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the largest whole number smaller than x.\n * @param x number from which floor is requested\n * @return a double number f such that f is an integer f <= x < f + 1.0\n */\npublic static double floor(double x) {\n    long y;\n    if (x != x) {\n        // NaN\n        return x;\n    }\n    if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n        return x;\n    }\n    y = (long) x;\n    if (x < 0 && y != x) {\n        y--;\n    }\n    if (y == 0) {\n        return x * y;\n    }\n    return y;\n}"
            ],
            [
                "ceil",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the smallest whole number larger than x.\n * @param x number from which ceil is requested\n * @return a double number c such that c is an integer c - 1.0 < x <= c\n */\npublic static double ceil(double x) {\n    double y;\n    if (x != x) {\n        // NaN\n        return x;\n    }\n    y = floor(x);\n    if (y == x) {\n        return y;\n    }\n    y += 1.0;\n    if (y == 0) {\n        return x * y;\n    }\n    return y;\n}"
            ],
            [
                "rint",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\n * @param x number from which nearest whole number is requested\n * @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5\n */\npublic static double rint(double x) {\n    double y = floor(x);\n    double d = x - y;\n    if (d > 0.5) {\n        if (y == -1.0) {\n            // Preserve sign of operand\n            return -0.0;\n        }\n        return y + 1.0;\n    }\n    if (d < 0.5) {\n        return y;\n    }\n    /* half way, round to even */\n    long z = (long) y;\n    return (z & 1) == 0 ? y : y + 1.0;\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the closest long to x.\n * @param x number from which closest long is requested\n * @return closest long to x\n */\npublic static long round(double x) {\n    return (long) floor(x + 0.5);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the closest int to x.\n * @param x number from which closest int is requested\n * @return closest int to x\n */\npublic static int round(final float x) {\n    return (int) floor(x + 0.5f);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static int min(final int a, final int b) {\n    return (a <= b) ? a : b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static long min(final long a, final long b) {\n    return (a <= b) ? a : b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static float min(final float a, final float b) {\n    if (a > b) {\n        return b;\n    }\n    if (a < b) {\n        return a;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Float.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */\n    int bits = Float.floatToRawIntBits(a);\n    if (bits == 0x80000000) {\n        return a;\n    }\n    return b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static double min(final double a, final double b) {\n    if (a > b) {\n        return b;\n    }\n    if (a < b) {\n        return a;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Double.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n    long bits = Double.doubleToRawLongBits(a);\n    if (bits == 0x8000000000000000L) {\n        return a;\n    }\n    return b;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static int max(final int a, final int b) {\n    return (a <= b) ? b : a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static long max(final long a, final long b) {\n    return (a <= b) ? b : a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static float max(final float a, final float b) {\n    if (a > b) {\n        return a;\n    }\n    if (a < b) {\n        return b;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Float.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */\n    int bits = Float.floatToRawIntBits(a);\n    if (bits == 0x80000000) {\n        return b;\n    }\n    return a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static double max(final double a, final double b) {\n    if (a > b) {\n        return a;\n    }\n    if (a < b) {\n        return b;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Double.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n    long bits = Double.doubleToRawLongBits(a);\n    if (bits == 0x8000000000000000L) {\n        return b;\n    }\n    return a;\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n */\npublic static double hypot(final double x, final double y) {\n    if (Double.isInfinite(x) || Double.isInfinite(y)) {\n        return Double.POSITIVE_INFINITY;\n    } else if (Double.isNaN(x) || Double.isNaN(y)) {\n        return Double.NaN;\n    } else {\n        final int expX = getExponent(x);\n        final int expY = getExponent(y);\n        if (expX > expY + 27) {\n            // y is neglectible with respect to x\n            return abs(x);\n        } else if (expY > expX + 27) {\n            // x is neglectible with respect to y\n            return abs(y);\n        } else {\n            // find an intermediate scale to avoid both overflow and underflow\n            final int middleExp = (expX + expY) / 2;\n            // scale parameters without losing precision\n            final double scaledX = scalb(x, -middleExp);\n            final double scaledY = scalb(y, -middleExp);\n            // compute scaled hypotenuse\n            final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n            // remove scaling\n            return scalb(scaledH, middleExp);\n        }\n    }\n}"
            ],
            [
                "IEEEremainder",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes the remainder as prescribed by the IEEE 754 standard.\n * The remainder value is mathematically equal to {@code x - y*n}\n * where {@code n} is the mathematical integer closest to the exact mathematical value\n * of the quotient {@code x/y}.\n * If two mathematical integers are equally close to {@code x/y} then\n * {@code n} is the integer that is even.\n * <p>\n * <ul>\n * <li>If either operand is NaN, the result is NaN.</li>\n * <li>If the result is not NaN, the sign of the result equals the sign of the dividend.</li>\n * <li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.</li>\n * <li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</li>\n * <li>If the dividend is a zero and the divisor is finite, the result equals the dividend.</li>\n * </ul>\n * <p><b>Note:</b> this implementation currently delegates to {@link StrictMath#IEEEremainder}\n * @param dividend the number to be divided\n * @param divisor the number by which to divide\n * @return the remainder, rounded\n */\npublic static double IEEEremainder(double dividend, double divisor) {\n    // TODO provide our own implementation\n    return StrictMath.IEEEremainder(dividend, divisor);\n}"
            ],
            [
                "toIntExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Convert a long to interger, detecting overflows\n * @param n number to convert to int\n * @return integer with same valie as n if no overflows occur\n * @exception MathArithmeticException if n cannot fit into an int\n * @since 3.4\n */\npublic static int toIntExact(final long n) throws MathArithmeticException {\n    if (n < Integer.MIN_VALUE || n > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    }\n    return (int) n;\n}"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Increment a number, detecting overflows.\n * @param n number to increment\n * @return n+1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int incrementExact(final int n) throws MathArithmeticException {\n    if (n == Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);\n    }\n    return n + 1;\n}"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Increment a number, detecting overflows.\n * @param n number to increment\n * @return n+1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long incrementExact(final long n) throws MathArithmeticException {\n    if (n == Long.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);\n    }\n    return n + 1;\n}"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Decrement a number, detecting overflows.\n * @param n number to decrement\n * @return n-1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int decrementExact(final int n) throws MathArithmeticException {\n    if (n == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);\n    }\n    return n - 1;\n}"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Decrement a number, detecting overflows.\n * @param n number to decrement\n * @return n-1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long decrementExact(final long n) throws MathArithmeticException {\n    if (n == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);\n    }\n    return n - 1;\n}"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Add two numbers, detecting overflows.\n * @param a first number to add\n * @param b second number to add\n * @return a+b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int addExact(final int a, final int b) throws MathArithmeticException {\n    // compute sum\n    final int sum = a + b;\n    // check for overflow\n    if ((a ^ b) >= 0 && (sum ^ b) < 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);\n    }\n    return sum;\n}"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Add two numbers, detecting overflows.\n * @param a first number to add\n * @param b second number to add\n * @return a+b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long addExact(final long a, final long b) throws MathArithmeticException {\n    // compute sum\n    final long sum = a + b;\n    // check for overflow\n    if ((a ^ b) >= 0 && (sum ^ b) < 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);\n    }\n    return sum;\n}"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Subtract two numbers, detecting overflows.\n * @param a first number\n * @param b second number to subtract from a\n * @return a-b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int subtractExact(final int a, final int b) {\n    // compute subtraction\n    final int sub = a - b;\n    // check for overflow\n    if ((a ^ b) < 0 && (sub ^ b) >= 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);\n    }\n    return sub;\n}"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Subtract two numbers, detecting overflows.\n * @param a first number\n * @param b second number to subtract from a\n * @return a-b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long subtractExact(final long a, final long b) {\n    // compute subtraction\n    final long sub = a - b;\n    // check for overflow\n    if ((a ^ b) < 0 && (sub ^ b) >= 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);\n    }\n    return sub;\n}"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply two numbers, detecting overflows.\n * @param a first number to multiply\n * @param b second number to multiply\n * @return a*b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int multiplyExact(final int a, final int b) {\n    if (((b > 0) && (a > Integer.MAX_VALUE / b || a < Integer.MIN_VALUE / b)) || ((b < -1) && (a > Integer.MIN_VALUE / b || a < Integer.MAX_VALUE / b)) || ((b == -1) && (a == Integer.MIN_VALUE))) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);\n    }\n    return a * b;\n}"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply two numbers, detecting overflows.\n * @param a first number to multiply\n * @param b second number to multiply\n * @return a*b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long multiplyExact(final long a, final long b) {\n    if (((b > 0l) && (a > Long.MAX_VALUE / b || a < Long.MIN_VALUE / b)) || ((b < -1l) && (a > Long.MIN_VALUE / b || a < Long.MAX_VALUE / b)) || ((b == -1l) && (a == Long.MIN_VALUE))) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);\n    }\n    return a * b;\n}"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer division when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorMod(int, int)\n * @since 3.4\n */\npublic static int floorDiv(final int a, final int b) throws MathArithmeticException {\n    if (b == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final int m = a % b;\n    if ((a ^ b) >= 0 || m == 0) {\n        // a an b have same sign, or division is exact\n        return a / b;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return (a / b) - 1;\n    }\n}"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer division when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorMod(long, long)\n * @since 3.4\n */\npublic static long floorDiv(final long a, final long b) throws MathArithmeticException {\n    if (b == 0l) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final long m = a % b;\n    if ((a ^ b) >= 0l || m == 0l) {\n        // a an b have same sign, or division is exact\n        return a / b;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return (a / b) - 1l;\n    }\n}"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer modulo when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorDiv(int, int)\n * @since 3.4\n */\npublic static int floorMod(final int a, final int b) throws MathArithmeticException {\n    if (b == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final int m = a % b;\n    if ((a ^ b) >= 0 || m == 0) {\n        // a an b have same sign, or division is exact\n        return m;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return b + m;\n    }\n}"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer modulo when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorDiv(long, long)\n * @since 3.4\n */\npublic static long floorMod(final long a, final long b) {\n    if (b == 0l) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final long m = a % b;\n    if ((a ^ b) >= 0l || m == 0l) {\n        // a an b have same sign, or division is exact\n        return m;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return b + m;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the first argument with the sign of the second argument.\n * A NaN {@code sign} argument is treated as positive.\n *\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\npublic static double copySign(double magnitude, double sign) {\n    // The highest order bit is going to be zero if the\n    // highest order bit of m and s is the same and one otherwise.\n    // So (m^s) will be positive if both m and s have the same sign\n    // and negative otherwise.\n    // don't care about NaN\n    final long m = Double.doubleToRawLongBits(magnitude);\n    final long s = Double.doubleToRawLongBits(sign);\n    if ((m ^ s) >= 0) {\n        return magnitude;\n    }\n    // flip sign\n    return -magnitude;\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the first argument with the sign of the second argument.\n * A NaN {@code sign} argument is treated as positive.\n *\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\npublic static float copySign(float magnitude, float sign) {\n    // The highest order bit is going to be zero if the\n    // highest order bit of m and s is the same and one otherwise.\n    // So (m^s) will be positive if both m and s have the same sign\n    // and negative otherwise.\n    final int m = Float.floatToRawIntBits(magnitude);\n    final int s = Float.floatToRawIntBits(sign);\n    if ((m ^ s) >= 0) {\n        return magnitude;\n    }\n    // flip sign\n    return -magnitude;\n}"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Return the exponent of a double number, removing the bias.\n * <p>\n * For double numbers of the form 2<sup>x</sup>, the unbiased\n * exponent is exactly x.\n * </p>\n * @param d number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\npublic static int getExponent(final double d) {\n    // NaN and Infinite will return 1024 anywho so can use raw bits\n    return (int) ((Double.doubleToRawLongBits(d) >>> 52) & 0x7ff) - 1023;\n}"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Return the exponent of a float number, removing the bias.\n * <p>\n * For float numbers of the form 2<sup>x</sup>, the unbiased\n * exponent is exactly x.\n * </p>\n * @param f number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\npublic static int getExponent(final float f) {\n    // NaN and Infinite will return the same exponent anywho so can use raw bits\n    return ((Float.floatToRawIntBits(f) >>> 23) & 0xff) - 127;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "BigRealField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static BigRealField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "Decimal64Field",
                "/**\n * Returns the unique instance of this class.\n *\n * @return the unique instance of this class\n */\npublic static final Decimal64Field getInstance() {\n    return INSTANCE;\n}"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns an integer hash code representing the given double value.\n *\n * @param value the value to be hashed\n * @return the hash code\n */\npublic static int hash(double value) {\n    return new Double(value).hashCode();\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns {@code true} if the values are equal according to semantics of\n * {@link Double#equals(Object)}.\n *\n * @param x Value\n * @param y Value\n * @return {@code new Double(x).equals(new Double(y))}\n */\npublic static boolean equals(double x, double y) {\n    return new Double(x).equals(new Double(y));\n}"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns an integer hash code representing the given double array.\n *\n * @param value the value to be hashed (may be null)\n * @return the hash code\n * @since 1.2\n */\npublic static int hash(double[] value) {\n    return Arrays.hashCode(value);\n}"
            ],
            [
                "normalizeAngle",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Normalize an angle in a 2&pi; wide interval around a center value.\n * <p>This method has three main uses:</p>\n * <ul>\n *   <li>normalize an angle between 0 and 2&pi;:<br/>\n *       {@code a = MathUtils.normalizeAngle(a, FastMath.PI);}</li>\n *   <li>normalize an angle between -&pi; and +&pi;<br/>\n *       {@code a = MathUtils.normalizeAngle(a, 0.0);}</li>\n *   <li>compute the angle between two defining angular positions:<br>\n *       {@code angle = MathUtils.normalizeAngle(end, start) - start;}</li>\n * </ul>\n * <p>Note that due to numerical accuracy and since &pi; cannot be represented\n * exactly, the result interval is <em>closed</em>, it cannot be half-closed\n * as would be more satisfactory in a purely mathematical view.</p>\n * @param a angle to normalize\n * @param center center of the desired 2&pi; interval for the result\n * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;\n * @since 1.2\n */\npublic static double normalizeAngle(double a, double center) {\n    return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Find the maximum of two field elements.\n * @param <T> the type of the field elements\n * @param e1 first element\n * @param e2 second element\n * @return max(a1, e2)\n * @since 3.6\n */\npublic static <T extends RealFieldElement<T>> T max(final T e1, final T e2) {\n    return e1.subtract(e2).getReal() >= 0 ? e1 : e2;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Find the minimum of two field elements.\n * @param <T> the type of the field elements\n * @param e1 first element\n * @param e2 second element\n * @return min(a1, e2)\n * @since 3.6\n */\npublic static <T extends RealFieldElement<T>> T min(final T e1, final T e2) {\n    return e1.subtract(e2).getReal() >= 0 ? e2 : e1;\n}"
            ],
            [
                "reduce",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * <p>Reduce {@code |a - offset|} to the primary interval\n * {@code [0, |period|)}.</p>\n *\n * <p>Specifically, the value returned is <br/>\n * {@code a - |period| * floor((a - offset) / |period|) - offset}.</p>\n *\n * <p>If any of the parameters are {@code NaN} or infinite, the result is\n * {@code NaN}.</p>\n *\n * @param a Value to reduce.\n * @param period Period.\n * @param offset Value that will be mapped to {@code 0}.\n * @return the value, within the interval {@code [0 |period|)},\n * that corresponds to {@code a}.\n */\npublic static double reduce(double a, double period, double offset) {\n    final double p = FastMath.abs(period);\n    return a - p * FastMath.floor((a - offset) / p) - offset;\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Byte.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static byte copySign(byte magnitude, byte sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Byte.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return (byte) -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Short.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static short copySign(short magnitude, short sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Short.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return (short) -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Integer.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static int copySign(int magnitude, int sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Long.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static long copySign(long magnitude, long sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return -magnitude;\n    }\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getInstance()} with the only customizing that the\n * maximum number of fraction digits is set to 10.\n * @return the default number format.\n */\npublic static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n * customizing that the maximum number of fraction digits is set to 10.\n * @param locale the specific locale used by the format.\n * @return the default number format specific to the given locale.\n */\npublic static NumberFormat getDefaultNumberFormat(final Locale locale) {\n    final NumberFormat nf = NumberFormat.getInstance(locale);\n    nf.setMaximumFractionDigits(10);\n    return nf;\n}"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parses <code>source</code> until a non-whitespace character is found.\n *\n * @param source the string to parse\n * @param pos input/output parsing parameter.\n * @return the first non-whitespace character.\n */\npublic static char parseNextCharacter(final String source, final ParsePosition pos) {\n    int index = pos.getIndex();\n    final int n = source.length();\n    char ret = 0;\n    if (index < n) {\n        char c;\n        do {\n            c = source.charAt(index++);\n        } while (Character.isWhitespace(c) && index < n);\n        pos.setIndex(index);\n        if (index < n) {\n            ret = c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "parseNumber",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parses <code>source</code> for a number.  This method can parse normal,\n * numeric values as well as special values.  These special values include\n * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n *\n * @param source the string to parse\n * @param format the number format used to parse normal, numeric values.\n * @param pos input/output parsing parameter.\n * @return the parsed number.\n */\npublic static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos) {\n    final int startIndex = pos.getIndex();\n    Number number = format.parse(source, pos);\n    final int endIndex = pos.getIndex();\n    // check for error parsing number\n    if (startIndex == endIndex) {\n        // try parsing special numbers\n        final double[] special = { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY };\n        for (int i = 0; i < special.length; ++i) {\n            number = parseNumber(source, special[i], pos);\n            if (number != null) {\n                break;\n            }\n        }\n    }\n    return number;\n}"
            ],
            [
                "parseFixedstring",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parse <code>source</code> for an expected fixed string.\n * @param source the string to parse\n * @param expected expected string\n * @param pos input/output parsing parameter.\n * @return true if the expected string was there\n */\npublic static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos) {\n    final int startIndex = pos.getIndex();\n    final int endIndex = startIndex + expected.length();\n    if ((startIndex >= source.length()) || (endIndex > source.length()) || (source.substring(startIndex, endIndex).compareTo(expected) != 0)) {\n        // set index back to start, error index should be the start index\n        pos.setIndex(startIndex);\n        pos.setErrorIndex(startIndex);\n        return false;\n    }\n    // the string was here\n    pos.setIndex(endIndex);\n    return true;\n}"
            ],
            [
                "formatDouble",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Formats a double value to produce a string.  In general, the value is\n * formatted using the formatting rules of <code>format</code>.  There are\n * three exceptions to this:\n * <ol>\n * <li>NaN is formatted as '(NaN)'</li>\n * <li>Positive infinity is formatted as '(Infinity)'</li>\n * <li>Negative infinity is formatted as '(-Infinity)'</li>\n * </ol>\n *\n * @param value the double to format.\n * @param format the format used.\n * @param toAppendTo where the text is to be appended\n * @param pos On input: an alignment field, if desired. On output: the\n *            offsets of the alignment field\n * @return the value passed in as toAppendTo.\n */\npublic static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos) {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n        toAppendTo.append('(');\n        toAppendTo.append(value);\n        toAppendTo.append(')');\n    } else {\n        format.format(value, toAppendTo, pos);\n    }\n    return toAppendTo;\n}"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Creates a sequence {@code [start .. end]}.\n * It calls {@link #range(int,int,int) range(start, end, 1)}.\n *\n * @param start First value of the range.\n * @param end Last value of the range.\n * @return a range.\n */\npublic static Range range(int start, int end) {\n    return range(start, end, 1);\n}"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Creates a sequence \\( a_i, i < 0 <= n \\)\n * where \\( a_i = start + i * step \\)\n * and \\( n \\) is such that \\( a_n <= max \\) and \\( a_{n+1} > max \\).\n *\n * @param start First value of the range.\n * @param max Last value of the range that satisfies the above\n * construction rule.\n * @param step Increment.\n * @return a range.\n */\npublic static Range range(final int start, final int max, final int step) {\n    return new Range(start, max, step);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Factory method that creates a default instance.\n * The initial and maximal values are set to 0.\n * For the new instance to be useful, the maximal count must be set\n * by calling {@link #withMaximalCount(int) withMaximalCount}.\n *\n * @return an new instance.\n */\npublic static Incrementor create() {\n    return new Incrementor(0, 0, 1, CALLBACK);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Incrementor",
                "/**\n * Factory method that creates a default instance.\n * The initial and maximal values are set to 0.\n * For the new instance to be useful, the maximal count must be set\n * by calling {@link #withMaximalCount(int) withMaximalCount}.\n *\n * @return an new instance.\n */\npublic static Incrementor create() {\n    return new Incrementor(0, 0, 1, CALLBACK);\n}"
            ],
            [
                "loadExpIntA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_INT_A\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpIntA() {\n    return EXP_INT_A.clone();\n}"
            ],
            [
                "loadExpIntB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_INT_B\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpIntB() {\n    return EXP_INT_B.clone();\n}"
            ],
            [
                "loadExpFracA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_FRAC_A\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpFracA() {\n    return EXP_FRAC_A.clone();\n}"
            ],
            [
                "loadExpFracB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_FRAC_B\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpFracB() {\n    return EXP_FRAC_B.clone();\n}"
            ],
            [
                "loadLnMant",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"LN_MANT\".\n *\n * @return a clone of the data array.\n */\nstatic double[][] loadLnMant() {\n    return LN_MANT.clone();\n}"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns an exact representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which all coefficients are\n * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n * {@code Long.MAX_VALUE} a {@code MathArithMeticException} is\n * thrown.</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    // Use symmetry for large k\n    if (k > n / 2) {\n        return binomialCoefficient(n, n - k);\n    }\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    long result = 1;\n    if (n <= 61) {\n        // For n <= 61, the naive implementation cannot overflow.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            result = result * i / j;\n            i++;\n        }\n    } else if (n <= 66) {\n        // For n > 61 but n <= 66, the result cannot overflow,\n        // but we must take care not to overflow intermediate values.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            // We know that (result * i) is divisible by j,\n            // but (result * i) may overflow, so we split j:\n            // Filter out the gcd, d, so j/d and i/d are integer.\n            // result is divisible by (j/d) because (j/d)\n            // is relative prime to (i/d) and is a divisor of\n            // result * (i/d).\n            final long d = ArithmeticUtils.gcd(i, j);\n            result = (result / (j / d)) * (i / d);\n            i++;\n        }\n    } else {\n        // For n > 66, a result overflow might occur, so we check\n        // the multiplication, taking care to not overflow\n        // unnecessary.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            final long d = ArithmeticUtils.gcd(i, j);\n            result = ArithmeticUtils.mulAndCheck(result / (j / d), i / d);\n            i++;\n        }\n    }\n    return result;\n}"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns a {@code double} representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code double}. The\n * largest value of {@code n} for which all coefficients are less than\n * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n * Double.POSITIVE_INFINITY is returned</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 1d;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    if (k > n / 2) {\n        return binomialCoefficientDouble(n, n - k);\n    }\n    if (n < 67) {\n        return binomialCoefficient(n, k);\n    }\n    double result = 1d;\n    for (int i = 1; i <= k; i++) {\n        result *= (double) (n - k + i) / (double) i;\n    }\n    return FastMath.floor(result + 0.5);\n}"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns the natural {@code log} of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 0;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return FastMath.log(n);\n    }\n    /*\n         * For values small enough to do exact integer computation,\n         * return the log of the exact value\n         */\n    if (n < 67) {\n        return FastMath.log(binomialCoefficient(n, k));\n    }\n    /*\n         * Return the log of binomialCoefficientDouble for values that will not\n         * overflow binomialCoefficientDouble\n         */\n    if (n < 1030) {\n        return FastMath.log(binomialCoefficientDouble(n, k));\n    }\n    if (k > n / 2) {\n        return binomialCoefficientLog(n, n - k);\n    }\n    /*\n         * Sum logs for values that could overflow\n         */\n    double logSum = 0;\n    // n!/(n-k)!\n    for (int i = n - k + 1; i <= n; i++) {\n        logSum += FastMath.log(i);\n    }\n    // divide by k!\n    for (int i = 2; i <= k; i++) {\n        logSum -= FastMath.log(i);\n    }\n    return logSum;\n}"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns n!. Shorthand for {@code n} <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers {@code 1,...,n}.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code n >= 0} (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which {@code n!} does not exceed\n * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n * an {@code MathArithMeticException } is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return {@code n!}\n * @throws MathArithmeticException if the result is too large to be represented\n * by a {@code long}.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n * large to fit in a {@code long}.\n */\npublic static long factorial(final int n) throws NotPositiveException, MathArithmeticException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n > 20) {\n        throw new MathArithmeticException();\n    }\n    return FACTORIALS[n];\n}"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n * {@code double}.\n * The result should be small enough to fit into a {@code double}: The\n * largest {@code n} for which {@code n!} does not exceed\n * {@code Double.MAX_VALUE} is 170. If the computed value exceeds\n * {@code Double.MAX_VALUE}, {@code Double.POSITIVE_INFINITY} is returned.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n */\npublic static double factorialDouble(final int n) throws NotPositiveException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n < 21) {\n        return FACTORIALS[n];\n    }\n    return FastMath.floor(FastMath.exp(CombinatoricsUtils.factorialLog(n)) + 0.5);\n}"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Compute the natural logarithm of the factorial of {@code n}.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n */\npublic static double factorialLog(final int n) throws NotPositiveException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n < 21) {\n        return FastMath.log(FACTORIALS[n]);\n    }\n    double logSum = 0;\n    for (int i = 2; i <= n; i++) {\n        logSum += FastMath.log(i);\n    }\n    return logSum;\n}"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns the <a\n * href=\"http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html\">\n * Stirling number of the second kind</a>, \"{@code S(n,k)}\", the number of\n * ways of partitioning an {@code n}-element set into {@code k} non-empty\n * subsets.\n * <p>\n * The preconditions are {@code 0 <= k <= n } (otherwise\n * {@code NotPositiveException} is thrown)\n * </p>\n * @param n the size of the set\n * @param k the number of non-empty subsets\n * @return {@code S(n,k)}\n * @throws NotPositiveException if {@code k < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\n * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)\n * @since 3.1\n */\npublic static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    if (k < 0) {\n        throw new NotPositiveException(k);\n    }\n    if (k > n) {\n        throw new NumberIsTooLargeException(k, n, true);\n    }\n    long[][] stirlingS2 = STIRLING_S2.get();\n    if (stirlingS2 == null) {\n        // the cache has never been initialized, compute the first numbers\n        // by direct recurrence relation\n        // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n        // we must stop computation at row 26\n        final int maxIndex = 26;\n        stirlingS2 = new long[maxIndex][];\n        stirlingS2[0] = new long[] { 1l };\n        for (int i = 1; i < stirlingS2.length; ++i) {\n            stirlingS2[i] = new long[i + 1];\n            stirlingS2[i][0] = 0;\n            stirlingS2[i][1] = 1;\n            stirlingS2[i][i] = 1;\n            for (int j = 2; j < i; ++j) {\n                stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n            }\n        }\n        // atomically save the cache\n        STIRLING_S2.compareAndSet(null, stirlingS2);\n    }\n    if (n < stirlingS2.length) {\n        // the number is in the small cache\n        return stirlingS2[n][k];\n    } else {\n        // use explicit formula to compute the number without caching it\n        if (k == 0) {\n            return 0;\n        } else if (k == 1 || k == n) {\n            return 1;\n        } else if (k == 2) {\n            return (1l << (n - 1)) - 1l;\n        } else if (k == n - 1) {\n            return binomialCoefficient(n, 2);\n        } else {\n            // definition formula: note that this may trigger some overflow\n            long sum = 0;\n            long sign = ((k & 0x1) == 0) ? 1 : -1;\n            for (int j = 1; j <= k; ++j) {\n                sign = -sign;\n                sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                if (sum < 0) {\n                    // there was an overflow somewhere\n                    throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN, n, 0, stirlingS2.length - 1);\n                }\n            }\n            return sum / factorial(k);\n        }\n    }\n}"
            ],
            [
                "combinationsIterator",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns an iterator whose range is the k-element subsets of {0, ..., n - 1}\n * represented as {@code int[]} arrays.\n * <p>\n * The arrays returned by the iterator are sorted in descending order and\n * they are visited in lexicographic order with significance from right to\n * left. For example, combinationsIterator(4, 2) returns an Iterator that\n * will generate the following sequence of arrays on successive calls to\n * {@code next()}:</p><p>\n * {@code [0, 1], [0, 2], [1, 2], [0, 3], [1, 3], [2, 3]}\n * </p><p>\n * If {@code k == 0} an Iterator containing an empty array is returned and\n * if {@code k == n} an Iterator containing [0, ..., n -1] is returned.</p>\n *\n * @param n Size of the set from which subsets are selected.\n * @param k Size of the subsets to be enumerated.\n * @return an {@link Iterator iterator} over the k-sets in n.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n */\npublic static Iterator<int[]> combinationsIterator(int n, int k) {\n    return new Combinations(n, k).iterator();\n}"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Add two integers, checking for overflow.\n *\n * @param x an addend\n * @param y an addend\n * @return the sum {@code x+y}\n * @throws MathArithmeticException if the result can not be represented\n * as an {@code int}.\n * @since 1.1\n */\npublic static int addAndCheck(int x, int y) throws MathArithmeticException {\n    long s = (long) x + (long) y;\n    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n    }\n    return (int) s;\n}"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Add two long integers, checking for overflow.\n *\n * @param a an addend\n * @param b an addend\n * @return the sum {@code a+b}\n * @throws MathArithmeticException if the result can not be represented as an long\n * @since 1.2\n */\npublic static long addAndCheck(long a, long b) throws MathArithmeticException {\n    return addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n}"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns an exact representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which all coefficients are\n * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n * {@code Long.MAX_VALUE} an {@code ArithMeticException} is\n * thrown.</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficient(int, int)}\n */\n@Deprecated\npublic static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficient(n, k);\n}"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns a {@code double} representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code double}. The\n * largest value of {@code n} for which all coefficients are <\n * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n * Double.POSITIVE_INFINITY is returned</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficientDouble(int, int)}\n */\n@Deprecated\npublic static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficientDouble(n, k);\n}"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns the natural {@code log} of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficientLog(int, int)}\n */\n@Deprecated\npublic static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficientLog(n, k);\n}"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns n!. Shorthand for {@code n} <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers {@code 1,...,n}.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code n >= 0} (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which {@code n!} <\n * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n * an {@code ArithMeticException } is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return {@code n!}\n * @throws MathArithmeticException if the result is too large to be represented\n * by a {@code long}.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n * large to fit in a {@code long}.\n * @deprecated use {@link CombinatoricsUtils#factorial(int)}\n */\n@Deprecated\npublic static long factorial(final int n) throws NotPositiveException, MathArithmeticException {\n    return CombinatoricsUtils.factorial(n);\n}"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n * {@code double}.\n * The result should be small enough to fit into a {@code double}: The\n * largest {@code n} for which {@code n! < Double.MAX_VALUE} is 170.\n * If the computed value exceeds {@code Double.MAX_VALUE},\n * {@code Double.POSITIVE_INFINITY} is returned.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n * @deprecated use {@link CombinatoricsUtils#factorialDouble(int)}\n */\n@Deprecated\npublic static double factorialDouble(final int n) throws NotPositiveException {\n    return CombinatoricsUtils.factorialDouble(n);\n}"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Compute the natural logarithm of the factorial of {@code n}.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n * @deprecated use {@link CombinatoricsUtils#factorialLog(int)}\n */\n@Deprecated\npublic static double factorialLog(final int n) throws NotPositiveException {\n    return CombinatoricsUtils.factorialLog(n);\n}"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Computes the greatest common divisor of the absolute value of two\n * numbers, using a modified version of the \"binary gcd\" method.\n * See Knuth 4.5.2 algorithm B.\n * The algorithm is due to Josef Stein (1961).\n * <br/>\n * Special cases:\n * <ul>\n *  <li>The invocations\n *   {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n *   {@code gcd(Integer.MIN_VALUE, 0)} and\n *   {@code gcd(0, Integer.MIN_VALUE)} throw an\n *   {@code ArithmeticException}, because the result would be 2^31, which\n *   is too large for an int value.</li>\n *  <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n *   {@code gcd(x, 0)} is the absolute value of {@code x}, except\n *   for the special cases above.</li>\n *  <li>The invocation {@code gcd(0, 0)} is the only one which returns\n *   {@code 0}.</li>\n * </ul>\n *\n * @param p Number.\n * @param q Number.\n * @return the greatest common divisor (never negative).\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code int} value.\n * @since 1.1\n */\npublic static int gcd(int p, int q) throws MathArithmeticException {\n    int a = p;\n    int b = q;\n    if (a == 0 || b == 0) {\n        if (a == Integer.MIN_VALUE || b == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return FastMath.abs(a + b);\n    }\n    long al = a;\n    long bl = b;\n    boolean useLong = false;\n    if (a < 0) {\n        if (Integer.MIN_VALUE == a) {\n            useLong = true;\n        } else {\n            a = -a;\n        }\n        al = -al;\n    }\n    if (b < 0) {\n        if (Integer.MIN_VALUE == b) {\n            useLong = true;\n        } else {\n            b = -b;\n        }\n        bl = -bl;\n    }\n    if (useLong) {\n        if (al == bl) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        long blbu = bl;\n        bl = al;\n        al = blbu % al;\n        if (al == 0) {\n            if (bl > Integer.MAX_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n            }\n            return (int) bl;\n        }\n        blbu = bl;\n        // Now \"al\" and \"bl\" fit in an \"int\".\n        b = (int) al;\n        a = (int) (blbu % al);\n    }\n    return gcdPositive(a, b);\n}"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Gets the greatest common divisor of the absolute value of two numbers,\n * using the \"binary gcd\" method which avoids division and modulo\n * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n * Stein (1961).\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations\n * {@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)},\n * {@code gcd(Long.MIN_VALUE, 0L)} and\n * {@code gcd(0L, Long.MIN_VALUE)} throw an\n * {@code ArithmeticException}, because the result would be 2^63, which\n * is too large for a long value.</li>\n * <li>The result of {@code gcd(x, x)}, {@code gcd(0L, x)} and\n * {@code gcd(x, 0L)} is the absolute value of {@code x}, except\n * for the special cases above.\n * <li>The invocation {@code gcd(0L, 0L)} is the only one which returns\n * {@code 0L}.</li>\n * </ul>\n *\n * @param p Number.\n * @param q Number.\n * @return the greatest common divisor, never negative.\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code long} value.\n * @since 2.1\n */\npublic static long gcd(final long p, final long q) throws MathArithmeticException {\n    long u = p;\n    long v = q;\n    if ((u == 0) || (v == 0)) {\n        if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);\n        }\n        return FastMath.abs(u) + FastMath.abs(v);\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^63, while positive numbers can only be as large as 2^63-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    /* assert u!=0 && v!=0; */\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 63) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 63) {\n        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    long t = ((u & 1) == 1) ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1L << k);\n}"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Returns the least common multiple of the absolute value of two numbers,\n * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations {@code lcm(Integer.MIN_VALUE, n)} and\n * {@code lcm(n, Integer.MIN_VALUE)}, where {@code abs(n)} is a\n * power of 2, throw an {@code ArithmeticException}, because the result\n * would be 2^31, which is too large for an int value.</li>\n * <li>The result of {@code lcm(0, x)} and {@code lcm(x, 0)} is\n * {@code 0} for any {@code x}.\n * </ul>\n *\n * @param a Number.\n * @param b Number.\n * @return the least common multiple, never negative.\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code int} value.\n * @since 1.1\n */\npublic static int lcm(int a, int b) throws MathArithmeticException {\n    if (a == 0 || b == 0) {\n        return 0;\n    }\n    int lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));\n    if (lcm == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS, a, b);\n    }\n    return lcm;\n}"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Returns the least common multiple of the absolute value of two numbers,\n * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations {@code lcm(Long.MIN_VALUE, n)} and\n * {@code lcm(n, Long.MIN_VALUE)}, where {@code abs(n)} is a\n * power of 2, throw an {@code ArithmeticException}, because the result\n * would be 2^63, which is too large for an int value.</li>\n * <li>The result of {@code lcm(0L, x)} and {@code lcm(x, 0L)} is\n * {@code 0L} for any {@code x}.\n * </ul>\n *\n * @param a Number.\n * @param b Number.\n * @return the least common multiple, never negative.\n * @throws MathArithmeticException if the result cannot be represented\n * as a non-negative {@code long} value.\n * @since 2.1\n */\npublic static long lcm(long a, long b) throws MathArithmeticException {\n    if (a == 0 || b == 0) {\n        return 0;\n    }\n    long lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));\n    if (lcm == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS, a, b);\n    }\n    return lcm;\n}"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Multiply two integers, checking for overflow.\n *\n * @param x Factor.\n * @param y Factor.\n * @return the product {@code x * y}.\n * @throws MathArithmeticException if the result can not be\n * represented as an {@code int}.\n * @since 1.1\n */\npublic static int mulAndCheck(int x, int y) throws MathArithmeticException {\n    long m = ((long) x) * ((long) y);\n    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n        throw new MathArithmeticException();\n    }\n    return (int) m;\n}"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Multiply two long integers, checking for overflow.\n *\n * @param a Factor.\n * @param b Factor.\n * @return the product {@code a * b}.\n * @throws MathArithmeticException if the result can not be represented\n * as a {@code long}.\n * @since 1.2\n */\npublic static long mulAndCheck(long a, long b) throws MathArithmeticException {\n    long ret;\n    if (a > b) {\n        // use symmetry to reduce boundary cases\n        ret = mulAndCheck(b, a);\n    } else {\n        if (a < 0) {\n            if (b < 0) {\n                // check for positive overflow with negative a, negative b\n                if (a >= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new MathArithmeticException();\n                }\n            } else if (b > 0) {\n                // check for negative overflow with negative a, positive b\n                if (Long.MIN_VALUE / b <= a) {\n                    ret = a * b;\n                } else {\n                    throw new MathArithmeticException();\n                }\n            } else {\n                // assert b == 0\n                ret = 0;\n            }\n        } else if (a > 0) {\n            // assert a > 0\n            // assert b > 0\n            // check for positive overflow with positive a, positive b\n            if (a <= Long.MAX_VALUE / b) {\n                ret = a * b;\n            } else {\n                throw new MathArithmeticException();\n            }\n        } else {\n            // assert a == 0\n            ret = 0;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Subtract two integers, checking for overflow.\n *\n * @param x Minuend.\n * @param y Subtrahend.\n * @return the difference {@code x - y}.\n * @throws MathArithmeticException if the result can not be represented\n * as an {@code int}.\n * @since 1.1\n */\npublic static int subAndCheck(int x, int y) throws MathArithmeticException {\n    long s = (long) x - (long) y;\n    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n    }\n    return (int) s;\n}"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Subtract two long integers, checking for overflow.\n *\n * @param a Value.\n * @param b Value.\n * @return the difference {@code a - b}.\n * @throws MathArithmeticException if the result can not be represented as a\n * {@code long}.\n * @since 1.2\n */\npublic static long subAndCheck(long a, long b) throws MathArithmeticException {\n    long ret;\n    if (b == Long.MIN_VALUE) {\n        if (a < 0) {\n            ret = a - b;\n        } else {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);\n        }\n    } else {\n        // use additive inverse\n        ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n    }\n    return ret;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise an int to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return \\( k^e \\)\n * @throws NotPositiveException if {@code e < 0}.\n * @throws MathArithmeticException if the result would overflow.\n */\npublic static int pow(final int k, final int e) throws NotPositiveException, MathArithmeticException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    try {\n        int exp = e;\n        int result = 1;\n        int k2p = k;\n        while (true) {\n            if ((exp & 0x1) != 0) {\n                result = mulAndCheck(result, k2p);\n            }\n            exp >>= 1;\n            if (exp == 0) {\n                break;\n            }\n            k2p = mulAndCheck(k2p, k2p);\n        }\n        return result;\n    } catch (MathArithmeticException mae) {\n        // Add context information.\n        mae.getContext().addMessage(LocalizedFormats.OVERFLOW);\n        mae.getContext().addMessage(LocalizedFormats.BASE, k);\n        mae.getContext().addMessage(LocalizedFormats.EXPONENT, e);\n        // Rethrow.\n        throw mae;\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise an int to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n * @deprecated As of 3.3. Please use {@link #pow(int,int)} instead.\n */\n@Deprecated\npublic static int pow(final int k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    int result = 1;\n    int k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result *= k2p;\n        }\n        k2p *= k2p;\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a long to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return \\( k^e \\)\n * @throws NotPositiveException if {@code e < 0}.\n * @throws MathArithmeticException if the result would overflow.\n */\npublic static long pow(final long k, final int e) throws NotPositiveException, MathArithmeticException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    try {\n        int exp = e;\n        long result = 1;\n        long k2p = k;\n        while (true) {\n            if ((exp & 0x1) != 0) {\n                result = mulAndCheck(result, k2p);\n            }\n            exp >>= 1;\n            if (exp == 0) {\n                break;\n            }\n            k2p = mulAndCheck(k2p, k2p);\n        }\n        return result;\n    } catch (MathArithmeticException mae) {\n        // Add context information.\n        mae.getContext().addMessage(LocalizedFormats.OVERFLOW);\n        mae.getContext().addMessage(LocalizedFormats.BASE, k);\n        mae.getContext().addMessage(LocalizedFormats.EXPONENT, e);\n        // Rethrow.\n        throw mae;\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a long to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n * @deprecated As of 3.3. Please use {@link #pow(long,int)} instead.\n */\n@Deprecated\npublic static long pow(final long k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    long result = 1l;\n    long k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result *= k2p;\n        }\n        k2p *= k2p;\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, int e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    return k.pow(e);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    BigInteger result = BigInteger.ONE;\n    BigInteger k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result = result.multiply(k2p);\n        }\n        k2p = k2p.multiply(k2p);\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to a BigInteger power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException {\n    if (e.compareTo(BigInteger.ZERO) < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    BigInteger result = BigInteger.ONE;\n    BigInteger k2p = k;\n    while (!BigInteger.ZERO.equals(e)) {\n        if (e.testBit(0)) {\n            result = result.multiply(k2p);\n        }\n        k2p = k2p.multiply(k2p);\n        e = e.shiftRight(1);\n    }\n    return result;\n}"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns the <a\n * href=\"http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html\">\n * Stirling number of the second kind</a>, \"{@code S(n,k)}\", the number of\n * ways of partitioning an {@code n}-element set into {@code k} non-empty\n * subsets.\n * <p>\n * The preconditions are {@code 0 <= k <= n } (otherwise\n * {@code NotPositiveException} is thrown)\n * </p>\n * @param n the size of the set\n * @param k the number of non-empty subsets\n * @return {@code S(n,k)}\n * @throws NotPositiveException if {@code k < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\n * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)\n * @since 3.1\n * @deprecated use {@link CombinatoricsUtils#stirlingS2(int, int)}\n */\n@Deprecated\npublic static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.stirlingS2(n, k);\n}"
            ],
            [
                "isPowerOfTwo",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns true if the argument is a power of two.\n *\n * @param n the number to test\n * @return true if the argument is a power of two\n */\npublic static boolean isPowerOfTwo(long n) {\n    return (n > 0) && ((n & (n - 1)) == 0);\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Get the set of locales for which complex formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static ComplexFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static ComplexFormat getInstance(Locale locale) {\n    NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n    return new ComplexFormat(f);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @param imaginaryCharacter Imaginary character.\n * @return the complex format specific to the given locale.\n * @throws NullArgumentException if {@code imaginaryCharacter} is\n * {@code null}.\n * @throws NoDataException if {@code imaginaryCharacter} is an\n * empty string.\n */\npublic static ComplexFormat getInstance(String imaginaryCharacter, Locale locale) throws NullArgumentException, NoDataException {\n    NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n    return new ComplexFormat(imaginaryCharacter, f);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static ComplexField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Returns the Hamilton product of two quaternions.\n *\n * @param q1 First quaternion.\n * @param q2 Second quaternion.\n * @return the product {@code q1} and {@code q2}, in that order.\n */\npublic static Quaternion multiply(final Quaternion q1, final Quaternion q2) {\n    // Components of the first quaternion.\n    final double q1a = q1.getQ0();\n    final double q1b = q1.getQ1();\n    final double q1c = q1.getQ2();\n    final double q1d = q1.getQ3();\n    // Components of the second quaternion.\n    final double q2a = q2.getQ0();\n    final double q2b = q2.getQ1();\n    final double q2c = q2.getQ2();\n    final double q2d = q2.getQ3();\n    // Components of the product.\n    final double w = q1a * q2a - q1b * q2b - q1c * q2c - q1d * q2d;\n    final double x = q1a * q2b + q1b * q2a + q1c * q2d - q1d * q2c;\n    final double y = q1a * q2c - q1b * q2d + q1c * q2a + q1d * q2b;\n    final double z = q1a * q2d + q1b * q2c - q1c * q2b + q1d * q2a;\n    return new Quaternion(w, x, y, z);\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Computes the sum of two quaternions.\n *\n * @param q1 Quaternion.\n * @param q2 Quaternion.\n * @return the sum of {@code q1} and {@code q2}.\n */\npublic static Quaternion add(final Quaternion q1, final Quaternion q2) {\n    return new Quaternion(q1.getQ0() + q2.getQ0(), q1.getQ1() + q2.getQ1(), q1.getQ2() + q2.getQ2(), q1.getQ3() + q2.getQ3());\n}"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Subtracts two quaternions.\n *\n * @param q1 First Quaternion.\n * @param q2 Second quaternion.\n * @return the difference between {@code q1} and {@code q2}.\n */\npublic static Quaternion subtract(final Quaternion q1, final Quaternion q2) {\n    return new Quaternion(q1.getQ0() - q2.getQ0(), q1.getQ1() - q2.getQ1(), q1.getQ2() - q2.getQ2(), q1.getQ3() - q2.getQ3());\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Computes the dot-product of two quaternions.\n *\n * @param q1 Quaternion.\n * @param q2 Quaternion.\n * @return the dot product of {@code q1} and {@code q2}.\n */\npublic static double dotProduct(final Quaternion q1, final Quaternion q2) {\n    return q1.getQ0() * q2.getQ0() + q1.getQ1() * q2.getQ1() + q1.getQ2() * q2.getQ2() + q1.getQ3() * q2.getQ3();\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Test for the floating-point equality between Complex objects.\n * It returns {@code true} if both arguments are equal or within the\n * range of allowed error (inclusive).\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between the real (resp. imaginary) parts of {@code x} and\n * {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between the real (resp. imaginary) parts of {@code x}\n * and {@code y}.\n *\n * @see Precision#equals(double,double,int)\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y, int maxUlps) {\n    return Precision.equals(x.real, y.real, maxUlps) && Precision.equals(x.imaginary, y.imaginary, maxUlps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} iff the values are equal as defined by\n * {@link #equals(Complex,Complex,int) equals(x, y, 1)}.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @return {@code true} if the values are equal.\n *\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} if, both for the real part and for the imaginary\n * part, there is no double value strictly between the arguments or the\n * difference between them is within the range of allowed error\n * (inclusive).  Returns {@code false} if either of the arguments is NaN.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param eps Amount of allowed absolute error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n *\n * @see Precision#equals(double,double,double)\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y, double eps) {\n    return Precision.equals(x.real, y.real, eps) && Precision.equals(x.imaginary, y.imaginary, eps);\n}"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} if, both for the real part and for the imaginary\n * part, there is no double value strictly between the arguments or the\n * relative difference between them is smaller or equal to the given\n * tolerance. Returns {@code false} if either of the arguments is NaN.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param eps Amount of allowed relative error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n *\n * @see Precision#equalsWithRelativeTolerance(double,double,double)\n * @since 3.3\n */\npublic static boolean equalsWithRelativeTolerance(Complex x, Complex y, double eps) {\n    return Precision.equalsWithRelativeTolerance(x.real, y.real, eps) && Precision.equalsWithRelativeTolerance(x.imaginary, y.imaginary, eps);\n}"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Create a complex number given the real and imaginary parts.\n *\n * @param realPart Real part.\n * @param imaginaryPart Imaginary part.\n * @return a Complex instance.\n */\npublic static Complex valueOf(double realPart, double imaginaryPart) {\n    if (Double.isNaN(realPart) || Double.isNaN(imaginaryPart)) {\n        return NaN;\n    }\n    return new Complex(realPart, imaginaryPart);\n}"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Create a complex number given only the real part.\n *\n * @param realPart Real part.\n * @return a Complex instance.\n */\npublic static Complex valueOf(double realPart) {\n    if (Double.isNaN(realPart)) {\n        return NaN;\n    }\n    return new Complex(realPart);\n}"
            ],
            [
                "polar2Complex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "/**\n * Creates a complex number from the given polar representation.\n * <p>\n * The value returned is <code>r&middot;e<sup>i&middot;theta</sup></code>,\n * computed as <code>r&middot;cos(theta) + r&middot;sin(theta)i</code></p>\n * <p>\n * If either <code>r</code> or <code>theta</code> is NaN, or\n * <code>theta</code> is infinite, {@link Complex#NaN} is returned.</p>\n * <p>\n * If <code>r</code> is infinite and <code>theta</code> is finite,\n * infinite or NaN values may be returned in parts of the result, following\n * the rules for double arithmetic.<pre>\n * Examples:\n * <code>\n * polar2Complex(INFINITY, &pi;/4) = INFINITY + INFINITY i\n * polar2Complex(INFINITY, 0) = INFINITY + NaN i\n * polar2Complex(INFINITY, -&pi;/4) = INFINITY - INFINITY i\n * polar2Complex(INFINITY, 5&pi;/4) = -INFINITY - INFINITY i </code></pre></p>\n *\n * @param r the modulus of the complex number to create\n * @param theta  the argument of the complex number to create\n * @return <code>r&middot;e<sup>i&middot;theta</sup></code>\n * @throws MathIllegalArgumentException if {@code r} is negative.\n * @since 1.1\n */\npublic static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException {\n    if (r < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_COMPLEX_MODULE, r);\n    }\n    return new Complex(r * FastMath.cos(theta), r * FastMath.sin(theta));\n}"
            ],
            [
                "convertToComplex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "/**\n * Convert an array of primitive doubles to an array of {@code Complex} objects.\n *\n * @param real Array of numbers to be converted to their {@code Complex}\n * equivalent.\n * @return an array of {@code Complex} objects.\n *\n * @since 3.1\n */\npublic static Complex[] convertToComplex(double[] real) {\n    final Complex[] c = new Complex[real.length];\n    for (int i = 0; i < real.length; i++) {\n        c[i] = new Complex(real[i], 0);\n    }\n    return c;\n}"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optimization.linear",
                "SimplexTableau",
                "/**\n * Get the -1 times the sum of all coefficients in the given array.\n * @param coefficients coefficients to sum\n * @return the -1 times the sum of all coefficients in the given array.\n */\nprotected static double getInvertedCoefficientSum(final RealVector coefficients) {\n    double sum = 0;\n    for (double coefficient : coefficients.toArray()) {\n        sum -= coefficient;\n    }\n    return sum;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Get the set of locales for which real vectors formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available real vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Returns the default real vector format for the current locale.\n * @return the default real vector format.\n */\npublic static RealMatrixFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Returns the default real vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the real vector format specific to the given locale.\n */\npublic static RealMatrixFormat getInstance(final Locale locale) {\n    return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link RealMatrix} with specified dimensions.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix) which can be stored in a 32kB array, a {@link\n * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n * BlockRealMatrix} instance is built.</p>\n * <p>The matrix elements are all set to 0.0.</p>\n * @param rows number of rows of the matrix\n * @param columns number of columns of the matrix\n * @return  RealMatrix with specified dimensions\n * @see #createRealMatrix(double[][])\n */\npublic static RealMatrix createRealMatrix(final int rows, final int columns) {\n    return (rows * columns <= 4096) ? new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n}"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link FieldMatrix} with specified dimensions.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix), a {@link FieldMatrix} instance is built. Above\n * this threshold a {@link BlockFieldMatrix} instance is built.</p>\n * <p>The matrix elements are all set to field.getZero().</p>\n * @param <T> the type of the field elements\n * @param field field to which the matrix elements belong\n * @param rows number of rows of the matrix\n * @param columns number of columns of the matrix\n * @return  FieldMatrix with specified dimensions\n * @see #createFieldMatrix(FieldElement[][])\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field, final int rows, final int columns) {\n    return (rows * columns <= 4096) ? new Array2DRowFieldMatrix<T>(field, rows, columns) : new BlockFieldMatrix<T>(field, rows, columns);\n}"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link RealMatrix} whose entries are the the values in the\n * the input array.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix) which can be stored in a 32kB array, a {@link\n * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n * BlockRealMatrix} instance is built.</p>\n * <p>The input array is copied, not referenced.</p>\n *\n * @param data input array\n * @return  RealMatrix containing the values of the array\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if {@code data} is not rectangular (not all rows have the same length).\n * @throws NoDataException if a row or column is empty.\n * @throws NullArgumentException if either {@code data} or {@code data[0]}\n * is {@code null}.\n * @throws DimensionMismatchException if {@code data} is not rectangular.\n * @see #createRealMatrix(int, int)\n */\npublic static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException {\n    if (data == null || data[0] == null) {\n        throw new NullArgumentException();\n    }\n    return (data.length * data[0].length <= 4096) ? new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n}"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link FieldMatrix} whose entries are the the values in the\n * the input array.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix), a {@link FieldMatrix} instance is built. Above\n * this threshold a {@link BlockFieldMatrix} instance is built.</p>\n * <p>The input array is copied, not referenced.</p>\n * @param <T> the type of the field elements\n * @param data input array\n * @return a matrix containing the values of the array.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if {@code data} is not rectangular (not all rows have the same length).\n * @throws NoDataException if a row or column is empty.\n * @throws NullArgumentException if either {@code data} or {@code data[0]}\n * is {@code null}.\n * @see #createFieldMatrix(Field, int, int)\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) throws DimensionMismatchException, NoDataException, NullArgumentException {\n    if (data == null || data[0] == null) {\n        throw new NullArgumentException();\n    }\n    return (data.length * data[0].length <= 4096) ? new Array2DRowFieldMatrix<T>(data) : new BlockFieldMatrix<T>(data);\n}"
            ],
            [
                "createRealIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns <code>dimension x dimension</code> identity matrix.\n *\n * @param dimension dimension of identity matrix to generate\n * @return identity matrix\n * @throws IllegalArgumentException if dimension is not positive\n * @since 1.1\n */\npublic static RealMatrix createRealIdentityMatrix(int dimension) {\n    final RealMatrix m = createRealMatrix(dimension, dimension);\n    for (int i = 0; i < dimension; ++i) {\n        m.setEntry(i, i, 1.0);\n    }\n    return m;\n}"
            ],
            [
                "createFieldIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns <code>dimension x dimension</code> identity matrix.\n *\n * @param <T> the type of the field elements\n * @param field field to which the elements belong\n * @param dimension dimension of identity matrix to generate\n * @return identity matrix\n * @throws IllegalArgumentException if dimension is not positive\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(final Field<T> field, final int dimension) {\n    final T zero = field.getZero();\n    final T one = field.getOne();\n    final T[][] d = MathArrays.buildArray(field, dimension, dimension);\n    for (int row = 0; row < dimension; row++) {\n        final T[] dRow = d[row];\n        Arrays.fill(dRow, zero);\n        dRow[row] = one;\n    }\n    return new Array2DRowFieldMatrix<T>(field, d, false);\n}"
            ],
            [
                "createRealDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a diagonal matrix with specified elements.\n *\n * @param diagonal diagonal elements of the matrix (the array elements\n * will be copied)\n * @return diagonal matrix\n * @since 2.0\n */\npublic static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n    final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n    for (int i = 0; i < diagonal.length; ++i) {\n        m.setEntry(i, i, diagonal[i]);\n    }\n    return m;\n}"
            ],
            [
                "createFieldDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a diagonal matrix with specified elements.\n *\n * @param <T> the type of the field elements\n * @param diagonal diagonal elements of the matrix (the array elements\n * will be copied)\n * @return diagonal matrix\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(final T[] diagonal) {\n    final FieldMatrix<T> m = createFieldMatrix(diagonal[0].getField(), diagonal.length, diagonal.length);\n    for (int i = 0; i < diagonal.length; ++i) {\n        m.setEntry(i, i, diagonal[i]);\n    }\n    return m;\n}"
            ],
            [
                "createRealVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a {@link RealVector} using the data from the input array.\n *\n * @param data the input data\n * @return a data.length RealVector\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code data} is {@code null}.\n */\npublic static RealVector createRealVector(double[] data) throws NoDataException, NullArgumentException {\n    if (data == null) {\n        throw new NullArgumentException();\n    }\n    return new ArrayRealVector(data, true);\n}"
            ],
            [
                "createFieldVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a {@link FieldVector} using the data from the input array.\n *\n * @param <T> the type of the field elements\n * @param data the input data\n * @return a data.length FieldVector\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code data} is {@code null}.\n * @throws ZeroException if {@code data} has 0 elements\n */\npublic static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) throws NoDataException, NullArgumentException, ZeroException {\n    if (data == null) {\n        throw new NullArgumentException();\n    }\n    if (data.length == 0) {\n        throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n    }\n    return new ArrayFieldVector<T>(data[0].getField(), data, true);\n}"
            ],
            [
                "createRowRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Create a row {@link RealMatrix} using the data from the input\n * array.\n *\n * @param rowData the input row data\n * @return a 1 x rowData.length RealMatrix\n * @throws NoDataException if {@code rowData} is empty.\n * @throws NullArgumentException if {@code rowData} is {@code null}.\n */\npublic static RealMatrix createRowRealMatrix(double[] rowData) throws NoDataException, NullArgumentException {\n    if (rowData == null) {\n        throw new NullArgumentException();\n    }\n    final int nCols = rowData.length;\n    final RealMatrix m = createRealMatrix(1, nCols);\n    for (int i = 0; i < nCols; ++i) {\n        m.setEntry(0, i, rowData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createRowFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Create a row {@link FieldMatrix} using the data from the input\n * array.\n *\n * @param <T> the type of the field elements\n * @param rowData the input row data\n * @return a 1 x rowData.length FieldMatrix\n * @throws NoDataException if {@code rowData} is empty.\n * @throws NullArgumentException if {@code rowData} is {@code null}.\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(final T[] rowData) throws NoDataException, NullArgumentException {\n    if (rowData == null) {\n        throw new NullArgumentException();\n    }\n    final int nCols = rowData.length;\n    if (nCols == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n    for (int i = 0; i < nCols; ++i) {\n        m.setEntry(0, i, rowData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createColumnRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a column {@link RealMatrix} using the data from the input\n * array.\n *\n * @param columnData  the input column data\n * @return a columnData x 1 RealMatrix\n * @throws NoDataException if {@code columnData} is empty.\n * @throws NullArgumentException if {@code columnData} is {@code null}.\n */\npublic static RealMatrix createColumnRealMatrix(double[] columnData) throws NoDataException, NullArgumentException {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createColumnFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a column {@link FieldMatrix} using the data from the input\n * array.\n *\n * @param <T> the type of the field elements\n * @param columnData  the input column data\n * @return a columnData x 1 FieldMatrix\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code columnData} is {@code null}.\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) throws NoDataException, NullArgumentException {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final FieldMatrix<T> m = createFieldMatrix(columnData[0].getField(), nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
            ],
            [
                "isSymmetric",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Checks whether a matrix is symmetric.\n *\n * @param matrix Matrix to check.\n * @param eps Relative tolerance.\n * @return {@code true} if {@code matrix} is symmetric.\n * @since 3.1\n */\npublic static boolean isSymmetric(RealMatrix matrix, double eps) {\n    return isSymmetricInternal(matrix, eps, false);\n}"
            ],
            [
                "fractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Convert a {@link FieldMatrix}/{@link Fraction} matrix to a {@link RealMatrix}.\n * @param m Matrix to convert.\n * @return the converted matrix.\n */\npublic static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m) {\n    final FractionMatrixConverter converter = new FractionMatrixConverter();\n    m.walkInOptimizedOrder(converter);\n    return converter.getConvertedMatrix();\n}"
            ],
            [
                "bigFractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Convert a {@link FieldMatrix}/{@link BigFraction} matrix to a {@link RealMatrix}.\n *\n * @param m Matrix to convert.\n * @return the converted matrix.\n */\npublic static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m) {\n    final BigFractionMatrixConverter converter = new BigFractionMatrixConverter();\n    m.walkInOptimizedOrder(converter);\n    return converter.getConvertedMatrix();\n}"
            ],
            [
                "blockInverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix by splitting it into\n * 4 sub-matrices.\n *\n * @param m Matrix whose inverse must be computed.\n * @param splitIndex Index that determines the \"split\" line and\n * column.\n * The element corresponding to this index will part of the\n * upper-left sub-matrix.\n * @return the inverse of {@code m}.\n * @throws NonSquareMatrixException if {@code m} is not square.\n */\npublic static RealMatrix blockInverse(RealMatrix m, int splitIndex) {\n    final int n = m.getRowDimension();\n    if (m.getColumnDimension() != n) {\n        throw new NonSquareMatrixException(m.getRowDimension(), m.getColumnDimension());\n    }\n    final int splitIndex1 = splitIndex + 1;\n    final RealMatrix a = m.getSubMatrix(0, splitIndex, 0, splitIndex);\n    final RealMatrix b = m.getSubMatrix(0, splitIndex, splitIndex1, n - 1);\n    final RealMatrix c = m.getSubMatrix(splitIndex1, n - 1, 0, splitIndex);\n    final RealMatrix d = m.getSubMatrix(splitIndex1, n - 1, splitIndex1, n - 1);\n    final SingularValueDecomposition aDec = new SingularValueDecomposition(a);\n    final DecompositionSolver aSolver = aDec.getSolver();\n    if (!aSolver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix aInv = aSolver.getInverse();\n    final SingularValueDecomposition dDec = new SingularValueDecomposition(d);\n    final DecompositionSolver dSolver = dDec.getSolver();\n    if (!dSolver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix dInv = dSolver.getInverse();\n    final RealMatrix tmp1 = a.subtract(b.multiply(dInv).multiply(c));\n    final SingularValueDecomposition tmp1Dec = new SingularValueDecomposition(tmp1);\n    final DecompositionSolver tmp1Solver = tmp1Dec.getSolver();\n    if (!tmp1Solver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix result00 = tmp1Solver.getInverse();\n    final RealMatrix tmp2 = d.subtract(c.multiply(aInv).multiply(b));\n    final SingularValueDecomposition tmp2Dec = new SingularValueDecomposition(tmp2);\n    final DecompositionSolver tmp2Solver = tmp2Dec.getSolver();\n    if (!tmp2Solver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix result11 = tmp2Solver.getInverse();\n    final RealMatrix result01 = aInv.multiply(b).multiply(result11).scalarMultiply(-1);\n    final RealMatrix result10 = dInv.multiply(c).multiply(result00).scalarMultiply(-1);\n    final RealMatrix result = new Array2DRowRealMatrix(n, n);\n    result.setSubMatrix(result00.getData(), 0, 0);\n    result.setSubMatrix(result01.getData(), 0, splitIndex1);\n    result.setSubMatrix(result10.getData(), splitIndex1, 0);\n    result.setSubMatrix(result11.getData(), splitIndex1, splitIndex1);\n    return result;\n}"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix.\n * <p>\n * By default, the inverse of the matrix is computed using the QR-decomposition,\n * unless a more efficient method can be determined for the input matrix.\n * <p>\n * Note: this method will use a singularity threshold of 0,\n * use {@link #inverse(RealMatrix, double)} if a different threshold is needed.\n *\n * @param matrix Matrix whose inverse shall be computed\n * @return the inverse of {@code matrix}\n * @throws NullArgumentException if {@code matrix} is {@code null}\n * @throws SingularMatrixException if m is singular\n * @throws NonSquareMatrixException if matrix is not square\n * @since 3.3\n */\npublic static RealMatrix inverse(RealMatrix matrix) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException {\n    return inverse(matrix, 0);\n}"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix.\n * <p>\n * By default, the inverse of the matrix is computed using the QR-decomposition,\n * unless a more efficient method can be determined for the input matrix.\n *\n * @param matrix Matrix whose inverse shall be computed\n * @param threshold Singularity threshold\n * @return the inverse of {@code m}\n * @throws NullArgumentException if {@code matrix} is {@code null}\n * @throws SingularMatrixException if matrix is singular\n * @throws NonSquareMatrixException if matrix is not square\n * @since 3.3\n */\npublic static RealMatrix inverse(RealMatrix matrix, double threshold) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException {\n    MathUtils.checkNotNull(matrix);\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n    }\n    if (matrix instanceof DiagonalMatrix) {\n        return ((DiagonalMatrix) matrix).inverse(threshold);\n    } else {\n        QRDecomposition decomposition = new QRDecomposition(matrix, threshold);\n        return decomposition.getSolver().getInverse();\n    }\n}"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Convert a data array from raw layout to blocks layout.\n * <p>\n * Raw layout is the straightforward layout where element at row i and\n * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n * is the layout used in {@link BlockFieldMatrix} instances, where the matrix\n * is split in square blocks (except at right and bottom side where blocks may\n * be rectangular to fit matrix size) and each block is stored in a flattened\n * one-dimensional array.\n * </p>\n * <p>\n * This method creates an array in blocks layout from an input array in raw layout.\n * It can be used to provide the array argument of the {@link\n * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n * constructor.\n * </p>\n * @param <T> Type of the field elements.\n * @param rawData Data array in raw layout.\n * @return a new data array containing the same entries but in blocks layout\n * @throws DimensionMismatchException if {@code rawData} is not rectangular\n *  (not all rows have the same length).\n * @see #createBlocksLayout(Field, int, int)\n * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n */\npublic static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n    // convert array\n    final Field<T> field = extractField(rawData);\n    final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            // allocate new block\n            final T[] block = MathArrays.buildArray(field, iHeight * jWidth);\n            blocks[blockIndex] = block;\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Create a data array in blocks layout.\n * <p>\n * This method can be used to create the array argument of the {@link\n * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n * constructor.\n * </p>\n * @param <T> Type of the field elements.\n * @param field Field to which the elements belong.\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(FieldElement[][])\n * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n */\npublic static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns) {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = MathArrays.buildArray(field, iHeight * jWidth);\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Convert a data array from raw layout to blocks layout.\n * <p>\n * Raw layout is the straightforward layout where element at row i and\n * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n * is the layout used in {@link BlockRealMatrix} instances, where the matrix\n * is split in square blocks (except at right and bottom side where blocks may\n * be rectangular to fit matrix size) and each block is stored in a flattened\n * one-dimensional array.\n * </p>\n * <p>\n * This method creates an array in blocks layout from an input array in raw layout.\n * It can be used to provide the array argument of the {@link\n * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n * </p>\n * @param rawData Data array in raw layout.\n * @return a new data array containing the same entries but in blocks layout.\n * @throws DimensionMismatchException if {@code rawData} is not rectangular.\n * @see #createBlocksLayout(int, int)\n * @see #BlockRealMatrix(int, int, double[][], boolean)\n */\npublic static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Create a data array in blocks layout.\n * <p>\n * This method can be used to create the array argument of the {@link\n * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n * </p>\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(double[][])\n * @see #BlockRealMatrix(int, int, double[][], boolean)\n */\npublic static double[][] createBlocksLayout(final int rows, final int columns) {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "unmodifiableRealVector",
                "org.apache.commons.math3.linear",
                "RealVector",
                "/**\n * Returns an unmodifiable view of the specified vector.\n * The returned vector has read-only access. An attempt to modify it will\n * result in a {@link MathUnsupportedOperationException}. However, the\n * returned vector is <em>not</em> immutable, since any modification of\n * {@code v} will also change the returned view.\n * For example, in the following piece of code\n * <pre>\n *     RealVector v = new ArrayRealVector(2);\n *     RealVector w = RealVector.unmodifiableRealVector(v);\n *     v.setEntry(0, 1.2);\n *     v.setEntry(1, -3.4);\n * </pre>\n * the changes will be seen in the {@code w} view of {@code v}.\n *\n * @param v Vector for which an unmodifiable view is to be returned.\n * @return an unmodifiable view of {@code v}.\n */\npublic static RealVector unmodifiableRealVector(final RealVector v) {\n    /**\n     * This anonymous class is an implementation of {@link RealVector}\n     * with read-only access.\n     * It wraps any {@link RealVector}, and exposes all methods which\n     * do not modify it. Invoking methods which should normally result\n     * in the modification of the calling {@link RealVector} results in\n     * a {@link MathUnsupportedOperationException}. It should be noted\n     * that {@link UnmodifiableVector} is <em>not</em> immutable.\n     */\n    return new RealVector() {\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all circumstances.\n         */\n        @Override\n        public RealVector mapToSelf(UnivariateFunction function) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector map(UnivariateFunction function) {\n            return v.map(function);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Iterator<Entry> iterator() {\n            final Iterator<Entry> i = v.iterator();\n            return new Iterator<Entry>() {\n\n                /**\n                 * The current entry.\n                 */\n                private final UnmodifiableEntry e = new UnmodifiableEntry();\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public boolean hasNext() {\n                    return i.hasNext();\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public Entry next() {\n                    e.setIndex(i.next().getIndex());\n                    return e;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 *\n                 * @throws MathUnsupportedOperationException in all\n                 * circumstances.\n                 */\n                public void remove() throws MathUnsupportedOperationException {\n                    throw new MathUnsupportedOperationException();\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Iterator<Entry> sparseIterator() {\n            final Iterator<Entry> i = v.sparseIterator();\n            return new Iterator<Entry>() {\n\n                /**\n                 * The current entry.\n                 */\n                private final UnmodifiableEntry e = new UnmodifiableEntry();\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public boolean hasNext() {\n                    return i.hasNext();\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public Entry next() {\n                    e.setIndex(i.next().getIndex());\n                    return e;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 *\n                 * @throws MathUnsupportedOperationException in all\n                 * circumstances.\n                 */\n                public void remove() throws MathUnsupportedOperationException {\n                    throw new MathUnsupportedOperationException();\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector copy() {\n            return v.copy();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector add(RealVector w) throws DimensionMismatchException {\n            return v.add(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector subtract(RealVector w) throws DimensionMismatchException {\n            return v.subtract(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapAdd(double d) {\n            return v.mapAdd(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapAddToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapSubtract(double d) {\n            return v.mapSubtract(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapSubtractToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapMultiply(double d) {\n            return v.mapMultiply(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapMultiplyToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapDivide(double d) {\n            return v.mapDivide(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapDivideToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector ebeMultiply(RealVector w) throws DimensionMismatchException {\n            return v.ebeMultiply(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector ebeDivide(RealVector w) throws DimensionMismatchException {\n            return v.ebeDivide(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double dotProduct(RealVector w) throws DimensionMismatchException {\n            return v.dotProduct(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double cosine(RealVector w) throws DimensionMismatchException, MathArithmeticException {\n            return v.cosine(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getNorm() {\n            return v.getNorm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getL1Norm() {\n            return v.getL1Norm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getLInfNorm() {\n            return v.getLInfNorm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getDistance(RealVector w) throws DimensionMismatchException {\n            return v.getDistance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getL1Distance(RealVector w) throws DimensionMismatchException {\n            return v.getL1Distance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getLInfDistance(RealVector w) throws DimensionMismatchException {\n            return v.getLInfDistance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector unitVector() throws MathArithmeticException {\n            return v.unitVector();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void unitize() throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealMatrix outerProduct(RealVector w) {\n            return v.outerProduct(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getEntry(int index) throws OutOfRangeException {\n            return v.getEntry(index);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void setEntry(int index, double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void addToEntry(int index, double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getDimension() {\n            return v.getDimension();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector append(RealVector w) {\n            return v.append(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector append(double d) {\n            return v.append(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector getSubVector(int index, int n) throws OutOfRangeException, NotPositiveException {\n            return v.getSubVector(index, n);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void setSubVector(int index, RealVector w) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void set(double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double[] toArray() {\n            return v.toArray();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isNaN() {\n            return v.isNaN();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isInfinite() {\n            return v.isInfinite();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector combine(double a, double b, RealVector y) throws DimensionMismatchException {\n            return v.combine(a, b, y);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector combineToSelf(double a, double b, RealVector y) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * An entry in the vector.\n         */\n        class UnmodifiableEntry extends Entry {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public double getValue() {\n                return v.getEntry(getIndex());\n            }\n\n            /**\n             * {@inheritDoc}\n             *\n             * @throws MathUnsupportedOperationException in all\n             * circumstances.\n             */\n            @Override\n            public void setValue(double value) throws MathUnsupportedOperationException {\n                throw new MathUnsupportedOperationException();\n            }\n        }\n    };\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Get the set of locales for which real vectors formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available real vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Returns the default real vector format for the current locale.\n * @return the default real vector format.\n */\npublic static RealVectorFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Returns the default real vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the real vector format specific to the given locale.\n */\npublic static RealVectorFormat getInstance(final Locale locale) {\n    return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.linear",
                "JacobiPreconditioner",
                "/**\n * Creates a new instance of this class. This method extracts the diagonal\n * coefficients of the specified linear operator. If {@code a} does not\n * extend {@link AbstractRealMatrix}, then the coefficients of the\n * underlying matrix are not accessible, coefficient extraction is made by\n * matrix-vector products with the basis vectors (and might therefore take\n * some time). With matrices, direct entry access is carried out.\n *\n * @param a the linear operator for which the preconditioner should be built\n * @return the diagonal preconditioner made of the inverse of the diagonal\n * coefficients of the specified linear operator\n * @throws NonSquareOperatorException if {@code a} is not square\n */\npublic static JacobiPreconditioner create(final RealLinearOperator a) throws NonSquareOperatorException {\n    final int n = a.getColumnDimension();\n    if (a.getRowDimension() != n) {\n        throw new NonSquareOperatorException(a.getRowDimension(), n);\n    }\n    final double[] diag = new double[n];\n    if (a instanceof AbstractRealMatrix) {\n        final AbstractRealMatrix m = (AbstractRealMatrix) a;\n        for (int i = 0; i < n; i++) {\n            diag[i] = m.getEntry(i, i);\n        }\n    } else {\n        final ArrayRealVector x = new ArrayRealVector(n);\n        for (int i = 0; i < n; i++) {\n            x.set(0.);\n            x.setEntry(i, 1.);\n            diag[i] = a.operate(x).getEntry(i);\n        }\n    }\n    return new JacobiPreconditioner(diag, false);\n}"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Get the elements type from an array.\n *\n * @param <T> Type of the field elements.\n * @param d Data array.\n * @return the field to which the array elements belong.\n * @throws NullArgumentException if the array is {@code null}.\n * @throws NoDataException if the array is empty.\n */\nprotected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException {\n    if (d == null) {\n        throw new NullArgumentException();\n    }\n    if (d.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    if (d[0].length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    return d[0][0].getField();\n}"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Get the elements type from an array.\n *\n * @param <T> Type of the field elements.\n * @param d Data array.\n * @return the field to which the array elements belong.\n * @throws NoDataException if array is empty.\n */\nprotected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException {\n    if (d.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    return d[0].getField();\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Build an array of elements.\n * <p>\n * Complete arrays are filled with field.getZero()\n * </p>\n * @param <T> Type of the field elements\n * @param field field to which array elements belong\n * @param rows number of rows\n * @param columns number of columns (may be negative to build partial\n * arrays in the same way <code>new Field[rows][]</code> works)\n * @return a new array\n * @deprecated as of 3.2, replaced by {@link MathArrays#buildArray(Field, int, int)}\n */\n@Deprecated\nprotected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n    return MathArrays.buildArray(field, rows, columns);\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Build an array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n * </p>\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param length of the array\n * @return a new array\n * @deprecated as of 3.2, replaced by {@link MathArrays#buildArray(Field, int)}\n */\n@Deprecated\nprotected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length) {\n    return MathArrays.buildArray(field, length);\n}"
            ],
            [
                "estimate",
                "org.apache.commons.math3.distribution.fitting",
                "MultivariateNormalMixtureExpectationMaximization",
                "/**\n * Helper method to create a multivariate normal mixture model which can be\n * used to initialize {@link #fit(MixtureMultivariateNormalDistribution)}.\n *\n * This method uses the data supplied to the constructor to try to determine\n * a good mixture model at which to start the fit, but it is not guaranteed\n * to supply a model which will find the optimal solution or even converge.\n *\n * @param data Data to estimate distribution\n * @param numComponents Number of components for estimated mixture\n * @return Multivariate normal mixture model estimated from the data\n * @throws NumberIsTooLargeException if {@code numComponents} is greater\n * than the number of data rows.\n * @throws NumberIsTooSmallException if {@code numComponents < 2}.\n * @throws NotStrictlyPositiveException if data has less than 2 rows\n * @throws DimensionMismatchException if rows of data have different numbers\n *             of columns\n */\npublic static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException {\n    if (data.length < 2) {\n        throw new NotStrictlyPositiveException(data.length);\n    }\n    if (numComponents < 2) {\n        throw new NumberIsTooSmallException(numComponents, 2, true);\n    }\n    if (numComponents > data.length) {\n        throw new NumberIsTooLargeException(numComponents, data.length, true);\n    }\n    final int numRows = data.length;\n    final int numCols = data[0].length;\n    // sort the data\n    final DataRow[] sortedData = new DataRow[numRows];\n    for (int i = 0; i < numRows; i++) {\n        sortedData[i] = new DataRow(data[i]);\n    }\n    Arrays.sort(sortedData);\n    // uniform weight for each bin\n    final double weight = 1d / numComponents;\n    // components of mixture model to be created\n    final List<Pair<Double, MultivariateNormalDistribution>> components = new ArrayList<Pair<Double, MultivariateNormalDistribution>>(numComponents);\n    // create a component based on data in each bin\n    for (int binIndex = 0; binIndex < numComponents; binIndex++) {\n        // minimum index (inclusive) from sorted data for this bin\n        final int minIndex = (binIndex * numRows) / numComponents;\n        // maximum index (exclusive) from sorted data for this bin\n        final int maxIndex = ((binIndex + 1) * numRows) / numComponents;\n        // number of data records that will be in this bin\n        final int numBinRows = maxIndex - minIndex;\n        // data for this bin\n        final double[][] binData = new double[numBinRows][numCols];\n        // mean of each column for the data in the this bin\n        final double[] columnMeans = new double[numCols];\n        // populate bin and create component\n        for (int i = minIndex, iBin = 0; i < maxIndex; i++, iBin++) {\n            for (int j = 0; j < numCols; j++) {\n                final double val = sortedData[i].getRow()[j];\n                columnMeans[j] += val;\n                binData[iBin][j] = val;\n            }\n        }\n        MathArrays.scaleInPlace(1d / numBinRows, columnMeans);\n        // covariance matrix for this bin\n        final double[][] covMat = new Covariance(binData).getCovarianceMatrix().getData();\n        final MultivariateNormalDistribution mvn = new MultivariateNormalDistribution(columnMeans, covMat);\n        components.add(new Pair<Double, MultivariateNormalDistribution>(weight, mvn));\n    }\n    return new MixtureMultivariateNormalDistribution(components);\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "/**\n * Returns one sample using Cheng's sampling algorithm.\n * @param random random generator to use\n * @param alpha distribution first shape parameter\n * @param beta distribution second shape parameter\n * @return sampled value\n */\nstatic double sample(RandomGenerator random, final double alpha, final double beta) {\n    final double a = FastMath.min(alpha, beta);\n    final double b = FastMath.max(alpha, beta);\n    if (a > 1) {\n        return algorithmBB(random, alpha, a, b);\n    } else {\n        return algorithmBC(random, alpha, b, a);\n    }\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "ChengBetaSampler",
                "/**\n * Returns one sample using Cheng's sampling algorithm.\n * @param random random generator to use\n * @param alpha distribution first shape parameter\n * @param beta distribution second shape parameter\n * @return sampled value\n */\nstatic double sample(RandomGenerator random, final double alpha, final double beta) {\n    final double a = FastMath.min(alpha, beta);\n    final double b = FastMath.max(alpha, beta);\n    if (a > 1) {\n        return algorithmBB(random, alpha, a, b);\n    } else {\n        return algorithmBC(random, alpha, b, a);\n    }\n}"
            ],
            [
                "getStirlingError",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * Compute the error of Stirling's series at the given value.\n * <p>\n * References:\n * <ol>\n * <li>Eric W. Weisstein. \"Stirling's Series.\" From MathWorld--A Wolfram Web\n * Resource. <a target=\"_blank\"\n * href=\"http://mathworld.wolfram.com/StirlingsSeries.html\">\n * http://mathworld.wolfram.com/StirlingsSeries.html</a></li>\n * </ol>\n * </p>\n *\n * @param z the value.\n * @return the Striling's series error.\n */\nstatic double getStirlingError(double z) {\n    double ret;\n    if (z < 15.0) {\n        double z2 = 2.0 * z;\n        if (FastMath.floor(z2) == z2) {\n            ret = EXACT_STIRLING_ERRORS[(int) z2];\n        } else {\n            ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * FastMath.log(z) + z - HALF_LOG_2_PI;\n        }\n    } else {\n        double z2 = z * z;\n        ret = (0.083333333333333333333 - (0.00277777777777777777778 - (0.00079365079365079365079365 - (0.000595238095238095238095238 - 0.0008417508417508417508417508 / z2) / z2) / z2) / z2) / z;\n    }\n    return ret;\n}"
            ],
            [
                "getDeviancePart",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * A part of the deviance portion of the saddle point approximation.\n * <p>\n * References:\n * <ol>\n * <li>Catherine Loader (2000). \"Fast and Accurate Computation of Binomial\n * Probabilities.\". <a target=\"_blank\"\n * href=\"http://www.herine.net/stat/papers/dbinom.pdf\">\n * http://www.herine.net/stat/papers/dbinom.pdf</a></li>\n * </ol>\n * </p>\n *\n * @param x the x value.\n * @param mu the average.\n * @return a part of the deviance.\n */\nstatic double getDeviancePart(double x, double mu) {\n    double ret;\n    if (FastMath.abs(x - mu) < 0.1 * (x + mu)) {\n        double d = x - mu;\n        double v = d / (x + mu);\n        double s1 = v * d;\n        double s = Double.NaN;\n        double ej = 2.0 * x * v;\n        v *= v;\n        int j = 1;\n        while (s1 != s) {\n            s = s1;\n            ej *= v;\n            s1 = s + ej / ((j * 2) + 1);\n            ++j;\n        }\n        ret = s1;\n    } else {\n        ret = x * FastMath.log(x / mu) + mu - x;\n    }\n    return ret;\n}"
            ],
            [
                "logBinomialProbability",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * Compute the logarithm of the PMF for a binomial distribution\n * using the saddle point expansion.\n *\n * @param x the value at which the probability is evaluated.\n * @param n the number of trials.\n * @param p the probability of success.\n * @param q the probability of failure (1 - p).\n * @return log(p(x)).\n */\nstatic double logBinomialProbability(int x, int n, double p, double q) {\n    double ret;\n    if (x == 0) {\n        if (p < 0.1) {\n            ret = -getDeviancePart(n, n * q) - n * p;\n        } else {\n            ret = n * FastMath.log(q);\n        }\n    } else if (x == n) {\n        if (q < 0.1) {\n            ret = -getDeviancePart(n, n * p) - n * q;\n        } else {\n            ret = n * FastMath.log(p);\n        }\n    } else {\n        ret = getStirlingError(n) - getStirlingError(x) - getStirlingError(n - x) - getDeviancePart(x, n * p) - getDeviancePart(n - x, n * q);\n        double f = (MathUtils.TWO_PI * x * (n - x)) / n;\n        ret = -0.5 * FastMath.log(f) + ret;\n    }\n    return ret;\n}"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "/**\n * Helper function that calculates {@code log(1+x)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x a value larger than or equal to -1\n * @return {@code log(1+x)/x}\n */\nstatic double helper1(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.log1p(x) / x;\n    } else {\n        return 1. - x * ((1. / 2.) - x * ((1. / 3.) - x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "/**\n * Helper function to calculate {@code (exp(x)-1)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x free parameter\n * @return {@code (exp(x)-1)/x} if x is non-zero, or 1 if x=0\n */\nstatic double helper2(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.expm1(x) / x;\n    } else {\n        return 1. + x * (1. / 2.) * (1. + x * (1. / 3.) * (1. + x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "/**\n * Helper function that calculates {@code log(1+x)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x a value larger than or equal to -1\n * @return {@code log(1+x)/x}\n */\nstatic double helper1(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.log1p(x) / x;\n    } else {\n        return 1. - x * ((1. / 2.) - x * ((1. / 3.) - x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "/**\n * Helper function to calculate {@code (exp(x)-1)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x free parameter\n * @return {@code (exp(x)-1)/x} if x is non-zero, or 1 if x=0\n */\nstatic double helper2(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.expm1(x) / x;\n    } else {\n        return 1. + x * (1. / 2.) * (1. + x * (1. / 3.) * (1. + x * (1. / 4.)));\n    }\n}"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxIter",
                "/**\n * Factory method that creates instance of this class that represents\n * a virtually unlimited number of iterations.\n *\n * @return a new instance suitable for allowing {@link Integer#MAX_VALUE}\n * evaluations.\n */\npublic static MaxIter unlimited() {\n    return new MaxIter(Integer.MAX_VALUE);\n}"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optim.linear",
                "SimplexTableau",
                "/**\n * Get the -1 times the sum of all coefficients in the given array.\n * @param coefficients coefficients to sum\n * @return the -1 times the sum of all coefficients in the given array.\n */\nprotected static double getInvertedCoefficientSum(final RealVector coefficients) {\n    double sum = 0;\n    for (double coefficient : coefficients.toArray()) {\n        sum -= coefficient;\n    }\n    return sum;\n}"
            ],
            [
                "unbounded",
                "org.apache.commons.math3.optim",
                "SimpleBounds",
                "/**\n * Factory method that creates instance of this class that represents\n * unbounded ranges.\n *\n * @param dim Number of parameters.\n * @return a new instance suitable for passing to an optimizer that\n * requires bounds specification.\n */\npublic static SimpleBounds unbounded(int dim) {\n    final double[] lB = new double[dim];\n    Arrays.fill(lB, Double.NEGATIVE_INFINITY);\n    final double[] uB = new double[dim];\n    Arrays.fill(uB, Double.POSITIVE_INFINITY);\n    return new SimpleBounds(lB, uB);\n}"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxEval",
                "/**\n * Factory method that creates instance of this class that represents\n * a virtually unlimited number of evaluations.\n *\n * @return a new instance suitable for allowing {@link Integer#MAX_VALUE}\n * evaluations.\n */\npublic static MaxEval unlimited() {\n    return new MaxEval(Integer.MAX_VALUE);\n}"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the error function.\n *\n * <p>erf(x) = 2/&radic;&pi; <sub>0</sub>&int;<sup>x</sup> e<sup>-t<sup>2</sup></sup>dt </p>\n *\n * <p>This implementation computes erf(x) using the\n * {@link Gamma#regularizedGammaP(double, double, double, int) regularized gamma function},\n * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3)</p>\n *\n * <p>The value returned is always between -1 and 1 (inclusive).\n * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from\n * either 1 or -1 as a double, so the appropriate extreme value is returned.\n * </p>\n *\n * @param x the value.\n * @return the error function erf(x)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n * @see Gamma#regularizedGammaP(double, double, double, int)\n */\npublic static double erf(double x) {\n    if (FastMath.abs(x) > 40) {\n        return x > 0 ? 1 : -1;\n    }\n    final double ret = Gamma.regularizedGammaP(0.5, x * x, 1.0e-15, 10000);\n    return x < 0 ? -ret : ret;\n}"
            ],
            [
                "erfc",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the complementary error function.\n *\n * <p>erfc(x) = 2/&radic;&pi; <sub>x</sub>&int;<sup>&infin;</sup> e<sup>-t<sup>2</sup></sup>dt\n * <br/>\n *    = 1 - {@link #erf(double) erf(x)} </p>\n *\n * <p>This implementation computes erfc(x) using the\n * {@link Gamma#regularizedGammaQ(double, double, double, int) regularized gamma function},\n * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3).</p>\n *\n * <p>The value returned is always between 0 and 2 (inclusive).\n * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from\n * either 0 or 2 as a double, so the appropriate extreme value is returned.\n * </p>\n *\n * @param x the value\n * @return the complementary error function erfc(x)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n * @see Gamma#regularizedGammaQ(double, double, double, int)\n * @since 2.2\n */\npublic static double erfc(double x) {\n    if (FastMath.abs(x) > 40) {\n        return x > 0 ? 0 : 2;\n    }\n    final double ret = Gamma.regularizedGammaQ(0.5, x * x, 1.0e-15, 10000);\n    return x < 0 ? 2 - ret : ret;\n}"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the difference between erf(x1) and erf(x2).\n *\n * The implementation uses either erf(double) or erfc(double)\n * depending on which provides the most precise result.\n *\n * @param x1 the first value\n * @param x2 the second value\n * @return erf(x2) - erf(x1)\n */\npublic static double erf(double x1, double x2) {\n    if (x1 > x2) {\n        return -erf(x2, x1);\n    }\n    return x1 < -X_CRIT ? x2 < 0.0 ? erfc(-x2) - erfc(-x1) : erf(x2) - erf(x1) : x2 > X_CRIT && x1 > 0.0 ? erfc(x1) - erfc(x2) : erf(x2) - erf(x1);\n}"
            ],
            [
                "erfInv",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the inverse erf.\n * <p>\n * This implementation is described in the paper:\n * <a href=\"http://people.maths.ox.ac.uk/gilesm/files/gems_erfinv.pdf\">Approximating\n * the erfinv function</a> by Mike Giles, Oxford-Man Institute of Quantitative Finance,\n * which was published in GPU Computing Gems, volume 2, 2010.\n * The source code is available <a href=\"http://gpucomputing.net/?q=node/1828\">here</a>.\n * </p>\n * @param x the value\n * @return t such that x = erf(t)\n * @since 3.2\n */\npublic static double erfInv(final double x) {\n    // beware that the logarithm argument must be\n    // commputed as (1.0 - x) * (1.0 + x),\n    // it must NOT be simplified as 1.0 - x * x as this\n    // would induce rounding errors near the boundaries +/-1\n    double w = -FastMath.log((1.0 - x) * (1.0 + x));\n    double p;\n    if (w < 6.25) {\n        w -= 3.125;\n        p = -3.6444120640178196996e-21;\n        p = -1.685059138182016589e-19 + p * w;\n        p = 1.2858480715256400167e-18 + p * w;\n        p = 1.115787767802518096e-17 + p * w;\n        p = -1.333171662854620906e-16 + p * w;\n        p = 2.0972767875968561637e-17 + p * w;\n        p = 6.6376381343583238325e-15 + p * w;\n        p = -4.0545662729752068639e-14 + p * w;\n        p = -8.1519341976054721522e-14 + p * w;\n        p = 2.6335093153082322977e-12 + p * w;\n        p = -1.2975133253453532498e-11 + p * w;\n        p = -5.4154120542946279317e-11 + p * w;\n        p = 1.051212273321532285e-09 + p * w;\n        p = -4.1126339803469836976e-09 + p * w;\n        p = -2.9070369957882005086e-08 + p * w;\n        p = 4.2347877827932403518e-07 + p * w;\n        p = -1.3654692000834678645e-06 + p * w;\n        p = -1.3882523362786468719e-05 + p * w;\n        p = 0.0001867342080340571352 + p * w;\n        p = -0.00074070253416626697512 + p * w;\n        p = -0.0060336708714301490533 + p * w;\n        p = 0.24015818242558961693 + p * w;\n        p = 1.6536545626831027356 + p * w;\n    } else if (w < 16.0) {\n        w = FastMath.sqrt(w) - 3.25;\n        p = 2.2137376921775787049e-09;\n        p = 9.0756561938885390979e-08 + p * w;\n        p = -2.7517406297064545428e-07 + p * w;\n        p = 1.8239629214389227755e-08 + p * w;\n        p = 1.5027403968909827627e-06 + p * w;\n        p = -4.013867526981545969e-06 + p * w;\n        p = 2.9234449089955446044e-06 + p * w;\n        p = 1.2475304481671778723e-05 + p * w;\n        p = -4.7318229009055733981e-05 + p * w;\n        p = 6.8284851459573175448e-05 + p * w;\n        p = 2.4031110387097893999e-05 + p * w;\n        p = -0.0003550375203628474796 + p * w;\n        p = 0.00095328937973738049703 + p * w;\n        p = -0.0016882755560235047313 + p * w;\n        p = 0.0024914420961078508066 + p * w;\n        p = -0.0037512085075692412107 + p * w;\n        p = 0.005370914553590063617 + p * w;\n        p = 1.0052589676941592334 + p * w;\n        p = 3.0838856104922207635 + p * w;\n    } else if (!Double.isInfinite(w)) {\n        w = FastMath.sqrt(w) - 5.0;\n        p = -2.7109920616438573243e-11;\n        p = -2.5556418169965252055e-10 + p * w;\n        p = 1.5076572693500548083e-09 + p * w;\n        p = -3.7894654401267369937e-09 + p * w;\n        p = 7.6157012080783393804e-09 + p * w;\n        p = -1.4960026627149240478e-08 + p * w;\n        p = 2.9147953450901080826e-08 + p * w;\n        p = -6.7711997758452339498e-08 + p * w;\n        p = 2.2900482228026654717e-07 + p * w;\n        p = -9.9298272942317002539e-07 + p * w;\n        p = 4.5260625972231537039e-06 + p * w;\n        p = -1.9681778105531670567e-05 + p * w;\n        p = 7.5995277030017761139e-05 + p * w;\n        p = -0.00021503011930044477347 + p * w;\n        p = -0.00013871931833623122026 + p * w;\n        p = 1.0103004648645343977 + p * w;\n        p = 4.8499064014085844221 + p * w;\n    } else {\n        // this branch does not appears in the original code, it\n        // was added because the previous branch does not handle\n        // x = +/-1 correctly. In this case, w is positive infinity\n        // and as the first coefficient (-2.71e-11) is negative.\n        // Once the first multiplication is done, p becomes negative\n        // infinity and remains so throughout the polynomial evaluation.\n        // So the branch above incorrectly returns negative infinity\n        // instead of the correct positive infinity.\n        p = Double.POSITIVE_INFINITY;\n    }\n    return p * x;\n}"
            ],
            [
                "erfcInv",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the inverse erfc.\n * @param x the value\n * @return t such that x = erfc(t)\n * @since 3.2\n */\npublic static double erfcInv(final double x) {\n    return erfInv(1 - x);\n}"
            ],
            [
                "value",
                "org.apache.commons.math3.special",
                "BesselJ",
                "/**\n * Returns the first Bessel function, \\(J_{order}(x)\\).\n *\n * @param order Order of the Bessel function\n * @param x Argument\n * @return Value of the Bessel function of the first kind, \\(J_{order}(x)\\)\n * @throws MathIllegalArgumentException if {@code x} is too large relative to {@code order}\n * @throws ConvergenceException if the algorithm fails to converge\n */\npublic static double value(double order, double x) throws MathIllegalArgumentException, ConvergenceException {\n    final int n = (int) order;\n    final double alpha = order - n;\n    final int nb = n + 1;\n    final BesselJResult res = rjBesl(x, alpha, nb);\n    if (res.nVals >= nb) {\n        return res.vals[n];\n    } else if (res.nVals < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.BESSEL_FUNCTION_BAD_ARGUMENT, order, x);\n    } else if (FastMath.abs(res.vals[res.nVals - 1]) < 1e-100) {\n        // underflow; return value (will be zero)\n        return res.vals[n];\n    }\n    throw new ConvergenceException(LocalizedFormats.BESSEL_FUNCTION_FAILED_CONVERGENCE, order, x);\n}"
            ],
            [
                "rjBesl",
                "org.apache.commons.math3.special",
                "BesselJ",
                "/**\n * Calculates Bessel functions \\(J_{n+alpha}(x)\\) for\n * non-negative argument x, and non-negative order n + alpha.\n * <p>\n * Before using the output vector, the user should check that\n * nVals = nb, i.e., all orders have been calculated to the desired accuracy.\n * See BesselResult class javadoc for details on return values.\n * </p>\n * @param x non-negative real argument for which J's are to be calculated\n * @param alpha fractional part of order for which J's or exponentially\n * scaled J's (\\(J\\cdot e^{x}\\)) are to be calculated. 0 <= alpha < 1.0.\n * @param nb integer number of functions to be calculated, nb > 0. The first\n * function calculated is of order alpha, and the last is of order\n * nb - 1 + alpha.\n * @return BesselJResult a vector of the functions\n * \\(J_{alpha}(x)\\) through \\(J_{nb-1+alpha}(x)\\), or the corresponding exponentially\n * scaled functions and an integer output variable indicating possible errors\n */\npublic static BesselJResult rjBesl(double x, double alpha, int nb) {\n    final double[] b = new double[nb];\n    int ncalc = 0;\n    double alpem = 0;\n    double alp2em = 0;\n    // ---------------------------------------------------------------------\n    // Check for out of range arguments.\n    // ---------------------------------------------------------------------\n    final int magx = (int) x;\n    if ((nb > 0) && (x >= X_MIN) && (x <= X_MAX) && (alpha >= 0) && (alpha < 1)) {\n        // ---------------------------------------------------------------------\n        // Initialize result array to zero.\n        // ---------------------------------------------------------------------\n        ncalc = nb;\n        for (int i = 0; i < nb; ++i) {\n            b[i] = 0;\n        }\n        // ---------------------------------------------------------------------\n        // Branch to use 2-term ascending series for small X and asymptotic\n        // form for large X when NB is not too large.\n        // ---------------------------------------------------------------------\n        double tempa;\n        double tempb;\n        double tempc;\n        double tover;\n        if (x < RTNSIG) {\n            // ---------------------------------------------------------------------\n            // Two-term ascending series for small X.\n            // ---------------------------------------------------------------------\n            tempa = 1;\n            alpem = 1 + alpha;\n            double halfx = 0;\n            if (x > ENMTEN) {\n                halfx = 0.5 * x;\n            }\n            if (alpha != 0) {\n                tempa = FastMath.pow(halfx, alpha) / (alpha * Gamma.gamma(alpha));\n            }\n            tempb = 0;\n            if (x + 1 > 1) {\n                tempb = -halfx * halfx;\n            }\n            b[0] = tempa + (tempa * tempb / alpem);\n            if ((x != 0) && (b[0] == 0)) {\n                ncalc = 0;\n            }\n            if (nb != 1) {\n                if (x <= 0) {\n                    for (int n = 1; n < nb; ++n) {\n                        b[n] = 0;\n                    }\n                } else {\n                    // ---------------------------------------------------------------------\n                    // Calculate higher order functions.\n                    // ---------------------------------------------------------------------\n                    tempc = halfx;\n                    tover = tempb != 0 ? ENMTEN / tempb : 2 * ENMTEN / x;\n                    for (int n = 1; n < nb; ++n) {\n                        tempa /= alpem;\n                        alpem += 1;\n                        tempa *= tempc;\n                        if (tempa <= tover * alpem) {\n                            tempa = 0;\n                        }\n                        b[n] = tempa + (tempa * tempb / alpem);\n                        if ((b[n] == 0) && (ncalc > n)) {\n                            ncalc = n;\n                        }\n                    }\n                }\n            }\n        } else if ((x > 25.0) && (nb <= magx + 1)) {\n            // ---------------------------------------------------------------------\n            // Asymptotic series for X > 25\n            // ---------------------------------------------------------------------\n            final double xc = FastMath.sqrt(PI2 / x);\n            final double mul = 0.125 / x;\n            final double xin = mul * mul;\n            int m = 0;\n            if (x >= 130.0) {\n                m = 4;\n            } else if (x >= 35.0) {\n                m = 8;\n            } else {\n                m = 11;\n            }\n            final double xm = 4.0 * m;\n            // ---------------------------------------------------------------------\n            // Argument reduction for SIN and COS routines.\n            // ---------------------------------------------------------------------\n            double t = (double) ((int) ((x / TWOPI) + 0.5));\n            final double z = x - t * TOWPI1 - t * TWOPI2 - (alpha + 0.5) / PI2;\n            double vsin = FastMath.sin(z);\n            double vcos = FastMath.cos(z);\n            double gnu = 2 * alpha;\n            double capq;\n            double capp;\n            double s;\n            double t1;\n            double xk;\n            for (int i = 1; i <= 2; i++) {\n                s = (xm - 1 - gnu) * (xm - 1 + gnu) * xin * 0.5;\n                t = (gnu - (xm - 3.0)) * (gnu + (xm - 3.0));\n                capp = (s * t) / FACT[2 * m];\n                t1 = (gnu - (xm + 1)) * (gnu + (xm + 1));\n                capq = (s * t1) / FACT[2 * m + 1];\n                xk = xm;\n                int k = 2 * m;\n                t1 = t;\n                for (int j = 2; j <= m; j++) {\n                    xk -= 4.0;\n                    s = (xk - 1 - gnu) * (xk - 1 + gnu);\n                    t = (gnu - (xk - 3.0)) * (gnu + (xk - 3.0));\n                    capp = (capp + 1 / FACT[k - 2]) * s * t * xin;\n                    capq = (capq + 1 / FACT[k - 1]) * s * t1 * xin;\n                    k -= 2;\n                    t1 = t;\n                }\n                capp += 1;\n                capq = (capq + 1) * ((gnu * gnu) - 1) * (0.125 / x);\n                b[i - 1] = xc * (capp * vcos - capq * vsin);\n                if (nb == 1) {\n                    return new BesselJResult(MathArrays.copyOf(b, b.length), ncalc);\n                }\n                t = vsin;\n                vsin = -vcos;\n                vcos = t;\n                gnu += 2.0;\n            }\n            // ---------------------------------------------------------------------\n            // If NB > 2, compute J(X,ORDER+I) I = 2, NB-1\n            // ---------------------------------------------------------------------\n            if (nb > 2) {\n                gnu = 2 * alpha + 2.0;\n                for (int j = 2; j < nb; ++j) {\n                    b[j] = gnu * b[j - 1] / x - b[j - 2];\n                    gnu += 2.0;\n                }\n            }\n        } else {\n            // ---------------------------------------------------------------------\n            // Use recurrence to generate results. First initialize the\n            // calculation of P*S.\n            // ---------------------------------------------------------------------\n            final int nbmx = nb - magx;\n            int n = magx + 1;\n            int nstart = 0;\n            int nend = 0;\n            double en = 2 * (n + alpha);\n            double plast = 1;\n            double p = en / x;\n            double pold;\n            // ---------------------------------------------------------------------\n            // Calculate general significance test.\n            // ---------------------------------------------------------------------\n            double test = 2 * ENSIG;\n            boolean readyToInitialize = false;\n            if (nbmx >= 3) {\n                // ---------------------------------------------------------------------\n                // Calculate P*S until N = NB-1. Check for possible\n                // overflow.\n                // ---------------------------------------------------------------------\n                tover = ENTEN / ENSIG;\n                nstart = magx + 2;\n                nend = nb - 1;\n                en = 2 * (nstart - 1 + alpha);\n                double psave;\n                double psavel;\n                for (int k = nstart; k <= nend; k++) {\n                    n = k;\n                    en += 2.0;\n                    pold = plast;\n                    plast = p;\n                    p = (en * plast / x) - pold;\n                    if (p > tover) {\n                        // ---------------------------------------------------------------------\n                        // To avoid overflow, divide P*S by TOVER. Calculate\n                        // P*S until\n                        // ABS(P) > 1.\n                        // ---------------------------------------------------------------------\n                        tover = ENTEN;\n                        p /= tover;\n                        plast /= tover;\n                        psave = p;\n                        psavel = plast;\n                        nstart = n + 1;\n                        do {\n                            n += 1;\n                            en += 2.0;\n                            pold = plast;\n                            plast = p;\n                            p = (en * plast / x) - pold;\n                        } while (p <= 1);\n                        tempb = en / x;\n                        // ---------------------------------------------------------------------\n                        // Calculate backward test and find NCALC, the\n                        // highest N such that\n                        // the test is passed.\n                        // ---------------------------------------------------------------------\n                        test = pold * plast * (0.5 - 0.5 / (tempb * tempb));\n                        test /= ENSIG;\n                        p = plast * tover;\n                        n -= 1;\n                        en -= 2.0;\n                        nend = FastMath.min(nb, n);\n                        for (int l = nstart; l <= nend; l++) {\n                            pold = psavel;\n                            psavel = psave;\n                            psave = (en * psavel / x) - pold;\n                            if (psave * psavel > test) {\n                                ncalc = l - 1;\n                                readyToInitialize = true;\n                                break;\n                            }\n                        }\n                        ncalc = nend;\n                        readyToInitialize = true;\n                        break;\n                    }\n                }\n                if (!readyToInitialize) {\n                    n = nend;\n                    en = 2 * (n + alpha);\n                    // ---------------------------------------------------------------------\n                    // Calculate special significance test for NBMX > 2.\n                    // ---------------------------------------------------------------------\n                    test = FastMath.max(test, FastMath.sqrt(plast * ENSIG) * FastMath.sqrt(2 * p));\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Calculate P*S until significance test passes.\n            // ---------------------------------------------------------------------\n            if (!readyToInitialize) {\n                do {\n                    n += 1;\n                    en += 2.0;\n                    pold = plast;\n                    plast = p;\n                    p = (en * plast / x) - pold;\n                } while (p < test);\n            }\n            // ---------------------------------------------------------------------\n            // Initialize the backward recursion and the normalization sum.\n            // ---------------------------------------------------------------------\n            n += 1;\n            en += 2.0;\n            tempb = 0;\n            tempa = 1 / p;\n            int m = (2 * n) - 4 * (n / 2);\n            double sum = 0;\n            double em = (double) (n / 2);\n            alpem = em - 1 + alpha;\n            alp2em = 2 * em + alpha;\n            if (m != 0) {\n                sum = tempa * alpem * alp2em / em;\n            }\n            nend = n - nb;\n            boolean readyToNormalize = false;\n            boolean calculatedB0 = false;\n            // ---------------------------------------------------------------------\n            // Recur backward via difference equation, calculating (but not\n            // storing) B(N), until N = NB.\n            // ---------------------------------------------------------------------\n            for (int l = 1; l <= nend; l++) {\n                n -= 1;\n                en -= 2.0;\n                tempc = tempb;\n                tempb = tempa;\n                tempa = (en * tempb / x) - tempc;\n                m = 2 - m;\n                if (m != 0) {\n                    em -= 1;\n                    alp2em = 2 * em + alpha;\n                    if (n == 1) {\n                        break;\n                    }\n                    alpem = em - 1 + alpha;\n                    if (alpem == 0) {\n                        alpem = 1;\n                    }\n                    sum = (sum + tempa * alp2em) * alpem / em;\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Store B(NB).\n            // ---------------------------------------------------------------------\n            b[n - 1] = tempa;\n            if (nend >= 0) {\n                if (nb <= 1) {\n                    alp2em = alpha;\n                    if (alpha + 1 == 1) {\n                        alp2em = 1;\n                    }\n                    sum += b[0] * alp2em;\n                    readyToNormalize = true;\n                } else {\n                    // ---------------------------------------------------------------------\n                    // Calculate and store B(NB-1).\n                    // ---------------------------------------------------------------------\n                    n -= 1;\n                    en -= 2.0;\n                    b[n - 1] = (en * tempa / x) - tempb;\n                    if (n == 1) {\n                        calculatedB0 = true;\n                    } else {\n                        m = 2 - m;\n                        if (m != 0) {\n                            em -= 1;\n                            alp2em = 2 * em + alpha;\n                            alpem = em - 1 + alpha;\n                            if (alpem == 0) {\n                                alpem = 1;\n                            }\n                            sum = (sum + (b[n - 1] * alp2em)) * alpem / em;\n                        }\n                    }\n                }\n            }\n            if (!readyToNormalize && !calculatedB0) {\n                nend = n - 2;\n                if (nend != 0) {\n                    // ---------------------------------------------------------------------\n                    // Calculate via difference equation and store B(N),\n                    // until N = 2.\n                    // ---------------------------------------------------------------------\n                    for (int l = 1; l <= nend; l++) {\n                        n -= 1;\n                        en -= 2.0;\n                        b[n - 1] = (en * b[n] / x) - b[n + 1];\n                        m = 2 - m;\n                        if (m != 0) {\n                            em -= 1;\n                            alp2em = 2 * em + alpha;\n                            alpem = em - 1 + alpha;\n                            if (alpem == 0) {\n                                alpem = 1;\n                            }\n                            sum = (sum + b[n - 1] * alp2em) * alpem / em;\n                        }\n                    }\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Calculate b[0]\n            // ---------------------------------------------------------------------\n            if (!readyToNormalize) {\n                if (!calculatedB0) {\n                    b[0] = 2.0 * (alpha + 1) * b[1] / x - b[2];\n                }\n                em -= 1;\n                alp2em = 2 * em + alpha;\n                if (alp2em == 0) {\n                    alp2em = 1;\n                }\n                sum += b[0] * alp2em;\n            }\n            // ---------------------------------------------------------------------\n            // Normalize. Divide all B(N) by sum.\n            // ---------------------------------------------------------------------\n            if (FastMath.abs(alpha) > 1e-16) {\n                sum *= Gamma.gamma(alpha) * FastMath.pow(x * 0.5, -alpha);\n            }\n            tempa = ENMTEN;\n            if (sum > 1) {\n                tempa *= sum;\n            }\n            for (n = 0; n < nb; n++) {\n                if (FastMath.abs(b[n]) < tempa) {\n                    b[n] = 0;\n                }\n                b[n] /= sum;\n            }\n        }\n        // ---------------------------------------------------------------------\n        // Error return -- X, NB, or ALPHA is out of range.\n        // ---------------------------------------------------------------------\n    } else {\n        if (b.length > 0) {\n            b[0] = 0;\n        }\n        ncalc = FastMath.min(nb, 0) - 1;\n    }\n    return new BesselJResult(MathArrays.copyOf(b, b.length), ncalc);\n}"
            ],
            [
                "logGamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>\n * Returns the value of log&nbsp;&Gamma;(x) for x&nbsp;&gt;&nbsp;0.\n * </p>\n * <p>\n * For x &le; 8, the implementation is based on the double precision\n * implementation in the <em>NSWC Library of Mathematics Subroutines</em>,\n * {@code DGAMLN}. For x &gt; 8, the implementation is based on\n * </p>\n * <ul>\n * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">Gamma\n *     Function</a>, equation (28).</li>\n * <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">\n *     Lanczos Approximation</a>, equations (1) through (5).</li>\n * <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on\n *     the computation of the convergent Lanczos complex Gamma\n *     approximation</a></li>\n * </ul>\n *\n * @param x Argument.\n * @return the value of {@code log(Gamma(x))}, {@code Double.NaN} if\n * {@code x <= 0.0}.\n */\npublic static double logGamma(double x) {\n    double ret;\n    if (Double.isNaN(x) || (x <= 0.0)) {\n        ret = Double.NaN;\n    } else if (x < 0.5) {\n        return logGamma1p(x) - FastMath.log(x);\n    } else if (x <= 2.5) {\n        return logGamma1p((x - 0.5) - 0.5);\n    } else if (x <= 8.0) {\n        final int n = (int) FastMath.floor(x - 1.5);\n        double prod = 1.0;\n        for (int i = 1; i <= n; i++) {\n            prod *= x - i;\n        }\n        return logGamma1p(x - (n + 1)) + FastMath.log(prod);\n    } else {\n        double sum = lanczos(x);\n        double tmp = x + LANCZOS_G + .5;\n        ret = ((x + .5) * FastMath.log(tmp)) - tmp + HALF_LOG_2_PI + FastMath.log(sum / x);\n    }\n    return ret;\n}"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function P(a, x).\n *\n * @param a Parameter.\n * @param x Value.\n * @return the regularized gamma function P(a, x).\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaP(double a, double x) {\n    return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function P(a, x).\n *\n * The implementation of this method is based on:\n * <ul>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n *   Regularized Gamma Function</a>, equation (1)\n *  </li>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n *   Incomplete Gamma Function</a>, equation (4).\n *  </li>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n *   Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n *  </li>\n * </ul>\n *\n * @param a the a parameter.\n * @param x the value.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized gamma function P(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n        ret = Double.NaN;\n    } else if (x == 0.0) {\n        ret = 0.0;\n    } else if (x >= a + 1) {\n        // use regularizedGammaQ because it should converge faster in this\n        // case.\n        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n    } else {\n        // calculate series\n        // current element index\n        double n = 0.0;\n        // n-th element in the series\n        double an = 1.0 / a;\n        // partial sum\n        double sum = an;\n        while (FastMath.abs(an / sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) {\n            // compute next element in the series\n            n += 1.0;\n            an *= x / (a + n);\n            // update partial sum\n            sum += an;\n        }\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(maxIterations);\n        } else if (Double.isInfinite(sum)) {\n            ret = 1.0;\n        } else {\n            ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * sum;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n *\n * @param a the a parameter.\n * @param x the value.\n * @return the regularized gamma function Q(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaQ(double a, double x) {\n    return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n *\n * The implementation of this method is based on:\n * <ul>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n *   Regularized Gamma Function</a>, equation (1).\n *  </li>\n *  <li>\n *   <a href=\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\">\n *   Regularized incomplete gamma function: Continued fraction representations\n *   (formula 06.08.10.0003)</a>\n *  </li>\n * </ul>\n *\n * @param a the a parameter.\n * @param x the value.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized gamma function P(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n        ret = Double.NaN;\n    } else if (x == 0.0) {\n        ret = 1.0;\n    } else if (x < a + 1.0) {\n        // use regularizedGammaP because it should converge faster in this\n        // case.\n        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        // create continued fraction\n        ContinuedFraction cf = new ContinuedFraction() {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}"
            ],
            [
                "digamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>Computes the digamma function of x.</p>\n *\n * <p>This is an independently written implementation of the algorithm described in\n * Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976.</p>\n *\n * <p>Some of the constants have been changed to increase accuracy at the moderate expense\n * of run-time.  The result should be accurate to within 10^-8 absolute tolerance for\n * x >= 10^-5 and within 10^-8 relative tolerance for x > 0.</p>\n *\n * <p>Performance for large negative values of x will be quite expensive (proportional to\n * |x|).  Accuracy for negative values of x should be about 10^-8 absolute for results\n * less than 10^5 and 10^-8 relative for results larger than that.</p>\n *\n * @param x Argument.\n * @return digamma(x) to within 10-8 relative or absolute error whichever is smaller.\n * @see <a href=\"http://en.wikipedia.org/wiki/Digamma_function\">Digamma</a>\n * @see <a href=\"http://www.uv.es/~bernardo/1976AppStatist.pdf\">Bernardo&apos;s original article </a>\n * @since 2.0\n */\npublic static double digamma(double x) {\n    if (Double.isNaN(x) || Double.isInfinite(x)) {\n        return x;\n    }\n    if (x > 0 && x <= S_LIMIT) {\n        // use method 5 from Bernardo AS103\n        // accurate to O(x)\n        return -GAMMA - 1 / x;\n    }\n    if (x >= C_LIMIT) {\n        // use method 4 (accurate to O(1/x^8)\n        double inv = 1 / (x * x);\n        //            1       1        1         1\n        // log(x) -  --- - ------ + ------- - -------\n        //           2 x   12 x^2   120 x^4   252 x^6\n        return FastMath.log(x) - 0.5 / x - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));\n    }\n    return digamma(x + 1) - 1 / x;\n}"
            ],
            [
                "trigamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Computes the trigamma function of x.\n * This function is derived by taking the derivative of the implementation\n * of digamma.\n *\n * @param x Argument.\n * @return trigamma(x) to within 10-8 relative or absolute error whichever is smaller\n * @see <a href=\"http://en.wikipedia.org/wiki/Trigamma_function\">Trigamma</a>\n * @see Gamma#digamma(double)\n * @since 2.0\n */\npublic static double trigamma(double x) {\n    if (Double.isNaN(x) || Double.isInfinite(x)) {\n        return x;\n    }\n    if (x > 0 && x <= S_LIMIT) {\n        return 1 / (x * x);\n    }\n    if (x >= C_LIMIT) {\n        double inv = 1 / (x * x);\n        //  1    1      1       1       1\n        //  - + ---- + ---- - ----- + -----\n        //  x      2      3       5       7\n        //      2 x    6 x    30 x    42 x\n        return 1 / x + inv / 2 + inv / x * (1.0 / 6 - inv * (1.0 / 30 + inv / 42));\n    }\n    return trigamma(x + 1) + 1 / (x * x);\n}"
            ],
            [
                "lanczos",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>\n * Returns the Lanczos approximation used to compute the gamma function.\n * The Lanczos approximation is related to the Gamma function by the\n * following equation\n * <center>\n * {@code gamma(x) = sqrt(2 * pi) / x * (x + g + 0.5) ^ (x + 0.5)\n *                   * exp(-x - g - 0.5) * lanczos(x)},\n * </center>\n * where {@code g} is the Lanczos constant.\n * </p>\n *\n * @param x Argument.\n * @return The Lanczos approximation.\n * @see <a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">Lanczos Approximation</a>\n * equations (1) through (5), and Paul Godfrey's\n * <a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Note on the computation\n * of the convergent Lanczos complex Gamma approximation</a>\n * @since 3.1\n */\npublic static double lanczos(final double x) {\n    double sum = 0.0;\n    for (int i = LANCZOS.length - 1; i > 0; --i) {\n        sum += LANCZOS[i] / (x + i);\n    }\n    return sum + LANCZOS[0];\n}"
            ],
            [
                "invGamma1pm1",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of 1 / &Gamma;(1 + x) - 1 for -0&#46;5 &le; x &le;\n * 1&#46;5. This implementation is based on the double precision\n * implementation in the <em>NSWC Library of Mathematics Subroutines</em>,\n * {@code DGAM1}.\n *\n * @param x Argument.\n * @return The value of {@code 1.0 / Gamma(1.0 + x) - 1.0}.\n * @throws NumberIsTooSmallException if {@code x < -0.5}\n * @throws NumberIsTooLargeException if {@code x > 1.5}\n * @since 3.1\n */\npublic static double invGamma1pm1(final double x) {\n    if (x < -0.5) {\n        throw new NumberIsTooSmallException(x, -0.5, true);\n    }\n    if (x > 1.5) {\n        throw new NumberIsTooLargeException(x, 1.5, true);\n    }\n    final double ret;\n    final double t = x <= 0.5 ? x : (x - 0.5) - 0.5;\n    if (t < 0.0) {\n        final double a = INV_GAMMA1P_M1_A0 + t * INV_GAMMA1P_M1_A1;\n        double b = INV_GAMMA1P_M1_B8;\n        b = INV_GAMMA1P_M1_B7 + t * b;\n        b = INV_GAMMA1P_M1_B6 + t * b;\n        b = INV_GAMMA1P_M1_B5 + t * b;\n        b = INV_GAMMA1P_M1_B4 + t * b;\n        b = INV_GAMMA1P_M1_B3 + t * b;\n        b = INV_GAMMA1P_M1_B2 + t * b;\n        b = INV_GAMMA1P_M1_B1 + t * b;\n        b = 1.0 + t * b;\n        double c = INV_GAMMA1P_M1_C13 + t * (a / b);\n        c = INV_GAMMA1P_M1_C12 + t * c;\n        c = INV_GAMMA1P_M1_C11 + t * c;\n        c = INV_GAMMA1P_M1_C10 + t * c;\n        c = INV_GAMMA1P_M1_C9 + t * c;\n        c = INV_GAMMA1P_M1_C8 + t * c;\n        c = INV_GAMMA1P_M1_C7 + t * c;\n        c = INV_GAMMA1P_M1_C6 + t * c;\n        c = INV_GAMMA1P_M1_C5 + t * c;\n        c = INV_GAMMA1P_M1_C4 + t * c;\n        c = INV_GAMMA1P_M1_C3 + t * c;\n        c = INV_GAMMA1P_M1_C2 + t * c;\n        c = INV_GAMMA1P_M1_C1 + t * c;\n        c = INV_GAMMA1P_M1_C + t * c;\n        if (x > 0.5) {\n            ret = t * c / x;\n        } else {\n            ret = x * ((c + 0.5) + 0.5);\n        }\n    } else {\n        double p = INV_GAMMA1P_M1_P6;\n        p = INV_GAMMA1P_M1_P5 + t * p;\n        p = INV_GAMMA1P_M1_P4 + t * p;\n        p = INV_GAMMA1P_M1_P3 + t * p;\n        p = INV_GAMMA1P_M1_P2 + t * p;\n        p = INV_GAMMA1P_M1_P1 + t * p;\n        p = INV_GAMMA1P_M1_P0 + t * p;\n        double q = INV_GAMMA1P_M1_Q4;\n        q = INV_GAMMA1P_M1_Q3 + t * q;\n        q = INV_GAMMA1P_M1_Q2 + t * q;\n        q = INV_GAMMA1P_M1_Q1 + t * q;\n        q = 1.0 + t * q;\n        double c = INV_GAMMA1P_M1_C13 + (p / q) * t;\n        c = INV_GAMMA1P_M1_C12 + t * c;\n        c = INV_GAMMA1P_M1_C11 + t * c;\n        c = INV_GAMMA1P_M1_C10 + t * c;\n        c = INV_GAMMA1P_M1_C9 + t * c;\n        c = INV_GAMMA1P_M1_C8 + t * c;\n        c = INV_GAMMA1P_M1_C7 + t * c;\n        c = INV_GAMMA1P_M1_C6 + t * c;\n        c = INV_GAMMA1P_M1_C5 + t * c;\n        c = INV_GAMMA1P_M1_C4 + t * c;\n        c = INV_GAMMA1P_M1_C3 + t * c;\n        c = INV_GAMMA1P_M1_C2 + t * c;\n        c = INV_GAMMA1P_M1_C1 + t * c;\n        c = INV_GAMMA1P_M1_C0 + t * c;\n        if (x > 0.5) {\n            ret = (t / x) * ((c - 0.5) - 0.5);\n        } else {\n            ret = x * c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "logGamma1p",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of log &Gamma;(1 + x) for -0&#46;5 &le; x &le; 1&#46;5.\n * This implementation is based on the double precision implementation in\n * the <em>NSWC Library of Mathematics Subroutines</em>, {@code DGMLN1}.\n *\n * @param x Argument.\n * @return The value of {@code log(Gamma(1 + x))}.\n * @throws NumberIsTooSmallException if {@code x < -0.5}.\n * @throws NumberIsTooLargeException if {@code x > 1.5}.\n * @since 3.1\n */\npublic static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException {\n    if (x < -0.5) {\n        throw new NumberIsTooSmallException(x, -0.5, true);\n    }\n    if (x > 1.5) {\n        throw new NumberIsTooLargeException(x, 1.5, true);\n    }\n    return -FastMath.log1p(invGamma1pm1(x));\n}"
            ],
            [
                "gamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of \u0393(x). Based on the <em>NSWC Library of\n * Mathematics Subroutines</em> double precision implementation,\n * {@code DGAMMA}.\n *\n * @param x Argument.\n * @return the value of {@code Gamma(x)}.\n * @since 3.1\n */\npublic static double gamma(final double x) {\n    if ((x == FastMath.rint(x)) && (x <= 0.0)) {\n        return Double.NaN;\n    }\n    final double ret;\n    final double absX = FastMath.abs(x);\n    if (absX <= 20.0) {\n        if (x >= 1.0) {\n            /*\n                 * From the recurrence relation\n                 * Gamma(x) = (x - 1) * ... * (x - n) * Gamma(x - n),\n                 * then\n                 * Gamma(t) = 1 / [1 + invGamma1pm1(t - 1)],\n                 * where t = x - n. This means that t must satisfy\n                 * -0.5 <= t - 1 <= 1.5.\n                 */\n            double prod = 1.0;\n            double t = x;\n            while (t > 2.5) {\n                t -= 1.0;\n                prod *= t;\n            }\n            ret = prod / (1.0 + invGamma1pm1(t - 1.0));\n        } else {\n            /*\n                 * From the recurrence relation\n                 * Gamma(x) = Gamma(x + n + 1) / [x * (x + 1) * ... * (x + n)]\n                 * then\n                 * Gamma(x + n + 1) = 1 / [1 + invGamma1pm1(x + n)],\n                 * which requires -0.5 <= x + n <= 1.5.\n                 */\n            double prod = x;\n            double t = x;\n            while (t < -0.5) {\n                t += 1.0;\n                prod *= t;\n            }\n            ret = 1.0 / (prod * (1.0 + invGamma1pm1(t)));\n        }\n    } else {\n        final double y = absX + LANCZOS_G + 0.5;\n        final double gammaAbs = SQRT_TWO_PI / absX * FastMath.pow(y, absX + 0.5) * FastMath.exp(-y) * lanczos(absX);\n        if (x > 0.0) {\n            ret = gammaAbs;\n        } else {\n            /*\n                 * From the reflection formula\n                 * Gamma(x) * Gamma(1 - x) * sin(pi * x) = pi,\n                 * and the recurrence relation\n                 * Gamma(1 - x) = -x * Gamma(-x),\n                 * it is found\n                 * Gamma(x) = -pi / [x * sin(pi * x) * Gamma(-x)].\n                 */\n            ret = -FastMath.PI / (x * FastMath.sin(FastMath.PI * x) * gammaAbs);\n        }\n    }\n    return ret;\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * regularized beta function</a> I(x, a, b).\n *\n * @param x Value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @return the regularized beta function I(x, a, b).\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b) {\n    return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * regularized beta function</a> I(x, a, b).\n *\n * @param x Value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b, double epsilon) {\n    return regularizedBeta(x, a, b, epsilon, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b, int maxIterations) {\n    return regularizedBeta(x, a, b, DEFAULT_EPSILON, maxIterations);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li>\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * Regularized Beta Function</a>.</li>\n * <li>\n * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n * Regularized Beta Function</a>.</li>\n * </ul>\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0 || b <= 0) {\n        ret = Double.NaN;\n    } else if (x > (a + 1) / (2 + b + a) && 1 - x <= (b + 1) / (2 + b + a)) {\n        ret = 1 - regularizedBeta(1 - x, b, a, epsilon, maxIterations);\n    } else {\n        ContinuedFraction fraction = new ContinuedFraction() {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getB(int n, double x) {\n                double ret;\n                double m;\n                if (n % 2 == 0) {\n                    // even\n                    m = n / 2.0;\n                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));\n                } else {\n                    m = (n - 1.0) / 2.0;\n                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                }\n                return ret;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getA(int n, double x) {\n                return 1.0;\n            }\n        };\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n    }\n    return ret;\n}"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the natural logarithm of the beta function B(a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n * Beta Function</a>, equation (1).</li>\n * </ul>\n *\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon This parameter is ignored.\n * @param maxIterations This parameter is ignored.\n * @return log(B(a, b)).\n * @deprecated as of version 3.1, this method is deprecated as the\n * computation of the beta function is no longer iterative; it will be\n * removed in version 4.0. Current implementation of this method\n * internally calls {@link #logBeta(double, double)}.\n */\n@Deprecated\npublic static double logBeta(double a, double b, double epsilon, int maxIterations) {\n    return logBeta(a, b);\n}"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the value of log B(p, q) for 0 \u2264 x \u2264 1 and p, q > 0. Based on the\n * <em>NSWC Library of Mathematics Subroutines</em> implementation,\n * {@code DBETLN}.\n *\n * @param p First argument.\n * @param q Second argument.\n * @return the value of {@code log(Beta(p, q))}, {@code NaN} if\n * {@code p <= 0} or {@code q <= 0}.\n */\npublic static double logBeta(final double p, final double q) {\n    if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n        return Double.NaN;\n    }\n    final double a = FastMath.min(p, q);\n    final double b = FastMath.max(p, q);\n    if (a >= 10.0) {\n        final double w = sumDeltaMinusDeltaSum(a, b);\n        final double h = a / b;\n        final double c = h / (1.0 + h);\n        final double u = -(a - 0.5) * FastMath.log(c);\n        final double v = b * FastMath.log1p(h);\n        if (u <= v) {\n            return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;\n        } else {\n            return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n        }\n    } else if (a > 2.0) {\n        if (b > 1000.0) {\n            final int n = (int) FastMath.floor(a - 1.0);\n            double prod = 1.0;\n            double ared = a;\n            for (int i = 0; i < n; i++) {\n                ared -= 1.0;\n                prod *= ared / (1.0 + ared / b);\n            }\n            return (FastMath.log(prod) - n * FastMath.log(b)) + (Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared, b));\n        } else {\n            double prod1 = 1.0;\n            double ared = a;\n            while (ared > 2.0) {\n                ared -= 1.0;\n                final double h = ared / b;\n                prod1 *= h / (1.0 + h);\n            }\n            if (b < 10.0) {\n                double prod2 = 1.0;\n                double bred = b;\n                while (bred > 2.0) {\n                    bred -= 1.0;\n                    prod2 *= bred / (ared + bred);\n                }\n                return FastMath.log(prod1) + FastMath.log(prod2) + (Gamma.logGamma(ared) + (Gamma.logGamma(bred) - logGammaSum(ared, bred)));\n            } else {\n                return FastMath.log(prod1) + Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared, b);\n            }\n        }\n    } else if (a >= 1.0) {\n        if (b > 2.0) {\n            if (b < 10.0) {\n                double prod = 1.0;\n                double bred = b;\n                while (bred > 2.0) {\n                    bred -= 1.0;\n                    prod *= bred / (a + bred);\n                }\n                return FastMath.log(prod) + (Gamma.logGamma(a) + (Gamma.logGamma(bred) - logGammaSum(a, bred)));\n            } else {\n                return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a, b);\n            }\n        } else {\n            return Gamma.logGamma(a) + Gamma.logGamma(b) - logGammaSum(a, b);\n        }\n    } else {\n        if (b >= 10.0) {\n            return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a, b);\n        } else {\n            // The following command is the original NSWC implementation.\n            // return Gamma.logGamma(a) +\n            // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n            // The following command turns out to be more accurate.\n            return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) / Gamma.gamma(a + b));\n        }\n    }\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.sampling",
                "DummyStepHandler",
                "/**\n * Get the only instance.\n * @return the only instance\n */\npublic static DummyStepHandler getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckTransformer",
                "/**\n * Get the Nordsieck transformer for a given number of steps.\n * @param nSteps number of steps of the multistep method\n * (excluding the one being computed)\n * @return Nordsieck transformer for the specified number of steps\n */\npublic static AdamsNordsieckTransformer getInstance(final int nSteps) {\n    synchronized (CACHE) {\n        AdamsNordsieckTransformer t = CACHE.get(nSteps);\n        if (t == null) {\n            t = new AdamsNordsieckTransformer(nSteps);\n            CACHE.put(nSteps, t);\n        }\n        return t;\n    }\n}"
            ],
            [
                "taylor",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsFieldStepInterpolator",
                "/**\n * Estimate state by applying Taylor formula.\n * @param reference reference state\n * @param time time at which state must be estimated\n * @param stepSize step size used in the scaled and Nordsieck arrays\n * @param scaled first scaled derivative\n * @param nordsieck Nordsieck vector\n * @return estimated state\n * @param <S> the type of the field elements\n */\npublic static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference, final S time, final S stepSize, final S[] scaled, final Array2DRowFieldMatrix<S> nordsieck) {\n    final S x = time.subtract(reference.getTime());\n    final S normalizedAbscissa = x.divide(stepSize);\n    S[] stateVariation = MathArrays.buildArray(time.getField(), scaled.length);\n    Arrays.fill(stateVariation, time.getField().getZero());\n    S[] estimatedDerivatives = MathArrays.buildArray(time.getField(), scaled.length);\n    Arrays.fill(estimatedDerivatives, time.getField().getZero());\n    // apply Taylor formula from high order to low order,\n    // for the sake of numerical accuracy\n    final S[][] nData = nordsieck.getDataRef();\n    for (int i = nData.length - 1; i >= 0; --i) {\n        final int order = i + 2;\n        final S[] nDataI = nData[i];\n        final S power = normalizedAbscissa.pow(order);\n        for (int j = 0; j < nDataI.length; ++j) {\n            final S d = nDataI[j].multiply(power);\n            stateVariation[j] = stateVariation[j].add(d);\n            estimatedDerivatives[j] = estimatedDerivatives[j].add(d.multiply(order));\n        }\n    }\n    S[] estimatedState = reference.getState();\n    for (int j = 0; j < stateVariation.length; ++j) {\n        stateVariation[j] = stateVariation[j].add(scaled[j].multiply(normalizedAbscissa));\n        estimatedState[j] = estimatedState[j].add(stateVariation[j]);\n        estimatedDerivatives[j] = estimatedDerivatives[j].add(scaled[j].multiply(normalizedAbscissa)).divide(x);\n    }\n    return new FieldODEStateAndDerivative<S>(time, estimatedState, estimatedDerivatives);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckFieldTransformer",
                "/**\n * Get the Nordsieck transformer for a given field and number of steps.\n * @param field field to which the time and state vector elements belong\n * @param nSteps number of steps of the multistep method\n * (excluding the one being computed)\n * @return Nordsieck transformer for the specified field and number of steps\n * @param <T> the type of the field elements\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T extends RealFieldElement<T>> AdamsNordsieckFieldTransformer<T> getInstance(final Field<T> field, final int nSteps) {\n    synchronized (CACHE) {\n        Map<Field<? extends RealFieldElement<?>>, AdamsNordsieckFieldTransformer<? extends RealFieldElement<?>>> map = CACHE.get(nSteps);\n        if (map == null) {\n            map = new HashMap<Field<? extends RealFieldElement<?>>, AdamsNordsieckFieldTransformer<? extends RealFieldElement<?>>>();\n            CACHE.put(nSteps, map);\n        }\n        // use rawtype to avoid compilation problems with java 1.5\n        @SuppressWarnings(\"rawtypes\")\n        AdamsNordsieckFieldTransformer t = map.get(field);\n        if (t == null) {\n            t = new AdamsNordsieckFieldTransformer<T>(field, nSteps);\n            map.put(field, (AdamsNordsieckFieldTransformer<T>) t);\n        }\n        return (AdamsNordsieckFieldTransformer<T>) t;\n    }\n}"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the values in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the input array\n * is null.</p>\n *\n * @param values  array of values to sum\n * @return the sum of the values or <code>Double.NaN</code> if the array\n * is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sum(final double[] values) throws MathIllegalArgumentException {\n    return SUM.evaluate(values);\n}"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double sum(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM.evaluate(values, begin, length);\n}"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the squares of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values  input array\n * @return the sum of the squared values or <code>Double.NaN</code> if the\n * array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sumSq(final double[] values) throws MathIllegalArgumentException {\n    return SUM_OF_SQUARES.evaluate(values);\n}"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the squares of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the squares of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double sumSq(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM_OF_SQUARES.evaluate(values, begin, length);\n}"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the product of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the product of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double product(final double[] values) throws MathIllegalArgumentException {\n    return PRODUCT.evaluate(values);\n}"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the product of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the product of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double product(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return PRODUCT.evaluate(values, begin, length);\n}"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the natural logs of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.summary.SumOfLogs}.\n * </p>\n *\n * @param values the input array\n * @return the sum of the natural logs of the values or Double.NaN if\n * the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sumLog(final double[] values) throws MathIllegalArgumentException {\n    return SUM_OF_LOGS.evaluate(values);\n}"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the natural logs of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.summary.SumOfLogs}.\n * </p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the natural logs of the values or Double.NaN if\n * length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double sumLog(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM_OF_LOGS.evaluate(values, begin, length);\n}"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the arithmetic mean of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Mean} for\n * details on the computing algorithm.</p>\n *\n * @param values the input array\n * @return the mean of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double mean(final double[] values) throws MathIllegalArgumentException {\n    return MEAN.evaluate(values);\n}"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the arithmetic mean of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Mean} for\n * details on the computing algorithm.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the mean of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double mean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MEAN.evaluate(values, begin, length);\n}"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the geometric mean of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.GeometricMean}\n * for details on the computing algorithm.</p>\n *\n * @param values the input array\n * @return the geometric mean of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double geometricMean(final double[] values) throws MathIllegalArgumentException {\n    return GEOMETRIC_MEAN.evaluate(values);\n}"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the geometric mean of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.GeometricMean}\n * for details on the computing algorithm.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the geometric mean of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double geometricMean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return GEOMETRIC_MEAN.evaluate(values, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[])} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double variance(final double[] values) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], int, int)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double variance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the specified portion of\n * the input array, using the precomputed mean value.  Returns\n * <code>Double.NaN</code> if the designated subarray is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], double, int, int)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double variance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, mean, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the input array, using the\n * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n * is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], double)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @return the variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double variance(final double[] values, final double mean) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, mean);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the formula and computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the population variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double populationVariance(final double[] values) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the population variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double populationVariance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, begin, length);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the specified portion of\n * the input array, using the precomputed mean value.  Returns\n * <code>Double.NaN</code> if the designated subarray is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the population variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double populationVariance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, mean, begin, length);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the input array, using the\n * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n * is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @return the population variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double populationVariance(final double[] values, final double mean) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, mean);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the maximum of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @return the maximum of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double max(final double[] values) throws MathIllegalArgumentException {\n    return MAX.evaluate(values);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the maximum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or\n * the array index parameters are not valid.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the maximum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double max(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MAX.evaluate(values, begin, length);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the minimum of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n * </ul> </p>\n *\n * @param values the input array\n * @return the minimum of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double min(final double[] values) throws MathIllegalArgumentException {\n    return MIN.evaluate(values);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the minimum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or\n * the array index parameters are not valid.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the minimum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double min(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MIN.evaluate(values, begin, length);\n}"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns an estimate of the <code>p</code>th percentile of the values\n * in the <code>values</code> array.\n * <p>\n * <ul>\n * <li>Returns <code>Double.NaN</code> if <code>values</code> has length\n * <code>0</code></li></p>\n * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n *  if <code>values</code> has length <code>1</code></li>\n * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n * is null  or p is not a valid quantile value (p must be greater than 0\n * and less than or equal to 100)</li>\n * </ul></p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n * a description of the percentile estimation algorithm used.</p>\n *\n * @param values input array of values\n * @param p the percentile value to compute\n * @return the percentile value or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if <code>values</code> is null\n * or p is invalid\n */\npublic static double percentile(final double[] values, final double p) throws MathIllegalArgumentException {\n    return PERCENTILE.evaluate(values, p);\n}"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns an estimate of the <code>p</code>th percentile of the values\n * in the <code>values</code> array, starting with the element in (0-based)\n * position <code>begin</code> in the array and including <code>length</code>\n * values.\n * <p>\n * <ul>\n * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n *  if <code>length = 1 </code></li>\n * <li>Throws <code>MathIllegalArgumentException</code> if <code>values</code>\n *  is null , <code>begin</code> or <code>length</code> is invalid, or\n * <code>p</code> is not a valid quantile value (p must be greater than 0\n * and less than or equal to 100)</li>\n * </ul></p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n * a description of the percentile estimation algorithm used.</p>\n *\n * @param values array of input values\n * @param p  the percentile to compute\n * @param begin  the first (0-based) element to include in the computation\n * @param length  the number of array elements to include\n * @return  the percentile value\n * @throws MathIllegalArgumentException if the parameters are not valid or the\n * input array is null\n */\npublic static double percentile(final double[] values, final int begin, final int length, final double p) throws MathIllegalArgumentException {\n    return PERCENTILE.evaluate(values, begin, length, p);\n}"
            ],
            [
                "sumDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., sum(sample1[i] - sample2[i]).\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @return sum of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * (positive) length.\n * @throws NoDataException if the sample arrays are empty.\n */\npublic static double sumDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n <= 0) {\n        throw new NoDataException(LocalizedFormats.INSUFFICIENT_DIMENSION);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        result += sample1[i] - sample2[i];\n    }\n    return result;\n}"
            ],
            [
                "meanDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the mean of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., sum(sample1[i] - sample2[i]) / sample1.length.\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @return mean of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * (positive) length.\n * @throws NoDataException if the sample arrays are empty.\n */\npublic static double meanDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException {\n    return sumDifference(sample1, sample2) / sample1.length;\n}"
            ],
            [
                "varianceDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., var(sample1[i] - sample2[i]).\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @param meanDifference   the mean difference between corresponding entries\n * @see #meanDifference(double[],double[])\n * @return variance of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * length.\n * @throws NumberIsTooSmallException if the arrays length is less than 2.\n */\npublic static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference) throws DimensionMismatchException, NumberIsTooSmallException {\n    double sum1 = 0d;\n    double sum2 = 0d;\n    double diff = 0d;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    for (int i = 0; i < n; i++) {\n        diff = sample1[i] - sample2[i];\n        sum1 += (diff - meanDifference) * (diff - meanDifference);\n        sum2 += diff - meanDifference;\n    }\n    return (sum1 - (sum2 * sum2 / n)) / (n - 1);\n}"
            ],
            [
                "normalize",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Normalize (standardize) the sample, so it is has a mean of 0 and a standard deviation of 1.\n *\n * @param sample Sample to normalize.\n * @return normalized (standardized) sample.\n * @since 2.2\n */\npublic static double[] normalize(final double[] sample) {\n    DescriptiveStatistics stats = new DescriptiveStatistics();\n    // Add the data from the series to stats\n    for (int i = 0; i < sample.length; i++) {\n        stats.addValue(sample[i]);\n    }\n    // Compute mean and standard deviation\n    double mean = stats.getMean();\n    double standardDeviation = stats.getStandardDeviation();\n    // initialize the standardizedSample, which has the same length as the sample\n    double[] standardizedSample = new double[sample.length];\n    for (int i = 0; i < sample.length; i++) {\n        // z = (x- mean)/standardDeviation\n        standardizedSample[i] = (sample[i] - mean) / standardDeviation;\n    }\n    return standardizedSample;\n}"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sample mode(s).  The mode is the most frequently occurring\n * value in the sample. If there is a unique value with maximum frequency,\n * this value is returned as the only element of the output array. Otherwise,\n * the returned array contains the maximum frequency elements in increasing\n * order.  For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},\n * the returned array will have length two, with 0 in the first element and\n * 5 in the second.\n *\n * <p>NaN values are ignored when computing the mode - i.e., NaNs will never\n * appear in the output array.  If the sample includes only NaNs or has\n * length 0, an empty array is returned.</p>\n *\n * @param sample input data\n * @return array of array of the most frequently occurring element(s) sorted in ascending order.\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static double[] mode(double[] sample) throws MathIllegalArgumentException {\n    if (sample == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    return getMode(sample, 0, sample.length);\n}"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sample mode(s).  The mode is the most frequently occurring\n * value in the sample. If there is a unique value with maximum frequency,\n * this value is returned as the only element of the output array. Otherwise,\n * the returned array contains the maximum frequency elements in increasing\n * order.  For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},\n * the returned array will have length two, with 0 in the first element and\n * 5 in the second.\n *\n * <p>NaN values are ignored when computing the mode - i.e., NaNs will never\n * appear in the output array.  If the sample includes only NaNs or has\n * length 0, an empty array is returned.</p>\n *\n * @param sample input data\n * @param begin index (0-based) of the first array element to include\n * @param length the number of elements to include\n *\n * @return array of array of the most frequently occurring element(s) sorted in ascending order.\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static double[] mode(double[] sample, final int begin, final int length) {\n    if (sample == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    if (begin < 0) {\n        throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));\n    }\n    if (length < 0) {\n        throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));\n    }\n    return getMode(sample, begin, length);\n}"
            ],
            [
                "getAgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create an Agresti-Coull binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getAgrestiCoullInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return AGRESTI_COULL.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a Clopper-Pearson binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n * <p>\n * Preconditions:\n * <ul>\n * <li>{@code numberOfTrials} must be positive</li>\n * <li>{@code numberOfSuccesses} may not exceed {@code numberOfTrials}</li>\n * <li>{@code confidenceLevel} must be strictly between 0 and 1 (exclusive)</li>\n * </ul>\n * </p>\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getClopperPearsonInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return CLOPPER_PEARSON.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getNormalApproximationInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a binomial confidence interval for the true probability of success\n * of an unknown binomial distribution with the given observed number of\n * trials, successes and confidence level using the Normal approximation to\n * the binomial distribution.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n */\npublic static ConfidenceInterval getNormalApproximationInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return NORMAL_APPROXIMATION.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getWilsonScoreInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a Wilson score binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getWilsonScoreInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return WILSON_SCORE.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "// CHECKSTYLE: stop JavadocMethodCheck\n/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticT(double[], double[])\n */\npublic static double homoscedasticT(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.homoscedasticT(sample1, sample2);\n}"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticT(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double homoscedasticT(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.homoscedasticT(sampleStats1, sampleStats2);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(double[], double[], double)\n */\npublic static boolean homoscedasticTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sample1, sample2, alpha);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(double[], double[])\n */\npublic static double homoscedasticTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sample1, sample2);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double homoscedasticTTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sampleStats1, sampleStats2);\n}"
            ],
            [
                "pairedT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedT(double[], double[])\n */\npublic static double pairedT(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException {\n    return T_TEST.pairedT(sample1, sample2);\n}"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedTTest(double[], double[], double)\n */\npublic static boolean pairedTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.pairedTTest(sample1, sample2, alpha);\n}"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedTTest(double[], double[])\n */\npublic static double pairedTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.pairedTTest(sample1, sample2);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double, double[])\n */\npublic static double t(final double mu, final double[] observed) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(mu, observed);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double t(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(mu, sampleStats);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double[], double[])\n */\npublic static double t(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(sample1, sample2);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double t(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(sampleStats1, sampleStats2);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, double[], double)\n */\npublic static boolean tTest(final double mu, final double[] sample, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sample, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, double[])\n */\npublic static double tTest(final double mu, final double[] sample) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sample);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary, double)\n */\npublic static boolean tTest(final double mu, final StatisticalSummary sampleStats, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sampleStats, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double tTest(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sampleStats);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double[], double[], double)\n */\npublic static boolean tTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(sample1, sample2, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double[], double[])\n */\npublic static double tTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(sample1, sample2);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary, double)\n */\npublic static boolean tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(sampleStats1, sampleStats2, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(sampleStats1, sampleStats2);\n}"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquare(double[], long[])\n */\npublic static double chiSquare(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException {\n    return CHI_SQUARE_TEST.chiSquare(expected, observed);\n}"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquare(long[][])\n */\npublic static double chiSquare(final long[][] counts) throws NullArgumentException, NotPositiveException, DimensionMismatchException {\n    return CHI_SQUARE_TEST.chiSquare(counts);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(double[], long[], double)\n */\npublic static boolean chiSquareTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(expected, observed, alpha);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(double[], long[])\n */\npublic static double chiSquareTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(expected, observed);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(long[][], double)\n */\npublic static boolean chiSquareTest(final long[][] counts, final double alpha) throws NullArgumentException, DimensionMismatchException, NotPositiveException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(counts, alpha);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(long[][])\n */\npublic static double chiSquareTest(final long[][] counts) throws NullArgumentException, DimensionMismatchException, NotPositiveException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(counts);\n}"
            ],
            [
                "chiSquareDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareDataSetsComparison(long[], long[])\n *\n * @since 1.2\n */\npublic static double chiSquareDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return CHI_SQUARE_TEST.chiSquareDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTestDataSetsComparison(long[], long[])\n *\n * @since 1.2\n */\npublic static double chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTestDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTestDataSetsComparison(long[], long[], double)\n *\n * @since 1.2\n */\npublic static boolean chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTestDataSetsComparison(observed1, observed2, alpha);\n}"
            ],
            [
                "oneWayAnovaFValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaFValue(Collection)\n *\n * @since 1.2\n */\npublic static double oneWayAnovaFValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException {\n    return ONE_WAY_ANANOVA.anovaFValue(categoryData);\n}"
            ],
            [
                "oneWayAnovaPValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaPValue(Collection)\n *\n * @since 1.2\n */\npublic static double oneWayAnovaPValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException, ConvergenceException, MaxCountExceededException {\n    return ONE_WAY_ANANOVA.anovaPValue(categoryData);\n}"
            ],
            [
                "oneWayAnovaTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaTest(Collection,double)\n *\n * @since 1.2\n */\npublic static boolean oneWayAnovaTest(final Collection<double[]> categoryData, final double alpha) throws NullArgumentException, DimensionMismatchException, OutOfRangeException, ConvergenceException, MaxCountExceededException {\n    return ONE_WAY_ANANOVA.anovaTest(categoryData, alpha);\n}"
            ],
            [
                "g",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#g(double[], long[])\n * @since 3.1\n */\npublic static double g(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException {\n    return G_TEST.g(expected, observed);\n}"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTest( double[],  long[] )\n * @since 3.1\n */\npublic static double gTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return G_TEST.gTest(expected, observed);\n}"
            ],
            [
                "gTestIntrinsic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestIntrinsic(double[], long[] )\n * @since 3.1\n */\npublic static double gTestIntrinsic(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return G_TEST.gTestIntrinsic(expected, observed);\n}"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTest( double[],long[],double)\n * @since 3.1\n */\npublic static boolean gTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException {\n    return G_TEST.gTest(expected, observed, alpha);\n}"
            ],
            [
                "gDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gDataSetsComparison(long[], long[])\n * @since 3.1\n */\npublic static double gDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return G_TEST.gDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "rootLogLikelihoodRatio",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#rootLogLikelihoodRatio(long, long, long, long)\n * @since 3.1\n */\npublic static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return G_TEST.rootLogLikelihoodRatio(k11, k12, k21, k22);\n}"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestDataSetsComparison(long[], long[])\n * @since 3.1\n */\npublic static double gTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException {\n    return G_TEST.gTestDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestDataSetsComparison(long[],long[],double)\n * @since 3.1\n */\npublic static boolean gTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException {\n    return G_TEST.gTestDataSetsComparison(observed1, observed2, alpha);\n}"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovStatistic(RealDistribution, double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovStatistic(dist, data);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[], boolean)\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data, strict);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[], double)\n * @since 3.3\n */\npublic static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data, alpha);\n}"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovStatistic(double[], double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovStatistic(double[] x, double[] y) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovStatistic(x, y);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(double[], double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(double[] x, double[] y) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(x, y);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(double[], double[], boolean)\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(double[] x, double[] y, boolean strict) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(x, y, strict);\n}"
            ],
            [
                "exactP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#exactP(double, int, int, boolean)\n * @since 3.3\n */\npublic static double exactP(double d, int m, int n, boolean strict) {\n    return KS_TEST.exactP(d, n, m, strict);\n}"
            ],
            [
                "approximateP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#approximateP(double, int, int)\n * @since 3.3\n */\npublic static double approximateP(double d, int n, int m) {\n    return KS_TEST.approximateP(d, n, m);\n}"
            ],
            [
                "monteCarloP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#monteCarloP(double, int, int, boolean, int)\n * @since 3.3\n */\npublic static double monteCarloP(double d, int n, int m, boolean strict, int iterations) {\n    return KS_TEST.monteCarloP(d, n, m, strict, iterations);\n}"
            ],
            [
                "aggregate",
                "org.apache.commons.math3.stat.descriptive",
                "AggregateSummaryStatistics",
                "/**\n * Computes aggregate summary statistics. This method can be used to combine statistics\n * computed over partitions or subsamples - i.e., the StatisticalSummaryValues returned\n * should contain the same values that would have been obtained by computing a single\n * StatisticalSummary over the combined dataset.\n * <p>\n * Returns null if the collection is empty or null.\n * </p>\n *\n * @param statistics collection of SummaryStatistics to aggregate\n * @return summary statistics for the combined dataset\n */\npublic static StatisticalSummaryValues aggregate(Collection<? extends StatisticalSummary> statistics) {\n    if (statistics == null) {\n        return null;\n    }\n    Iterator<? extends StatisticalSummary> iterator = statistics.iterator();\n    if (!iterator.hasNext()) {\n        return null;\n    }\n    StatisticalSummary current = iterator.next();\n    long n = current.getN();\n    double min = current.getMin();\n    double sum = current.getSum();\n    double max = current.getMax();\n    double var = current.getVariance();\n    double m2 = var * (n - 1d);\n    double mean = current.getMean();\n    while (iterator.hasNext()) {\n        current = iterator.next();\n        if (current.getMin() < min || Double.isNaN(min)) {\n            min = current.getMin();\n        }\n        if (current.getMax() > max || Double.isNaN(max)) {\n            max = current.getMax();\n        }\n        sum += current.getSum();\n        final double oldN = n;\n        final double curN = current.getN();\n        n += curN;\n        final double meanDiff = current.getMean() - mean;\n        mean = sum / n;\n        final double curM2 = current.getVariance() * (curN - 1d);\n        m2 = m2 + curM2 + meanDiff * meanDiff * oldN * curN / n;\n    }\n    final double variance;\n    if (n == 0) {\n        variance = Double.NaN;\n    } else if (n == 1) {\n        variance = 0d;\n    } else {\n        variance = m2 / (n - 1);\n    }\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}"
            ],
            [
                "newMarkers",
                "org.apache.commons.math3.stat.descriptive.rank",
                "PSquarePercentile",
                "/**\n * A creation method to build Markers\n *\n * @param initialFive list of initial five elements\n * @param p the quantile desired\n * @return an instance of PSquareMarkers\n */\npublic static PSquareMarkers newMarkers(final List<Double> initialFive, final double p) {\n    return new Markers(initialFive, p);\n}"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "/**\n * Creates an exponential decay {@link NeighbourhoodSizeFunction function}.\n * It will compute <code>a e<sup>-x / b</sup></code>,\n * where {@code x} is the (integer) independent variable and\n * <ul>\n *  <li><code>a = initValue</code>\n *  <li><code>b = -numCall / ln(valueAtNumCall / initValue)</code>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link NeighbourhoodSizeFunction#value(long) value(0)}.\n * @param valueAtNumCall Value of the function at {@code numCall}.\n * @param numCall Argument for which the function returns\n * {@code valueAtNumCall}.\n * @return the neighbourhood size function.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code initValue <= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code valueAtNumCall <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code valueAtNumCall >= initValue}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static NeighbourhoodSizeFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall) {\n    return new NeighbourhoodSizeFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final ExponentialDecayFunction decay = new ExponentialDecayFunction(initValue, valueAtNumCall, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public int value(long n) {\n            return (int) FastMath.rint(decay.value(n));\n        }\n    };\n}"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "/**\n * Creates an sigmoid-like {@code NeighbourhoodSizeFunction function}.\n * The function {@code f} will have the following properties:\n * <ul>\n *  <li>{@code f(0) = initValue}</li>\n *  <li>{@code numCall} is the inflexion point</li>\n *  <li>{@code slope = f'(numCall)}</li>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link NeighbourhoodSizeFunction#value(long) value(0)}.\n * @param slope Value of the function derivative at {@code numCall}.\n * @param numCall Inflexion point.\n * @return the neighbourhood size function.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code initValue <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code slope >= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static NeighbourhoodSizeFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall) {\n    return new NeighbourhoodSizeFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final QuasiSigmoidDecayFunction decay = new QuasiSigmoidDecayFunction(initValue, slope, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public int value(long n) {\n            return (int) FastMath.rint(decay.value(n));\n        }\n    };\n}"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "/**\n * Creates an exponential decay {@link LearningFactorFunction function}.\n * It will compute <code>a e<sup>-x / b</sup></code>,\n * where {@code x} is the (integer) independent variable and\n * <ul>\n *  <li><code>a = initValue</code>\n *  <li><code>b = -numCall / ln(valueAtNumCall / initValue)</code>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link LearningFactorFunction#value(long) value(0)}.\n * @param valueAtNumCall Value of the function at {@code numCall}.\n * @param numCall Argument for which the function returns\n * {@code valueAtNumCall}.\n * @return the learning factor function.\n * @throws org.apache.commons.math3.exception.OutOfRangeException\n * if {@code initValue <= 0} or {@code initValue > 1}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code valueAtNumCall <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code valueAtNumCall >= initValue}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static LearningFactorFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall) {\n    if (initValue <= 0 || initValue > 1) {\n        throw new OutOfRangeException(initValue, 0, 1);\n    }\n    return new LearningFactorFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final ExponentialDecayFunction decay = new ExponentialDecayFunction(initValue, valueAtNumCall, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(long n) {\n            return decay.value(n);\n        }\n    };\n}"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "/**\n * Creates an sigmoid-like {@code LearningFactorFunction function}.\n * The function {@code f} will have the following properties:\n * <ul>\n *  <li>{@code f(0) = initValue}</li>\n *  <li>{@code numCall} is the inflexion point</li>\n *  <li>{@code slope = f'(numCall)}</li>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link LearningFactorFunction#value(long) value(0)}.\n * @param slope Value of the function derivative at {@code numCall}.\n * @param numCall Inflexion point.\n * @return the learning factor function.\n * @throws org.apache.commons.math3.exception.OutOfRangeException\n * if {@code initValue <= 0} or {@code initValue > 1}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code slope >= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static LearningFactorFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall) {\n    if (initValue <= 0 || initValue > 1) {\n        throw new OutOfRangeException(initValue, 0, 1);\n    }\n    return new LearningFactorFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final QuasiSigmoidDecayFunction decay = new QuasiSigmoidDecayFunction(initValue, slope, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(long n) {\n            return decay.value(n);\n        }\n    };\n}"
            ],
            [
                "findBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Finds the neuron that best matches the given features.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If the list is empty\n * {@code null} will be returned.\n * @param distance Distance function. The neuron's features are\n * passed as the first argument to {@link DistanceMeasure#compute(double[],double[])}.\n * @return the neuron whose features are closest to the given data.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n */\npublic static Neuron findBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    Neuron best = null;\n    double min = Double.POSITIVE_INFINITY;\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        if (d < min) {\n            min = d;\n            best = n;\n        }\n    }\n    return best;\n}"
            ],
            [
                "findBestAndSecondBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Finds the two neurons that best match the given features.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If the list is empty\n * {@code null} will be returned.\n * @param distance Distance function. The neuron's features are\n * passed as the first argument to {@link DistanceMeasure#compute(double[],double[])}.\n * @return the two neurons whose features are closest to the given data.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n */\npublic static Pair<Neuron, Neuron> findBestAndSecondBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    Neuron[] best = { null, null };\n    double[] min = { Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY };\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        if (d < min[0]) {\n            // Replace second best with old best.\n            min[1] = min[0];\n            best[1] = best[0];\n            // Store current as new best.\n            min[0] = d;\n            best[0] = n;\n        } else if (d < min[1]) {\n            // Replace old second best with current.\n            min[1] = d;\n            best[1] = n;\n        }\n    }\n    return new Pair<Neuron, Neuron>(best[0], best[1]);\n}"
            ],
            [
                "sort",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Creates a list of neurons sorted in increased order of the distance\n * to the given {@code features}.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If it is empty, an empty array\n * will be returned.\n * @param distance Distance function.\n * @return the neurons, sorted in increasing order of distance in data\n * space.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n *\n * @see #findBest(double[],Iterable,DistanceMeasure)\n * @see #findBestAndSecondBest(double[],Iterable,DistanceMeasure)\n *\n * @since 3.6\n */\npublic static Neuron[] sort(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    final List<PairNeuronDouble> list = new ArrayList<PairNeuronDouble>();\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        list.add(new PairNeuronDouble(n, d));\n    }\n    Collections.sort(list, PairNeuronDouble.COMPARATOR);\n    final int len = list.size();\n    final Neuron[] sorted = new Neuron[len];\n    for (int i = 0; i < len; i++) {\n        sorted[i] = list.get(i).getNeuron();\n    }\n    return sorted;\n}"
            ],
            [
                "computeU",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the <a href=\"http://en.wikipedia.org/wiki/U-Matrix\">\n *  U-matrix</a> of a two-dimensional map.\n *\n * @param map Network.\n * @param distance Function to use for computing the average\n * distance from a neuron to its neighbours.\n * @return the matrix of average distances.\n */\npublic static double[][] computeU(NeuronSquareMesh2D map, DistanceMeasure distance) {\n    final int numRows = map.getNumberOfRows();\n    final int numCols = map.getNumberOfColumns();\n    final double[][] uMatrix = new double[numRows][numCols];\n    final Network net = map.getNetwork();\n    for (int i = 0; i < numRows; i++) {\n        for (int j = 0; j < numCols; j++) {\n            final Neuron neuron = map.getNeuron(i, j);\n            final Collection<Neuron> neighbours = net.getNeighbours(neuron);\n            final double[] features = neuron.getFeatures();\n            double d = 0;\n            int count = 0;\n            for (Neuron n : neighbours) {\n                ++count;\n                d += distance.compute(features, n.getFeatures());\n            }\n            uMatrix[i][j] = d / count;\n        }\n    }\n    return uMatrix;\n}"
            ],
            [
                "computeHitHistogram",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the \"hit\" histogram of a two-dimensional map.\n *\n * @param data Feature vectors.\n * @param map Network.\n * @param distance Function to use for determining the best matching unit.\n * @return the number of hits for each neuron in the map.\n */\npublic static int[][] computeHitHistogram(Iterable<double[]> data, NeuronSquareMesh2D map, DistanceMeasure distance) {\n    final HashMap<Neuron, Integer> hit = new HashMap<Neuron, Integer>();\n    final Network net = map.getNetwork();\n    for (double[] f : data) {\n        final Neuron best = findBest(f, net, distance);\n        final Integer count = hit.get(best);\n        if (count == null) {\n            hit.put(best, 1);\n        } else {\n            hit.put(best, count + 1);\n        }\n    }\n    // Copy the histogram data into a 2D map.\n    final int numRows = map.getNumberOfRows();\n    final int numCols = map.getNumberOfColumns();\n    final int[][] histo = new int[numRows][numCols];\n    for (int i = 0; i < numRows; i++) {\n        for (int j = 0; j < numCols; j++) {\n            final Neuron neuron = map.getNeuron(i, j);\n            final Integer count = hit.get(neuron);\n            if (count == null) {\n                histo[i][j] = 0;\n            } else {\n                histo[i][j] = count;\n            }\n        }\n    }\n    return histo;\n}"
            ],
            [
                "computeQuantizationError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the quantization error.\n * The quantization error is the average distance between a feature vector\n * and its \"best matching unit\" (closest neuron).\n *\n * @param data Feature vectors.\n * @param neurons List of neurons to scan.\n * @param distance Distance function.\n * @return the error.\n * @throws NoDataException if {@code data} is empty.\n */\npublic static double computeQuantizationError(Iterable<double[]> data, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    double d = 0;\n    int count = 0;\n    for (double[] f : data) {\n        ++count;\n        d += distance.compute(f, findBest(f, neurons, distance).getFeatures());\n    }\n    if (count == 0) {\n        throw new NoDataException();\n    }\n    return d / count;\n}"
            ],
            [
                "computeTopographicError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the topographic error.\n * The topographic error is the proportion of data for which first and\n * second best matching units are not adjacent in the map.\n *\n * @param data Feature vectors.\n * @param net Network.\n * @param distance Distance function.\n * @return the error.\n * @throws NoDataException if {@code data} is empty.\n */\npublic static double computeTopographicError(Iterable<double[]> data, Network net, DistanceMeasure distance) {\n    int notAdjacentCount = 0;\n    int count = 0;\n    for (double[] f : data) {\n        ++count;\n        final Pair<Neuron, Neuron> p = findBestAndSecondBest(f, net, distance);\n        if (!net.getNeighbours(p.getFirst()).contains(p.getSecond())) {\n            // Increment count if first and second best matching units\n            // are not neighbours.\n            ++notAdjacentCount;\n        }\n    }\n    if (count == 0) {\n        throw new NoDataException();\n    }\n    return ((double) notAdjacentCount) / count;\n}"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Uniform sampling of the given range.\n *\n * @param min Lower bound of the range.\n * @param max Upper bound of the range.\n * @param rng Random number generator used to draw samples from a\n * uniform distribution.\n * @return an initializer such that the features will be initialized with\n * values within the given range.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code min >= max}.\n */\npublic static FeatureInitializer uniform(final RandomGenerator rng, final double min, final double max) {\n    return randomize(new UniformRealDistribution(rng, min, max), function(new Constant(0), 0, 0));\n}"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Uniform sampling of the given range.\n *\n * @param min Lower bound of the range.\n * @param max Upper bound of the range.\n * @return an initializer such that the features will be initialized with\n * values within the given range.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code min >= max}.\n */\npublic static FeatureInitializer uniform(final double min, final double max) {\n    return randomize(new UniformRealDistribution(min, max), function(new Constant(0), 0, 0));\n}"
            ],
            [
                "function",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Creates an initializer from a univariate function {@code f(x)}.\n * The argument {@code x} is set to {@code init} at the first call\n * and will be incremented at each call.\n *\n * @param f Function.\n * @param init Initial value.\n * @param inc Increment\n * @return the initializer.\n */\npublic static FeatureInitializer function(final UnivariateFunction f, final double init, final double inc) {\n    return new FeatureInitializer() {\n\n        /**\n         * Argument.\n         */\n        private double arg = init;\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value() {\n            final double result = f.value(arg);\n            arg += inc;\n            return result;\n        }\n    };\n}"
            ],
            [
                "randomize",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Adds some amount of random data to the given initializer.\n *\n * @param random Random variable distribution.\n * @param orig Original initializer.\n * @return an initializer whose {@link FeatureInitializer#value() value}\n * method will return {@code orig.value() + random.sample()}.\n */\npublic static FeatureInitializer randomize(final RealDistribution random, final FeatureInitializer orig) {\n    return new FeatureInitializer() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value() {\n            return orig.value() + random.sample();\n        }\n    };\n}"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Breaks a string representation up into two dfp's.\n * <p>The two dfp are such that the sum of them is equivalent\n * to the input string, but has higher precision than using a\n * single dfp. This is useful for improving accuracy of\n * exponentiation and critical multiplies.\n * @param field field to which the Dfp must belong\n * @param a string representation to split\n * @return an array of two {@link Dfp} which sum is a\n */\nprotected static Dfp[] split(final DfpField field, final String a) {\n    Dfp[] result = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n    buf = new char[a.length()];\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n        if (sig == (field.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig++;\n        }\n    }\n    result[0] = field.newDfp(new String(buf, 0, sp));\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n    result[1] = field.newDfp(new String(buf));\n    return result;\n}"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Splits a {@link Dfp} into 2 {@link Dfp}'s such that their sum is equal to the input {@link Dfp}.\n * @param a number to split\n * @return two elements array containing the split number\n */\nprotected static Dfp[] split(final Dfp a) {\n    final Dfp[] result = new Dfp[2];\n    final Dfp shift = a.multiply(a.power10K(a.getRadixDigits() / 2));\n    result[0] = a.add(shift).subtract(shift);\n    result[1] = a.subtract(result[0]);\n    return result;\n}"
            ],
            [
                "splitMult",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Multiply two numbers that are split in to two pieces that are\n *  meant to be added together.\n *  Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1\n *  Store the first term in result0, the rest in result1\n *  @param a first factor of the multiplication, in split form\n *  @param b second factor of the multiplication, in split form\n *  @return a &times; b, in split form\n */\nprotected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b) {\n    final Dfp[] result = new Dfp[2];\n    result[1] = a[0].getZero();\n    result[0] = a[0].multiply(b[0]);\n    /* If result[0] is infinite or zero, don't compute result[1].\n         * Attempting to do so may produce NaNs.\n         */\n    if (result[0].classify() == Dfp.INFINITE || result[0].equals(result[1])) {\n        return result;\n    }\n    result[1] = a[0].multiply(b[1]).add(a[1].multiply(b[0])).add(a[1].multiply(b[1]));\n    return result;\n}"
            ],
            [
                "splitDiv",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Divide two numbers that are split in to two pieces that are meant to be added together.\n * Inverse of split multiply above:\n *  (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c**2+cd) )\n *  @param a dividend, in split form\n *  @param b divisor, in split form\n *  @return a / b, in split form\n */\nprotected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b) {\n    final Dfp[] result;\n    result = new Dfp[2];\n    result[0] = a[0].divide(b[0]);\n    result[1] = a[1].multiply(b[0]).subtract(a[0].multiply(b[1]));\n    result[1] = result[1].divide(b[0].multiply(b[0]).add(b[0].multiply(b[1])));\n    return result;\n}"
            ],
            [
                "splitPow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Raise a split base to the a power.\n * @param base number to raise\n * @param a power\n * @return base<sup>a</sup>\n */\nprotected static Dfp splitPow(final Dfp[] base, int a) {\n    boolean invert = false;\n    Dfp[] r = new Dfp[2];\n    Dfp[] result = new Dfp[2];\n    result[0] = base[0].getOne();\n    result[1] = base[0].getZero();\n    if (a == 0) {\n        // Special case a = 0\n        return result[0].add(result[1]);\n    }\n    if (a < 0) {\n        // If a is less than zero\n        invert = true;\n        a = -a;\n    }\n    // Exponentiate by successive squaring\n    do {\n        r[0] = new Dfp(base[0]);\n        r[1] = new Dfp(base[1]);\n        int trial = 1;\n        int prevtrial;\n        while (true) {\n            prevtrial = trial;\n            trial *= 2;\n            if (trial > a) {\n                break;\n            }\n            r = splitMult(r, r);\n        }\n        trial = prevtrial;\n        a -= trial;\n        result = splitMult(result, r);\n    } while (a >= 1);\n    result[0] = result[0].add(result[1]);\n    if (invert) {\n        result[0] = base[0].getOne().divide(result[0]);\n    }\n    return result[0];\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Raises base to the power a by successive squaring.\n * @param base number to raise\n * @param a power\n * @return base<sup>a</sup>\n */\npublic static Dfp pow(Dfp base, int a) {\n    boolean invert = false;\n    Dfp result = base.getOne();\n    if (a == 0) {\n        // Special case\n        return result;\n    }\n    if (a < 0) {\n        invert = true;\n        a = -a;\n    }\n    // Exponentiate by successive squaring\n    do {\n        Dfp r = new Dfp(base);\n        Dfp prevr;\n        int trial = 1;\n        int prevtrial;\n        do {\n            prevr = new Dfp(r);\n            prevtrial = trial;\n            r = r.multiply(r);\n            trial *= 2;\n        } while (a > trial);\n        r = prevr;\n        trial = prevtrial;\n        a -= trial;\n        result = result.multiply(r);\n    } while (a >= 1);\n    if (invert) {\n        result = base.getOne().divide(result);\n    }\n    return base.newInstance(result);\n}"
            ],
            [
                "exp",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes e to the given power.\n * a is broken into two parts, such that a = n+m  where n is an integer.\n * We use pow() to compute e<sup>n</sup> and a Taylor series to compute\n * e<sup>m</sup>.  We return e*<sup>n</sup> &times; e<sup>m</sup>\n * @param a power at which e should be raised\n * @return e<sup>a</sup>\n */\npublic static Dfp exp(final Dfp a) {\n    final Dfp inta = a.rint();\n    final Dfp fraca = a.subtract(inta);\n    final int ia = inta.intValue();\n    if (ia > 2147483646) {\n        // return +Infinity\n        return a.newInstance((byte) 1, Dfp.INFINITE);\n    }\n    if (ia < -2147483646) {\n        // return 0;\n        return a.newInstance();\n    }\n    final Dfp einta = splitPow(a.getField().getESplit(), ia);\n    final Dfp efraca = expInternal(fraca);\n    return einta.multiply(efraca);\n}"
            ],
            [
                "expInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes e to the given power.\n * Where -1 < a < 1.  Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...\n * @param a power at which e should be raised\n * @return e<sup>a</sup>\n */\nprotected static Dfp expInternal(final Dfp a) {\n    Dfp y = a.getOne();\n    Dfp x = a.getOne();\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n    for (int i = 1; i < 90; i++) {\n        x = x.multiply(a);\n        fact = fact.divide(i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Returns the natural logarithm of a.\n * a is first split into three parts such that  a = (10000^h)(2^j)k.\n * ln(a) is computed by ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k)\n * k is in the range 2/3 < k <4/3 and is passed on to a series expansion.\n * @param a number from which logarithm is requested\n * @return log(a)\n */\npublic static Dfp log(Dfp a) {\n    int lr;\n    Dfp x;\n    int ix;\n    int p2 = 0;\n    // Check the arguments somewhat here\n    if (a.equals(a.getZero()) || a.lessThan(a.getZero()) || a.isNaN()) {\n        // negative, zero or NaN\n        a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return a.dotrap(DfpField.FLAG_INVALID, \"ln\", a, a.newInstance((byte) 1, Dfp.QNAN));\n    }\n    if (a.classify() == Dfp.INFINITE) {\n        return a;\n    }\n    x = new Dfp(a);\n    lr = x.log10K();\n    x = x.divide(pow(a.newInstance(10000), lr));\n    /* This puts x in the range 0-10000 */\n    ix = x.floor().intValue();\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n    Dfp[] spx = split(x);\n    Dfp[] spy = new Dfp[2];\n    // use spy[0] temporarily as a divisor\n    spy[0] = pow(a.getTwo(), p2);\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n    // Use spy[0] for comparison\n    spy[0] = a.newInstance(\"1.33333\");\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n    // X is now in the range of 2/3 < x < 4/3\n    Dfp[] spz = logInternal(spx);\n    spx[0] = a.newInstance(new StringBuilder().append(p2 + 4 * lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn2Split(), spx);\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n    spx[0] = a.newInstance(new StringBuilder().append(4 * lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn5Split(), spx);\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n    return a.newInstance(spz[0].add(spz[1]));\n}"
            ],
            [
                "logInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes the natural log of a number between 0 and 2.\n *  Let f(x) = ln(x),\n *\n *  We know that f'(x) = 1/x, thus from Taylor's theorum we have:\n *\n *           -----          n+1         n\n *  f(x) =   \\           (-1)    (x - 1)\n *           /          ----------------    for 1 <= n <= infinity\n *           -----             n\n *\n *  or\n *                       2        3       4\n *                   (x-1)   (x-1)    (x-1)\n *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n *                     2       3        4\n *\n *  alternatively,\n *\n *                  2    3   4\n *                 x    x   x\n *  ln(x+1) =  x - -  + - - - + ...\n *                 2    3   4\n *\n *  This series can be used to compute ln(x), but it converges too slowly.\n *\n *  If we substitute -x for x above, we get\n *\n *                   2    3    4\n *                  x    x    x\n *  ln(1-x) =  -x - -  - -  - - + ...\n *                  2    3    4\n *\n *  Note that all terms are now negative.  Because the even powered ones\n *  absorbed the sign.  Now, subtract the series above from the previous\n *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n *  only the odd ones\n *\n *                             3     5      7\n *                           2x    2x     2x\n *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n *                            3     5      7\n *\n *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n *\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      x-1           \\          3        5        7          /\n *\n *  But now we want to find ln(a), so we need to find the value of x\n *  such that a = (x+1)/(x-1).   This is easily solved to find that\n *  x = (a-1)/(a+1).\n * @param a number from which logarithm is requested, in split form\n * @return log(a)\n */\nprotected static Dfp[] logInternal(final Dfp[] a) {\n    /* Now we want to compute x = (a-1)/(a+1) but this is prone to\n         * loss of precision.  So instead, compute x = (a/4 - 1/4) / (a/4 + 1/4)\n         */\n    Dfp t = a[0].divide(4).add(a[1].divide(4));\n    Dfp x = t.add(a[0].newInstance(\"-0.25\")).divide(t.add(a[0].newInstance(\"0.25\")));\n    Dfp y = new Dfp(x);\n    Dfp num = new Dfp(x);\n    Dfp py = new Dfp(y);\n    int den = 1;\n    for (int i = 0; i < 10000; i++) {\n        num = num.multiply(x);\n        num = num.multiply(x);\n        den += 2;\n        t = num.divide(den);\n        y = y.add(t);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    y = y.multiply(a[0].getTwo());\n    return split(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes x to the y power.<p>\n *\n *  Uses the following method:<p>\n *\n *  <ol>\n *  <li> Set u = rint(y), v = y-u\n *  <li> Compute a = v * ln(x)\n *  <li> Compute b = rint( a/ln(2) )\n *  <li> Compute c = a - b*ln(2)\n *  <li> x<sup>y</sup> = x<sup>u</sup>  *   2<sup>b</sup> * e<sup>c</sup>\n *  </ol>\n *  if |y| > 1e8, then we compute by exp(y*ln(x))   <p>\n *\n *  <b>Special Cases</b><p>\n *  <ul>\n *  <li>  if y is 0.0 or -0.0 then result is 1.0\n *  <li>  if y is 1.0 then result is x\n *  <li>  if y is NaN then result is NaN\n *  <li>  if x is NaN and y is not zero then result is NaN\n *  <li>  if |x| > 1.0 and y is +Infinity then result is +Infinity\n *  <li>  if |x| < 1.0 and y is -Infinity then result is +Infinity\n *  <li>  if |x| > 1.0 and y is -Infinity then result is +0\n *  <li>  if |x| < 1.0 and y is +Infinity then result is +0\n *  <li>  if |x| = 1.0 and y is +/-Infinity then result is NaN\n *  <li>  if x = +0 and y > 0 then result is +0\n *  <li>  if x = +Inf and y < 0 then result is +0\n *  <li>  if x = +0 and y < 0 then result is +Inf\n *  <li>  if x = +Inf and y > 0 then result is +Inf\n *  <li>  if x = -0 and y > 0, finite, not odd integer then result is +0\n *  <li>  if x = -0 and y < 0, finite, and odd integer then result is -Inf\n *  <li>  if x = -Inf and y > 0, finite, and odd integer then result is -Inf\n *  <li>  if x = -0 and y < 0, not finite odd integer then result is +Inf\n *  <li>  if x = -Inf and y > 0, not finite odd integer then result is +Inf\n *  <li>  if x < 0 and y > 0, finite, and odd integer then result is -(|x|<sup>y</sup>)\n *  <li>  if x < 0 and y > 0, finite, and not integer then result is NaN\n *  </ul>\n *  @param x base to be raised\n *  @param y power to which base should be raised\n *  @return x<sup>y</sup>\n */\npublic static Dfp pow(Dfp x, final Dfp y) {\n    // make sure we don't mix number with different precision\n    if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = x.newInstance(x.getZero());\n        result.nans = Dfp.QNAN;\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n    }\n    final Dfp zero = x.getZero();\n    final Dfp one = x.getOne();\n    final Dfp two = x.getTwo();\n    boolean invert = false;\n    int ui;\n    /* Check for special cases */\n    if (y.equals(zero)) {\n        return x.newInstance(one);\n    }\n    if (y.equals(one)) {\n        if (x.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n        }\n        return x;\n    }\n    if (x.isNaN() || y.isNaN()) {\n        // Test for NaNs\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    // X == 0\n    if (x.equals(zero)) {\n        if (Dfp.copysign(one, x).greaterThan(zero)) {\n            // X == +0\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n            }\n        } else {\n            // X == -0\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero.negate());\n                } else {\n                    return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE));\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n                }\n            }\n        }\n    }\n    if (x.lessThan(zero)) {\n        // Make x positive, but keep track of it\n        x = x.negate();\n        invert = true;\n    }\n    if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return y;\n        } else {\n            return x.newInstance(zero);\n        }\n    }\n    if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return x.newInstance(zero);\n        } else {\n            return x.newInstance(Dfp.copysign(y, one));\n        }\n    }\n    if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    if (x.classify() == Dfp.INFINITE) {\n        // x = +/- inf\n        if (invert) {\n            // negative infinity\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero.negate());\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        } else {\n            // positive infinity\n            if (y.greaterThan(zero)) {\n                return x;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n    }\n    if (invert && !y.rint().equals(y)) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    // End special cases\n    Dfp r;\n    if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) {\n        final Dfp u = y.rint();\n        ui = u.intValue();\n        final Dfp v = y.subtract(u);\n        if (v.unequal(zero)) {\n            final Dfp a = v.multiply(log(x));\n            final Dfp b = a.divide(x.getField().getLn2()).rint();\n            final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n            r = splitPow(split(x), ui);\n            r = r.multiply(pow(two, b.intValue()));\n            r = r.multiply(exp(c));\n        } else {\n            r = splitPow(split(x), ui);\n        }\n    } else {\n        // very large exponent.  |y| > 1e8\n        r = exp(log(x).multiply(y));\n    }\n    if (invert && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n        // if y is odd integer\n        r = r.negate();\n    }\n    return x.newInstance(r);\n}"
            ],
            [
                "sinInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes sin(a)  Used when 0 < a < pi/4.\n * Uses the classic Taylor series.  x - x**3/3! + x**5/5!  ...\n * @param a number from which sine is desired, in split form\n * @return sin(a)\n */\nprotected static Dfp sinInternal(Dfp[] a) {\n    Dfp c = a[0].add(a[1]);\n    Dfp y = c;\n    c = c.multiply(c);\n    Dfp x = y;\n    Dfp fact = a[0].getOne();\n    Dfp py = new Dfp(y);\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n        // 1 over fact\n        fact = fact.divide((i - 1) * i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "cosInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes cos(a)  Used when 0 < a < pi/4.\n * Uses the classic Taylor series for cosine.  1 - x**2/2! + x**4/4!  ...\n * @param a number from which cosine is desired, in split form\n * @return cos(a)\n */\nprotected static Dfp cosInternal(Dfp[] a) {\n    final Dfp one = a[0].getOne();\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a[0].add(a[1]);\n    c = c.multiply(c);\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n        // 1 over fact\n        fact = fact.divide((i - 1) * i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "sin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the sine of the argument.\n * @param a number from which sine is desired\n * @return sin(a)\n */\npublic static Dfp sin(final Dfp a) {\n    final Dfp pi = a.getField().getPi();\n    final Dfp zero = a.getField().getZero();\n    boolean neg = false;\n    /* First reduce the argument to the range of +/- PI */\n    Dfp x = a.remainder(pi.multiply(2));\n    /* if x < 0 then apply identity sin(-x) = -sin(x) */\n    /* This puts x in the range 0 < x < PI            */\n    if (x.lessThan(zero)) {\n        x = x.negate();\n        neg = true;\n    }\n    /* Since sine(x) = sine(pi - x) we can reduce the range to\n         * 0 < x < pi/2\n         */\n    if (x.greaterThan(pi.divide(2))) {\n        x = pi.subtract(x);\n    }\n    Dfp y;\n    if (x.lessThan(pi.divide(4))) {\n        y = sinInternal(split(x));\n    } else {\n        final Dfp[] c = new Dfp[2];\n        final Dfp[] piSplit = a.getField().getPiSplit();\n        c[0] = piSplit[0].divide(2).subtract(x);\n        c[1] = piSplit[1].divide(2);\n        y = cosInternal(c);\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "cos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the cosine of the argument.\n * @param a number from which cosine is desired\n * @return cos(a)\n */\npublic static Dfp cos(Dfp a) {\n    final Dfp pi = a.getField().getPi();\n    final Dfp zero = a.getField().getZero();\n    boolean neg = false;\n    /* First reduce the argument to the range of +/- PI */\n    Dfp x = a.remainder(pi.multiply(2));\n    /* if x < 0 then apply identity cos(-x) = cos(x) */\n    /* This puts x in the range 0 < x < PI           */\n    if (x.lessThan(zero)) {\n        x = x.negate();\n    }\n    /* Since cos(x) = -cos(pi - x) we can reduce the range to\n         * 0 < x < pi/2\n         */\n    if (x.greaterThan(pi.divide(2))) {\n        x = pi.subtract(x);\n        neg = true;\n    }\n    Dfp y;\n    if (x.lessThan(pi.divide(4))) {\n        Dfp[] c = new Dfp[2];\n        c[0] = x;\n        c[1] = zero;\n        y = cosInternal(c);\n    } else {\n        final Dfp[] c = new Dfp[2];\n        final Dfp[] piSplit = a.getField().getPiSplit();\n        c[0] = piSplit[0].divide(2).subtract(x);\n        c[1] = piSplit[1].divide(2);\n        y = sinInternal(c);\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "tan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the tangent of the argument.\n * @param a number from which tangent is desired\n * @return tan(a)\n */\npublic static Dfp tan(final Dfp a) {\n    return sin(a).divide(cos(a));\n}"
            ],
            [
                "atanInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-tangent of the argument.\n * @param a number from which arc-tangent is desired\n * @return atan(a)\n */\nprotected static Dfp atanInternal(final Dfp a) {\n    Dfp y = new Dfp(a);\n    Dfp x = new Dfp(y);\n    Dfp py = new Dfp(y);\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(a);\n        x = x.multiply(a);\n        x = x.negate();\n        y = y.add(x.divide(i));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "atan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc tangent of the argument\n *\n *  Uses the typical taylor series\n *\n *  but may reduce arguments using the following identity\n * tan(x+y) = (tan(x) + tan(y)) / (1 - tan(x)*tan(y))\n *\n * since tan(PI/8) = sqrt(2)-1,\n *\n * atan(x) = atan( (x - sqrt(2) + 1) / (1+x*sqrt(2) - x) + PI/8.0\n * @param a number from which arc-tangent is desired\n * @return atan(a)\n */\npublic static Dfp atan(final Dfp a) {\n    final Dfp zero = a.getField().getZero();\n    final Dfp one = a.getField().getOne();\n    final Dfp[] sqr2Split = a.getField().getSqr2Split();\n    final Dfp[] piSplit = a.getField().getPiSplit();\n    boolean recp = false;\n    boolean neg = false;\n    boolean sub = false;\n    final Dfp ty = sqr2Split[0].subtract(one).add(sqr2Split[1]);\n    Dfp x = new Dfp(a);\n    if (x.lessThan(zero)) {\n        neg = true;\n        x = x.negate();\n    }\n    if (x.greaterThan(one)) {\n        recp = true;\n        x = one.divide(x);\n    }\n    if (x.greaterThan(ty)) {\n        Dfp[] sty = new Dfp[2];\n        sub = true;\n        sty[0] = sqr2Split[0].subtract(one);\n        sty[1] = sqr2Split[1];\n        Dfp[] xs = split(x);\n        Dfp[] ds = splitMult(xs, sty);\n        ds[0] = ds[0].add(one);\n        xs[0] = xs[0].subtract(sty[0]);\n        xs[1] = xs[1].subtract(sty[1]);\n        xs = splitDiv(xs, ds);\n        x = xs[0].add(xs[1]);\n        //x = x.subtract(ty).divide(dfp.one.add(x.multiply(ty)));\n    }\n    Dfp y = atanInternal(x);\n    if (sub) {\n        y = y.add(piSplit[0].divide(8)).add(piSplit[1].divide(8));\n    }\n    if (recp) {\n        y = piSplit[0].divide(2).subtract(y).add(piSplit[1].divide(2));\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "asin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-sine of the argument.\n * @param a number from which arc-sine is desired\n * @return asin(a)\n */\npublic static Dfp asin(final Dfp a) {\n    return atan(a.divide(a.getOne().subtract(a.multiply(a)).sqrt()));\n}"
            ],
            [
                "acos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-cosine of the argument.\n * @param a number from which arc-cosine is desired\n * @return acos(a)\n */\npublic static Dfp acos(Dfp a) {\n    Dfp result;\n    boolean negative = false;\n    if (a.lessThan(a.getZero())) {\n        negative = true;\n    }\n    // absolute value\n    a = Dfp.copysign(a, a.getOne());\n    result = atan(a.getOne().subtract(a.multiply(a)).sqrt().divide(a));\n    if (negative) {\n        result = a.getField().getPi().subtract(result);\n    }\n    return a.newInstance(result);\n}"
            ],
            [
                "copysign",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Creates an instance that is the same as x except that it has the sign of y.\n * abs(x) = dfp.copysign(x, dfp.one)\n * @param x number to get the value from\n * @param y number to get the sign from\n * @return a number with the value of x and the sign of y\n */\npublic static Dfp copysign(final Dfp x, final Dfp y) {\n    Dfp result = x.newInstance(x);\n    result.sign = y.sign;\n    return result;\n}"
            ],
            [
                "computeExp",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * Compute exp(a).\n * @param a number for which we want the exponential\n * @param one constant with value 1 at desired precision\n * @return exp(a)\n */\npublic static Dfp computeExp(final Dfp a, final Dfp one) {\n    Dfp y = new Dfp(one);\n    Dfp py = new Dfp(one);\n    Dfp f = new Dfp(one);\n    Dfp fi = new Dfp(one);\n    Dfp x = new Dfp(one);\n    for (int i = 0; i < 10000; i++) {\n        x = x.multiply(a);\n        y = y.add(x.divide(f));\n        fi = fi.add(one);\n        f = f.multiply(fi);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "computeLn",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * Compute ln(a).\n *\n *  Let f(x) = ln(x),\n *\n *  We know that f'(x) = 1/x, thus from Taylor's theorem we have:\n *\n *           -----          n+1         n\n *  f(x) =   \\           (-1)    (x - 1)\n *           /          ----------------    for 1 <= n <= infinity\n *           -----             n\n *\n *  or\n *                       2        3       4\n *                   (x-1)   (x-1)    (x-1)\n *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n *                     2       3        4\n *\n *  alternatively,\n *\n *                  2    3   4\n *                 x    x   x\n *  ln(x+1) =  x - -  + - - - + ...\n *                 2    3   4\n *\n *  This series can be used to compute ln(x), but it converges too slowly.\n *\n *  If we substitute -x for x above, we get\n *\n *                   2    3    4\n *                  x    x    x\n *  ln(1-x) =  -x - -  - -  - - + ...\n *                  2    3    4\n *\n *  Note that all terms are now negative.  Because the even powered ones\n *  absorbed the sign.  Now, subtract the series above from the previous\n *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n *  only the odd ones\n *\n *                             3     5      7\n *                           2x    2x     2x\n *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n *                            3     5      7\n *\n *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n *\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      x-1           \\          3        5        7          /\n *\n *  But now we want to find ln(a), so we need to find the value of x\n *  such that a = (x+1)/(x-1).   This is easily solved to find that\n *  x = (a-1)/(a+1).\n * @param a number for which we want the exponential\n * @param one constant with value 1 at desired precision\n * @param two constant with value 2 at desired precision\n * @return ln(a)\n */\npublic static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two) {\n    int den = 1;\n    Dfp x = a.add(new Dfp(a.getField(), -1)).divide(a.add(one));\n    Dfp y = new Dfp(x);\n    Dfp num = new Dfp(x);\n    Dfp py = new Dfp(y);\n    for (int i = 0; i < 10000; i++) {\n        num = num.multiply(x);\n        num = num.multiply(x);\n        den += 2;\n        Dfp t = num.divide(den);\n        y = y.add(t);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y.multiply(two);\n}"
            ],
            [
                "getRandomGenerator",
                "org.apache.commons.math3.genetics",
                "GeneticAlgorithm",
                "/**\n * Returns the (static) random generator.\n *\n * @return the static random generator shared by GA implementation classes\n */\npublic static synchronized RandomGenerator getRandomGenerator() {\n    return randomGenerator;\n}"
            ],
            [
                "randomPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation corresponding to a random permutation of\n * length l which can be passed to the RandomKey constructor.\n *\n * @param l length of the permutation\n * @return representation of a random permutation\n */\npublic static final List<Double> randomPermutation(final int l) {\n    List<Double> repr = new ArrayList<Double>(l);\n    for (int i = 0; i < l; i++) {\n        repr.add(GeneticAlgorithm.getRandomGenerator().nextDouble());\n    }\n    return repr;\n}"
            ],
            [
                "identityPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation corresponding to an identity permutation of\n * length l which can be passed to the RandomKey constructor.\n *\n * @param l length of the permutation\n * @return representation of an identity permutation\n */\npublic static final List<Double> identityPermutation(final int l) {\n    List<Double> repr = new ArrayList<Double>(l);\n    for (int i = 0; i < l; i++) {\n        repr.add((double) i / l);\n    }\n    return repr;\n}"
            ],
            [
                "comparatorPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation of a permutation corresponding to the\n * <code>data</code> sorted by <code>comparator</code>. The\n * <code>data</code> is not modified during the process.\n *\n * This is useful if you want to inject some permutations to the initial\n * population.\n *\n * @param <S> type of the data\n * @param data list of data determining the order\n * @param comparator how the data will be compared\n * @return list representation of the permutation corresponding to the parameters\n */\npublic static <S> List<Double> comparatorPermutation(final List<S> data, final Comparator<S> comparator) {\n    List<S> sortedData = new ArrayList<S>(data);\n    Collections.sort(sortedData, comparator);\n    return inducedPermutation(data, sortedData);\n}"
            ],
            [
                "inducedPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation of a permutation corresponding to a\n * permutation which yields <code>permutedData</code> when applied to\n * <code>originalData</code>.\n *\n * This method can be viewed as an inverse to {@link #decode(List)}.\n *\n * @param <S> type of the data\n * @param originalData the original, unpermuted data\n * @param permutedData the data, somehow permuted\n * @return representation of a permutation corresponding to the permutation\n *   <code>originalData -> permutedData</code>\n * @throws DimensionMismatchException iff the length of <code>originalData</code>\n *   and <code>permutedData</code> lists are not equal\n * @throws MathIllegalArgumentException iff the <code>permutedData</code> and\n *   <code>originalData</code> lists contain different data\n */\npublic static <S> List<Double> inducedPermutation(final List<S> originalData, final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException {\n    if (originalData.size() != permutedData.size()) {\n        throw new DimensionMismatchException(permutedData.size(), originalData.size());\n    }\n    int l = originalData.size();\n    List<S> origDataCopy = new ArrayList<S>(originalData);\n    Double[] res = new Double[l];\n    for (int i = 0; i < l; i++) {\n        int index = origDataCopy.indexOf(permutedData.get(i));\n        if (index == -1) {\n            throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_ORIG_AND_PERMUTED_DATA);\n        }\n        res[index] = (double) i / l;\n        origDataCopy.set(index, null);\n    }\n    return Arrays.asList(res);\n}"
            ],
            [
                "randomBinaryRepresentation",
                "org.apache.commons.math3.genetics",
                "BinaryChromosome",
                "/**\n * Returns a representation of a random binary array of length <code>length</code>.\n * @param length length of the array\n * @return a random binary array of length <code>length</code>\n */\npublic static List<Integer> randomBinaryRepresentation(int length) {\n    // random binary list\n    List<Integer> rList = new ArrayList<Integer>(length);\n    for (int j = 0; j < length; j++) {\n        rList.add(GeneticAlgorithm.getRandomGenerator().nextInt(2));\n    }\n    return rList;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * Get the set of locales for which point/vector formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available point/vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "/**\n * Returns the default 3D vector format for the current locale.\n * @return the default 3D vector format.\n */\npublic static Vector3DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "/**\n * Returns the default 3D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 3D vector format specific to the given locale.\n */\npublic static Vector3DFormat getInstance(final Locale locale) {\n    return new Vector3DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2) throws MathArithmeticException {\n    final T normProduct = v1.getNorm().multiply(v2.getNorm());\n    if (normProduct.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    final T dot = dotProduct(v1, v2);\n    final double threshold = normProduct.getReal() * 0.9999;\n    if ((dot.getReal() < -threshold) || (dot.getReal() > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        FieldVector3D<T> v3 = crossProduct(v1, v2);\n        if (dot.getReal() >= 0) {\n            return v3.getNorm().divide(normProduct).asin();\n        }\n        return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return dot.divide(normProduct).acos();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2) throws MathArithmeticException {\n    final T normProduct = v1.getNorm().multiply(v2.getNorm());\n    if (normProduct.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    final T dot = dotProduct(v1, v2);\n    final double threshold = normProduct.getReal() * 0.9999;\n    if ((dot.getReal() < -threshold) || (dot.getReal() > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        FieldVector3D<T> v3 = crossProduct(v1, v2);\n        if (dot.getReal() >= 0) {\n            return v3.getNorm().divide(normProduct).asin();\n        }\n        return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return dot.divide(normProduct).acos();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2) throws MathArithmeticException {\n    return angle(v2, v1);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.dotProduct(v1);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1, final FieldVector3D<T> v2) {\n    return new FieldVector3D<T>(v2.x.linearCombination(v1.getY(), v2.z, -v1.getZ(), v2.y), v2.y.linearCombination(v1.getZ(), v2.x, -v1.getX(), v2.z), v2.z.linearCombination(v1.getX(), v2.y, -v1.getY(), v2.x));\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distance1(v1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distance(v1);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distanceInf(v1);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distanceSq(v1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "/**\n * Compute the <i>distance</i> between two rotations.\n * <p>The <i>distance</i> is intended here as a way to check if two\n * rotations are almost similar (i.e. they transform vectors the same way)\n * or very different. It is mathematically defined as the angle of\n * the rotation r that prepended to one of the rotations gives the other\n * one:</p>\n * <pre>\n *        r<sub>1</sub>(r) = r<sub>2</sub>\n * </pre>\n * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n * reached for some v. The distance is equal to 0 if and only if the two\n * rotations are identical.</p>\n * <p>Comparing two rotations should always be done using this value rather\n * than for example comparing the components of the quaternions. It is much\n * more stable, and has a geometric meaning. Also comparing quaternions\n * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n * their components are different (they are exact opposites).</p>\n * @param r1 first rotation\n * @param r2 second rotation\n * @return <i>distance</i> between r1 and r2\n */\npublic static double distance(Rotation r1, Rotation r2) {\n    return r1.composeInverseInternal(r2).getAngle();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Euclidean3D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean3D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply a rotation to a vector.\n * @param r rotation to apply\n * @param u vector to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new vector which is the image of u by the rotation\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n    final T x = u.getX();\n    final T y = u.getY();\n    final T z = u.getZ();\n    final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n    return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x), y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y), z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n}"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply the inverse of a rotation to a vector.\n * @param r rotation to apply\n * @param u vector to apply the inverse of the rotation to\n * @param <T> the type of the field elements\n * @return a new vector which such that u is its image by the rotation\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n    final T x = u.getX();\n    final T y = u.getY();\n    final T z = u.getZ();\n    final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n    final double m0 = -r.getQ0();\n    return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x), y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y), z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n}"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply a rotation to another rotation.\n * Applying a rotation to another rotation is computing the composition\n * in an order compliant with the following rule : let u be any\n * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n * where comp = applyTo(rOuter, rInner).\n * @param r1 rotation to apply\n * @param rInner rotation to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new rotation which is the composition of r by the instance\n */\npublic static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n    return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))), rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))), rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))), rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))), false);\n}"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply the inverse of a rotation to another rotation.\n * Applying the inverse of a rotation to another rotation is computing\n * the composition in an order compliant with the following rule :\n * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n * let w be the inverse image of v by rOuter\n * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n * comp = applyInverseTo(rOuter, rInner).\n * @param rOuter rotation to apply the rotation to\n * @param rInner rotation to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new rotation which is the composition of r by the inverse\n * of the instance\n */\npublic static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n    return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(), rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())), rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())), rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())), false);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Compute the <i>distance</i> between two rotations.\n * <p>The <i>distance</i> is intended here as a way to check if two\n * rotations are almost similar (i.e. they transform vectors the same way)\n * or very different. It is mathematically defined as the angle of\n * the rotation r that prepended to one of the rotations gives the other\n * one:</p>\n * <pre>\n *        r<sub>1</sub>(r) = r<sub>2</sub>\n * </pre>\n * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n * reached for some v. The distance is equal to 0 if and only if the two\n * rotations are identical.</p>\n * <p>Comparing two rotations should always be done using this value rather\n * than for example comparing the components of the quaternions. It is much\n * more stable, and has a geometric meaning. Also comparing quaternions\n * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n * their components are different (they are exact opposites).</p>\n * @param r1 first rotation\n * @param r2 second rotation\n * @param <T> the type of the field elements\n * @return <i>distance</i> between r1 and r2\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n    return r1.composeInverseInternal(r2).getAngle();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException {\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    double dot = v1.dotProduct(v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        Vector3D v3 = crossProduct(v1, v2);\n        if (dot >= 0) {\n            return FastMath.asin(v3.getNorm() / normProduct);\n        }\n        return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return FastMath.acos(dot / normProduct);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the dot product v1.v2\n */\npublic static double dotProduct(Vector3D v1, Vector3D v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static double distance1(Vector3D v1, Vector3D v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector3D v1, Vector3D v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector3D v1, Vector3D v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the square of the distance between v1 and v2\n */\npublic static double distanceSq(Vector3D v1, Vector3D v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "intersection",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Plane",
                "/**\n * Get the intersection point of three planes.\n * @param plane1 first plane1\n * @param plane2 second plane2\n * @param plane3 third plane2\n * @return intersection point of three planes, null if some planes are parallel\n */\npublic static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3) {\n    // coefficients of the three planes linear equations\n    final double a1 = plane1.w.getX();\n    final double b1 = plane1.w.getY();\n    final double c1 = plane1.w.getZ();\n    final double d1 = plane1.originOffset;\n    final double a2 = plane2.w.getX();\n    final double b2 = plane2.w.getY();\n    final double c2 = plane2.w.getZ();\n    final double d2 = plane2.originOffset;\n    final double a3 = plane3.w.getX();\n    final double b3 = plane3.w.getY();\n    final double c3 = plane3.w.getZ();\n    final double d3 = plane3.originOffset;\n    // direct Cramer resolution of the linear system\n    // (this is still feasible for a 3x3 system)\n    final double a23 = b2 * c3 - b3 * c2;\n    final double b23 = c2 * a3 - c3 * a2;\n    final double c23 = a2 * b3 - a3 * b2;\n    final double determinant = a1 * a23 + b1 * b23 + c1 * c23;\n    if (FastMath.abs(determinant) < 1.0e-10) {\n        return null;\n    }\n    final double r = 1.0 / determinant;\n    return new Vector3D((-a23 * d1 - (c1 * b3 - c3 * b1) * d2 - (c2 * b1 - c1 * b2) * d3) * r, (-b23 * d1 - (c3 * a1 - c1 * a3) * d2 - (c1 * a2 - c2 * a1) * d3) * r, (-c23 * d1 - (b1 * a3 - b3 * a1) * d2 - (b2 * a1 - b1 * a2) * d3) * r);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Euclidean1D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean1D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "/**\n * Returns the default 1D vector format for the current locale.\n * @return the default 1D vector format.\n */\npublic static Vector1DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "/**\n * Returns the default 1D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 1D vector format specific to the given locale.\n */\npublic static Vector1DFormat getInstance(final Locale locale) {\n    return new Vector1DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector1D p1, Vector1D p2) {\n    return p1.distance(p2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector1D p1, Vector1D p2) {\n    return p1.distanceInf(p2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\npublic static double distanceSq(Vector1D p1, Vector1D p2) {\n    return p1.distanceSq(p2);\n}"
            ],
            [
                "reducePoints",
                "org.apache.commons.math3.geometry.euclidean.twod.hull",
                "AklToussaintHeuristic",
                "/**\n * Returns a point set that is reduced by all points for which it is safe to assume\n * that they are not part of the convex hull.\n *\n * @param points the original point set\n * @return a reduced point set, useful as input for convex hull algorithms\n */\npublic static Collection<Vector2D> reducePoints(final Collection<Vector2D> points) {\n    // find the leftmost point\n    int size = 0;\n    Vector2D minX = null;\n    Vector2D maxX = null;\n    Vector2D minY = null;\n    Vector2D maxY = null;\n    for (Vector2D p : points) {\n        if (minX == null || p.getX() < minX.getX()) {\n            minX = p;\n        }\n        if (maxX == null || p.getX() > maxX.getX()) {\n            maxX = p;\n        }\n        if (minY == null || p.getY() < minY.getY()) {\n            minY = p;\n        }\n        if (maxY == null || p.getY() > maxY.getY()) {\n            maxY = p;\n        }\n        size++;\n    }\n    if (size < 4) {\n        return points;\n    }\n    final List<Vector2D> quadrilateral = buildQuadrilateral(minY, maxX, maxY, minX);\n    // if the quadrilateral is not well formed, e.g. only 2 points, do not attempt to reduce\n    if (quadrilateral.size() < 3) {\n        return points;\n    }\n    final List<Vector2D> reducedPoints = new ArrayList<Vector2D>(quadrilateral);\n    for (final Vector2D p : points) {\n        // check all points if they are within the quadrilateral\n        // in which case they can not be part of the convex hull\n        if (!insideQuadrilateral(p, quadrilateral)) {\n            reducedPoints.add(p);\n        }\n    }\n    return reducedPoints;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "/**\n * Returns the default 2D vector format for the current locale.\n * @return the default 2D vector format.\n */\npublic static Vector2DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "/**\n * Returns the default 2D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 2D vector format specific to the given locale.\n */\npublic static Vector2DFormat getInstance(final Locale locale) {\n    return new Vector2DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException {\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    double dot = v1.dotProduct(v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        final double n = FastMath.abs(MathArrays.linearCombination(v1.x, v2.y, -v1.y, v2.x));\n        if (dot >= 0) {\n            return FastMath.asin(n / normProduct);\n        }\n        return FastMath.PI - FastMath.asin(n / normProduct);\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return FastMath.acos(dot / normProduct);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector2D p1, Vector2D p2) {\n    return p1.distance(p2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector2D p1, Vector2D p2) {\n    return p1.distanceInf(p2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\npublic static double distanceSq(Vector2D p1, Vector2D p2) {\n    return p1.distanceSq(p2);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Euclidean2D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean2D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding an affine transform.\n * @param transform affine transform to embed (must be inversible\n * otherwise the {@link\n * org.apache.commons.math3.geometry.partitioning.Transform#apply(Hyperplane)\n * apply(Hyperplane)} method would work only for some lines, and\n * fail for other ones)\n * @return a new transform that can be applied to either {@link\n * Vector2D Vector2D}, {@link Line Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n * @exception MathIllegalArgumentException if the transform is non invertible\n * @deprecated as of 3.6, replaced with {@link #getTransform(double, double, double, double, double, double)}\n */\n@Deprecated\npublic static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException {\n    final double[] m = new double[6];\n    transform.getMatrix(m);\n    return new LineTransform(m[0], m[1], m[2], m[3], m[4], m[5]);\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding an affine transform.\n * @param cXX transform factor between input abscissa and output abscissa\n * @param cYX transform factor between input abscissa and output ordinate\n * @param cXY transform factor between input ordinate and output abscissa\n * @param cYY transform factor between input ordinate and output ordinate\n * @param cX1 transform addendum for output abscissa\n * @param cY1 transform addendum for output ordinate\n * @return a new transform that can be applied to either {@link\n * Vector2D Vector2D}, {@link Line Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n * @exception MathIllegalArgumentException if the transform is non invertible\n * @since 3.6\n */\npublic static Transform<Euclidean2D, Euclidean1D> getTransform(final double cXX, final double cYX, final double cXY, final double cYY, final double cX1, final double cY1) throws MathIllegalArgumentException {\n    return new LineTransform(cXX, cYX, cXY, cYY, cX1, cY1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "/**\n * Compute the distance (angular separation) between two points.\n * @param p1 first vector\n * @param p2 second vector\n * @return the angular separation between p1 and p2\n */\npublic static double distance(S1Point p1, S1Point p2) {\n    return Vector2D.angle(p1.vector, p2.vector);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "Sphere1D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Sphere1D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Sphere2D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Sphere2D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Circle",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding a 3D rotation.\n * @param rotation rotation to use\n * @return a new transform that can be applied to either {@link\n * Point Point}, {@link Circle Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n */\npublic static Transform<Sphere2D, Sphere1D> getTransform(final Rotation rotation) {\n    return new CircleTransform(rotation);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * Compute the distance (angular separation) between two points.\n * @param p1 first vector\n * @param p2 second vector\n * @return the angular separation between p1 and p2\n */\npublic static double distance(S2Point p1, S2Point p2) {\n    return Vector3D.angle(p1.vector, p2.vector);\n}"
            ],
            [
                "createAdaptor",
                "org.apache.commons.math3.random",
                "RandomAdaptor",
                "/**\n * Factory method to create a <code>Random</code> using the supplied\n * <code>RandomGenerator</code>.\n *\n * @param randomGenerator  wrapped RandomGenerator instance\n * @return a Random instance wrapping the RandomGenerator\n */\npublic static Random createAdaptor(RandomGenerator randomGenerator) {\n    return new RandomAdaptor(randomGenerator);\n}"
            ],
            [
                "createRandomGenerator",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "/**\n * Creates a {@link RandomDataGenerator} instance that wraps a\n * {@link Random} instance.\n *\n * @param rng JDK {@link Random} instance that will generate the\n * the random data.\n * @return the given RNG, wrapped in a {@link RandomGenerator}.\n */\npublic static RandomGenerator createRandomGenerator(final Random rng) {\n    return new RandomGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(int seed) {\n            rng.setSeed((long) seed);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(int[] seed) {\n            rng.setSeed(convertToLong(seed));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(long seed) {\n            rng.setSeed(seed);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void nextBytes(byte[] bytes) {\n            rng.nextBytes(bytes);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int nextInt() {\n            return rng.nextInt();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int nextInt(int n) {\n            if (n <= 0) {\n                throw new NotStrictlyPositiveException(n);\n            }\n            return rng.nextInt(n);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public long nextLong() {\n            return rng.nextLong();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean nextBoolean() {\n            return rng.nextBoolean();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public float nextFloat() {\n            return rng.nextFloat();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public double nextDouble() {\n            return rng.nextDouble();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public double nextGaussian() {\n            return rng.nextGaussian();\n        }\n    };\n}"
            ],
            [
                "convertToLong",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "/**\n * Converts seed from one representation to another.\n *\n * @param seed Original seed.\n * @return the converted seed.\n */\npublic static long convertToLong(int[] seed) {\n    // The following number is the largest prime that fits\n    // in 32 bits (i.e. 2^32 - 5).\n    final long prime = 4294967291l;\n    long combined = 0l;\n    for (int s : seed) {\n        combined = combined * prime + s;\n    }\n    return combined;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Get the set of locales for which complex formats are available.  This\n * is the same set as the {@link NumberFormat} set.\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "formatBigFraction",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * This static method calls formatBigFraction() on a default instance of\n * BigFractionFormat.\n *\n * @param f BigFraction object to format\n * @return A formatted BigFraction in proper form.\n */\npublic static String formatBigFraction(final BigFraction f) {\n    return getImproperInstance().format(f);\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static BigFractionFormat getImproperInstance() {\n    return getImproperInstance(Locale.getDefault());\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static BigFractionFormat getImproperInstance(final Locale locale) {\n    return new BigFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static BigFractionFormat getProperInstance() {\n    return getProperInstance(Locale.getDefault());\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static BigFractionFormat getProperInstance(final Locale locale) {\n    return new ProperBigFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * <p>Creates a {@code Fraction} instance with the 2 parts\n * of a fraction Y/Z.</p>\n *\n * <p>Any negative signs are resolved to be on the numerator.</p>\n *\n * @param numerator  the numerator, for example the three in 'three sevenths'\n * @param denominator  the denominator, for example the seven in 'three sevenths'\n * @return a new fraction instance, with the numerator and denominator reduced\n * @throws MathArithmeticException if the denominator is {@code zero}\n */\npublic static Fraction getReducedFraction(int numerator, int denominator) {\n    if (denominator == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, numerator, denominator);\n    }\n    if (numerator == 0) {\n        // normalize zero.\n        return ZERO;\n    }\n    // allow 2^k/-2^31 as a valid fraction (where k>0)\n    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n        numerator /= 2;\n        denominator /= 2;\n    }\n    if (denominator < 0) {\n        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n        }\n        numerator = -numerator;\n        denominator = -denominator;\n    }\n    // simplify fraction.\n    int gcd = ArithmeticUtils.gcd(numerator, denominator);\n    numerator /= gcd;\n    denominator /= gcd;\n    return new Fraction(numerator, denominator);\n}"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * <p>\n * Creates a <code>BigFraction</code> instance with the 2 parts of a fraction\n * Y/Z.\n * </p>\n *\n * <p>\n * Any negative signs are resolved to be on the numerator.\n * </p>\n *\n * @param numerator\n *            the numerator, for example the three in 'three sevenths'.\n * @param denominator\n *            the denominator, for example the seven in 'three sevenths'.\n * @return a new fraction instance, with the numerator and denominator\n *         reduced.\n * @throws ArithmeticException\n *             if the denominator is <code>zero</code>.\n */\npublic static BigFraction getReducedFraction(final int numerator, final int denominator) {\n    if (numerator == 0) {\n        // normalize zero.\n        return ZERO;\n    }\n    return new BigFraction(numerator, denominator);\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)}. The only\n * customization is the maximum number of BigFraction digits, which is set to 0.\n * @return the default number format.\n */\nprotected static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)}. The only\n * customization is the maximum number of BigFraction digits, which is set to 0.\n * @param locale the specific locale used by the format.\n * @return the default number format specific to the given locale.\n */\nprotected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n    final NumberFormat nf = NumberFormat.getNumberInstance(locale);\n    nf.setMaximumFractionDigits(0);\n    nf.setParseIntegerOnly(true);\n    return nf;\n}"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Parses <code>source</code> until a non-whitespace character is found.\n * @param source the string to parse\n * @param pos input/output parsing parameter.\n * @return the first non-whitespace character.\n */\nprotected static char parseNextCharacter(final String source, final ParsePosition pos) {\n    int index = pos.getIndex();\n    final int n = source.length();\n    char ret = 0;\n    if (index < n) {\n        char c;\n        do {\n            c = source.charAt(index++);\n        } while (Character.isWhitespace(c) && index < n);\n        pos.setIndex(index);\n        if (index < n) {\n            ret = c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Get the set of locales for which complex formats are available.  This\n * is the same set as the {@link NumberFormat} set.\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "formatFraction",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * This static method calls formatFraction() on a default instance of\n * FractionFormat.\n *\n * @param f Fraction object to format\n * @return a formatted fraction in proper form.\n */\npublic static String formatFraction(Fraction f) {\n    return getImproperInstance().format(f);\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static FractionFormat getImproperInstance() {\n    return getImproperInstance(Locale.getDefault());\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static FractionFormat getImproperInstance(final Locale locale) {\n    return new FractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static FractionFormat getProperInstance() {\n    return getProperInstance(Locale.getDefault());\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static FractionFormat getProperInstance(final Locale locale) {\n    return new ProperFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n * customizing is the maximum number of fraction digits, which is set to 0.\n * @return the default number format.\n */\nprotected static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "FractionField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static FractionField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static BigFractionField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "flatten",
                "org.apache.commons.math3.exception.util",
                "ArgUtils",
                "/**\n * Transform a multidimensional array into a one-dimensional list.\n *\n * @param array Array (possibly multidimensional).\n * @return a list of all the {@code Object} instances contained in\n * {@code array}.\n */\npublic static Object[] flatten(Object[] array) {\n    final List<Object> list = new ArrayList<Object>();\n    if (array != null) {\n        for (Object o : array) {\n            if (o instanceof Object[]) {\n                for (Object oR : flatten((Object[]) o)) {\n                    list.add(oR);\n                }\n            } else {\n                list.add(o);\n            }\n        }\n    }\n    return list.toArray();\n}"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Multiply every component in the given real array by the\n * given real number. The change is made in place.\n *\n * @param f the real array to be scaled\n * @param d the real scaling coefficient\n * @return a reference to the scaled array\n */\npublic static double[] scaleArray(double[] f, double d) {\n    for (int i = 0; i < f.length; i++) {\n        f[i] *= d;\n    }\n    return f;\n}"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Multiply every component in the given complex array by the\n * given real number. The change is made in place.\n *\n * @param f the complex array to be scaled\n * @param d the real scaling coefficient\n * @return a reference to the scaled array\n */\npublic static Complex[] scaleArray(Complex[] f, double d) {\n    for (int i = 0; i < f.length; i++) {\n        f[i] = new Complex(d * f[i].getReal(), d * f[i].getImaginary());\n    }\n    return f;\n}"
            ],
            [
                "createRealImaginaryArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Builds a new two dimensional array of {@code double} filled with the real\n * and imaginary parts of the specified {@link Complex} numbers. In the\n * returned array {@code dataRI}, the data is laid out as follows\n * <ul>\n * <li>{@code dataRI[0][i] = dataC[i].getReal()},</li>\n * <li>{@code dataRI[1][i] = dataC[i].getImaginary()}.</li>\n * </ul>\n *\n * @param dataC the array of {@link Complex} data to be transformed\n * @return a two dimensional array filled with the real and imaginary parts\n *   of the specified complex input\n */\npublic static double[][] createRealImaginaryArray(final Complex[] dataC) {\n    final double[][] dataRI = new double[2][dataC.length];\n    final double[] dataR = dataRI[0];\n    final double[] dataI = dataRI[1];\n    for (int i = 0; i < dataC.length; i++) {\n        final Complex c = dataC[i];\n        dataR[i] = c.getReal();\n        dataI[i] = c.getImaginary();\n    }\n    return dataRI;\n}"
            ],
            [
                "createComplexArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Builds a new array of {@link Complex} from the specified two dimensional\n * array of real and imaginary parts. In the returned array {@code dataC},\n * the data is laid out as follows\n * <ul>\n * <li>{@code dataC[i].getReal() = dataRI[0][i]},</li>\n * <li>{@code dataC[i].getImaginary() = dataRI[1][i]}.</li>\n * </ul>\n *\n * @param dataRI the array of real and imaginary parts to be transformed\n * @return an array of {@link Complex} with specified real and imaginary parts.\n * @throws DimensionMismatchException if the number of rows of the specified\n *   array is not two, or the array is not rectangular\n */\npublic static Complex[] createComplexArray(final double[][] dataRI) throws DimensionMismatchException {\n    if (dataRI.length != 2) {\n        throw new DimensionMismatchException(dataRI.length, 2);\n    }\n    final double[] dataR = dataRI[0];\n    final double[] dataI = dataRI[1];\n    if (dataR.length != dataI.length) {\n        throw new DimensionMismatchException(dataI.length, dataR.length);\n    }\n    final int n = dataR.length;\n    final Complex[] c = new Complex[n];\n    for (int i = 0; i < n; i++) {\n        c[i] = new Complex(dataR[i], dataI[i]);\n    }\n    return c;\n}"
            ],
            [
                "exactLog2",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Returns the base-2 logarithm of the specified {@code int}. Throws an\n * exception if {@code n} is not a power of two.\n *\n * @param n the {@code int} whose base-2 logarithm is to be evaluated\n * @return the base-2 logarithm of {@code n}\n * @throws MathIllegalArgumentException if {@code n} is not a power of two\n */\npublic static int exactLog2(final int n) throws MathIllegalArgumentException {\n    int index = Arrays.binarySearch(TransformUtils.POWERS_OF_TWO, n);\n    if (index < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, Integer.valueOf(n));\n    }\n    return index;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "PRIMES",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * The first 512 prime numbers.\n * <p>\n * It contains all primes smaller or equal to the cubic square of Integer.MAX_VALUE.\n * As a result, <code>int</code> numbers which are not reduced by those primes are guaranteed\n * to be either prime or semi prime.\n */\npublic static final int[] PRIMES = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671 };"
            ],
            [
                "PRIMES_LAST",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * The last number in PRIMES.\n */\npublic static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];"
            ],
            [
                "MIDPOINT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "MidPointIntegrator",
                "/**\n * Maximum number of iterations for midpoint.\n */\npublic static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "ROMBERG_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "RombergIntegrator",
                "/**\n * Maximal number of iterations for Romberg.\n */\npublic static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;"
            ],
            [
                "SIMPSON_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "SimpsonIntegrator",
                "/**\n * Maximal number of iterations for Simpson.\n */\npublic static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default absolute accuracy.\n */\npublic static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;"
            ],
            [
                "DEFAULT_RELATIVE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default relative accuracy.\n */\npublic static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;"
            ],
            [
                "DEFAULT_MIN_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default minimal iteration count.\n */\npublic static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default maximal iteration count.\n */\npublic static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;"
            ],
            [
                "TRAPEZOID_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "TrapezoidIntegrator",
                "/**\n * Maximum number of iterations for trapezoid.\n */\npublic static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "BaseSecantSolver",
                "/**\n * Default absolute accuracy.\n */\nprotected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "SecantSolver",
                "/**\n * Default absolute accuracy.\n */\nprotected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_BANDWIDTH",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value of the bandwidth parameter.\n */\npublic static final double DEFAULT_BANDWIDTH = 0.3;"
            ],
            [
                "DEFAULT_ROBUSTNESS_ITERS",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value of the number of robustness iterations.\n */\npublic static final int DEFAULT_ROBUSTNESS_ITERS = 2;"
            ],
            [
                "DEFAULT_ACCURACY",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value for accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_ACCURACY = 1e-12;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.analysis.interpolation",
                "NevilleInterpolator",
                "/**\n * serializable version identifier\n */\nstatic final long serialVersionUID = 3003707660147873733L;"
            ],
            [
                "DEFAULT_EXTEND",
                "org.apache.commons.math3.analysis.interpolation",
                "UnivariatePeriodicInterpolator",
                "/**\n * Default number of extension points of the samples array.\n */\npublic static final int DEFAULT_EXTEND = 5;"
            ],
            [
                "DEFAULT_MICROSPHERE_ELEMENTS",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "/**\n * Default number of surface elements that composes the microsphere.\n */\npublic static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;"
            ],
            [
                "DEFAULT_BRIGHTNESS_EXPONENT",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "/**\n * Default exponent used the weights calculation.\n */\npublic static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;"
            ],
            [
                "EPSILON",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * <p>\n * Largest double-precision floating-point number such that\n * {@code 1 + EPSILON} is numerically equal to 1. This value is an upper\n * bound on the relative error due to rounding real numbers to double\n * precision floating-point numbers.\n * </p>\n * <p>\n * In IEEE 754 arithmetic, this is 2<sup>-53</sup>.\n * </p>\n *\n * @see <a href=\"http://en.wikipedia.org/wiki/Machine_epsilon\">Machine epsilon</a>\n */\npublic static final double EPSILON;"
            ],
            [
                "SAFE_MIN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Safe minimum, such that {@code 1 / SAFE_MIN} does not overflow.\n * <br/>\n * In IEEE 754 arithmetic, this is also the smallest normalized\n * number 2<sup>-1022</sup>.\n */\npublic static final double SAFE_MIN;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;"
            ],
            [
                "PI",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Archimede's constant PI, ratio of circle circumference to diameter.\n */\npublic static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
            ],
            [
                "E",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Napier's constant e, base of the natural logarithm.\n */\npublic static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
            ],
            [
                "EXP_INT_TABLE_MAX_INDEX",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Index of exp(0) in the array of integer exponentials.\n */\nstatic final int EXP_INT_TABLE_MAX_INDEX = 750;"
            ],
            [
                "EXP_INT_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Length of the array of integer exponentials.\n */\nstatic final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;"
            ],
            [
                "LN_MANT_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Logarithm table length.\n */\nstatic final int LN_MANT_LEN = 1024;"
            ],
            [
                "EXP_FRAC_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Exponential fractions table length.\n */\n// 0, 1/1024, ... 1024/1024\nstatic final int EXP_FRAC_TABLE_LEN = 1025;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of NaN.\n */\npublic static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of positive infinity.\n */\npublic static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of negative infinity.\n */\npublic static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of NaN.\n */\npublic static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of positive infinity.\n */\npublic static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of negative infinity.\n */\npublic static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "ADDITIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "/**\n * Additive expansion mode.\n * @deprecated As of 3.1. Please use {@link ExpansionMode#ADDITIVE} instead.\n */\n@Deprecated\npublic static final int ADDITIVE_MODE = 1;"
            ],
            [
                "MULTIPLICATIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "/**\n * Multiplicative expansion mode.\n * @deprecated As of 3.1. Please use {@link ExpansionMode#MULTIPLICATIVE} instead.\n */\n@Deprecated\npublic static final int MULTIPLICATIVE_MODE = 0;"
            ],
            [
                "TWO_PI",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * \\(2\\pi\\)\n * @since 2.1\n */\npublic static final double TWO_PI = 2 * FastMath.PI;"
            ],
            [
                "PI_SQUARED",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * \\(\\pi^2\\)\n * @since 3.4\n */\npublic static final double PI_SQUARED = FastMath.PI * FastMath.PI;"
            ],
            [
                "FACTORIALS",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * All long-representable factorials\n */\nstatic final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };"
            ],
            [
                "STIRLING_S2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Stirling numbers of the second kind.\n */\nstatic final AtomicReference<long[][]> STIRLING_S2 = new AtomicReference<long[][]>(null);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@code 0d} as a {@code Decimal64}.\n */\npublic static final Decimal64 ZERO;"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@code 1d} as a {@code Decimal64}.\n */\npublic static final Decimal64 ONE;"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#NEGATIVE_INFINITY} as a\n * {@code Decimal64}.\n */\npublic static final Decimal64 NEGATIVE_INFINITY;"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#POSITIVE_INFINITY} as a\n * {@code Decimal64}.\n */\npublic static final Decimal64 POSITIVE_INFINITY;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#NaN} as a {@code Decimal64}.\n */\npublic static final Decimal64 NAN;"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "BigReal",
                "/**\n * A big real representing 0.\n */\npublic static final BigReal ZERO = new BigReal(BigDecimal.ZERO);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "BigReal",
                "/**\n * A big real representing 1.\n */\npublic static final BigReal ONE = new BigReal(BigDecimal.ONE);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Identity quaternion.\n */\npublic static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Zero quaternion.\n */\npublic static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * i\n */\npublic static final Quaternion I = new Quaternion(0, 1, 0, 0);"
            ],
            [
                "J",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * j\n */\npublic static final Quaternion J = new Quaternion(0, 0, 1, 0);"
            ],
            [
                "K",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * k\n */\npublic static final Quaternion K = new Quaternion(0, 0, 0, 1);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * The square root of -1. A number representing \"0.0 + 1.0i\"\n */\npublic static final Complex I = new Complex(0.0, 1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A complex number representing \"NaN + NaNi\"\n */\npublic static final Complex NaN = new Complex(Double.NaN, Double.NaN);"
            ],
            [
                "INF",
                "org.apache.commons.math3.complex",
                "Complex",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A complex number representing \"+INF + INFi\"\n */\npublic static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * A complex number representing \"1.0 + 0.0i\"\n */\npublic static final Complex ONE = new Complex(1.0, 0.0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * A complex number representing \"0.0 + 0.0i\"\n */\npublic static final Complex ZERO = new Complex(0.0, 0.0);"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Minimum dimension of the problem: {@value}\n */\npublic static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #initialTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #stoppingTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "DEFAULT_CHECKFEASABLECOUNT",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #checkFeasableCount}: {@value}.\n */\npublic static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
            ],
            [
                "DEFAULT_STOPFITNESS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #stopFitness}: {@value}.\n */\npublic static final double DEFAULT_STOPFITNESS = 0;"
            ],
            [
                "DEFAULT_ISACTIVECMA",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #isActiveCMA}: {@value}.\n */\npublic static final boolean DEFAULT_ISACTIVECMA = true;"
            ],
            [
                "DEFAULT_MAXITERATIONS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #maxIterations}: {@value}.\n */\npublic static final int DEFAULT_MAXITERATIONS = 30000;"
            ],
            [
                "DEFAULT_DIAGONALONLY",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #diagonalOnly}: {@value}.\n */\npublic static final int DEFAULT_DIAGONALONLY = 0;"
            ],
            [
                "DEFAULT_RANDOMGENERATOR",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #random}.\n */\npublic static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.optimization.linear",
                "AbstractLinearOptimizer",
                "/**\n * Default maximal number of iterations allowed.\n */\npublic static final int DEFAULT_MAX_ITERATIONS = 100;"
            ],
            [
                "DEFAULT_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * The default format for {@link RealMatrix} objects.\n * @since 3.1\n */\npublic static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();"
            ],
            [
                "OCTAVE_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * A format for {@link RealMatrix} objects compatible with octave.\n * @since 3.1\n */\npublic static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat(\"[\", \"]\", \"\", \"\", \"; \", \", \");"
            ],
            [
                "DEFAULT_ZERO_TOLERANCE",
                "org.apache.commons.math3.linear",
                "OpenMapRealVector",
                "/**\n * Default Tolerance for having a value considered zero.\n */\npublic static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Block size.\n */\npublic static final int BLOCK_SIZE = 36;"
            ],
            [
                "OPERATOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "/**\n * Key for the <a href=\"#context\">exception context</a>.\n */\npublic static final String OPERATOR = \"operator\";"
            ],
            [
                "VECTOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "/**\n * Key for the <a href=\"#context\">exception context</a>.\n */\npublic static final String VECTOR = \"vector\";"
            ],
            [
                "DEFAULT_RELATIVE_SYMMETRY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "/**\n * Default threshold above which off-diagonal elements are considered too different\n * and matrix not symmetric.\n */\npublic static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;"
            ],
            [
                "DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "/**\n * Default threshold below which diagonal elements are considered null\n * and matrix not positive definite.\n */\npublic static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Block size.\n */\npublic static final int BLOCK_SIZE = 52;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "/**\n * The cubic root of {@link #MACH_PREC}.\n */\nstatic final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "/**\n * The machine precision.\n */\nstatic final double MACH_PREC;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "/**\n * The cubic root of {@link #MACH_PREC}.\n */\nstatic final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "/**\n * The machine precision.\n */\nstatic final double MACH_PREC;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "CauchyDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "SOLVER_DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "AbstractRealDistribution",
                "/**\n * Default accuracy.\n */\npublic static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "TDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ChiSquaredDistribution",
                "/**\n * Default inverse cumulative probability accuracy\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NormalDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "UniformRealDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @deprecated as of 3.2 not used anymore, will be removed in 4.0\n */\n@Deprecated\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "WeibullDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NakagamiDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ExponentialDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "LogNormalDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ParetoDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "FDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "/**\n * Default maximum number of iterations for cumulative probability calculations.\n * @since 2.1\n */\npublic static final int DEFAULT_MAX_ITERATIONS = 10000000;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "/**\n * Default convergence criterion.\n * @since 2.1\n */\npublic static final double DEFAULT_EPSILON = 1e-12;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "GammaDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_ULPS",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "/**\n * Default amount of error to accept in floating point comparisons (as ulps).\n */\nstatic final int DEFAULT_ULPS = 10;"
            ],
            [
                "DEFAULT_CUT_OFF",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "/**\n * Default cut-off value.\n */\nstatic final double DEFAULT_CUT_OFF = 1e-10;"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Minimum dimension of the problem: {@value}\n */\npublic static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #initialTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #stoppingTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "GAMMA",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <a href=\"http://en.wikipedia.org/wiki/Euler-Mascheroni_constant\">Euler-Mascheroni constant</a>\n * @since 2.0\n */\npublic static final double GAMMA = 0.577215664901532860606512090082;"
            ],
            [
                "LANCZOS_G",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * The value of the {@code g} constant in the Lanczos approximation, see\n * {@link #lanczos(double)}.\n * @since 3.1\n */\npublic static final double LANCZOS_G = 607.0 / 128.0;"
            ],
            [
                "DEFAULT_NAN_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "/**\n * default NaN strategy\n */\npublic static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.FAILED;"
            ],
            [
                "DEFAULT_TIES_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "/**\n * default ties strategy\n */\npublic static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;"
            ],
            [
                "MAXIMUM_PARTIAL_SUM_COUNT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Bound on the number of partial sums in {@link #ksSum(double, double, int)}\n */\nprotected static final int MAXIMUM_PARTIAL_SUM_COUNT = 100000;"
            ],
            [
                "KS_SUM_CAUCHY_CRITERION",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Convergence criterion for {@link #ksSum(double, double, int)}\n */\nprotected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;"
            ],
            [
                "PG_SUM_RELATIVE_ERROR",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Convergence criterion for the sums in #pelzGood(double, double, int)}\n */\nprotected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;"
            ],
            [
                "SMALL_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * No longer used.\n */\n@Deprecated\nprotected static final int SMALL_SAMPLE_PRODUCT = 200;"
            ],
            [
                "LARGE_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * When product of sample sizes exceeds this value, 2-sample K-S test uses asymptotic\n * distribution to compute the p-value.\n */\nprotected static final int LARGE_SAMPLE_PRODUCT = 10000;"
            ],
            [
                "MONTE_CARLO_ITERATIONS",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Default number of iterations used by {@link #monteCarloP(double, int, int, boolean, int)}.\n *  Deprecated as of version 3.6, as this method is no longer needed.\n */\n@Deprecated\nprotected static final int MONTE_CARLO_ITERATIONS = 1000000;"
            ],
            [
                "INFINITE_WINDOW",
                "org.apache.commons.math3.stat.descriptive",
                "DescriptiveStatistics",
                "/**\n * Represents an infinite window size.  When the {@link #getWindowSize()}\n * returns this value, there is no limit to the number of data values\n * that can be stored in the dataset.\n */\npublic static final int INFINITE_WINDOW = -1;"
            ],
            [
                "UPSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "/**\n * The UPSIDE Direction is used to specify that the observations above the\n * cutoff point will be used to calculate SemiVariance.\n */\npublic static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;"
            ],
            [
                "DOWNSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "/**\n * The DOWNSIDE Direction is used to specify that the observations below\n * the cutoff point will be used to calculate SemiVariance\n */\npublic static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Comparator.\n */\nstatic final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "PairNeuronDouble",
                "/**\n * Comparator.\n */\nstatic final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "RADIX",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The radix, or base of this system.  Set to 10000\n */\npublic static final int RADIX = 10000;"
            ],
            [
                "MIN_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The minimum exponent before underflow is signaled.  Flush to zero\n *  occurs at minExp-DIGITS\n */\npublic static final int MIN_EXP = -32767;"
            ],
            [
                "MAX_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The maximum exponent before overflow is signaled and results flushed\n *  to infinity\n */\npublic static final int MAX_EXP = 32768;"
            ],
            [
                "ERR_SCALE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The amount under/overflows are scaled by before going to trap handler\n */\npublic static final int ERR_SCALE = 32760;"
            ],
            [
                "FINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for normal finite numbers.\n */\npublic static final byte FINITE = 0;"
            ],
            [
                "INFINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for Infinity.\n */\npublic static final byte INFINITE = 1;"
            ],
            [
                "SNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for signaling NaN.\n */\npublic static final byte SNAN = 2;"
            ],
            [
                "QNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for quiet NaN.\n */\npublic static final byte QNAN = 3;"
            ],
            [
                "FLAG_INVALID",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for invalid operation.\n */\npublic static final int FLAG_INVALID = 1;"
            ],
            [
                "FLAG_DIV_ZERO",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for division by zero.\n */\npublic static final int FLAG_DIV_ZERO = 2;"
            ],
            [
                "FLAG_OVERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for overflow.\n */\npublic static final int FLAG_OVERFLOW = 4;"
            ],
            [
                "FLAG_UNDERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for underflow.\n */\npublic static final int FLAG_UNDERFLOW = 8;"
            ],
            [
                "FLAG_INEXACT",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for inexact result.\n */\npublic static final int FLAG_INEXACT = 16;"
            ],
            [
                "DEFAULT_PREFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default prefix: \"{\".\n */\npublic static final String DEFAULT_PREFIX = \"{\";"
            ],
            [
                "DEFAULT_SUFFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default suffix: \"}\".\n */\npublic static final String DEFAULT_SUFFIX = \"}\";"
            ],
            [
                "DEFAULT_SEPARATOR",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default separator: \", \".\n */\npublic static final String DEFAULT_SEPARATOR = \"; \";"
            ],
            [
                "XYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around X, then around Y, then\n * around Z\n */\npublic static final RotationOrder XYZ = new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "XZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around X, then around Z, then\n * around Y\n */\npublic static final RotationOrder XZY = new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "YXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Y, then around X, then\n * around Z\n */\npublic static final RotationOrder YXZ = new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "YZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Y, then around Z, then\n * around X\n */\npublic static final RotationOrder YZX = new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "ZXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Z, then around X, then\n * around Y\n */\npublic static final RotationOrder ZXY = new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "ZYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Z, then around Y, then\n * around X\n */\npublic static final RotationOrder ZYX = new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around X, then around Y, then\n * around X\n */\npublic static final RotationOrder XYX = new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around X, then around Z, then\n * around X\n */\npublic static final RotationOrder XZX = new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "YXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Y, then around X, then\n * around Y\n */\npublic static final RotationOrder YXY = new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "YZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Y, then around Z, then\n * around Y\n */\npublic static final RotationOrder YZY = new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "ZXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Z, then around X, then\n * around Z\n */\npublic static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "ZYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Z, then around Y, then\n * around Z\n */\npublic static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "/**\n * Identity rotation.\n */\npublic static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Null vector (coordinates: 0, 0, 0).\n */\npublic static final Vector3D ZERO = new Vector3D(0, 0, 0);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * First canonical vector (coordinates: 1, 0, 0).\n */\npublic static final Vector3D PLUS_I = new Vector3D(1, 0, 0);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the first canonical vector (coordinates: -1, 0, 0).\n */\npublic static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Second canonical vector (coordinates: 0, 1, 0).\n */\npublic static final Vector3D PLUS_J = new Vector3D(0, 1, 0);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the second canonical vector (coordinates: 0, -1, 0).\n */\npublic static final Vector3D MINUS_J = new Vector3D(0, -1, 0);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Third canonical vector (coordinates: 0, 0, 1).\n */\npublic static final Vector3D PLUS_K = new Vector3D(0, 0, 1);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the third canonical vector (coordinates: 0, 0, -1).\n */\npublic static final Vector3D MINUS_K = new Vector3D(0, 0, -1);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Origin (coordinates: 0).\n */\npublic static final Vector1D ZERO = new Vector1D(0.0);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Unit (coordinates: 1).\n */\npublic static final Vector1D ONE = new Vector1D(1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector1D NaN = new Vector1D(Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector1D POSITIVE_INFINITY = new Vector1D(Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector1D NEGATIVE_INFINITY = new Vector1D(Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Origin (coordinates: 0, 0).\n */\npublic static final Vector2D ZERO = new Vector2D(0, 0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector2D POSITIVE_INFINITY = new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector2D NEGATIVE_INFINITY = new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +I (coordinates: \\( \\theta = 0, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +J (coordinates: \\( \\theta = \\pi/2, \\varphi = \\pi/2 \\))).\n */\npublic static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +K (coordinates: \\( \\theta = any angle, \\varphi = 0 \\)).\n */\npublic static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -I (coordinates: \\( \\theta = \\pi, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -J (coordinates: \\( \\theta = 3\\pi/2, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -K (coordinates: \\( \\theta = any angle, \\varphi = \\pi \\)).\n */\npublic static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);"
            ],
            [
                "DIGEST_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Use empirical distribution.\n */\npublic static final int DIGEST_MODE = 0;"
            ],
            [
                "REPLAY_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Replay data from valuesFilePath.\n */\npublic static final int REPLAY_MODE = 1;"
            ],
            [
                "UNIFORM_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Uniform random deviates with mean = &mu;.\n */\npublic static final int UNIFORM_MODE = 2;"
            ],
            [
                "EXPONENTIAL_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Exponential random deviates with mean = &mu;.\n */\npublic static final int EXPONENTIAL_MODE = 3;"
            ],
            [
                "GAUSSIAN_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Gaussian random deviates with mean = &mu;, std dev = &sigma;.\n */\npublic static final int GAUSSIAN_MODE = 4;"
            ],
            [
                "CONSTANT_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Always return mu\n */\npublic static final int CONSTANT_MODE = 5;"
            ],
            [
                "DEFAULT_BIN_COUNT",
                "org.apache.commons.math3.random",
                "EmpiricalDistribution",
                "/**\n * Default bin count\n */\npublic static final int DEFAULT_BIN_COUNT = 1000;"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2 / 1\".\n */\npublic static final Fraction TWO = new Fraction(2, 1);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1\".\n */\npublic static final Fraction ONE = new Fraction(1, 1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"0\".\n */\npublic static final Fraction ZERO = new Fraction(0, 1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"4/5\".\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/5\".\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/2\".\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/4\".\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/3\".\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"3/5\".\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"3/4\".\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/5\".\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/4\".\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/3\".\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"-1 / 1\".\n */\npublic static final Fraction MINUS_ONE = new Fraction(-1, 1);"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2 / 1\".\n */\npublic static final BigFraction TWO = new BigFraction(2);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1\".\n */\npublic static final BigFraction ONE = new BigFraction(1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"0\".\n */\npublic static final BigFraction ZERO = new BigFraction(0);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"-1 / 1\".\n */\npublic static final BigFraction MINUS_ONE = new BigFraction(-1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"4/5\".\n */\npublic static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/5\".\n */\npublic static final BigFraction ONE_FIFTH = new BigFraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/2\".\n */\npublic static final BigFraction ONE_HALF = new BigFraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/4\".\n */\npublic static final BigFraction ONE_QUARTER = new BigFraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/3\".\n */\npublic static final BigFraction ONE_THIRD = new BigFraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"3/5\".\n */\npublic static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"3/4\".\n */\npublic static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/5\".\n */\npublic static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/4\".\n */\npublic static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/3\".\n */\npublic static final BigFraction TWO_THIRDS = new BigFraction(2, 3);"
            ],
            [
                "INTEGER_ZERO",
                "org.apache.commons.math3.exception",
                "MathIllegalNumberException",
                "/**\n * Helper to avoid boxing warnings. @since 3.3\n */\nprotected static final Integer INTEGER_ZERO = Integer.valueOf(0);"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastSineTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120211L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastFourierTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120210L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastCosineTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120212L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastHadamardTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120211L;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "subtrahend",
                "",
                "double"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "getField",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract Field<T> getField()"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this - subtrahend)}.\n *\n * @param  subtrahend value to be subtracted from this {@code Complex}.\n * @return {@code this - subtrahend}.\n * @see #subtract(Complex)\n */\npublic Complex subtract(double subtrahend) {\n    if (isNaN || Double.isNaN(subtrahend)) {\n        return NaN;\n    }\n    return createComplex(real - subtrahend, imaginary);\n}"
            ],
            [
                "conjugate",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns the conjugate of this complex number.\n * The conjugate of {@code a + bi} is {@code a - bi}.\n * <p>\n * {@link #NaN} is returned if either the real or imaginary\n * part of this Complex number equals {@code Double.NaN}.\n * </p><p>\n * If the imaginary part is infinite, and the real part is not\n * {@code NaN}, the returned value has infinite imaginary part\n * of the opposite sign, e.g. the conjugate of\n * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.\n * </p>\n * @return the conjugate of this Complex object.\n */\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(real, -imaginary);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns of value of this complex number raised to the power of {@code x}.\n *\n * @param  x exponent to which this {@code Complex} is to be raised.\n * @return <code>this<sup>x</sup></code>.\n * @see #pow(Complex)\n */\npublic Complex pow(double x) {\n    return this.log().multiply(x).exp();\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n * interpreted as a integer number.\n *\n * @param  factor value to be multiplied by this {@code Complex}.\n * @return {@code this * factor}.\n * @see #multiply(Complex)\n */\npublic Complex multiply(final int factor) {\n    if (isNaN) {\n        return NaN;\n    }\n    if (Double.isInfinite(real) || Double.isInfinite(imaginary)) {\n        return INF;\n    }\n    return createComplex(real * factor, imaginary * factor);\n}"
            ],
            [
                "acos",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n * inverse cosine</a> of this complex number.\n * Implements the formula:\n * <p>\n *  {@code acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))}\n * </p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite.\n *\n * @return the inverse cosine of this complex number.\n * @since 1.2\n */\npublic Complex acos() {\n    if (isNaN) {\n        return NaN;\n    }\n    return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());\n}"
            ],
            [
                "getField",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * {@inheritDoc}\n */\npublic ComplexField getField() {\n    return ComplexField.getInstance();\n}"
            ],
            [
                "divide",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T divide(T arg0) throws NullArgumentException, MathArithmeticException"
            ],
            [
                "abs",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Return the absolute value of this complex number.\n * Returns {@code NaN} if either real or imaginary part is {@code NaN}\n * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},\n * but at least one part is infinite.\n *\n * @return the absolute value.\n */\npublic double abs() {\n    if (isNaN) {\n        return Double.NaN;\n    }\n    if (isInfinite()) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        if (imaginary == 0.0) {\n            return FastMath.abs(real);\n        }\n        double q = real / imaginary;\n        return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n    } else {\n        if (real == 0.0) {\n            return FastMath.abs(imaginary);\n        }\n        double q = imaginary / real;\n        return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n    }\n}"
            ],
            [
                "readResolve",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Resolve the transient fields in a deserialized Complex Object.\n * Subclasses will need to override {@link #createComplex} to\n * deserialize properly.\n *\n * @return A Complex instance with all fields resolved.\n * @since 2.0\n */\nprotected final Object readResolve() {\n    return createComplex(real, imaginary);\n}"
            ],
            [
                "tanh",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n * hyperbolic tangent</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n * {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\n *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\n *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i\n *  </code>\n * </pre>\n *\n * @return the hyperbolic tangent of {@code this}.\n * @since 1.2\n */\npublic Complex tanh() {\n    if (isNaN || Double.isInfinite(imaginary)) {\n        return NaN;\n    }\n    if (real > 20.0) {\n        return createComplex(1.0, 0.0);\n    }\n    if (real < -20.0) {\n        return createComplex(-1.0, 0.0);\n    }\n    double real2 = 2.0 * real;\n    double imaginary2 = 2.0 * imaginary;\n    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n    return createComplex(FastMath.sinh(real2) / d, FastMath.sin(imaginary2) / d);\n}"
            ],
            [
                "reciprocal",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * {@inheritDoc}\n */\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return INF;\n    }\n    if (isInfinite) {\n        return ZERO;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}"
            ],
            [
                "getArgument",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the argument of this complex number.\n * The argument is the angle phi between the positive real axis and\n * the point representing this number in the complex plane.\n * The value returned is between -PI (not inclusive)\n * and PI (inclusive), with negative values returned for numbers with\n * negative imaginary parts.\n * <p>\n * If either real or imaginary part (or both) is NaN, NaN is returned.\n * Infinite parts are handled as {@code Math.atan2} handles them,\n * essentially treating finite parts as zero in the presence of an\n * infinite coordinate and returning a multiple of pi/4 depending on\n * the signs of the infinite parts.\n * See the javadoc for {@code Math.atan2} for full details.\n *\n * @return the argument of {@code this}.\n */\npublic double getArgument() {\n    return FastMath.atan2(getImaginary(), getReal());\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code (this + addend)},\n * with {@code addend} interpreted as a real number.\n *\n * @param addend Value to be added to this {@code Complex}.\n * @return {@code this + addend}.\n * @see #add(Complex)\n */\npublic Complex add(double addend) {\n    if (isNaN || Double.isNaN(addend)) {\n        return NaN;\n    }\n    return createComplex(real + addend, imaginary);\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n * interpreted as a real number.\n *\n * @param  factor value to be multiplied by this {@code Complex}.\n * @return {@code this * factor}.\n * @see #multiply(Complex)\n */\npublic Complex multiply(double factor) {\n    if (isNaN || Double.isNaN(factor)) {\n        return NaN;\n    }\n    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor)) {\n        // we don't use isInfinite() to avoid testing for NaN again\n        return INF;\n    }\n    return createComplex(real * factor, imaginary * factor);\n}"
            ],
            [
                "toString",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * {@inheritDoc}\n */\n@Override\npublic String toString() {\n    return \"(\" + real + \", \" + imaginary + \")\";\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n * natural logarithm</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i\n *  </code>\n * </pre>\n * where ln on the right hand side is {@link FastMath#log},\n * {@code |a + bi|} is the modulus, {@link Complex#abs},  and\n * {@code arg(a + bi) = }{@link FastMath#atan2}(b, a).\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite (or critical) values in real or imaginary parts of the input may\n * result in infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n *   log(INFINITY + i) = INFINITY + 0i\n *   log(-INFINITY + i) = INFINITY + &pi;i\n *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n *   log(0 + 0i) = -INFINITY + 0i\n *  </code>\n * </pre>\n *\n * @return the value <code>ln &nbsp; this</code>, the natural logarithm\n * of {@code this}.\n * @since 1.2\n */\npublic Complex log() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.log(abs()), FastMath.atan2(imaginary, real));\n}"
            ],
            [
                "cosh",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n * hyperbolic cosine</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n *   cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n *   cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the hyperbolic cosine of this complex number.\n * @since 1.2\n */\npublic Complex cosh() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.cosh(real) * FastMath.cos(imaginary), FastMath.sinh(real) * FastMath.sin(imaginary));\n}"
            ],
            [
                "sqrt1z",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n * square root</a> of <code>1 - this<sup>2</sup></code> for this complex\n * number.\n * Computes the result directly as\n * {@code sqrt(ONE.subtract(z.multiply(z)))}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n *\n * @return the square root of <code>1 - this<sup>2</sup></code>.\n * @since 1.2\n */\npublic Complex sqrt1z() {\n    return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n}"
            ],
            [
                "exp",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n * exponential function</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#exp}, {@link FastMath#cos}, and\n * {@link FastMath#sin}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   exp(1 &plusmn; INFINITY i) = NaN + NaN i\n *   exp(INFINITY + i) = INFINITY + INFINITY i\n *   exp(-INFINITY + i) = 0 + 0i\n *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return <code><i>e</i><sup>this</sup></code>.\n * @since 1.2\n */\npublic Complex exp() {\n    if (isNaN) {\n        return NaN;\n    }\n    double expReal = FastMath.exp(real);\n    return createComplex(expReal * FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code this * factor}.\n * Implements preliminary checks for {@code NaN} and infinity followed by\n * the definitional formula:\n * <p>\n *   {@code (a + bi)(c + di) = (ac - bd) + (ad + bc)i}\n * </p>\n * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n * more {@code NaN} parts.\n * <p>\n * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n * or more {@code NaN} parts and if either {@code this} or {@code factor}\n * has one or more infinite parts (same result is returned regardless of\n * the sign of the components).\n * </p><p>\n * Returns finite values in components of the result per the definitional\n * formula in all remaining cases.</p>\n *\n * @param  factor value to be multiplied by this {@code Complex}.\n * @return {@code this * factor}.\n * @throws NullArgumentException if {@code factor} is {@code null}.\n */\npublic Complex multiply(Complex factor) throws NullArgumentException {\n    MathUtils.checkNotNull(factor);\n    if (isNaN || factor.isNaN) {\n        return NaN;\n    }\n    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {\n        // we don't use isInfinite() to avoid testing for NaN again\n        return INF;\n    }\n    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns of value of this complex number raised to the power of {@code x}.\n * Implements the formula:\n * <pre>\n *  <code>\n *   y<sup>x</sup> = exp(x&middot;log(y))\n *  </code>\n * </pre>\n * where {@code exp} and {@code log} are {@link #exp} and\n * {@link #log}, respectively.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite, or if {@code y}\n * equals {@link Complex#ZERO}.</p>\n *\n * @param  x exponent to which this {@code Complex} is to be raised.\n * @return <code> this<sup>x</sup></code>.\n * @throws NullArgumentException if x is {@code null}.\n * @since 1.2\n */\npublic Complex pow(Complex x) throws NullArgumentException {\n    MathUtils.checkNotNull(x);\n    return this.log().multiply(x).exp();\n}"
            ],
            [
                "isInfinite",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Checks whether either the real or imaginary part of this complex number\n * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or\n * {@code Double.NEGATIVE_INFINITY}) and neither part\n * is {@code NaN}.\n *\n * @return true if one or both parts of this complex number are infinite\n * and neither part is {@code NaN}.\n */\npublic boolean isInfinite() {\n    return isInfinite;\n}"
            ],
            [
                "asin",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n * inverse sine</a> of this complex number.\n * Implements the formula:\n * <p>\n *  {@code asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))}\n * </p><p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite.</p>\n *\n * @return the inverse sine of this complex number.\n * @since 1.2\n */\npublic Complex asin() {\n    if (isNaN) {\n        return NaN;\n    }\n    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());\n}"
            ],
            [
                "getImaginary",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Access the imaginary part.\n *\n * @return the imaginary part.\n */\npublic double getImaginary() {\n    return imaginary;\n}"
            ],
            [
                "sinh",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n * hyperbolic sine</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p><p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n *   sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n *   sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the hyperbolic sine of {@code this}.\n * @since 1.2\n */\npublic Complex sinh() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary), FastMath.cosh(real) * FastMath.sin(imaginary));\n}"
            ],
            [
                "divide",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this / divisor)}.\n * Implements the definitional formula\n * <pre>\n *  <code>\n *    a + bi          ac + bd + (bc - ad)i\n *    ----------- = -------------------------\n *    c + di         c<sup>2</sup> + d<sup>2</sup>\n *  </code>\n * </pre>\n * but uses\n * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n * prescaling of operands</a> to limit the effects of overflows and\n * underflows in the computation.\n * <p>\n * {@code Infinite} and {@code NaN} values are handled according to the\n * following rules, applied in the order presented:\n * <ul>\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n *   in either part, {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code this} and {@code divisor} are both infinite,\n *   {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\n *   infinite), {@link #ZERO} is returned.\n *  </li>\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\n *   {@code NaN} values are returned in the parts of the result if the\n *   {@link java.lang.Double} rules applied to the definitional formula\n *   force {@code NaN} results.\n *  </li>\n * </ul>\n *\n * @param divisor Value by which this {@code Complex} is to be divided.\n * @return {@code this / divisor}.\n * @throws NullArgumentException if {@code divisor} is {@code null}.\n */\npublic Complex divide(Complex divisor) throws NullArgumentException {\n    MathUtils.checkNotNull(divisor);\n    if (isNaN || divisor.isNaN) {\n        return NaN;\n    }\n    final double c = divisor.getReal();\n    final double d = divisor.getImaginary();\n    if (c == 0.0 && d == 0.0) {\n        return NaN;\n    }\n    if (divisor.isInfinite() && !isInfinite()) {\n        return ZERO;\n    }\n    if (FastMath.abs(c) < FastMath.abs(d)) {\n        double q = c / d;\n        double denominator = c * q + d;\n        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);\n    } else {\n        double q = d / c;\n        double denominator = d * q + c;\n        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);\n    }\n}"
            ],
            [
                "createComplex",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Create a complex number given the real and imaginary parts.\n *\n * @param realPart Real part.\n * @param imaginaryPart Imaginary part.\n * @return a new complex number instance.\n * @since 1.2\n * @see #valueOf(double, double)\n */\nprotected Complex createComplex(double realPart, double imaginaryPart) {\n    return new Complex(realPart, imaginaryPart);\n}"
            ],
            [
                "cos",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n * cosine</a> of this complex number.\n * Implements the formula:\n * <p>\n *  {@code cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i}\n * </p><p>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * </p><p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p><p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.</p>\n * <pre>\n *  Examples:\n *  <code>\n *   cos(1 &plusmn; INFINITY i) = 1 \\u2213 INFINITY i\n *   cos(&plusmn;INFINITY + i) = NaN + NaN i\n *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the cosine of this complex number.\n * @since 1.2\n */\npublic Complex cos() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.cos(real) * FastMath.cosh(imaginary), -FastMath.sin(real) * FastMath.sinh(imaginary));\n}"
            ],
            [
                "divide",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code (this / divisor)},\n * with {@code divisor} interpreted as a real number.\n *\n * @param  divisor Value by which this {@code Complex} is to be divided.\n * @return {@code this / divisor}.\n * @see #divide(Complex)\n */\npublic Complex divide(double divisor) {\n    if (isNaN || Double.isNaN(divisor)) {\n        return NaN;\n    }\n    if (divisor == 0d) {\n        return NaN;\n    }\n    if (Double.isInfinite(divisor)) {\n        return !isInfinite() ? ZERO : NaN;\n    }\n    return createComplex(real / divisor, imaginary / divisor);\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T multiply(T arg0) throws NullArgumentException"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this + addend)}.\n * Uses the definitional formula\n * <p>\n *   {@code (a + bi) + (c + di) = (a+c) + (b+d)i}\n * </p>\n * If either {@code this} or {@code addend} has a {@code NaN} value in\n * either part, {@link #NaN} is returned; otherwise {@code Infinite}\n * and {@code NaN} values are returned in the parts of the result\n * according to the rules for {@link java.lang.Double} arithmetic.\n *\n * @param  addend Value to be added to this {@code Complex}.\n * @return {@code this + addend}.\n * @throws NullArgumentException if {@code addend} is {@code null}.\n */\npublic Complex add(Complex addend) throws NullArgumentException {\n    MathUtils.checkNotNull(addend);\n    if (isNaN || addend.isNaN) {\n        return NaN;\n    }\n    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());\n}"
            ],
            [
                "isNaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Checks whether either or both parts of this complex number is\n * {@code NaN}.\n *\n * @return true if either or both parts of this complex number is\n * {@code NaN}; false otherwise.\n */\npublic boolean isNaN() {\n    return isNaN;\n}"
            ],
            [
                "getReal",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Access the real part.\n *\n * @return the real part.\n */\npublic double getReal() {\n    return real;\n}"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this - subtrahend)}.\n * Uses the definitional formula\n * <p>\n *  {@code (a + bi) - (c + di) = (a-c) + (b-d)i}\n * </p>\n * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,\n * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are\n * returned in the parts of the result according to the rules for\n * {@link java.lang.Double} arithmetic.\n *\n * @param  subtrahend value to be subtracted from this {@code Complex}.\n * @return {@code this - subtrahend}.\n * @throws NullArgumentException if {@code subtrahend} is {@code null}.\n */\npublic Complex subtract(Complex subtrahend) throws NullArgumentException {\n    MathUtils.checkNotNull(subtrahend);\n    if (isNaN || subtrahend.isNaN) {\n        return NaN;\n    }\n    return createComplex(real - subtrahend.getReal(), imaginary - subtrahend.getImaginary());\n}"
            ],
            [
                "tan",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n * tangent</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n * {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite (or critical) values in real or imaginary parts of the input may\n * result in infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\n *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\n *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n *  </code>\n * </pre>\n *\n * @return the tangent of {@code this}.\n * @since 1.2\n */\npublic Complex tan() {\n    if (isNaN || Double.isInfinite(real)) {\n        return NaN;\n    }\n    if (imaginary > 20.0) {\n        return createComplex(0.0, 1.0);\n    }\n    if (imaginary < -20.0) {\n        return createComplex(0.0, -1.0);\n    }\n    double real2 = 2.0 * real;\n    double imaginary2 = 2.0 * imaginary;\n    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);\n}"
            ],
            [
                "reciprocal",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T reciprocal() throws MathArithmeticException"
            ],
            [
                "hashCode",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Get a hashCode for the complex number.\n * Any {@code Double.NaN} value in real or imaginary part produces\n * the same hash code {@code 7}.\n *\n * @return a hash code value for this object.\n */\n@Override\npublic int hashCode() {\n    if (isNaN) {\n        return 7;\n    }\n    return 37 * (17 * MathUtils.hash(imaginary) + MathUtils.hash(real));\n}"
            ],
            [
                "negate",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code (-this)}.\n * Returns {@code NaN} if either real or imaginary\n * part of this Complex number is {@code Double.NaN}.\n *\n * @return {@code -this}.\n */\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(-real, -imaginary);\n}"
            ],
            [
                "atan",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n * inverse tangent</a> of this complex number.\n * Implements the formula:\n * <p>\n * {@code atan(z) = (i/2) log((i + z)/(i - z))}\n * </p><p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite.</p>\n *\n * @return the inverse tangent of this complex number\n * @since 1.2\n */\npublic Complex atan() {\n    if (isNaN) {\n        return NaN;\n    }\n    return this.add(I).divide(I.subtract(this)).log().multiply(I.divide(createComplex(2.0, 0.0)));\n}"
            ],
            [
                "nthRoot",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Computes the n-th roots of this complex number.\n * The nth roots are defined by the formula:\n * <pre>\n *  <code>\n *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n *  </code>\n * </pre>\n * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n * are respectively the {@link #abs() modulus} and\n * {@link #getArgument() argument} of this complex number.\n * <p>\n * If one or both parts of this complex number is NaN, a list with just\n * one element, {@link #NaN} is returned.\n * if neither part is NaN, but at least one part is infinite, the result\n * is a one-element list containing {@link #INF}.\n *\n * @param n Degree of root.\n * @return a List of all {@code n}-th roots of {@code this}.\n * @throws NotPositiveException if {@code n <= 0}.\n * @since 2.0\n */\npublic List<Complex> nthRoot(int n) throws NotPositiveException {\n    if (n <= 0) {\n        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);\n    }\n    final List<Complex> result = new ArrayList<Complex>();\n    if (isNaN) {\n        result.add(NaN);\n        return result;\n    }\n    if (isInfinite()) {\n        result.add(INF);\n        return result;\n    }\n    // nth root of abs -- faster / more accurate to use a solver here?\n    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n    // Compute nth roots of complex number with k = 0, 1, ... n-1\n    final double nthPhi = getArgument() / n;\n    final double slice = 2 * FastMath.PI / n;\n    double innerPart = nthPhi;\n    for (int k = 0; k < n; k++) {\n        // inner part\n        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);\n        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);\n        result.add(createComplex(realPart, imaginaryPart));\n        innerPart += slice;\n    }\n    return result;\n}"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n * square root</a> of this complex number.\n * Implements the following algorithm to compute {@code sqrt(a + bi)}:\n * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>\n * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}\n *  else return {@code |b|/2t + sign(b)t i }</pre></li>\n * </ol>\n * where <ul>\n * <li>{@code |a| = }{@link FastMath#abs}(a)</li>\n * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>\n * <li>{@code sign(b) =  }{@link FastMath#copySign(double,double) copySign(1d, b)}\n * </ul>\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n *   sqrt(INFINITY + i) = INFINITY + 0i\n *   sqrt(-INFINITY + i) = 0 + INFINITY i\n *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n *  </code>\n * </pre>\n *\n * @return the square root of {@code this}.\n * @since 1.2\n */\npublic Complex sqrt() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return createComplex(0.0, 0.0);\n    }\n    double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n    if (real >= 0.0) {\n        return createComplex(t, imaginary / (2.0 * t));\n    } else {\n        return createComplex(FastMath.abs(imaginary) / (2.0 * t), FastMath.copySign(1d, imaginary) * t);\n    }\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T multiply(int arg0)"
            ],
            [
                "sin",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n * sine</a>\n * of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p><p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or {@code NaN} values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n *   sin(&plusmn;INFINITY + i) = NaN + NaN i\n *   sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the sine of this complex number.\n * @since 1.2\n */\npublic Complex sin() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.sin(real) * FastMath.cosh(imaginary), FastMath.cos(real) * FastMath.sinh(imaginary));\n}"
            ],
            [
                "add",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T add(T arg0) throws NullArgumentException"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "negate",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T negate()"
            ],
            [
                "subtract",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T subtract(T arg0) throws NullArgumentException"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Test for equality with another object.\n * If both the real and imaginary parts of two complex numbers\n * are exactly the same, and neither is {@code Double.NaN}, the two\n * Complex objects are considered to be equal.\n * The behavior is the same as for JDK's {@link Double#equals(Object)\n * Double}:\n * <ul>\n *  <li>All {@code NaN} values are considered to be equal,\n *   i.e, if either (or both) real and imaginary parts of the complex\n *   number are equal to {@code Double.NaN}, the complex number is equal\n *   to {@code NaN}.\n *  </li>\n *  <li>\n *   Instances constructed with different representations of zero (i.e.\n *   either \"0\" or \"-0\") are <em>not</em> considered to be equal.\n *  </li>\n * </ul>\n *\n * @param other Object to test for equality with this instance.\n * @return {@code true} if the objects are equal, {@code false} if object\n * is {@code null}, not an instance of {@code Complex}, or not equal to\n * this instance.\n */\n@Override\npublic boolean equals(Object other) {\n    if (this == other) {\n        return true;\n    }\n    if (other instanceof Complex) {\n        Complex c = (Complex) other;\n        if (c.isNaN) {\n            return isNaN;\n        } else {\n            return MathUtils.equals(real, c.real) && MathUtils.equals(imaginary, c.imaginary);\n        }\n    }\n    return false;\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 15381,
        "oracle": ";",
        "oracleType": "NORMAL_POST",
        "projectName": "commons-math3-3.6.1",
        "packageName": "org.apache.commons.math3.complex",
        "className": "Complex",
        "javadocTag": "@return a Complex instance.",
        "methodJavadoc": "    /**\n     * Create a complex number given only the real part.\n     *\n     * @param realPart Real part.\n     * @return a Complex instance.\n     */",
        "methodSourceCode": "public static Complex valueOf(double realPart){\n    if (Double.isNaN(realPart)) {\n        return NaN;\n    }\n    return new Complex(realPart);\n}",
        "classJavadoc": "/**\n * Representation of a Complex number, i.e. a number which has both a\n * real and imaginary part.\n * <p>\n * Implementations of arithmetic operations handle {@code NaN} and\n * infinite values according to the rules for {@link java.lang.Double}, i.e.\n * {@link #equals} is an equivalence relation for all instances that have\n * a {@code NaN} in either real or imaginary part, e.g. the following are\n * considered equal:\n * <ul>\n *  <li>{@code 1 + NaNi}</li>\n *  <li>{@code NaN + i}</li>\n *  <li>{@code NaN + NaNi}</li>\n * </ul><p>\n * Note that this contradicts the IEEE-754 standard for floating\n * point numbers (according to which the test {@code x == x} must fail if\n * {@code x} is {@code NaN}). The method\n * {@link org.apache.commons.math3.util.Precision#equals(double,double,int)\n * equals for primitive double} in {@link org.apache.commons.math3.util.Precision}\n * conforms with IEEE-754 while this class conforms with the standard behavior\n * for Java object types.</p>\n *\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.complex;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.FieldElement;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.Precision;\n\n/**\n * Representation of a Complex number, i.e. a number which has both a\n * real and imaginary part.\n * <p>\n * Implementations of arithmetic operations handle {@code NaN} and\n * infinite values according to the rules for {@link java.lang.Double}, i.e.\n * {@link #equals} is an equivalence relation for all instances that have\n * a {@code NaN} in either real or imaginary part, e.g. the following are\n * considered equal:\n * <ul>\n *  <li>{@code 1 + NaNi}</li>\n *  <li>{@code NaN + i}</li>\n *  <li>{@code NaN + NaNi}</li>\n * </ul><p>\n * Note that this contradicts the IEEE-754 standard for floating\n * point numbers (according to which the test {@code x == x} must fail if\n * {@code x} is {@code NaN}). The method\n * {@link org.apache.commons.math3.util.Precision#equals(double,double,int)\n * equals for primitive double} in {@link org.apache.commons.math3.util.Precision}\n * conforms with IEEE-754 while this class conforms with the standard behavior\n * for Java object types.</p>\n *\n */\npublic class Complex implements FieldElement<Complex>, Serializable  {\n    /** The square root of -1. A number representing \"0.0 + 1.0i\" */\n    public static final Complex I = new Complex(0.0, 1.0);\n    // CHECKSTYLE: stop ConstantName\n    /** A complex number representing \"NaN + NaNi\" */\n    public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n    // CHECKSTYLE: resume ConstantName\n    /** A complex number representing \"+INF + INFi\" */\n    public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    /** A complex number representing \"1.0 + 0.0i\" */\n    public static final Complex ONE = new Complex(1.0, 0.0);\n    /** A complex number representing \"0.0 + 0.0i\" */\n    public static final Complex ZERO = new Complex(0.0, 0.0);\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6195664516687396620L;\n\n    /** The imaginary part. */\n    private final double imaginary;\n    /** The real part. */\n    private final double real;\n    /** Record whether this complex number is equal to NaN. */\n    private final transient boolean isNaN;\n    /** Record whether this complex number is infinite. */\n    private final transient boolean isInfinite;\n\n    /**\n     * Create a complex number given only the real part.\n     *\n     * @param real Real part.\n     */\n    public Complex(double real) {\n        this(real, 0.0);\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param real Real part.\n     * @param imaginary Imaginary part.\n     */\n    public Complex(double real, double imaginary) {\n        this.real = real;\n        this.imaginary = imaginary;\n\n        isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n        isInfinite = !isNaN &&\n            (Double.isInfinite(real) || Double.isInfinite(imaginary));\n    }\n\n    /**\n     * Return the absolute value of this complex number.\n     * Returns {@code NaN} if either real or imaginary part is {@code NaN}\n     * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},\n     * but at least one part is infinite.\n     *\n     * @return the absolute value.\n     */\n    public double abs() {\n        if (isNaN) {\n            return Double.NaN;\n        }\n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return FastMath.abs(real);\n            }\n            double q = real / imaginary;\n            return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n        } else {\n            if (real == 0.0) {\n                return FastMath.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n        }\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this + addend)}.\n     * Uses the definitional formula\n     * <p>\n     *   {@code (a + bi) + (c + di) = (a+c) + (b+d)i}\n     * </p>\n     * If either {@code this} or {@code addend} has a {@code NaN} value in\n     * either part, {@link #NaN} is returned; otherwise {@code Infinite}\n     * and {@code NaN} values are returned in the parts of the result\n     * according to the rules for {@link java.lang.Double} arithmetic.\n     *\n     * @param  addend Value to be added to this {@code Complex}.\n     * @return {@code this + addend}.\n     * @throws NullArgumentException if {@code addend} is {@code null}.\n     */\n    public Complex add(Complex addend) throws NullArgumentException {\n        MathUtils.checkNotNull(addend);\n        if (isNaN || addend.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real + addend.getReal(),\n                             imaginary + addend.getImaginary());\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code (this + addend)},\n     * with {@code addend} interpreted as a real number.\n     *\n     * @param addend Value to be added to this {@code Complex}.\n     * @return {@code this + addend}.\n     * @see #add(Complex)\n     */\n    public Complex add(double addend) {\n        if (isNaN || Double.isNaN(addend)) {\n            return NaN;\n        }\n\n        return createComplex(real + addend, imaginary);\n    }\n\n     /**\n     * Returns the conjugate of this complex number.\n     * The conjugate of {@code a + bi} is {@code a - bi}.\n     * <p>\n     * {@link #NaN} is returned if either the real or imaginary\n     * part of this Complex number equals {@code Double.NaN}.\n     * </p><p>\n     * If the imaginary part is infinite, and the real part is not\n     * {@code NaN}, the returned value has infinite imaginary part\n     * of the opposite sign, e.g. the conjugate of\n     * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.\n     * </p>\n     * @return the conjugate of this Complex object.\n     */\n    public Complex conjugate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real, -imaginary);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this / divisor)}.\n     * Implements the definitional formula\n     * <pre>\n     *  <code>\n     *    a + bi          ac + bd + (bc - ad)i\n     *    ----------- = -------------------------\n     *    c + di         c<sup>2</sup> + d<sup>2</sup>\n     *  </code>\n     * </pre>\n     * but uses\n     * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n     * prescaling of operands</a> to limit the effects of overflows and\n     * underflows in the computation.\n     * <p>\n     * {@code Infinite} and {@code NaN} values are handled according to the\n     * following rules, applied in the order presented:\n     * <ul>\n     *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n     *   in either part, {@link #NaN} is returned.\n     *  </li>\n     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n     *  </li>\n     *  <li>If {@code this} and {@code divisor} are both infinite,\n     *   {@link #NaN} is returned.\n     *  </li>\n     *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\n     *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\n     *   infinite), {@link #ZERO} is returned.\n     *  </li>\n     *  <li>If {@code this} is infinite and {@code divisor} is finite,\n     *   {@code NaN} values are returned in the parts of the result if the\n     *   {@link java.lang.Double} rules applied to the definitional formula\n     *   force {@code NaN} results.\n     *  </li>\n     * </ul>\n     *\n     * @param divisor Value by which this {@code Complex} is to be divided.\n     * @return {@code this / divisor}.\n     * @throws NullArgumentException if {@code divisor} is {@code null}.\n     */\n    public Complex divide(Complex divisor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(divisor);\n        if (isNaN || divisor.isNaN) {\n            return NaN;\n        }\n\n        final double c = divisor.getReal();\n        final double d = divisor.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n\n        if (divisor.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(c) < FastMath.abs(d)) {\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code (this / divisor)},\n     * with {@code divisor} interpreted as a real number.\n     *\n     * @param  divisor Value by which this {@code Complex} is to be divided.\n     * @return {@code this / divisor}.\n     * @see #divide(Complex)\n     */\n    public Complex divide(double divisor) {\n        if (isNaN || Double.isNaN(divisor)) {\n            return NaN;\n        }\n        if (divisor == 0d) {\n            return NaN;\n        }\n        if (Double.isInfinite(divisor)) {\n            return !isInfinite() ? ZERO : NaN;\n        }\n        return createComplex(real / divisor,\n                             imaginary  / divisor);\n    }\n\n    /** {@inheritDoc} */\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return INF;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }\n\n    /**\n     * Test for equality with another object.\n     * If both the real and imaginary parts of two complex numbers\n     * are exactly the same, and neither is {@code Double.NaN}, the two\n     * Complex objects are considered to be equal.\n     * The behavior is the same as for JDK's {@link Double#equals(Object)\n     * Double}:\n     * <ul>\n     *  <li>All {@code NaN} values are considered to be equal,\n     *   i.e, if either (or both) real and imaginary parts of the complex\n     *   number are equal to {@code Double.NaN}, the complex number is equal\n     *   to {@code NaN}.\n     *  </li>\n     *  <li>\n     *   Instances constructed with different representations of zero (i.e.\n     *   either \"0\" or \"-0\") are <em>not</em> considered to be equal.\n     *  </li>\n     * </ul>\n     *\n     * @param other Object to test for equality with this instance.\n     * @return {@code true} if the objects are equal, {@code false} if object\n     * is {@code null}, not an instance of {@code Complex}, or not equal to\n     * this instance.\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex c = (Complex) other;\n            if (c.isNaN) {\n                return isNaN;\n            } else {\n                return MathUtils.equals(real, c.real) &&\n                    MathUtils.equals(imaginary, c.imaginary);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Test for the floating-point equality between Complex objects.\n     * It returns {@code true} if both arguments are equal or within the\n     * range of allowed error (inclusive).\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between the real (resp. imaginary) parts of {@code x} and\n     * {@code y}.\n     * @return {@code true} if there are fewer than {@code maxUlps} floating\n     * point values between the real (resp. imaginary) parts of {@code x}\n     * and {@code y}.\n     *\n     * @see Precision#equals(double,double,int)\n     * @since 3.3\n     */\n    public static boolean equals(Complex x, Complex y, int maxUlps) {\n        return Precision.equals(x.real, y.real, maxUlps) &&\n            Precision.equals(x.imaginary, y.imaginary, maxUlps);\n    }\n\n    /**\n     * Returns {@code true} iff the values are equal as defined by\n     * {@link #equals(Complex,Complex,int) equals(x, y, 1)}.\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @return {@code true} if the values are equal.\n     *\n     * @since 3.3\n     */\n    public static boolean equals(Complex x, Complex y) {\n        return equals(x, y, 1);\n    }\n\n    /**\n     * Returns {@code true} if, both for the real part and for the imaginary\n     * part, there is no double value strictly between the arguments or the\n     * difference between them is within the range of allowed error\n     * (inclusive).  Returns {@code false} if either of the arguments is NaN.\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @param eps Amount of allowed absolute error.\n     * @return {@code true} if the values are two adjacent floating point\n     * numbers or they are within range of each other.\n     *\n     * @see Precision#equals(double,double,double)\n     * @since 3.3\n     */\n    public static boolean equals(Complex x, Complex y, double eps) {\n        return Precision.equals(x.real, y.real, eps) &&\n            Precision.equals(x.imaginary, y.imaginary, eps);\n    }\n\n    /**\n     * Returns {@code true} if, both for the real part and for the imaginary\n     * part, there is no double value strictly between the arguments or the\n     * relative difference between them is smaller or equal to the given\n     * tolerance. Returns {@code false} if either of the arguments is NaN.\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @param eps Amount of allowed relative error.\n     * @return {@code true} if the values are two adjacent floating point\n     * numbers or they are within range of each other.\n     *\n     * @see Precision#equalsWithRelativeTolerance(double,double,double)\n     * @since 3.3\n     */\n    public static boolean equalsWithRelativeTolerance(Complex x, Complex y,\n                                                      double eps) {\n        return Precision.equalsWithRelativeTolerance(x.real, y.real, eps) &&\n            Precision.equalsWithRelativeTolerance(x.imaginary, y.imaginary, eps);\n    }\n\n    /**\n     * Get a hashCode for the complex number.\n     * Any {@code Double.NaN} value in real or imaginary part produces\n     * the same hash code {@code 7}.\n     *\n     * @return a hash code value for this object.\n     */\n    @Override\n    public int hashCode() {\n        if (isNaN) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) +\n            MathUtils.hash(real));\n    }\n\n    /**\n     * Access the imaginary part.\n     *\n     * @return the imaginary part.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Access the real part.\n     *\n     * @return the real part.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Checks whether either or both parts of this complex number is\n     * {@code NaN}.\n     *\n     * @return true if either or both parts of this complex number is\n     * {@code NaN}; false otherwise.\n     */\n    public boolean isNaN() {\n        return isNaN;\n    }\n\n    /**\n     * Checks whether either the real or imaginary part of this complex number\n     * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or\n     * {@code Double.NEGATIVE_INFINITY}) and neither part\n     * is {@code NaN}.\n     *\n     * @return true if one or both parts of this complex number are infinite\n     * and neither part is {@code NaN}.\n     */\n    public boolean isInfinite() {\n        return isInfinite;\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <p>\n     *   {@code (a + bi)(c + di) = (ac - bd) + (ad + bc)i}\n     * </p>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <p>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * </p><p>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.</p>\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN || factor.isNaN) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n     * interpreted as a integer number.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @see #multiply(Complex)\n     */\n    public Complex multiply(final int factor) {\n        if (isNaN) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary)) {\n            return INF;\n        }\n        return createComplex(real * factor, imaginary * factor);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n     * interpreted as a real number.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @see #multiply(Complex)\n     */\n    public Complex multiply(double factor) {\n        if (isNaN || Double.isNaN(factor)) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor, imaginary * factor);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code (-this)}.\n     * Returns {@code NaN} if either real or imaginary\n     * part of this Complex number is {@code Double.NaN}.\n     *\n     * @return {@code -this}.\n     */\n    public Complex negate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(-real, -imaginary);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this - subtrahend)}.\n     * Uses the definitional formula\n     * <p>\n     *  {@code (a + bi) - (c + di) = (a-c) + (b-d)i}\n     * </p>\n     * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,\n     * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.\n     *\n     * @param  subtrahend value to be subtracted from this {@code Complex}.\n     * @return {@code this - subtrahend}.\n     * @throws NullArgumentException if {@code subtrahend} is {@code null}.\n     */\n    public Complex subtract(Complex subtrahend)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(subtrahend);\n        if (isNaN || subtrahend.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real - subtrahend.getReal(),\n                             imaginary - subtrahend.getImaginary());\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this - subtrahend)}.\n     *\n     * @param  subtrahend value to be subtracted from this {@code Complex}.\n     * @return {@code this - subtrahend}.\n     * @see #subtract(Complex)\n     */\n    public Complex subtract(double subtrahend) {\n        if (isNaN || Double.isNaN(subtrahend)) {\n            return NaN;\n        }\n        return createComplex(real - subtrahend, imaginary);\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n     * inverse cosine</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     *  {@code acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))}\n     * </p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite.\n     *\n     * @return the inverse cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex acos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n     * inverse sine</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     *  {@code asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))}\n     * </p><p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite.</p>\n     *\n     * @return the inverse sine of this complex number.\n     * @since 1.2\n     */\n    public Complex asin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n     * inverse tangent</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     * {@code atan(z) = (i/2) log((i + z)/(i - z))}\n     * </p><p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite.</p>\n     *\n     * @return the inverse tangent of this complex number\n     * @since 1.2\n     */\n    public Complex atan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(I).divide(I.subtract(this)).log()\n                .multiply(I.divide(createComplex(2.0, 0.0)));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n     * cosine</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     *  {@code cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i}\n     * </p><p>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * </p><p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p><p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.</p>\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   cos(1 &plusmn; INFINITY i) = 1 \\u2213 INFINITY i\n     *   cos(&plusmn;INFINITY + i) = NaN + NaN i\n     *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex cos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cos(real) * FastMath.cosh(imaginary),\n                             -FastMath.sin(real) * FastMath.sinh(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n     * hyperbolic cosine</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n     *   cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n     *   cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the hyperbolic cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex cosh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cosh(real) * FastMath.cos(imaginary),\n                             FastMath.sinh(real) * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n     * exponential function</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#exp}, {@link FastMath#cos}, and\n     * {@link FastMath#sin}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   exp(1 &plusmn; INFINITY i) = NaN + NaN i\n     *   exp(INFINITY + i) = INFINITY + INFINITY i\n     *   exp(-INFINITY + i) = 0 + 0i\n     *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return <code><i>e</i><sup>this</sup></code>.\n     * @since 1.2\n     */\n    public Complex exp() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double expReal = FastMath.exp(real);\n        return createComplex(expReal *  FastMath.cos(imaginary),\n                             expReal * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n     * natural logarithm</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i\n     *  </code>\n     * </pre>\n     * where ln on the right hand side is {@link FastMath#log},\n     * {@code |a + bi|} is the modulus, {@link Complex#abs},  and\n     * {@code arg(a + bi) = }{@link FastMath#atan2}(b, a).\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n     *   log(INFINITY + i) = INFINITY + 0i\n     *   log(-INFINITY + i) = INFINITY + &pi;i\n     *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n     *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n     *   log(0 + 0i) = -INFINITY + 0i\n     *  </code>\n     * </pre>\n     *\n     * @return the value <code>ln &nbsp; this</code>, the natural logarithm\n     * of {@code this}.\n     * @since 1.2\n     */\n    public Complex log() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.log(abs()),\n                             FastMath.atan2(imaginary, real));\n    }\n\n    /**\n     * Returns of value of this complex number raised to the power of {@code x}.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   y<sup>x</sup> = exp(x&middot;log(y))\n     *  </code>\n     * </pre>\n     * where {@code exp} and {@code log} are {@link #exp} and\n     * {@link #log}, respectively.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite, or if {@code y}\n     * equals {@link Complex#ZERO}.</p>\n     *\n     * @param  x exponent to which this {@code Complex} is to be raised.\n     * @return <code> this<sup>x</sup></code>.\n     * @throws NullArgumentException if x is {@code null}.\n     * @since 1.2\n     */\n    public Complex pow(Complex x)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(x);\n        return this.log().multiply(x).exp();\n    }\n\n    /**\n     * Returns of value of this complex number raised to the power of {@code x}.\n     *\n     * @param  x exponent to which this {@code Complex} is to be raised.\n     * @return <code>this<sup>x</sup></code>.\n     * @see #pow(Complex)\n     */\n     public Complex pow(double x) {\n        return this.log().multiply(x).exp();\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n     * sine</a>\n     * of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p><p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or {@code NaN} values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n     *   sin(&plusmn;INFINITY + i) = NaN + NaN i\n     *   sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the sine of this complex number.\n     * @since 1.2\n     */\n    public Complex sin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sin(real) * FastMath.cosh(imaginary),\n                             FastMath.cos(real) * FastMath.sinh(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n     * hyperbolic sine</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p><p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n     *   sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n     *   sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the hyperbolic sine of {@code this}.\n     * @since 1.2\n     */\n    public Complex sinh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary),\n            FastMath.cosh(real) * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of this complex number.\n     * Implements the following algorithm to compute {@code sqrt(a + bi)}:\n     * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>\n     * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}\n     *  else return {@code |b|/2t + sign(b)t i }</pre></li>\n     * </ol>\n     * where <ul>\n     * <li>{@code |a| = }{@link FastMath#abs}(a)</li>\n     * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>\n     * <li>{@code sign(b) =  }{@link FastMath#copySign(double,double) copySign(1d, b)}\n     * </ul>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n     *   sqrt(INFINITY + i) = INFINITY + 0i\n     *   sqrt(-INFINITY + i) = 0 + INFINITY i\n     *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n     *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n     *  </code>\n     * </pre>\n     *\n     * @return the square root of {@code this}.\n     * @since 1.2\n     */\n    public Complex sqrt() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n\n        double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n                                 FastMath.copySign(1d, imaginary) * t);\n        }\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of <code>1 - this<sup>2</sup></code> for this complex\n     * number.\n     * Computes the result directly as\n     * {@code sqrt(ONE.subtract(z.multiply(z)))}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     *\n     * @return the square root of <code>1 - this<sup>2</sup></code>.\n     * @since 1.2\n     */\n    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n     * tangent</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n     * {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\n     *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\n     *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the tangent of {@code this}.\n     * @since 1.2\n     */\n    public Complex tan() {\n        if (isNaN || Double.isInfinite(real)) {\n            return NaN;\n        }\n        if (imaginary > 20.0) {\n            return createComplex(0.0, 1.0);\n        }\n        if (imaginary < -20.0) {\n            return createComplex(0.0, -1.0);\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n\n        return createComplex(FastMath.sin(real2) / d,\n                             FastMath.sinh(imaginary2) / d);\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n     * hyperbolic tangent</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n     * {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\n     *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\n     *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i\n     *  </code>\n     * </pre>\n     *\n     * @return the hyperbolic tangent of {@code this}.\n     * @since 1.2\n     */\n    public Complex tanh() {\n        if (isNaN || Double.isInfinite(imaginary)) {\n            return NaN;\n        }\n        if (real > 20.0) {\n            return createComplex(1.0, 0.0);\n        }\n        if (real < -20.0) {\n            return createComplex(-1.0, 0.0);\n        }\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n\n        return createComplex(FastMath.sinh(real2) / d,\n                             FastMath.sin(imaginary2) / d);\n    }\n\n\n\n    /**\n     * Compute the argument of this complex number.\n     * The argument is the angle phi between the positive real axis and\n     * the point representing this number in the complex plane.\n     * The value returned is between -PI (not inclusive)\n     * and PI (inclusive), with negative values returned for numbers with\n     * negative imaginary parts.\n     * <p>\n     * If either real or imaginary part (or both) is NaN, NaN is returned.\n     * Infinite parts are handled as {@code Math.atan2} handles them,\n     * essentially treating finite parts as zero in the presence of an\n     * infinite coordinate and returning a multiple of pi/4 depending on\n     * the signs of the infinite parts.\n     * See the javadoc for {@code Math.atan2} for full details.\n     *\n     * @return the argument of {@code this}.\n     */\n    public double getArgument() {\n        return FastMath.atan2(getImaginary(), getReal());\n    }\n\n    /**\n     * Computes the n-th roots of this complex number.\n     * The nth roots are defined by the formula:\n     * <pre>\n     *  <code>\n     *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n     *  </code>\n     * </pre>\n     * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n     * are respectively the {@link #abs() modulus} and\n     * {@link #getArgument() argument} of this complex number.\n     * <p>\n     * If one or both parts of this complex number is NaN, a list with just\n     * one element, {@link #NaN} is returned.\n     * if neither part is NaN, but at least one part is infinite, the result\n     * is a one-element list containing {@link #INF}.\n     *\n     * @param n Degree of root.\n     * @return a List of all {@code n}-th roots of {@code this}.\n     * @throws NotPositiveException if {@code n <= 0}.\n     * @since 2.0\n     */\n    public List<Complex> nthRoot(int n) throws NotPositiveException {\n\n        if (n <= 0) {\n            throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                                           n);\n        }\n\n        final List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN) {\n            result.add(NaN);\n            return result;\n        }\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        // nth root of abs -- faster / more accurate to use a solver here?\n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\n        final double nthPhi = getArgument() / n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n            // inner part\n            final double realPart = nthRootOfAbs *  FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param realPart Real part.\n     * @param imaginaryPart Imaginary part.\n     * @return a new complex number instance.\n     * @since 1.2\n     * @see #valueOf(double, double)\n     */\n    protected Complex createComplex(double realPart,\n                                    double imaginaryPart) {\n        return new Complex(realPart, imaginaryPart);\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param realPart Real part.\n     * @param imaginaryPart Imaginary part.\n     * @return a Complex instance.\n     */\n    public static Complex valueOf(double realPart,\n                                  double imaginaryPart) {\n        if (Double.isNaN(realPart) ||\n            Double.isNaN(imaginaryPart)) {\n            return NaN;\n        }\n        return new Complex(realPart, imaginaryPart);\n    }\n\n    /**\n     * Create a complex number given only the real part.\n     *\n     * @param realPart Real part.\n     * @return a Complex instance.\n     */\n    public static Complex valueOf(double realPart) {\n        if (Double.isNaN(realPart)) {\n            return NaN;\n        }\n        return new Complex(realPart);\n    }\n\n    /**\n     * Resolve the transient fields in a deserialized Complex Object.\n     * Subclasses will need to override {@link #createComplex} to\n     * deserialize properly.\n     *\n     * @return A Complex instance with all fields resolved.\n     * @since 2.0\n     */\n    protected final Object readResolve() {\n        return createComplex(real, imaginary);\n    }\n\n    /** {@inheritDoc} */\n    public ComplexField getField() {\n        return ComplexField.getInstance();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String toString() {\n        return \"(\" + real + \", \" + imaginary + \")\";\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "RealFieldElement",
                "org.apache.commons.math3"
            ],
            [
                "Primes",
                "org.apache.commons.math3.primes"
            ],
            [
                "SmallPrimes",
                "org.apache.commons.math3.primes"
            ],
            [
                "PollardRho",
                "org.apache.commons.math3.primes"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "SimpleCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.fitting"
            ],
            [
                "ParameterValidator",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "EvaluationRmsChecker",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "OptimumImpl",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresAdapter",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "DenseWeightedEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "AbstractEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresFactory",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "ValueAndJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "MultivariateJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresBuilder",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresProblem",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "WeightedObservedPoints",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "AbstractCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "UnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "FunctionUtils",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "IterativeLegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "LegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "MidPointIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "RombergIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "SimpsonIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BaseRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "HermiteRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegratorFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreHighPrecisionRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "SymmetricGaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "BaseAbstractUnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "UnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "TrapezoidIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "AbstractDifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PegasusSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolverUtils",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "FieldBracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonRaphsonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseSecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "SecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "DifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver2",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractPolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseAbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "LaguerreSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "IllinoisSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RegulaFalsiSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AllowedSolution",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RiddersSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BisectionSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedRealFieldUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "Asin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Multiply",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Asinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Rint",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "StepFunction",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Add",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sqrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Inverse",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Gaussian",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Pow",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Exp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cbrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log1p",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Constant",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Identity",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Signum",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logit",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ceil",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Subtract",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Max",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Min",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Expm1",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Abs",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Divide",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ulp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log10",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Power",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Minus",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan2",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logistic",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Floor",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sigmoid",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinc",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "HarmonicOscillator",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "MultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TrivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "MultivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "ParametricUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableMatrixFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DSCompiler",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "SparseGradient",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateMatrixFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "JacobianFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "GradientFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DerivativeStructure",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateVectorFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "FiniteDifferencesDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "PolynomialFunctionNewtonForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunctionLagrangeForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialSplineFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialsUtils",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "RealFieldUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TricubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LoessInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "DividedDifferenceInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "HermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TrivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "NevilleInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereProjectionInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "AkimaSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MultivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "FieldHermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LinearInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariatePeriodicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SmoothingPolynomialBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere2D",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "Precision",
                "org.apache.commons.math3.util"
            ],
            [
                "MultidimensionalCounter",
                "org.apache.commons.math3.util"
            ],
            [
                "DoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "Incrementor",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToDoubleHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToFieldHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "MathArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "Pair",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathCalc",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMath",
                "org.apache.commons.math3.util"
            ],
            [
                "ResizableDoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "BigRealField",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64Field",
                "org.apache.commons.math3.util"
            ],
            [
                "Combinations",
                "org.apache.commons.math3.util"
            ],
            [
                "MathUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "NumberTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "ContinuedFraction",
                "org.apache.commons.math3.util"
            ],
            [
                "RandomPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationManager",
                "org.apache.commons.math3.util"
            ],
            [
                "CompositeFormat",
                "org.apache.commons.math3.util"
            ],
            [
                "KthSelector",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationEvent",
                "org.apache.commons.math3.util"
            ],
            [
                "TransformerMap",
                "org.apache.commons.math3.util"
            ],
            [
                "IntegerSequence",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathLiteralArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "CombinatoricsUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationListener",
                "org.apache.commons.math3.util"
            ],
            [
                "PivotingStrategyInterface",
                "org.apache.commons.math3.util"
            ],
            [
                "CentralPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64",
                "org.apache.commons.math3.util"
            ],
            [
                "DefaultTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "BigReal",
                "org.apache.commons.math3.util"
            ],
            [
                "ArithmeticUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "MedianOf3PivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "ComplexFormat",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexField",
                "org.apache.commons.math3.complex"
            ],
            [
                "RootsOfUnity",
                "org.apache.commons.math3.complex"
            ],
            [
                "Quaternion",
                "org.apache.commons.math3.complex"
            ],
            [
                "Complex",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexUtils",
                "org.apache.commons.math3.complex"
            ],
            [
                "DifferentiableMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractScalarDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "ConjugateGradientFormula",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "BaseMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "AbstractLinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseAbstractUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Target",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NonSymmetricMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "AnyMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularValueDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "EigenDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldLUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixUtils",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "TriDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixDimensionMismatchException",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "DecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "LUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "ConjugateGradient",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSelfAdjointOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BiDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "CholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldDecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "PreconditionedIterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "QRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "SymmLQ",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "IllConditionedOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultIterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DiagonalMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "HessenbergTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RectangularCholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "JacobiPreconditioner",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealLinearOperator",
                "org.apache.commons.math3.linear"
            ],
            [
                "RRQRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SchurTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "CauchyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LaplaceDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "HypergeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ChiSquaredDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TriangularDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalMixtureExpectationMaximization",
                "org.apache.commons.math3.distribution.fitting"
            ],
            [
                "BetaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "RealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "SaddlePointExpansion",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GumbelDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ZipfDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "BinomialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "IntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "WeibullDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NakagamiDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ConstantRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ExponentialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PascalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ParetoDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "FDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PoissonDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "KolmogorovSmirnovDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GammaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogisticDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LevyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxIter",
                "org.apache.commons.math3.optim"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraintSet",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "PivotSelectionRule",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SolutionCallback",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "NonNegativeConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "AbstractOptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optim"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseMultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "MultiStartUnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateObjectiveFunction",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SearchInterval",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxEval",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optim"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GradientMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "LineSearch",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunction",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunctionGradient",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ModelFunction",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "ModelFunctionJacobian",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "JacobianMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Target",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultiStartMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Erf",
                "org.apache.commons.math3.special"
            ],
            [
                "BesselJ",
                "org.apache.commons.math3.special"
            ],
            [
                "Gamma",
                "org.apache.commons.math3.special"
            ],
            [
                "Beta",
                "org.apache.commons.math3.special"
            ],
            [
                "FieldODEState",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldODEStateAndDerivative",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ODEIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterConfiguration",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputFieldModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderConverter",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ExpandableStatefulODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "Parameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "JacobianMatrices",
                "org.apache.commons.math3.ode"
            ],
            [
                "StepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "DummyStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractFieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldFixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerMode",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerBounds",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "NordsieckStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "RungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldButcherArrayProvider",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckFieldTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldSecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MainStateJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldEquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldExpandableODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterizedWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractParameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "UnknownParameterException",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "EquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "Transformer",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "Action",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventFilter",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FilterType",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "ParameterizedODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "NaNStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "NaturalRanking",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "TiesStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "RankingAlgorithm",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "StatUtils",
                "org.apache.commons.math3.stat"
            ],
            [
                "IntervalUtils",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "AgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "WilsonScoreInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "NormalApproximationInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "BinomialConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "StorelessCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "StorelessBivariateCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "KendallsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "Covariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "PearsonsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "SpearmansCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanIntegerPoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanDoublePoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "TestUtils",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "TTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "GTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AlternativeHypothesis",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "MannWhitneyUTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "WilcoxonSignedRankTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "OneWayAnova",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "ChiSquareTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "BinomialTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "KolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AbstractUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "DescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "MultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SecondMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Mean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FourthMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Variance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Kurtosis",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "GeometricMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StandardDeviation",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialCovariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "ThirdMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "SemiVariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FirstMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Skewness",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StatisticalSummaryValues",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalMultivariateSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "AggregateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "WeightedEvaluation",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "UnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "Percentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Max",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "PSquarePercentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Min",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Median",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "SynchronizedDescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedMultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SumOfSquares",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Product",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Sum",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "SumOfLogs",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "AbstractStorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SimpleRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "UpdatingMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "AbstractMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "GLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "ModelSpecificationException",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "RegressionResults",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MillerUpdatingRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "OLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "Frequency",
                "org.apache.commons.math3.stat"
            ],
            [
                "ChebyshevDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CanberraDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EuclideanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "ManhattanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EarthMoversDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "DistanceMeasure",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CentroidCluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "MultiKMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "FuzzyKMeansClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "SumOfClusterVariances",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "ClusterEvaluator",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "Clusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DoublePoint",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KohonenTrainingTask",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "KohonenUpdateAction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "QuasiSigmoidDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "ExponentialDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "NeighbourhoodSizeFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "NeighbourhoodSizeFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "MapUtils",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Network",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializerFactory",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Neuron",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializer",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "NeuronString",
                "org.apache.commons.math3.ml.neuralnet.oned"
            ],
            [
                "NeuronSquareMesh2D",
                "org.apache.commons.math3.ml.neuralnet.twod"
            ],
            [
                "SmoothedDataHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "UnifiedDistanceMatrix",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapDataVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "LocationFinder",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "HitHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "QuantizationError",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "TopographicErrorHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "SquareNeighbourhood",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "UpdateAction",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "BracketingNthOrderBrentSolverDFP",
                "org.apache.commons.math3.dfp"
            ],
            [
                "UnivariateDfpFunction",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpDec",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpMath",
                "org.apache.commons.math3.dfp"
            ],
            [
                "Dfp",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpField",
                "org.apache.commons.math3.dfp"
            ],
            [
                "GeneticAlgorithm",
                "org.apache.commons.math3.genetics"
            ],
            [
                "SelectionPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedGenerationCount",
                "org.apache.commons.math3.genetics"
            ],
            [
                "AbstractListChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OnePointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ElitisticListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Chromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OrderedCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "InvalidRepresentationException",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKey",
                "org.apache.commons.math3.genetics"
            ],
            [
                "StoppingCondition",
                "org.apache.commons.math3.genetics"
            ],
            [
                "PermutationChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ChromosomePair",
                "org.apache.commons.math3.genetics"
            ],
            [
                "TournamentSelection",
                "org.apache.commons.math3.genetics"
            ],
            [
                "NPointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "UniformCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "MutationPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedElapsedTime",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CycleCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Population",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKeyMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Fitness",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CrossoverPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Vector",
                "org.apache.commons.math3.geometry"
            ],
            [
                "VectorFormat",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Point",
                "org.apache.commons.math3.geometry"
            ],
            [
                "RotationConvention",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubPlane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3DFormat",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "OutlineExtractor",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "PolyhedronsSet",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "RotationOrder",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Rotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Euclidean3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphericalCoordinates",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "CardanEulerSingularityException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "NotARotationMatrixException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldRotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Plane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphereGenerator",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "IntervalsSet",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Interval",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "SubOrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "OrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Euclidean1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1DFormat",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "AbstractConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "AklToussaintHeuristic",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHull2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "MonotoneChain",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "Vector2DFormat",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "PolygonsSet",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "DiskGenerator",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Vector2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "NestedLoops",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Euclidean2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "ConvexHullGenerator",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ConvexHull",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ArcsSet",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "S1Point",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere1D",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Arc",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "LimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "SubLimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere2D",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SubCircle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Vertex",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Circle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "PropertiesComputer",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SphericalPolygonsSet",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Edge",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "EdgesBuilder",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "S2Point",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SupportBallGenerator",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "EnclosingBall",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "WelzlEncloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "Encloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "InsideFinder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjection",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjector",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Region",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Transform",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "NodesSet",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractRegion",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Characterization",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractSubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BSPTree",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "RegionFactory",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Side",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundarySizeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AVLTree",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "OrderedTuple",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "BSPTreeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Hyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Embedding",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryAttribute",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "SubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryBuilder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Space",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Field",
                "org.apache.commons.math3"
            ],
            [
                "ProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "MeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "KalmanFilter",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultMeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "NormalizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "GaussianRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "ISAACRandom",
                "org.apache.commons.math3.random"
            ],
            [
                "CorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937a",
                "org.apache.commons.math3.random"
            ],
            [
                "Well1024a",
                "org.apache.commons.math3.random"
            ],
            [
                "UniformRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497a",
                "org.apache.commons.math3.random"
            ],
            [
                "BitsStreamGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "SynchronizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "UncorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937c",
                "org.apache.commons.math3.random"
            ],
            [
                "ValueServer",
                "org.apache.commons.math3.random"
            ],
            [
                "HaltonSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497b",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomData",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well512a",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "JDKRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "StableRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomAdaptor",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGeneratorFactory",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractWell",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataImpl",
                "org.apache.commons.math3.random"
            ],
            [
                "EmpiricalDistribution",
                "org.apache.commons.math3.random"
            ],
            [
                "SobolSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "MersenneTwister",
                "org.apache.commons.math3.random"
            ],
            [
                "UnitSphereRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "FieldElement",
                "org.apache.commons.math3"
            ],
            [
                "BigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "Fraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "AbstractFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionConversionException",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperBigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "NotFiniteNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoBracketingException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathArithmeticException",
                "org.apache.commons.math3.exception"
            ],
            [
                "InsufficientDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyEvaluationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ExceptionContextProvider",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ExceptionContext",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ArgUtils",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "DummyLocalizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "Localizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "LocalizedFormats",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "NotANumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MultiDimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "OutOfRangeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyIterationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NullArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooLargeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalStateException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathUnsupportedOperationException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotStrictlyPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NonMonotonicSequenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ZeroException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "DimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathRuntimeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathParseException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MaxCountExceededException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooSmallException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ConvergenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathInternalError",
                "org.apache.commons.math3.exception"
            ],
            [
                "DftNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "RealTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastSineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "DctNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastFourierTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformType",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastCosineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformUtils",
                "org.apache.commons.math3.transform"
            ],
            [
                "DstNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastHadamardTransformer",
                "org.apache.commons.math3.transform"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "isPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Primality test: tells if the argument is a (provable) prime or not.\n * <p>\n * It uses the Miller-Rabin probabilistic test in such a way that a result is guaranteed:\n * it uses the firsts prime numbers as successive base (see Handbook of applied cryptography\n * by Menezes, table 4.1).\n *\n * @param n number to test.\n * @return true if n is prime. (All numbers &lt; 2 return false).\n */\npublic static boolean isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int p : SmallPrimes.PRIMES) {\n        if (0 == (n % p)) {\n            return n == p;\n        }\n    }\n    return SmallPrimes.millerRabinPrimeTest(n);\n}"
            ],
            [
                "nextPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Return the smallest prime greater than or equal to n.\n *\n * @param n a positive number.\n * @return the smallest prime greater than or equal to n.\n * @throws MathIllegalArgumentException if n &lt; 0.\n */\npublic static int nextPrime(int n) {\n    if (n < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL, n, 0);\n    }\n    if (n == 2) {\n        return 2;\n    }\n    //make sure n is odd\n    n |= 1;\n    if (n == 1) {\n        return 2;\n    }\n    if (isPrime(n)) {\n        return n;\n    }\n    // prepare entry in the +2, +4 loop:\n    // n should not be a multiple of 3\n    final int rem = n % 3;\n    if (0 == rem) {\n        // if n % 3 == 0\n        // n % 3 == 2\n        n += 2;\n    } else if (1 == rem) {\n        // if n % 3 == 1\n        // if (isPrime(n)) return n;\n        // n % 3 == 2\n        n += 4;\n    }\n    while (true) {\n        // this loop skips all multiple of 3\n        if (isPrime(n)) {\n            return n;\n        }\n        // n % 3 == 1\n        n += 2;\n        if (isPrime(n)) {\n            return n;\n        }\n        // n % 3 == 2\n        n += 4;\n    }\n}"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Prime factors decomposition\n *\n * @param n number to factorize: must be &ge; 2\n * @return list of prime factors of n\n * @throws MathIllegalArgumentException if n &lt; 2.\n */\npublic static List<Integer> primeFactors(int n) {\n    if (n < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL, n, 2);\n    }\n    // slower than trial div unless we do an awful lot of computation\n    // (then it finally gets JIT-compiled efficiently\n    // List<Integer> out = PollardRho.primeFactors(n);\n    return SmallPrimes.trialDivision(n);\n}"
            ],
            [
                "smallTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Extract small factors.\n * @param n the number to factor, must be &gt; 0.\n * @param factors the list where to add the factors.\n * @return the part of n which remains to be factored, it is either a prime or a semi-prime\n */\npublic static int smallTrialDivision(int n, final List<Integer> factors) {\n    for (int p : PRIMES) {\n        while (0 == n % p) {\n            n /= p;\n            factors.add(p);\n        }\n    }\n    return n;\n}"
            ],
            [
                "boundedTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Extract factors in the range <code>PRIME_LAST+2</code> to <code>maxFactors</code>.\n * @param n the number to factorize, must be >= PRIME_LAST+2 and must not contain any factor below PRIME_LAST+2\n * @param maxFactor the upper bound of trial division: if it is reached, the method gives up and returns n.\n * @param factors the list where to add the factors.\n * @return  n or 1 if factorization is completed.\n */\npublic static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors) {\n    int f = PRIMES_LAST + 2;\n    // no check is done about n >= f\n    while (f <= maxFactor) {\n        if (0 == n % f) {\n            n /= f;\n            factors.add(f);\n            break;\n        }\n        f += 4;\n        if (0 == n % f) {\n            n /= f;\n            factors.add(f);\n            break;\n        }\n        f += 2;\n    }\n    if (n != 1) {\n        factors.add(n);\n    }\n    return n;\n}"
            ],
            [
                "trialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Factorization by trial division.\n * @param n the number to factor\n * @return the list of prime factors of n\n */\npublic static List<Integer> trialDivision(int n) {\n    final List<Integer> factors = new ArrayList<Integer>(32);\n    n = smallTrialDivision(n, factors);\n    if (1 == n) {\n        return factors;\n    }\n    // here we are sure that n is either a prime or a semi prime\n    final int bound = (int) FastMath.sqrt(n);\n    boundedTrialDivision(n, bound, factors);\n    return factors;\n}"
            ],
            [
                "millerRabinPrimeTest",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Miller-Rabin probabilistic primality test for int type, used in such a way that a result is always guaranteed.\n * <p>\n * It uses the prime numbers as successive base therefore it is guaranteed to be always correct.\n * (see Handbook of applied cryptography by Menezes, table 4.1)\n *\n * @param n number to test: an odd integer &ge; 3\n * @return true if n is prime. false if n is definitely composite.\n */\npublic static boolean millerRabinPrimeTest(final int n) {\n    final int nMinus1 = n - 1;\n    final int s = Integer.numberOfTrailingZeros(nMinus1);\n    final int r = nMinus1 >> s;\n    //r must be odd, it is not checked here\n    int t = 1;\n    if (n >= 2047) {\n        t = 2;\n    }\n    if (n >= 1373653) {\n        t = 3;\n    }\n    if (n >= 25326001) {\n        t = 4;\n    }\n    // works up to 3.2 billion, int range stops at 2.7 so we are safe :-)\n    BigInteger br = BigInteger.valueOf(r);\n    BigInteger bn = BigInteger.valueOf(n);\n    for (int i = 0; i < t; i++) {\n        BigInteger a = BigInteger.valueOf(SmallPrimes.PRIMES[i]);\n        BigInteger bPow = a.modPow(br, bn);\n        int y = bPow.intValue();\n        if ((1 != y) && (y != nMinus1)) {\n            int j = 1;\n            while ((j <= s - 1) && (nMinus1 != y)) {\n                long square = ((long) y) * y;\n                y = (int) (square % n);\n                if (1 == y) {\n                    return false;\n                }\n                // definitely composite\n                j++;\n            }\n            if (nMinus1 != y) {\n                return false;\n            }\n            // definitely composite\n        }\n    }\n    // definitely prime\n    return true;\n}"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Factorization using Pollard's rho algorithm.\n * @param n number to factors, must be &gt; 0\n * @return the list of prime factors of n.\n */\npublic static List<Integer> primeFactors(int n) {\n    final List<Integer> factors = new ArrayList<Integer>();\n    n = SmallPrimes.smallTrialDivision(n, factors);\n    if (1 == n) {\n        return factors;\n    }\n    if (SmallPrimes.millerRabinPrimeTest(n)) {\n        factors.add(n);\n        return factors;\n    }\n    int divisor = rhoBrent(n);\n    factors.add(divisor);\n    factors.add(n / divisor);\n    return factors;\n}"
            ],
            [
                "rhoBrent",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Implementation of the Pollard's rho factorization algorithm.\n * <p>\n * This implementation follows the paper \"An improved Monte Carlo factorization algorithm\"\n * by Richard P. Brent. This avoids the triple computation of f(x) typically found in Pollard's\n * rho implementations. It also batches several gcd computation into 1.\n * <p>\n * The backtracking is not implemented as we deal only with semi-primes.\n *\n * @param n number to factor, must be semi-prime.\n * @return a prime factor of n.\n */\nstatic int rhoBrent(final int n) {\n    final int x0 = 2;\n    final int m = 25;\n    int cst = SmallPrimes.PRIMES_LAST;\n    int y = x0;\n    int r = 1;\n    do {\n        int x = y;\n        for (int i = 0; i < r; i++) {\n            final long y2 = ((long) y) * y;\n            y = (int) ((y2 + cst) % n);\n        }\n        int k = 0;\n        do {\n            final int bound = FastMath.min(m, r - k);\n            int q = 1;\n            for (int i = -3; i < bound; i++) {\n                //start at -3 to ensure we enter this loop at least 3 times\n                final long y2 = ((long) y) * y;\n                y = (int) ((y2 + cst) % n);\n                final long divisor = FastMath.abs(x - y);\n                if (0 == divisor) {\n                    cst += SmallPrimes.PRIMES_LAST;\n                    k = -m;\n                    y = x0;\n                    r = 1;\n                    break;\n                }\n                final long prod = divisor * q;\n                q = (int) (prod % n);\n                if (0 == q) {\n                    return gcdPositive(FastMath.abs((int) divisor), n);\n                }\n            }\n            final int out = gcdPositive(FastMath.abs(q), n);\n            if (1 != out) {\n                return out;\n            }\n            k += m;\n        } while (k < r);\n        r = 2 * r;\n    } while (true);\n}"
            ],
            [
                "gcdPositive",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Gcd between two positive numbers.\n * <p>\n * Gets the greatest common divisor of two numbers, using the \"binary gcd\" method,\n * which avoids division and modulo operations. See Knuth 4.5.2 algorithm B.\n * This algorithm is due to Josef Stein (1961).\n * </p>\n * Special cases:\n * <ul>\n * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and {@code gcd(x, 0)} is the value of {@code x}.</li>\n * <li>The invocation {@code gcd(0, 0)} is the only one which returns {@code 0}.</li>\n * </ul>\n *\n * @param a first number, must be &ge; 0\n * @param b second number, must be &ge; 0\n * @return gcd(a,b)\n */\nstatic int gcdPositive(int a, int b) {\n    // both a and b must be positive, it is not checked here\n    // gdc(a,0) = a\n    if (a == 0) {\n        return b;\n    } else if (b == 0) {\n        return a;\n    }\n    // make a and b odd, keep in mind the common power of twos\n    final int aTwos = Integer.numberOfTrailingZeros(a);\n    a >>= aTwos;\n    final int bTwos = Integer.numberOfTrailingZeros(b);\n    b >>= bTwos;\n    final int shift = FastMath.min(aTwos, bTwos);\n    // a and b >0\n    // if a > b then gdc(a,b) = gcd(a-b,b)\n    // if a < b then gcd(a,b) = gcd(b-a,a)\n    // so next a is the absolute difference and next b is the minimum of current values\n    while (a != b) {\n        final int delta = a - b;\n        b = FastMath.min(a, b);\n        a = FastMath.abs(delta);\n        // for speed optimization:\n        // remove any power of two in a as b is guaranteed to be odd throughout all iterations\n        a >>= Integer.numberOfTrailingZeros(a);\n    }\n    // gcd(a,a) = a, just \"add\" the common power of twos\n    return a << shift;\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "GaussianCurveFitter",
                "/**\n * Creates a default curve fitter.\n * The initial guess for the parameters will be {@link ParameterGuesser}\n * computed automatically, and the maximum number of iterations of the\n * optimization algorithm is set to {@link Integer#MAX_VALUE}.\n *\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static GaussianCurveFitter create() {\n    return new GaussianCurveFitter(null, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "SimpleCurveFitter",
                "/**\n * Creates a curve fitter.\n * The maximum number of iterations of the optimization algorithm is set\n * to {@link Integer#MAX_VALUE}.\n *\n * @param f Function to fit.\n * @param start Initial guess for the parameters.  Cannot be {@code null}.\n * Its length must be consistent with the number of parameters of the\n * function to fit.\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static SimpleCurveFitter create(ParametricUnivariateFunction f, double[] start) {\n    return new SimpleCurveFitter(f, start, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements. There will be no weights applied (unit weights).\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @param lazyEvaluation Whether the call to {@link Evaluation#evaluate(RealVector)}\n * will defer the evaluation until access to the value is requested.\n * @param paramValidator Model parameters validator.\n * @return the specified General Least Squares problem.\n *\n * @since 3.4\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations, final boolean lazyEvaluation, final ParameterValidator paramValidator) {\n    final LeastSquaresProblem p = new LocalLeastSquaresProblem(model, observed, start, checker, maxEvaluations, maxIterations, lazyEvaluation, paramValidator);\n    if (weight != null) {\n        return weightMatrix(p, weight);\n    } else {\n        return p;\n    }\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements. There will be no weights applied (unit weights).\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return create(model, observed, start, null, checker, maxEvaluations, maxIterations, false, null);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements.\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return weightMatrix(create(model, observed, start, checker, maxEvaluations, maxIterations), weight);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements.\n * <p>\n * This factory method is provided for continuity with previous interfaces. Newer\n * applications should use {@link #create(MultivariateJacobianFunction, RealVector,\n * RealVector, ConvergenceChecker, int, int)}, or {@link #create(MultivariateJacobianFunction,\n * RealVector, RealVector, RealMatrix, ConvergenceChecker, int, int)}.\n *\n * @param model          the model function. Produces the computed values.\n * @param jacobian       the jacobian of the model with respect to the parameters\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateVectorFunction model, final MultivariateMatrixFunction jacobian, final double[] observed, final double[] start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return create(model(model, jacobian), new ArrayRealVector(observed, false), new ArrayRealVector(start, false), weight, checker, maxEvaluations, maxIterations);\n}"
            ],
            [
                "weightMatrix",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Apply a dense weight matrix to the {@link LeastSquaresProblem}.\n *\n * @param problem the unweighted problem\n * @param weights the matrix of weights\n * @return a new {@link LeastSquaresProblem} with the weights applied. The original\n *         {@code problem} is not modified.\n */\npublic static LeastSquaresProblem weightMatrix(final LeastSquaresProblem problem, final RealMatrix weights) {\n    final RealMatrix weightSquareRoot = squareRoot(weights);\n    return new LeastSquaresAdapter(problem) {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Evaluation evaluate(final RealVector point) {\n            return new DenseWeightedEvaluation(super.evaluate(point), weightSquareRoot);\n        }\n    };\n}"
            ],
            [
                "weightDiagonal",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Apply a diagonal weight matrix to the {@link LeastSquaresProblem}.\n *\n * @param problem the unweighted problem\n * @param weights the diagonal of the weight matrix\n * @return a new {@link LeastSquaresProblem} with the weights applied. The original\n *         {@code problem} is not modified.\n */\npublic static LeastSquaresProblem weightDiagonal(final LeastSquaresProblem problem, final RealVector weights) {\n    // TODO more efficient implementation\n    return weightMatrix(problem, new DiagonalMatrix(weights.toArray()));\n}"
            ],
            [
                "countEvaluations",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Count the evaluations of a particular problem. The {@code counter} will be\n * incremented every time {@link LeastSquaresProblem#evaluate(RealVector)} is called on\n * the <em>returned</em> problem.\n *\n * @param problem the problem to track.\n * @param counter the counter to increment.\n * @return a least squares problem that tracks evaluations\n */\npublic static LeastSquaresProblem countEvaluations(final LeastSquaresProblem problem, final Incrementor counter) {\n    return new LeastSquaresAdapter(problem) {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Evaluation evaluate(final RealVector point) {\n            counter.incrementCount();\n            return super.evaluate(point);\n        }\n    };\n}"
            ],
            [
                "evaluationChecker",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * View a convergence checker specified for a {@link PointVectorValuePair} as one\n * specified for an {@link Evaluation}.\n *\n * @param checker the convergence checker to adapt.\n * @return a convergence checker that delegates to {@code checker}.\n */\npublic static ConvergenceChecker<Evaluation> evaluationChecker(final ConvergenceChecker<PointVectorValuePair> checker) {\n    return new ConvergenceChecker<Evaluation>() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean converged(final int iteration, final Evaluation previous, final Evaluation current) {\n            return checker.converged(iteration, new PointVectorValuePair(previous.getPoint().toArray(), previous.getResiduals().toArray(), false), new PointVectorValuePair(current.getPoint().toArray(), current.getResiduals().toArray(), false));\n        }\n    };\n}"
            ],
            [
                "model",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Combine a {@link MultivariateVectorFunction} with a {@link\n * MultivariateMatrixFunction} to produce a {@link MultivariateJacobianFunction}.\n *\n * @param value    the vector value function\n * @param jacobian the Jacobian function\n * @return a function that computes both at the same time\n */\npublic static MultivariateJacobianFunction model(final MultivariateVectorFunction value, final MultivariateMatrixFunction jacobian) {\n    return new LocalValueAndJacobianFunction(value, jacobian);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "HarmonicCurveFitter",
                "/**\n * Creates a default curve fitter.\n * The initial guess for the parameters will be {@link ParameterGuesser}\n * computed automatically, and the maximum number of iterations of the\n * optimization algorithm is set to {@link Integer#MAX_VALUE}.\n *\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static HarmonicCurveFitter create() {\n    return new HarmonicCurveFitter(null, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "PolynomialCurveFitter",
                "/**\n * Creates a default curve fitter.\n * Zero will be used as initial guess for the coefficients, and the maximum\n * number of iterations of the optimization algorithm is set to\n * {@link Integer#MAX_VALUE}.\n *\n * @param degree Degree of the polynomial to be fitted.\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static PolynomialCurveFitter create(int degree) {\n    return new PolynomialCurveFitter(new double[degree + 1], Integer.MAX_VALUE);\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n */\npublic static UnivariateFunction compose(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = x;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction compose(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = t;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public DerivativeStructure value(final DerivativeStructure t) {\n            DerivativeStructure r = t;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n * @deprecated as of 3.1 replaced by {@link #compose(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = x;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double p = 1;\n                    double r = x;\n                    for (int i = f.length - 1; i >= 0; i--) {\n                        p *= f[i].derivative().value(r);\n                        r = f[i].value(r);\n                    }\n                    return p;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n */\npublic static UnivariateFunction add(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(x);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction add(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(t);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         * @throws DimensionMismatchException if functions are not consistent with each other\n         */\n        public DerivativeStructure value(final DerivativeStructure t) throws DimensionMismatchException {\n            DerivativeStructure r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r = r.add(f[i].value(t));\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n * @deprecated as of 3.1 replaced by {@link #add(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(x);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double r = f[0].derivative().value(x);\n                    for (int i = 1; i < f.length; i++) {\n                        r += f[i].derivative().value(x);\n                    }\n                    return r;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n */\npublic static UnivariateFunction multiply(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(x);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction multiply(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(t);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public DerivativeStructure value(final DerivativeStructure t) {\n            DerivativeStructure r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r = r.multiply(f[i].value(t));\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n * @deprecated as of 3.1 replaced by {@link #multiply(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(x);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double sum = 0;\n                    for (int i = 0; i < f.length; i++) {\n                        double prod = f[i].derivative().value(x);\n                        for (int j = 0; j < f.length; j++) {\n                            if (i != j) {\n                                prod *= f[j].value(x);\n                            }\n                        }\n                        sum += prod;\n                    }\n                    return sum;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "combine",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns the univariate function\n * {@code h(x) = combiner(f(x), g(x)).}\n *\n * @param combiner Combiner function.\n * @param f Function.\n * @param g Function.\n * @return the composite function.\n */\npublic static UnivariateFunction combine(final BivariateFunction combiner, final UnivariateFunction f, final UnivariateFunction g) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return combiner.value(f.value(x), g.value(x));\n        }\n    };\n}"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns a MultivariateFunction h(x[]) defined by <pre> <code>\n * h(x[]) = combiner(...combiner(combiner(initialValue,f(x[0])),f(x[1]))...),f(x[x.length-1]))\n * </code></pre>\n *\n * @param combiner Combiner function.\n * @param f Function.\n * @param initialValue Initial value.\n * @return a collector function.\n */\npublic static MultivariateFunction collector(final BivariateFunction combiner, final UnivariateFunction f, final double initialValue) {\n    return new MultivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double[] point) {\n            double result = combiner.value(initialValue, f.value(point[0]));\n            for (int i = 1; i < point.length; i++) {\n                result = combiner.value(result, f.value(point[i]));\n            }\n            return result;\n        }\n    };\n}"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns a MultivariateFunction h(x[]) defined by <pre> <code>\n * h(x[]) = combiner(...combiner(combiner(initialValue,x[0]),x[1])...),x[x.length-1])\n * </code></pre>\n *\n * @param combiner Combiner function.\n * @param initialValue Initial value.\n * @return a collector function.\n */\npublic static MultivariateFunction collector(final BivariateFunction combiner, final double initialValue) {\n    return collector(combiner, new Identity(), initialValue);\n}"
            ],
            [
                "fix1stArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Creates a unary function by fixing the first argument of a binary function.\n *\n * @param f Binary function.\n * @param fixed value to which the first argument of {@code f} is set.\n * @return the unary function h(x) = f(fixed, x)\n */\npublic static UnivariateFunction fix1stArgument(final BivariateFunction f, final double fixed) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return f.value(fixed, x);\n        }\n    };\n}"
            ],
            [
                "fix2ndArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Creates a unary function by fixing the second argument of a binary function.\n *\n * @param f Binary function.\n * @param fixed value to which the second argument of {@code f} is set.\n * @return the unary function h(x) = f(x, fixed)\n */\npublic static UnivariateFunction fix2ndArgument(final BivariateFunction f, final double fixed) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return f.value(x, fixed);\n        }\n    };\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Samples the specified univariate real function on the specified interval.\n * <p>\n * The interval is divided equally into {@code n} sections and sample points\n * are taken from {@code min} to {@code max - (max - min) / n}; therefore\n * {@code f} is not sampled at the upper bound {@code max}.</p>\n *\n * @param f Function to be sampled\n * @param min Lower bound of the interval (included).\n * @param max Upper bound of the interval (excluded).\n * @param n Number of sample points.\n * @return the array of samples.\n * @throws NumberIsTooLargeException if the lower bound {@code min} is\n * greater than, or equal to the upper bound {@code max}.\n * @throws NotStrictlyPositiveException if the number of sample points\n * {@code n} is negative.\n */\npublic static double[] sample(UnivariateFunction f, double min, double max, int n) throws NumberIsTooLargeException, NotStrictlyPositiveException {\n    if (n <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES, Integer.valueOf(n));\n    }\n    if (min >= max) {\n        throw new NumberIsTooLargeException(min, max, false);\n    }\n    final double[] s = new double[n];\n    final double h = (max - min) / n;\n    for (int i = 0; i < n; i++) {\n        s[i] = f.value(min + i * h);\n    }\n    return s;\n}"
            ],
            [
                "toDifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link UnivariateDifferentiableFunction} into a {@link DifferentiableUnivariateFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableUnivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction toDifferentiableUnivariateFunction(final UnivariateDifferentiableFunction f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(final double x) {\n                    return f.value(new DerivativeStructure(1, 1, 0, x)).getPartialDerivative(1);\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toUnivariateDifferential",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableUnivariateFunction} into a {@link UnivariateDifferentiableFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} up to order one.\n * If the function is called with higher order, a {@link NumberIsTooLargeException} is thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableUnivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static UnivariateDifferentiableFunction toUnivariateDifferential(final DifferentiableUnivariateFunction f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is greater than 1\n         */\n        public DerivativeStructure value(final DerivativeStructure t) throws NumberIsTooLargeException {\n            switch(t.getOrder()) {\n                case 0:\n                    return new DerivativeStructure(t.getFreeParameters(), 0, f.value(t.getValue()));\n                case 1:\n                    {\n                        final int parameters = t.getFreeParameters();\n                        final double[] derivatives = new double[parameters + 1];\n                        derivatives[0] = f.value(t.getValue());\n                        final double fPrime = f.derivative().value(t.getValue());\n                        int[] orders = new int[parameters];\n                        for (int i = 0; i < parameters; ++i) {\n                            orders[i] = 1;\n                            derivatives[i + 1] = fPrime * t.getPartialDerivative(orders);\n                            orders[i] = 0;\n                        }\n                        return new DerivativeStructure(parameters, 1, derivatives);\n                    }\n                default:\n                    throw new NumberIsTooLargeException(t.getOrder(), 1, true);\n            }\n        }\n    };\n}"
            ],
            [
                "toDifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link MultivariateDifferentiableFunction} into a {@link DifferentiableMultivariateFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f) {\n    return new DifferentiableMultivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateFunction partialDerivative(final int k) {\n            return new MultivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        if (i == k) {\n                            dsX[i] = new DerivativeStructure(1, 1, 0, x[i]);\n                        } else {\n                            dsX[i] = new DerivativeStructure(1, 1, x[i]);\n                        }\n                    }\n                    final DerivativeStructure y = f.value(dsX);\n                    // extract partial derivative\n                    return y.getPartialDerivative(1);\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateVectorFunction gradient() {\n            return new MultivariateVectorFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double[] value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        dsX[i] = new DerivativeStructure(n, 1, i, x[i]);\n                    }\n                    final DerivativeStructure y = f.value(dsX);\n                    // extract gradient\n                    final double[] gradient = new double[n];\n                    final int[] orders = new int[n];\n                    for (int i = 0; i < n; ++i) {\n                        orders[i] = 1;\n                        gradient[i] = y.getPartialDerivative(orders);\n                        orders[i] = 0;\n                    }\n                    return gradient;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toMultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableMultivariateFunction} into a {@link MultivariateDifferentiableFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} elements\n * that all have the same number of free parameters and order, and with order at most 1.\n * If the function is called with inconsistent numbers of free parameters or higher order, a\n * {@link DimensionMismatchException} or a {@link NumberIsTooLargeException} will be thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f) {\n    return new MultivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is higher than 1\n         * @exception DimensionMismatchException if numbers of free parameters are inconsistent\n         */\n        public DerivativeStructure value(final DerivativeStructure[] t) throws DimensionMismatchException, NumberIsTooLargeException {\n            // check parameters and orders limits\n            final int parameters = t[0].getFreeParameters();\n            final int order = t[0].getOrder();\n            final int n = t.length;\n            if (order > 1) {\n                throw new NumberIsTooLargeException(order, 1, true);\n            }\n            // check all elements in the array are consistent\n            for (int i = 0; i < n; ++i) {\n                if (t[i].getFreeParameters() != parameters) {\n                    throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n                }\n                if (t[i].getOrder() != order) {\n                    throw new DimensionMismatchException(t[i].getOrder(), order);\n                }\n            }\n            // delegate computation to underlying function\n            final double[] point = new double[n];\n            for (int i = 0; i < n; ++i) {\n                point[i] = t[i].getValue();\n            }\n            final double value = f.value(point);\n            final double[] gradient = f.gradient().value(point);\n            // merge value and gradient into one DerivativeStructure\n            final double[] derivatives = new double[parameters + 1];\n            derivatives[0] = value;\n            final int[] orders = new int[parameters];\n            for (int i = 0; i < parameters; ++i) {\n                orders[i] = 1;\n                for (int j = 0; j < n; ++j) {\n                    derivatives[i + 1] += gradient[j] * t[j].getPartialDerivative(orders);\n                }\n                orders[i] = 0;\n            }\n            return new DerivativeStructure(parameters, order, derivatives);\n        }\n    };\n}"
            ],
            [
                "toDifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link MultivariateDifferentiableVectorFunction} into a {@link DifferentiableMultivariateVectorFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateVectorFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f) {\n    return new DifferentiableMultivariateVectorFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double[] value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateMatrixFunction jacobian() {\n            return new MultivariateMatrixFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double[][] value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        dsX[i] = new DerivativeStructure(n, 1, i, x[i]);\n                    }\n                    final DerivativeStructure[] y = f.value(dsX);\n                    // extract Jacobian\n                    final double[][] jacobian = new double[y.length][n];\n                    final int[] orders = new int[n];\n                    for (int i = 0; i < y.length; ++i) {\n                        for (int j = 0; j < n; ++j) {\n                            orders[j] = 1;\n                            jacobian[i][j] = y[i].getPartialDerivative(orders);\n                            orders[j] = 0;\n                        }\n                    }\n                    return jacobian;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toMultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableMultivariateVectorFunction} into a {@link MultivariateDifferentiableVectorFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} elements\n * that all have the same number of free parameters and order, and with order at most 1.\n * If the function is called with inconsistent numbers of free parameters or higher order, a\n * {@link DimensionMismatchException} or a {@link NumberIsTooLargeException} will be thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f) {\n    return new MultivariateDifferentiableVectorFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double[] value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is higher than 1\n         * @exception DimensionMismatchException if numbers of free parameters are inconsistent\n         */\n        public DerivativeStructure[] value(final DerivativeStructure[] t) throws DimensionMismatchException, NumberIsTooLargeException {\n            // check parameters and orders limits\n            final int parameters = t[0].getFreeParameters();\n            final int order = t[0].getOrder();\n            final int n = t.length;\n            if (order > 1) {\n                throw new NumberIsTooLargeException(order, 1, true);\n            }\n            // check all elements in the array are consistent\n            for (int i = 0; i < n; ++i) {\n                if (t[i].getFreeParameters() != parameters) {\n                    throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n                }\n                if (t[i].getOrder() != order) {\n                    throw new DimensionMismatchException(t[i].getOrder(), order);\n                }\n            }\n            // delegate computation to underlying function\n            final double[] point = new double[n];\n            for (int i = 0; i < n; ++i) {\n                point[i] = t[i].getValue();\n            }\n            final double[] value = f.value(point);\n            final double[][] jacobian = f.jacobian().value(point);\n            // merge value and Jacobian into a DerivativeStructure array\n            final DerivativeStructure[] merged = new DerivativeStructure[value.length];\n            for (int k = 0; k < merged.length; ++k) {\n                final double[] derivatives = new double[parameters + 1];\n                derivatives[0] = value[k];\n                final int[] orders = new int[parameters];\n                for (int i = 0; i < parameters; ++i) {\n                    orders[i] = 1;\n                    for (int j = 0; j < n; ++j) {\n                        derivatives[i + 1] += jacobian[k][j] * t[j].getPartialDerivative(orders);\n                    }\n                    orders[i] = 0;\n                }\n                merged[k] = new DerivativeStructure(parameters, order, derivatives);\n            }\n            return merged;\n        }\n    };\n}"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Convenience method to find a zero of a univariate real function.  A default\n * solver is used.\n *\n * @param function Function.\n * @param x0 Lower bound for the interval.\n * @param x1 Upper bound for the interval.\n * @return a value where the function is zero.\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double solve(UnivariateFunction function, double x0, double x1) throws NullArgumentException, NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final UnivariateSolver solver = new BrentSolver();\n    return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n}"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Convenience method to find a zero of a univariate real function.  A default\n * solver is used.\n *\n * @param function Function.\n * @param x0 Lower bound for the interval.\n * @param x1 Upper bound for the interval.\n * @param absoluteAccuracy Accuracy to be used by the solver.\n * @return a value where the function is zero.\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double solve(UnivariateFunction function, double x0, double x1, double absoluteAccuracy) throws NullArgumentException, NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final UnivariateSolver solver = new BrentSolver(absoluteAccuracy);\n    return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n}"
            ],
            [
                "forceSide",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Force a root found by a non-bracketing solver to lie on a specified side,\n * as if the solver were a bracketing one.\n *\n * @param maxEval maximal number of new evaluations of the function\n * (evaluations already done for finding the root should have already been subtracted\n * from this number)\n * @param f function to solve\n * @param bracketing bracketing solver to use for shifting the root\n * @param baseRoot original root found by a previous non-bracketing solver\n * @param min minimal bound of the search interval\n * @param max maximal bound of the search interval\n * @param allowedSolution the kind of solutions that the root-finding algorithm may\n * accept as solutions.\n * @return a root approximation, on the specified side of the exact root\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n */\npublic static double forceSide(final int maxEval, final UnivariateFunction f, final BracketedUnivariateSolver<UnivariateFunction> bracketing, final double baseRoot, final double min, final double max, final AllowedSolution allowedSolution) throws NoBracketingException {\n    if (allowedSolution == AllowedSolution.ANY_SIDE) {\n        // no further bracketing required\n        return baseRoot;\n    }\n    // find a very small interval bracketing the root\n    final double step = FastMath.max(bracketing.getAbsoluteAccuracy(), FastMath.abs(baseRoot * bracketing.getRelativeAccuracy()));\n    double xLo = FastMath.max(min, baseRoot - step);\n    double fLo = f.value(xLo);\n    double xHi = FastMath.min(max, baseRoot + step);\n    double fHi = f.value(xHi);\n    int remainingEval = maxEval - 2;\n    while (remainingEval > 0) {\n        if ((fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0)) {\n            // compute the root on the selected side\n            return bracketing.solve(remainingEval, f, xLo, xHi, baseRoot, allowedSolution);\n        }\n        // try increasing the interval\n        boolean changeLo = false;\n        boolean changeHi = false;\n        if (fLo < fHi) {\n            // increasing function\n            if (fLo >= 0) {\n                changeLo = true;\n            } else {\n                changeHi = true;\n            }\n        } else if (fLo > fHi) {\n            // decreasing function\n            if (fLo <= 0) {\n                changeLo = true;\n            } else {\n                changeHi = true;\n            }\n        } else {\n            // unknown variation\n            changeLo = true;\n            changeHi = true;\n        }\n        // update the lower bound\n        if (changeLo) {\n            xLo = FastMath.max(min, xLo - step);\n            fLo = f.value(xLo);\n            remainingEval--;\n        }\n        // update the higher bound\n        if (changeHi) {\n            xHi = FastMath.min(max, xHi + step);\n            fHi = f.value(xHi);\n            remainingEval--;\n        }\n    }\n    throw new NoBracketingException(LocalizedFormats.FAILED_BRACKETING, xLo, xHi, fLo, fHi, maxEval - remainingEval, maxEval, baseRoot, min, max);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method simply calls {@link #bracket(UnivariateFunction, double, double, double,\n * double, double, int) bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)}\n * with {@code q} and {@code r} set to 1.0 and {@code maximumIterations} set to {@code Integer.MAX_VALUE}.\n * <p>\n * <strong>Note: </strong> this method can take {@code Integer.MAX_VALUE}\n * iterations to throw a {@code ConvergenceException.}  Unless you are\n * confident that there is a root between {@code lowerBound} and\n * {@code upperBound} near {@code initial}, it is better to use\n * {@link #bracket(UnivariateFunction, double, double, double, double,double, int)\n * bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)},\n * explicitly specifying the maximum number of iterations.</p>\n *\n * @param function Function.\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value)\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @return a two-element array holding a and b.\n * @throws NoBracketingException if a root cannot be bracketted.\n * @throws NotStrictlyPositiveException if {@code maximumIterations <= 0}.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException {\n    return bracket(function, initial, lowerBound, upperBound, 1.0, 1.0, Integer.MAX_VALUE);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method simply calls {@link #bracket(UnivariateFunction, double, double, double,\n * double, double, int) bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)}\n * with {@code q} and {@code r} set to 1.0.\n * @param function Function.\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value).\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @param maximumIterations Maximum number of iterations to perform\n * @return a two element array holding a and b.\n * @throws NoBracketingException if the algorithm fails to find a and b\n * satisfying the desired conditions.\n * @throws NotStrictlyPositiveException if {@code maximumIterations <= 0}.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException {\n    return bracket(function, initial, lowerBound, upperBound, 1.0, 1.0, maximumIterations);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method attempts to find two values a and b satisfying <ul>\n * <li> {@code lowerBound <= a < initial < b <= upperBound} </li>\n * <li> {@code f(a) * f(b) <= 0} </li>\n * </ul>\n * If {@code f} is continuous on {@code [a,b]}, this means that {@code a}\n * and {@code b} bracket a root of {@code f}.\n * <p>\n * The algorithm checks the sign of \\( f(l_k) \\) and \\( f(u_k) \\) for increasing\n * values of k, where \\( l_k = max(lower, initial - \\delta_k) \\),\n * \\( u_k = min(upper, initial + \\delta_k) \\), using recurrence\n * \\( \\delta_{k+1} = r \\delta_k + q, \\delta_0 = 0\\) and starting search with \\( k=1 \\).\n * The algorithm stops when one of the following happens: <ul>\n * <li> at least one positive and one negative value have been found --  success!</li>\n * <li> both endpoints have reached their respective limits -- NoBracketingException </li>\n * <li> {@code maximumIterations} iterations elapse -- NoBracketingException </li></ul>\n * <p>\n * If different signs are found at first iteration ({@code k=1}), then the returned\n * interval will be \\( [a, b] = [l_1, u_1] \\). If different signs are found at a later\n * iteration {@code k>1}, then the returned interval will be either\n * \\( [a, b] = [l_{k+1}, l_{k}] \\) or \\( [a, b] = [u_{k}, u_{k+1}] \\). A root solver called\n * with these parameters will therefore start with the smallest bracketing interval known\n * at this step.\n * </p>\n * <p>\n * Interval expansion rate is tuned by changing the recurrence parameters {@code r} and\n * {@code q}. When the multiplicative factor {@code r} is set to 1, the sequence is a\n * simple arithmetic sequence with linear increase. When the multiplicative factor {@code r}\n * is larger than 1, the sequence has an asymptotically exponential rate. Note than the\n * additive parameter {@code q} should never be set to zero, otherwise the interval would\n * degenerate to the single initial point for all values of {@code k}.\n * </p>\n * <p>\n * As a rule of thumb, when the location of the root is expected to be approximately known\n * within some error margin, {@code r} should be set to 1 and {@code q} should be set to the\n * order of magnitude of the error margin. When the location of the root is really a wild guess,\n * then {@code r} should be set to a value larger than 1 (typically 2 to double the interval\n * length at each iteration) and {@code q} should be set according to half the initial\n * search interval length.\n * </p>\n * <p>\n * As an example, if we consider the trivial function {@code f(x) = 1 - x} and use\n * {@code initial = 4}, {@code r = 1}, {@code q = 2}, the algorithm will compute\n * {@code f(4-2) = f(2) = -1} and {@code f(4+2) = f(6) = -5} for {@code k = 1}, then\n * {@code f(4-4) = f(0) = +1} and {@code f(4+4) = f(8) = -7} for {@code k = 2}. Then it will\n * return the interval {@code [0, 2]} as the smallest one known to be bracketing the root.\n * As shown by this example, the initial value (here {@code 4}) may lie outside of the returned\n * bracketing interval.\n * </p>\n * @param function function to check\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value).\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @param q additive offset used to compute bounds sequence (must be strictly positive)\n * @param r multiplicative factor used to compute bounds sequence\n * @param maximumIterations Maximum number of iterations to perform\n * @return a two element array holding the bracketing values.\n * @exception NoBracketingException if function cannot be bracketed in the search interval\n */\npublic static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    if (q <= 0) {\n        throw new NotStrictlyPositiveException(q);\n    }\n    if (maximumIterations <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.INVALID_MAX_ITERATIONS, maximumIterations);\n    }\n    verifySequence(lowerBound, initial, upperBound);\n    // initialize the recurrence\n    double a = initial;\n    double b = initial;\n    double fa = Double.NaN;\n    double fb = Double.NaN;\n    double delta = 0;\n    for (int numIterations = 0; (numIterations < maximumIterations) && (a > lowerBound || b < upperBound); ++numIterations) {\n        final double previousA = a;\n        final double previousFa = fa;\n        final double previousB = b;\n        final double previousFb = fb;\n        delta = r * delta + q;\n        a = FastMath.max(initial - delta, lowerBound);\n        b = FastMath.min(initial + delta, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        if (numIterations == 0) {\n            // at first iteration, we don't have a previous interval\n            // we simply compare both sides of the initial interval\n            if (fa * fb <= 0) {\n                // the first interval already brackets a root\n                return new double[] { a, b };\n            }\n        } else {\n            // we have a previous interval with constant sign and expand it,\n            // we expect sign changes to occur at boundaries\n            if (fa * previousFa <= 0) {\n                // sign change detected at near lower bound\n                return new double[] { a, previousA };\n            } else if (fb * previousFb <= 0) {\n                // sign change detected at near upper bound\n                return new double[] { previousB, b };\n            }\n        }\n    }\n    // no bracketing found\n    throw new NoBracketingException(a, b, fa, fb);\n}"
            ],
            [
                "midpoint",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Compute the midpoint of two values.\n *\n * @param a first value.\n * @param b second value.\n * @return the midpoint.\n */\npublic static double midpoint(double a, double b) {\n    return (a + b) * 0.5;\n}"
            ],
            [
                "isBracketing",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Check whether the interval bounds bracket a root. That is, if the\n * values at the endpoints are not equal to zero, then the function takes\n * opposite signs at the endpoints.\n *\n * @param function Function.\n * @param lower Lower endpoint.\n * @param upper Upper endpoint.\n * @return {@code true} if the function values have opposite signs at the\n * given points.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static boolean isBracketing(UnivariateFunction function, final double lower, final double upper) throws NullArgumentException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final double fLo = function.value(lower);\n    final double fHi = function.value(upper);\n    return (fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0);\n}"
            ],
            [
                "isSequence",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Check whether the arguments form a (strictly) increasing sequence.\n *\n * @param start First number.\n * @param mid Second number.\n * @param end Third number.\n * @return {@code true} if the arguments form an increasing sequence.\n */\npublic static boolean isSequence(final double start, final double mid, final double end) {\n    return (start < mid) && (mid < end);\n}"
            ],
            [
                "getCompiler",
                "org.apache.commons.math3.analysis.differentiation",
                "DSCompiler",
                "/**\n * Get the compiler for number of free parameters and order.\n * @param parameters number of free parameters\n * @param order derivation order\n * @return cached rules set\n * @throws NumberIsTooLargeException if order is too large\n */\npublic static DSCompiler getCompiler(int parameters, int order) throws NumberIsTooLargeException {\n    // get the cached compilers\n    final DSCompiler[][] cache = compilers.get();\n    if (cache != null && cache.length > parameters && cache[parameters].length > order && cache[parameters][order] != null) {\n        // the compiler has already been created\n        return cache[parameters][order];\n    }\n    // we need to create more compilers\n    final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);\n    final int maxOrder = FastMath.max(order, cache == null ? 0 : cache[0].length);\n    final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];\n    if (cache != null) {\n        // preserve the already created compilers\n        for (int i = 0; i < cache.length; ++i) {\n            System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);\n        }\n    }\n    // create the array in increasing diagonal order\n    for (int diag = 0; diag <= parameters + order; ++diag) {\n        for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {\n            final int p = diag - o;\n            if (newCache[p][o] == null) {\n                final DSCompiler valueCompiler = (p == 0) ? null : newCache[p - 1][o];\n                final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];\n                newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);\n            }\n        }\n    }\n    // atomically reset the cached compilers array\n    compilers.compareAndSet(cache, newCache);\n    return newCache[parameters][order];\n}"
            ],
            [
                "createConstant",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Factory method creating a constant.\n * @param value value of the constant\n * @return a new instance\n */\npublic static SparseGradient createConstant(final double value) {\n    return new SparseGradient(value, Collections.<Integer, Double>emptyMap());\n}"
            ],
            [
                "createVariable",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Factory method creating an independent variable.\n * @param idx index of the variable\n * @param value value of the variable\n * @return a new instance\n */\npublic static SparseGradient createVariable(final int idx, final double value) {\n    return new SparseGradient(value, Collections.singletonMap(idx, 1.0));\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n */\npublic static SparseGradient hypot(final SparseGradient x, final SparseGradient y) {\n    return x.hypot(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Compute a<sup>x</sup> where a is a double and x a {@link SparseGradient}\n * @param a number to exponentiate\n * @param x power to apply\n * @return a<sup>x</sup>\n */\npublic static SparseGradient pow(final double a, final SparseGradient x) {\n    if (a == 0) {\n        if (x.value == 0) {\n            return x.compose(1.0, Double.NEGATIVE_INFINITY);\n        } else if (x.value < 0) {\n            return x.compose(Double.NaN, Double.NaN);\n        } else {\n            return x.getField().getZero();\n        }\n    } else {\n        final double ax = FastMath.pow(a, x.value);\n        return new SparseGradient(ax, ax * FastMath.log(a), x.derivatives);\n    }\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Two arguments arc tangent operation.\n * @param y first argument of the arc tangent\n * @param x second argument of the arc tangent\n * @return atan2(y, x)\n */\npublic static SparseGradient atan2(final SparseGradient y, final SparseGradient x) {\n    return y.atan2(x);\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * @exception DimensionMismatchException if number of free parameters\n * or orders do not match\n * @since 3.2\n */\npublic static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y) throws DimensionMismatchException {\n    return x.hypot(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Compute a<sup>x</sup> where a is a double and x a {@link DerivativeStructure}\n * @param a number to exponentiate\n * @param x power to apply\n * @return a<sup>x</sup>\n * @since 3.3\n */\npublic static DerivativeStructure pow(final double a, final DerivativeStructure x) {\n    final DerivativeStructure result = new DerivativeStructure(x.compiler);\n    x.compiler.pow(a, x.data, 0, result.data, 0);\n    return result;\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Two arguments arc tangent operation.\n * @param y first argument of the arc tangent\n * @param x second argument of the arc tangent\n * @return atan2(y, x)\n * @exception DimensionMismatchException if number of free parameters\n * or orders do not match\n * @since 3.2\n */\npublic static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException {\n    return y.atan2(x);\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionNewtonForm",
                "/**\n * Evaluate the Newton polynomial using nested multiplication. It is\n * also called <a href=\"http://mathworld.wolfram.com/HornersRule.html\">\n * Horner's Rule</a> and takes O(N) time.\n *\n * @param a Coefficients in Newton form formula.\n * @param c Centers.\n * @param z Point at which the function value is to be computed.\n * @return the function value.\n * @throws NullArgumentException if any argument is {@code null}.\n * @throws NoDataException if any array has zero length.\n * @throws DimensionMismatchException if the size difference between\n * {@code a} and {@code c} is not equal to 1.\n */\npublic static double evaluate(double[] a, double[] c, double z) throws NullArgumentException, DimensionMismatchException, NoDataException {\n    verifyInputArray(a, c);\n    final int n = c.length;\n    double value = a[n];\n    for (int i = n - 1; i >= 0; i--) {\n        value = a[i] + (z - c[i]) * value;\n    }\n    return value;\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "/**\n * Evaluate the Lagrange polynomial using\n * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n * Neville's Algorithm</a>. It takes O(n^2) time.\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @param z Point at which the function value is to be computed.\n * @return the function value.\n * @throws DimensionMismatchException if {@code x} and {@code y} have\n * different lengths.\n * @throws NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order.\n * @throws NumberIsTooSmallException if the size of {@code x} is less\n * than 2.\n */\npublic static double evaluate(double[] x, double[] y, double z) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    if (verifyInterpolationArray(x, y, false)) {\n        return evaluateInternal(x, y, z);\n    }\n    // Array is not sorted.\n    final double[] xNew = new double[x.length];\n    final double[] yNew = new double[y.length];\n    System.arraycopy(x, 0, xNew, 0, x.length);\n    System.arraycopy(y, 0, yNew, 0, y.length);\n    MathArrays.sortInPlace(xNew, yNew);\n    // Second check in case some abscissa is duplicated.\n    verifyInterpolationArray(xNew, yNew, true);\n    return evaluateInternal(xNew, yNew, z);\n}"
            ],
            [
                "verifyInterpolationArray",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "/**\n * Check that the interpolation arrays are valid.\n * The arrays features checked by this method are that both arrays have the\n * same length and this length is at least 2.\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @param abort Whether to throw an exception if {@code x} is not sorted.\n * @throws DimensionMismatchException if the array lengths are different.\n * @throws NumberIsTooSmallException if the number of points is less than 2.\n * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order and {@code abort}\n * is {@code true}.\n * @return {@code false} if the {@code x} is not sorted in increasing order,\n * {@code true} otherwise.\n * @see #evaluate(double[], double[], double)\n * @see #computeCoefficients()\n */\npublic static boolean verifyInterpolationArray(double[] x, double[] y, boolean abort) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    if (x.length != y.length) {\n        throw new DimensionMismatchException(x.length, y.length);\n    }\n    if (x.length < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.WRONG_NUMBER_OF_POINTS, 2, x.length, true);\n    }\n    return MathArrays.checkOrder(x, MathArrays.OrderDirection.INCREASING, true, abort);\n}"
            ],
            [
                "createChebyshevPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Chebyshev polynomial of the first kind.\n * <p><a href=\"https://en.wikipedia.org/wiki/Chebyshev_polynomials\">Chebyshev\n * polynomials of the first kind</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *    T_0(x) = 1 \\\\\n *    T_1(x) = x \\\\\n *    T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Chebyshev polynomial of specified degree\n */\npublic static PolynomialFunction createChebyshevPolynomial(final int degree) {\n    return buildPolynomial(degree, CHEBYSHEV_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * Fixed recurrence coefficients.\n         */\n        private final BigFraction[] coeffs = { BigFraction.ZERO, BigFraction.TWO, BigFraction.ONE };\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            return coeffs;\n        }\n    });\n}"
            ],
            [
                "createHermitePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Hermite polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/HermitePolynomial.html\">Hermite\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *  H_0(x) = 1 \\\\\n *  H_1(x) = 2x \\\\\n *  H_{k+1}(x) = 2x H_k(X) - 2k H_{k-1}(x)\n * \\)\n * </p>\n *\n * @param degree degree of the polynomial\n * @return Hermite polynomial of specified degree\n */\npublic static PolynomialFunction createHermitePolynomial(final int degree) {\n    return buildPolynomial(degree, HERMITE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            return new BigFraction[] { BigFraction.ZERO, BigFraction.TWO, new BigFraction(2 * k) };\n        }\n    });\n}"
            ],
            [
                "createLaguerrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Laguerre polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/LaguerrePolynomial.html\">Laguerre\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *   L_0(x) = 1 \\\\\n *   L_1(x) = 1 - x \\\\\n *   (k+1) L_{k+1}(x) = (2k + 1 - x) L_k(x) - k L_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Laguerre polynomial of specified degree\n */\npublic static PolynomialFunction createLaguerrePolynomial(final int degree) {\n    return buildPolynomial(degree, LAGUERRE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            final int kP1 = k + 1;\n            return new BigFraction[] { new BigFraction(2 * k + 1, kP1), new BigFraction(-1, kP1), new BigFraction(k, kP1) };\n        }\n    });\n}"
            ],
            [
                "createLegendrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Legendre polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/LegendrePolynomial.html\">Legendre\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *   P_0(x) = 1 \\\\\n *   P_1(x) = x \\\\\n *   (k+1) P_{k+1}(x) = (2k+1) x P_k(x) - k P_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Legendre polynomial of specified degree\n */\npublic static PolynomialFunction createLegendrePolynomial(final int degree) {\n    return buildPolynomial(degree, LEGENDRE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            final int kP1 = k + 1;\n            return new BigFraction[] { BigFraction.ZERO, new BigFraction(k + kP1, kP1), new BigFraction(k, kP1) };\n        }\n    });\n}"
            ],
            [
                "createJacobiPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Jacobi polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/JacobiPolynomial.html\">Jacobi\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *    P_0^{vw}(x) = 1 \\\\\n *    P_{-1}^{vw}(x) = 0 \\\\\n *    2k(k + v + w)(2k + v + w - 2) P_k^{vw}(x) = \\\\\n *    (2k + v + w - 1)[(2k + v + w)(2k + v + w - 2) x + v^2 - w^2] P_{k-1}^{vw}(x) \\\\\n *  - 2(k + v - 1)(k + w - 1)(2k + v + w) P_{k-2}^{vw}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @param v first exponent\n * @param w second exponent\n * @return Jacobi polynomial of specified degree\n */\npublic static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w) {\n    // select the appropriate list\n    final JacobiKey key = new JacobiKey(v, w);\n    if (!JACOBI_COEFFICIENTS.containsKey(key)) {\n        // allocate a new list for v, w\n        final List<BigFraction> list = new ArrayList<BigFraction>();\n        JACOBI_COEFFICIENTS.put(key, list);\n        // Pv,w,0(x) = 1;\n        list.add(BigFraction.ONE);\n        // P1(x) = (v - w) / 2 + (2 + v + w) * X / 2\n        list.add(new BigFraction(v - w, 2));\n        list.add(new BigFraction(2 + v + w, 2));\n    }\n    return buildPolynomial(degree, JACOBI_COEFFICIENTS.get(key), new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            k++;\n            final int kvw = k + v + w;\n            final int twoKvw = kvw + k;\n            final int twoKvwM1 = twoKvw - 1;\n            final int twoKvwM2 = twoKvw - 2;\n            final int den = 2 * k * kvw * twoKvwM2;\n            return new BigFraction[] { new BigFraction(twoKvwM1 * (v * v - w * w), den), new BigFraction(twoKvwM1 * twoKvw * twoKvwM2, den), new BigFraction(2 * (k + v - 1) * (k + w - 1) * twoKvw, den) };\n        }\n    });\n}"
            ],
            [
                "shift",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Compute the coefficients of the polynomial \\(P_s(x)\\)\n * whose values at point {@code x} will be the same as the those from the\n * original polynomial \\(P(x)\\) when computed at {@code x + shift}.\n * <p>\n * More precisely, let \\(\\Delta = \\) {@code shift} and let\n * \\(P_s(x) = P(x + \\Delta)\\).  The returned array\n * consists of the coefficients of \\(P_s\\).  So if \\(a_0, ..., a_{n-1}\\)\n * are the coefficients of \\(P\\), then the returned array\n * \\(b_0, ..., b_{n-1}\\) satisfies the identity\n * \\(\\sum_{i=0}^{n-1} b_i x^i = \\sum_{i=0}^{n-1} a_i (x + \\Delta)^i\\) for all \\(x\\).\n *\n * @param coefficients Coefficients of the original polynomial.\n * @param shift Shift value.\n * @return the coefficients \\(b_i\\) of the shifted\n * polynomial.\n */\npublic static double[] shift(final double[] coefficients, final double shift) {\n    final int dp1 = coefficients.length;\n    final double[] newCoefficients = new double[dp1];\n    // Pascal triangle.\n    final int[][] coeff = new int[dp1][dp1];\n    for (int i = 0; i < dp1; i++) {\n        for (int j = 0; j <= i; j++) {\n            coeff[i][j] = (int) CombinatoricsUtils.binomialCoefficient(i, j);\n        }\n    }\n    // First polynomial coefficient.\n    for (int i = 0; i < dp1; i++) {\n        newCoefficients[0] += coefficients[i] * FastMath.pow(shift, i);\n    }\n    // Superior order.\n    final int d = dp1 - 1;\n    for (int i = 0; i < d; i++) {\n        for (int j = i; j < d; j++) {\n            newCoefficients[i + 1] += coeff[j + 1][j - i] * coefficients[j + 1] * FastMath.pow(shift, j - i);\n        }\n    }\n    return newCoefficients;\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "/**\n * Uses Horner's Method to evaluate the polynomial with the given coefficients at\n * the argument.\n *\n * @param coefficients Coefficients of the polynomial to evaluate.\n * @param argument Input value.\n * @return the value of the polynomial.\n * @throws NoDataException if {@code coefficients} is empty.\n * @throws NullArgumentException if {@code coefficients} is {@code null}.\n */\nprotected static double evaluate(double[] coefficients, double argument) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(coefficients);\n    int n = coefficients.length;\n    if (n == 0) {\n        throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n    }\n    double result = coefficients[n - 1];\n    for (int j = n - 2; j >= 0; j--) {\n        result = argument * result + coefficients[j];\n    }\n    return result;\n}"
            ],
            [
                "differentiate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "/**\n * Returns the coefficients of the derivative of the polynomial with the given coefficients.\n *\n * @param coefficients Coefficients of the polynomial to differentiate.\n * @return the coefficients of the derivative or {@code null} if coefficients has length 1.\n * @throws NoDataException if {@code coefficients} is empty.\n * @throws NullArgumentException if {@code coefficients} is {@code null}.\n */\nprotected static double[] differentiate(double[] coefficients) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(coefficients);\n    int n = coefficients.length;\n    if (n == 0) {\n        throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n    }\n    if (n == 1) {\n        return new double[] { 0 };\n    }\n    double[] result = new double[n - 1];\n    for (int i = n - 1; i > 0; i--) {\n        result[i - 1] = i * coefficients[i];\n    }\n    return result;\n}"
            ],
            [
                "computeDividedDifference",
                "org.apache.commons.math3.analysis.interpolation",
                "DividedDifferenceInterpolator",
                "/**\n * Return a copy of the divided difference array.\n * <p>\n * The divided difference array is defined recursively by <pre>\n * f[x0] = f(x0)\n * f[x0,x1,...,xk] = (f[x1,...,xk] - f[x0,...,x[k-1]]) / (xk - x0)\n * </pre>\n * <p>\n * The computational complexity is \\(O(n^2)\\) where \\(n\\) is the common\n * length of {@code x} and {@code y}.</p>\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @return a fresh copy of the divided difference array.\n * @throws DimensionMismatchException if the array lengths are different.\n * @throws NumberIsTooSmallException if the number of points is less than 2.\n * @throws NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order.\n */\nprotected static double[] computeDividedDifference(final double[] x, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y, true);\n    // initialization\n    final double[] divdiff = y.clone();\n    final int n = x.length;\n    final double[] a = new double[n];\n    a[0] = divdiff[0];\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n - i; j++) {\n            final double denominator = x[j + i] - x[j];\n            divdiff[j] = (divdiff[j + 1] - divdiff[j]) / denominator;\n        }\n        a[i] = divdiff[0];\n    }\n    return a;\n}"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Compares two numbers given some amount of allowed error.\n *\n * @param x the first number\n * @param y the second number\n * @param eps the amount of error to allow when checking for equality\n * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y or\n *       either argument is NaN</li></ul>\n */\npublic static int compareTo(double x, double y, double eps) {\n    if (equals(x, y, eps)) {\n        return 0;\n    } else if (x < y) {\n        return -1;\n    }\n    return 1;\n}"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Compares two numbers given some amount of allowed error.\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>. Returns {@code false} if either of the arguments is NaN.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return <ul><li>0 if  {@link #equals(double, double, int) equals(x, y, maxUlps)}</li>\n *       <li>&lt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y</li>\n *       <li>&gt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x > y\n *       or either argument is NaN</li></ul>\n */\npublic static int compareTo(final double x, final double y, final int maxUlps) {\n    if (equals(x, y, maxUlps)) {\n        return 0;\n    } else if (x < y) {\n        return -1;\n    }\n    return 1;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true iff they are equal as defined by\n * {@link #equals(float,float,int) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\npublic static boolean equals(float x, float y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if both arguments are NaN or they are\n * equal as defined by {@link #equals(float,float) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).  Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other.\n * @since 2.2\n */\npublic static boolean equals(float x, float y, float eps) {\n    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN, are equal, or are within the range\n * of allowed error (inclusive).\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,\n * or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y, float eps) {\n    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>.  Returns {@code false} if either of the arguments is NaN.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equals(final float x, final float y, final int maxUlps) {\n    final int xInt = Float.floatToRawIntBits(x);\n    final int yInt = Float.floatToRawIntBits(y);\n    final boolean isEqual;\n    if (((xInt ^ yInt) & SGN_MASK_FLOAT) == 0) {\n        // number have same sign, there is no risk of overflow\n        isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    } else {\n        // number have opposite signs, take care of overflow\n        final int deltaPlus;\n        final int deltaMinus;\n        if (xInt < yInt) {\n            deltaPlus = yInt - POSITIVE_ZERO_FLOAT_BITS;\n            deltaMinus = xInt - NEGATIVE_ZERO_FLOAT_BITS;\n        } else {\n            deltaPlus = xInt - POSITIVE_ZERO_FLOAT_BITS;\n            deltaMinus = yInt - NEGATIVE_ZERO_FLOAT_BITS;\n        }\n        if (deltaPlus > maxUlps) {\n            isEqual = false;\n        } else {\n            isEqual = deltaMinus <= (maxUlps - deltaPlus);\n        }\n    }\n    return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN or if they are equal as defined\n * by {@link #equals(float,float,int) equals(x, y, maxUlps)}.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than\n * {@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, maxUlps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true iff they are equal as defined by\n * {@link #equals(double,double,int) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\npublic static boolean equals(double x, double y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN or they are\n * equal as defined by {@link #equals(double,double) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns {@code true} if there is no double value strictly between the\n * arguments or the difference between them is within the range of allowed\n * error (inclusive). Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed absolute error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n */\npublic static boolean equals(double x, double y, double eps) {\n    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n}"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns {@code true} if there is no double value strictly between the\n * arguments or the relative difference between them is less than or equal\n * to the given tolerance. Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed relative error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n * @since 3.1\n */\npublic static boolean equalsWithRelativeTolerance(double x, double y, double eps) {\n    if (equals(x, y, 1)) {\n        return true;\n    }\n    final double absoluteMax = FastMath.max(FastMath.abs(x), FastMath.abs(y));\n    final double relativeDifference = FastMath.abs((x - y) / absoluteMax);\n    return relativeDifference <= eps;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN, are equal or are within the range\n * of allowed error (inclusive).\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,\n * or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y, double eps) {\n    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).\n * <p>\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent\n * floating point numbers are considered equal.\n * </p>\n * <p>\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>. Returns {@code false} if either of the arguments is NaN.\n * </p>\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n */\npublic static boolean equals(final double x, final double y, final int maxUlps) {\n    final long xInt = Double.doubleToRawLongBits(x);\n    final long yInt = Double.doubleToRawLongBits(y);\n    final boolean isEqual;\n    if (((xInt ^ yInt) & SGN_MASK) == 0l) {\n        // number have same sign, there is no risk of overflow\n        isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    } else {\n        // number have opposite signs, take care of overflow\n        final long deltaPlus;\n        final long deltaMinus;\n        if (xInt < yInt) {\n            deltaPlus = yInt - POSITIVE_ZERO_DOUBLE_BITS;\n            deltaMinus = xInt - NEGATIVE_ZERO_DOUBLE_BITS;\n        } else {\n            deltaPlus = xInt - POSITIVE_ZERO_DOUBLE_BITS;\n            deltaMinus = yInt - NEGATIVE_ZERO_DOUBLE_BITS;\n        }\n        if (deltaPlus > maxUlps) {\n            isEqual = false;\n        } else {\n            isEqual = deltaMinus <= (maxUlps - deltaPlus);\n        }\n    }\n    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if both arguments are NaN or if they are equal as defined\n * by {@link #equals(double,double,int) equals(x, y, maxUlps)}.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than\n * {@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, maxUlps);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double round(double x, int scale) {\n    return round(x, scale, BigDecimal.ROUND_HALF_UP);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is\n * returned unchanged, regardless of the other parameters.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}\n * and the specified scaling operation would require rounding.\n * @throws IllegalArgumentException if {@code roundingMethod} does not\n * represent a valid rounding mode.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double round(double x, int scale, int roundingMethod) {\n    try {\n        final double rounded = (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\n        // MATH-1089: negative values rounded to zero should result in negative zero\n        return rounded == POSITIVE_ZERO ? POSITIVE_ZERO * x : rounded;\n    } catch (NumberFormatException ex) {\n        if (Double.isInfinite(x)) {\n            return x;\n        } else {\n            return Double.NaN;\n        }\n    }\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static float round(float x, int scale) {\n    return round(x, scale, BigDecimal.ROUND_HALF_UP);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n * @throws MathArithmeticException if an exact operation is required but result is not exact\n * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n */\npublic static float round(float x, int scale, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException {\n    final float sign = FastMath.copySign(1f, x);\n    final float factor = (float) FastMath.pow(10.0f, scale) * sign;\n    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;\n}"
            ],
            [
                "representableDelta",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Computes a number {@code delta} close to {@code originalDelta} with\n * the property that <pre><code>\n *   x + delta - x\n * </code></pre>\n * is exactly machine-representable.\n * This is useful when computing numerical derivatives, in order to reduce\n * roundoff errors.\n *\n * @param x Value.\n * @param originalDelta Offset value.\n * @return a number {@code delta} so that {@code x + delta} and {@code x}\n * differ by a representable floating number.\n */\npublic static double representableDelta(double x, double originalDelta) {\n    return x + originalDelta - x;\n}"
            ],
            [
                "wrap",
                "org.apache.commons.math3.util",
                "Incrementor",
                "/**\n * Create an instance that delegates everything to a {@link IntegerSequence.Incrementor}.\n * <p>\n * This factory method is intended only as a temporary hack for internal use in\n * Apache Commons Math 3.X series, when {@code Incrementor} is required in\n * interface (as a return value or in protected fields). It should <em>not</em>\n * be used in other cases. The {@link IntegerSequence.Incrementor} class should\n * be used instead of {@code Incrementor}.\n * </p>\n * <p>\n * All methods are mirrored to the underlying {@link IntegerSequence.Incrementor},\n * as long as neither {@link #setMaximalCount(int)} nor {@link #resetCount()} are called.\n * If one of these two methods is called, the created instance becomes independent\n * of the {@link IntegerSequence.Incrementor} used at creation. The rationale is that\n * {@link IntegerSequence.Incrementor} cannot change their maximal count and cannot be reset.\n * </p>\n * @param incrementor wrapped {@link IntegerSequence.Incrementor}\n * @return an incrementor wrapping an {@link IntegerSequence.Incrementor}\n * @since 3.6\n */\npublic static Incrementor wrap(final IntegerSequence.Incrementor incrementor) {\n    return new Incrementor() {\n\n        /**\n         * Underlying incrementor.\n         */\n        private IntegerSequence.Incrementor delegate;\n\n        {\n            // set up matching values at initialization\n            delegate = incrementor;\n            super.setMaximalCount(delegate.getMaximalCount());\n            super.incrementCount(delegate.getCount());\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void setMaximalCount(int max) {\n            super.setMaximalCount(max);\n            delegate = delegate.withMaximalCount(max);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void resetCount() {\n            super.resetCount();\n            delegate = delegate.withStart(0);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void incrementCount() {\n            super.incrementCount();\n            delegate.increment();\n        }\n    };\n}"
            ],
            [
                "scale",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Create a copy of an array scaled by a value.\n *\n * @param arr Array to scale.\n * @param val Scalar.\n * @return scaled copy of array with each entry multiplied by val.\n * @since 3.2\n */\npublic static double[] scale(double val, final double[] arr) {\n    double[] newArr = new double[arr.length];\n    for (int i = 0; i < arr.length; i++) {\n        newArr[i] = arr[i] * val;\n    }\n    return newArr;\n}"
            ],
            [
                "ebeAdd",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * addition of the arguments.\n *\n * @param a First term of the addition.\n * @param b Second term of the addition.\n * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] += b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeSubtract",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * subtraction of the second argument from the first.\n *\n * @param a First term.\n * @param b Element to be subtracted.\n * @return a new array {@code r} where {@code r[i] = a[i] - b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] -= b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeMultiply",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * multiplication of the arguments.\n *\n * @param a First factor of the multiplication.\n * @param b Second factor of the multiplication.\n * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] *= b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeDivide",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * division of the first argument by the second.\n *\n * @param a Numerator of the division.\n * @param b Denominator of the division.\n * @return a new array {@code r} where {@code r[i] = a[i] / b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] /= b[i];\n    }\n    return result;\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>1</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance1(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        sum += FastMath.abs(p1[i] - p2[i]);\n    }\n    return sum;\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>1</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static int distance1(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    int sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        sum += FastMath.abs(p1[i] - p2[i]);\n    }\n    return sum;\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>2</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final double dp = p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return FastMath.sqrt(sum);\n}"
            ],
            [
                "cosAngle",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the cosine of the angle between two vectors.\n *\n * @param v1 Cartesian coordinates of the first vector.\n * @param v2 Cartesian coordinates of the second vector.\n * @return the cosine of the angle between the vectors.\n * @since 3.6\n */\npublic static double cosAngle(double[] v1, double[] v2) {\n    return linearCombination(v1, v2) / (safeNorm(v1) * safeNorm(v2));\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>2</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final double dp = p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return FastMath.sqrt(sum);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>&infin;</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double max = 0;\n    for (int i = 0; i < p1.length; i++) {\n        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n    }\n    return max;\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>&infin;</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    int max = 0;\n    for (int i = 0; i < p1.length; i++) {\n        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n    }\n    return max;\n}"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that an array is monotonically increasing or decreasing.\n *\n * @param <T> the type of the elements in the specified array\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\npublic static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {\n    T previous = val[0];\n    final int max = val.length;\n    for (int i = 1; i < max; i++) {\n        final int comp;\n        switch(dir) {\n            case INCREASING:\n                comp = previous.compareTo(val[i]);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            case DECREASING:\n                comp = val[i].compareTo(previous);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n        }\n        previous = val[i];\n    }\n    return true;\n}"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that an array is monotonically increasing or decreasing.\n *\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\npublic static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {\n    return checkOrder(val, dir, strict, false);\n}"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that both arrays have the same length.\n *\n * @param a Array.\n * @param b Array.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the arrays have the same length.\n * @throws DimensionMismatchException if the lengths differ and\n * {@code abort} is {@code true}.\n * @since 3.6\n */\npublic static boolean checkEqualLength(double[] a, double[] b, boolean abort) {\n    if (a.length == b.length) {\n        return true;\n    } else {\n        if (abort) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n        return false;\n    }\n}"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that both arrays have the same length.\n *\n * @param a Array.\n * @param b Array.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the arrays have the same length.\n * @throws DimensionMismatchException if the lengths differ and\n * {@code abort} is {@code true}.\n * @since 3.6\n */\npublic static boolean checkEqualLength(int[] a, int[] b, boolean abort) {\n    if (a.length == b.length) {\n        return true;\n    } else {\n        if (abort) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n        return false;\n    }\n}"
            ],
            [
                "checkOrder",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that the given array is sorted.\n *\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the array is sorted.\n * @throws NonMonotonicSequenceException if the array is not sorted\n * and {@code abort} is {@code true}.\n */\npublic static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {\n    double previous = val[0];\n    final int max = val.length;\n    int index;\n    ITEM: for (index = 1; index < max; index++) {\n        switch(dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[index] <= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] < previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[index] >= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] > previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n        }\n        previous = val[index];\n    }\n    if (index == max) {\n        // Loop completed.\n        return true;\n    }\n    // Loop early exit means wrong ordering.\n    if (abort) {\n        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n    } else {\n        return false;\n    }\n}"
            ],
            [
                "safeNorm",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n * Translation of the minpack enorm subroutine.\n *\n * The redistribution policy for MINPACK is available\n * <a href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n * convenience, it is reproduced below.</p>\n *\n * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n * <tr><td>\n *    Minpack Copyright Notice (1999) University of Chicago.\n *    All rights reserved\n * </td></tr>\n * <tr><td>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * <ol>\n *  <li>Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.</li>\n * <li>Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.</li>\n * <li>The end-user documentation included with the redistribution, if any,\n *     must include the following acknowledgment:\n *     {@code This product includes software developed by the University of\n *           Chicago, as Operator of Argonne National Laboratory.}\n *     Alternately, this acknowledgment may appear in the software itself,\n *     if and wherever such third-party acknowledgments normally appear.</li>\n * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n *     BE CORRECTED.</strong></li>\n * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n * <ol></td></tr>\n * </table>\n *\n * @param v Vector of doubles.\n * @return the 2-norm of the vector.\n * @since 2.2\n */\npublic static double safeNorm(double[] v) {\n    double rdwarf = 3.834e-20;\n    double rgiant = 1.304e+19;\n    double s1 = 0;\n    double s2 = 0;\n    double s3 = 0;\n    double x1max = 0;\n    double x3max = 0;\n    double floatn = v.length;\n    double agiant = rgiant / floatn;\n    for (int i = 0; i < v.length; i++) {\n        double xabs = FastMath.abs(v[i]);\n        if (xabs < rdwarf || xabs > agiant) {\n            if (xabs > rdwarf) {\n                if (xabs > x1max) {\n                    double r = x1max / xabs;\n                    s1 = 1 + s1 * r * r;\n                    x1max = xabs;\n                } else {\n                    double r = xabs / x1max;\n                    s1 += r * r;\n                }\n            } else {\n                if (xabs > x3max) {\n                    double r = x3max / xabs;\n                    s3 = 1 + s3 * r * r;\n                    x3max = xabs;\n                } else {\n                    if (xabs != 0) {\n                        double r = xabs / x3max;\n                        s3 += r * r;\n                    }\n                }\n            }\n        } else {\n            s2 += xabs * xabs;\n        }\n    }\n    double norm;\n    if (s1 != 0) {\n        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n    } else {\n        if (s2 == 0) {\n            norm = x3max * Math.sqrt(s3);\n        } else {\n            if (s2 >= x3max) {\n                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n            } else {\n                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n            }\n        }\n    }\n    return norm;\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @return the copied array.\n */\npublic static int[] copyOf(int[] source) {\n    return copyOf(source, source.length);\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @return the copied array.\n */\npublic static double[] copyOf(double[] source) {\n    return copyOf(source, source.length);\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the source\n * length, the copy will be truncated, if larger it will padded with\n * zeroes.\n * @return the copied array.\n */\npublic static int[] copyOf(int[] source, int len) {\n    final int[] output = new int[len];\n    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n    return output;\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the source\n * length, the copy will be truncated, if larger it will padded with\n * zeroes.\n * @return the copied array.\n */\npublic static double[] copyOf(double[] source, int len) {\n    final double[] output = new double[len];\n    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n    return output;\n}"
            ],
            [
                "copyOfRange",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param from Initial index of the range to be copied, inclusive.\n * @param to Final index of the range to be copied, exclusive. (This index may lie outside the array.)\n * @return the copied array.\n */\npublic static double[] copyOfRange(double[] source, int from, int to) {\n    final int len = to - from;\n    final double[] output = new double[len];\n    System.arraycopy(source, from, output, 0, FastMath.min(len, source.length - from));\n    return output;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * This method computes the sum of the products\n * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n * It does so by using specific multiplication and addition algorithms to\n * preserve accuracy and reduce cancellation effects.\n * <br/>\n * It is based on the 2005 paper\n * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n *\n * @param a Factors.\n * @param b Factors.\n * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n * @throws DimensionMismatchException if arrays dimensions don't match\n */\npublic static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final int len = a.length;\n    if (len == 1) {\n        // Revert to scalar multiplication.\n        return a[0] * b[0];\n    }\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double aHigh = Double.longBitsToDouble(Double.doubleToRawLongBits(ai) & ((-1L) << 27));\n        final double aLow = ai - aHigh;\n        final double bi = b[i];\n        final double bHigh = Double.longBitsToDouble(Double.doubleToRawLongBits(bi) & ((-1L) << 27));\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n    final double prodHighCur = prodHigh[0];\n    double prodHighNext = prodHigh[1];\n    double sHighPrev = prodHighCur + prodHighNext;\n    double sPrime = sHighPrev - prodHighNext;\n    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n    final int lenMinusOne = len - 1;\n    for (int i = 1; i < lenMinusOne; i++) {\n        prodHighNext = prodHigh[i + 1];\n        final double sHighCur = sHighPrev + prodHighNext;\n        sPrime = sHighCur - prodHighNext;\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n        sHighPrev = sHighCur;\n    }\n    double result = sHighPrev + (prodLowSum + sLowSum);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\n * so by using specific multiplication and addition algorithms to\n * preserve accuracy and reduce cancellation effects. It is based\n * on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub>\n * @see #linearCombination(double, double, double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // use IEEE754 floating point arithmetic rounding properties.\n    // The variable naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // final rounding, s12 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s12High + (prod1Low + prod2Low + s12Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2;\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n * to high accuracy. It does so by using specific multiplication and\n * addition algorithms to preserve accuracy and reduce cancellation effects.\n * It is based on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n * @see #linearCombination(double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // do use IEEE754 floating point arithmetic rounding properties.\n    // The variables naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // split a3 and b3 as one 26 bits number and one 27 bits number\n    final double a3High = Double.longBitsToDouble(Double.doubleToRawLongBits(a3) & ((-1L) << 27));\n    final double a3Low = a3 - a3High;\n    final double b3High = Double.longBitsToDouble(Double.doubleToRawLongBits(b3) & ((-1L) << 27));\n    final double b3Low = b3 - b3High;\n    // accurate multiplication a3 * b3\n    final double prod3High = a3 * b3;\n    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n    final double s123High = s12High + prod3High;\n    final double s123Prime = s123High - prod3High;\n    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n    // final rounding, s123 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2 + a3 * b3;\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n * a<sub>4</sub>&times;b<sub>4</sub>\n * to high accuracy. It does so by using specific multiplication and\n * addition algorithms to preserve accuracy and reduce cancellation effects.\n * It is based on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @param a4 first factor of the third term\n * @param b4 second factor of the third term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n * a<sub>4</sub>&times;b<sub>4</sub>\n * @see #linearCombination(double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // do use IEEE754 floating point arithmetic rounding properties.\n    // The variables naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // split a3 and b3 as one 26 bits number and one 27 bits number\n    final double a3High = Double.longBitsToDouble(Double.doubleToRawLongBits(a3) & ((-1L) << 27));\n    final double a3Low = a3 - a3High;\n    final double b3High = Double.longBitsToDouble(Double.doubleToRawLongBits(b3) & ((-1L) << 27));\n    final double b3Low = b3 - b3High;\n    // accurate multiplication a3 * b3\n    final double prod3High = a3 * b3;\n    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n    // split a4 and b4 as one 26 bits number and one 27 bits number\n    final double a4High = Double.longBitsToDouble(Double.doubleToRawLongBits(a4) & ((-1L) << 27));\n    final double a4Low = a4 - a4High;\n    final double b4High = Double.longBitsToDouble(Double.doubleToRawLongBits(b4) & ((-1L) << 27));\n    final double b4Low = b4 - b4High;\n    // accurate multiplication a4 * b4\n    final double prod4High = a4 * b4;\n    final double prod4Low = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n    final double s123High = s12High + prod3High;\n    final double s123Prime = s123High - prod3High;\n    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4\n    final double s1234High = s123High + prod4High;\n    final double s1234Prime = s1234High - prod4High;\n    final double s1234Low = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n    // final rounding, s1234 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n    }\n    return result;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns true iff both arguments are null or have same dimensions and all\n * their elements are equal as defined by\n * {@link Precision#equals(float,float)}.\n *\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension\n * and equal elements.\n */\npublic static boolean equals(float[] x, float[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equals(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns true iff both arguments are null or have same dimensions and all\n * their elements are equal as defined by\n * {@link Precision#equalsIncludingNaN(double,double) this method}.\n *\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension and\n * equal elements\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float[] x, float[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns {@code true} iff both arguments are {@code null} or have same\n * dimensions and all their elements are equal as defined by\n * {@link Precision#equals(double,double)}.\n *\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have same\n * dimension and equal elements.\n */\npublic static boolean equals(double[] x, double[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equals(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns {@code true} iff both arguments are {@code null} or have same\n * dimensions and all their elements are equal as defined by\n * {@link Precision#equalsIncludingNaN(double,double) this method}.\n *\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have same\n * dimension and equal elements.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double[] x, double[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "normalizeArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Normalizes an array to make it sum to a specified value.\n * Returns the result of the transformation\n * <pre>\n *    x |-> x * normalizedSum / sum\n * </pre>\n * applied to each non-NaN element x of the input array, where sum is the\n * sum of the non-NaN entries in the input array.\n * <p>\n * Throws IllegalArgumentException if {@code normalizedSum} is infinite\n * or NaN and ArithmeticException if the input array contains any infinite elements\n * or sums to 0.\n * <p>\n * Ignores (i.e., copies unchanged to the output array) NaNs in the input array.\n *\n * @param values Input array to be normalized\n * @param normalizedSum Target sum for the normalized array\n * @return the normalized array.\n * @throws MathArithmeticException if the input array contains infinite\n * elements or sums to zero.\n * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.\n * @since 2.1\n */\npublic static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n    }\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n    }\n    double sum = 0d;\n    final int len = values.length;\n    double[] out = new double[len];\n    for (int i = 0; i < len; i++) {\n        if (Double.isInfinite(values[i])) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n        }\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n    }\n    for (int i = 0; i < len; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Build an array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n *\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param length of the array\n * @return a new array\n * @since 3.2\n */\npublic static <T> T[] buildArray(final Field<T> field, final int length) {\n    // OK because field must be correct class\n    @SuppressWarnings(\"unchecked\")\n    T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);\n    Arrays.fill(array, field.getZero());\n    return array;\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Build a double dimension  array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n *\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param rows number of rows in the array\n * @param columns number of columns (may be negative to build partial\n * arrays in the same way <code>new Field[rows][]</code> works)\n * @return a new array\n * @since 3.2\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n    final T[][] array;\n    if (columns < 0) {\n        T[] dummyRow = buildArray(field, 0);\n        array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n    } else {\n        array = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { rows, columns });\n        for (int i = 0; i < rows; ++i) {\n            Arrays.fill(array[i], field.getZero());\n        }\n    }\n    return array;\n}"
            ],
            [
                "convolve",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the <a href=\"http://en.wikipedia.org/wiki/Convolution\">\n * convolution</a> between two sequences.\n * <p>\n * The solution is obtained via straightforward computation of the\n * convolution sum (and not via FFT). Whenever the computation needs\n * an element that would be located at an index outside the input arrays,\n * the value is assumed to be zero.\n *\n * @param x First sequence.\n * Typically, this sequence will represent an input signal to a system.\n * @param h Second sequence.\n * Typically, this sequence will represent the impulse response of the system.\n * @return the convolution of {@code x} and {@code h}.\n * This array's length will be {@code x.length + h.length - 1}.\n * @throws NullArgumentException if either {@code x} or {@code h} is {@code null}.\n * @throws NoDataException if either {@code x} or {@code h} is empty.\n *\n * @since 3.3\n */\npublic static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(x);\n    MathUtils.checkNotNull(h);\n    final int xLen = x.length;\n    final int hLen = h.length;\n    if (xLen == 0 || hLen == 0) {\n        throw new NoDataException();\n    }\n    // initialize the output array\n    final int totalLength = xLen + hLen - 1;\n    final double[] y = new double[totalLength];\n    // straightforward implementation of the convolution sum\n    for (int n = 0; n < totalLength; n++) {\n        double yn = 0;\n        int k = FastMath.max(0, n + 1 - xLen);\n        int j = n - k;\n        while (k < hLen && j >= 0) {\n            yn += x[j--] * h[k++];\n        }\n        y[n] = yn;\n    }\n    return y;\n}"
            ],
            [
                "natural",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array representing the natural number {@code n}.\n *\n * @param n Natural number.\n * @return an array whose entries are the numbers 0, 1, ..., {@code n}-1.\n * If {@code n == 0}, the returned array is empty.\n */\npublic static int[] natural(int n) {\n    return sequence(n, 0, 1);\n}"
            ],
            [
                "sequence",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array of {@code size} integers starting at {@code start},\n * skipping {@code stride} numbers.\n *\n * @param size Natural number.\n * @param start Natural number.\n * @param stride Natural number.\n * @return an array whose entries are the numbers\n * {@code start, start + stride, ..., start + (size - 1) * stride}.\n * If {@code size == 0}, the returned array is empty.\n *\n * @since 3.4\n */\npublic static int[] sequence(int size, int start, int stride) {\n    final int[] a = new int[size];\n    for (int i = 0; i < size; i++) {\n        a[i] = start + i * stride;\n    }\n    return a;\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the input parameters designate a subarray of positive length.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * positive length</li>\n * <li>throws <code>MathIllegalArgumentException</code> if the array is null or\n * or the indices are invalid</li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0.\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return true if the parameters are valid and designate a subarray of positive length\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return verifyValues(values, begin, length, false);\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the input parameters designate a subarray of positive length.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * non-negative length</li>\n * <li>throws <code>IllegalArgumentException</code> if the array is null or\n * or the indices are invalid</li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @param allowEmpty if <code>true</code> then zero length arrays are allowed\n * @return true if the parameters are valid\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {\n    if (values == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    if (begin < 0) {\n        throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));\n    }\n    if (length < 0) {\n        throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));\n    }\n    if (begin + length > values.length) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END, Integer.valueOf(begin + length), Integer.valueOf(values.length), true);\n    }\n    if (length == 0 && !allowEmpty) {\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the begin and length parameters designate a subarray of positive length\n * and the weights are all non-negative, non-NaN, finite, and not all zero.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * positive length and the weights array contains legitimate values.</li>\n * <li>throws <code>IllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li></ul>\n * </li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0.\n * </ul></p>\n *\n * @param values the input array\n * @param weights the weights array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return true if the parameters are valid and designate a subarray of positive length\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException {\n    return verifyValues(values, weights, begin, length, false);\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the begin and length parameters designate a subarray of positive length\n * and the weights are all non-negative, non-NaN, finite, and not all zero.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * non-negative length and the weights array contains legitimate values.</li>\n * <li>throws <code>MathIllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li></ul>\n * </li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>.\n * </ul></p>\n *\n * @param values the input array.\n * @param weights the weights array.\n * @param begin index of the first array element to include.\n * @param length the number of elements to include.\n * @param allowEmpty if {@code true} than allow zero length arrays to pass.\n * @return {@code true} if the parameters are valid.\n * @throws NullArgumentException if either of the arrays are null\n * @throws MathIllegalArgumentException if the array indices are not valid,\n * the weights array contains NaN, infinite or negative elements, or there\n * are no positive weights.\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {\n    if (weights == null || values == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    checkEqualLength(weights, values);\n    boolean containsPositiveWeight = false;\n    for (int i = begin; i < begin + length; i++) {\n        final double weight = weights[i];\n        if (Double.isNaN(weight)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_ELEMENT_AT_INDEX, Integer.valueOf(i));\n        }\n        if (Double.isInfinite(weight)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, Double.valueOf(weight), Integer.valueOf(i));\n        }\n        if (weight < 0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX, Integer.valueOf(i), Double.valueOf(weight));\n        }\n        if (!containsPositiveWeight && weight > 0.0) {\n            containsPositiveWeight = true;\n        }\n    }\n    if (!containsPositiveWeight) {\n        throw new MathIllegalArgumentException(LocalizedFormats.WEIGHT_AT_LEAST_ONE_NON_ZERO);\n    }\n    return verifyValues(values, begin, length, allowEmpty);\n}"
            ],
            [
                "concatenate",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Concatenates a sequence of arrays. The return array consists of the\n * entries of the input arrays concatenated in the order they appear in\n * the argument list.  Null arrays cause NullPointerExceptions; zero\n * length arrays are allowed (contributing nothing to the output array).\n *\n * @param x list of double[] arrays to concatenate\n * @return a new array consisting of the entries of the argument arrays\n * @throws NullPointerException if any of the arrays are null\n * @since 3.6\n */\npublic static double[] concatenate(double[]... x) {\n    int combinedLength = 0;\n    for (double[] a : x) {\n        combinedLength += a.length;\n    }\n    int offset = 0;\n    int curLength = 0;\n    final double[] combined = new double[combinedLength];\n    for (int i = 0; i < x.length; i++) {\n        curLength = x[i].length;\n        System.arraycopy(x[i], 0, combined, offset, curLength);\n        offset += curLength;\n    }\n    return combined;\n}"
            ],
            [
                "unique",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array consisting of the unique values in {@code data}.\n * The return array is sorted in descending order.  Empty arrays\n * are allowed, but null arrays result in NullPointerException.\n * Infinities are allowed.  NaN values are allowed with maximum\n * sort order - i.e., if there are NaN values in {@code data},\n * {@code Double.NaN} will be the first element of the output array,\n * even if the array also contains {@code Double.POSITIVE_INFINITY}.\n *\n * @param data array to scan\n * @return descending list of values included in the input array\n * @throws NullPointerException if data is null\n * @since 3.6\n */\npublic static double[] unique(double[] data) {\n    TreeSet<Double> values = new TreeSet<Double>();\n    for (int i = 0; i < data.length; i++) {\n        values.add(data[i]);\n    }\n    final int count = values.size();\n    final double[] out = new double[count];\n    Iterator<Double> iterator = values.iterator();\n    int i = 0;\n    while (iterator.hasNext()) {\n        out[count - ++i] = iterator.next();\n    }\n    return out;\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Pair",
                "/**\n * Convenience factory method that calls the\n * {@link #Pair(Object, Object) constructor}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param k First element of the pair.\n * @param v Second element of the pair.\n * @return a new {@code Pair} containing {@code k} and {@code v}.\n * @since 3.3\n */\npublic static <K, V> Pair<K, V> create(K k, V v) {\n    return new Pair<K, V>(k, v);\n}"
            ],
            [
                "slowCos",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n *  For x between 0 and pi/4 compute cosine using Talor series\n *  cos(x) = 1 - x^2/2! + x^4/4! ...\n * @param x number from which cosine is requested\n * @param result placeholder where to put the result in extended precision\n * (may be null)\n * @return cos(x)\n */\nstatic double slowCos(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        if ((i & 1) != 0) {\n            // skip odd entries\n            continue;\n        }\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        if ((i & 2) != 0) {\n            // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowSin",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * For x between 0 and pi/4 compute sine using Taylor expansion:\n * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...\n * @param x number from which sine is requested\n * @param result placeholder where to put the result in extended precision\n * (may be null)\n * @return sin(x)\n */\nstatic double slowSin(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        if ((i & 1) == 0) {\n            // Ignore even numbers\n            continue;\n        }\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        if ((i & 2) != 0) {\n            // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowexp",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n *  For x between 0 and 1, returns exp(x), uses extended precision\n *  @param x argument of exponential\n *  @param result placeholder where to place exp(x) split in two terms\n *  for extra precision (i.e. exp(x) = result[0] + result[1]\n *  @return exp(x)\n */\nstatic double slowexp(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "expint",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * Compute exp(p) for a integer p in extended precision.\n * @param p integer whose exponential is requested\n * @param result placeholder where to put the result in extended precision\n * @return exp(p) in standard precision (equal to result[0] + result[1])\n */\nstatic double expint(int p, final double[] result) {\n    //double x = M_E;\n    final double[] xs = new double[2];\n    final double[] as = new double[2];\n    final double[] ys = new double[2];\n    //split(x, xs);\n    //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n    //xs[0] = 2.71827697753906250000;\n    //xs[1] = 4.85091998273542816811e-06;\n    //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n    //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n    /* E */\n    xs[0] = 2.718281828459045;\n    xs[1] = 1.4456468917292502E-16;\n    split(1.0, ys);\n    while (p > 0) {\n        if ((p & 1) != 0) {\n            quadMult(ys, xs, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n        quadMult(xs, xs, as);\n        xs[0] = as[0];\n        xs[1] = as[1];\n        p >>= 1;\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n        resplit(result);\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowLog",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * xi in the range of [1, 2].\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      1-x           \\          3        5        7          /\n *\n * So, compute a Remez approximation of the following function\n *\n *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n *\n * This will be an even function with only positive coefficents.\n * x is in the range [0 - 1/3].\n *\n * Transform xi for input to the above function by setting\n * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n * the result is multiplied by x.\n * @param xi number from which log is requested\n * @return log(xi)\n */\nstatic double[] slowLog(double xi) {\n    double[] x = new double[2];\n    double[] x2 = new double[2];\n    double[] y = new double[2];\n    double[] a = new double[2];\n    split(xi, x);\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a, y);\n    x[0] = y[0];\n    x[1] = y[1];\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n    //x[0] -= 1.0;\n    //resplit(x);\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][1];\n    for (int i = LN_SPLIT_COEF.length - 2; i >= 0; i--) {\n        splitMult(y, x2, a);\n        y[0] = a[0];\n        y[1] = a[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a);\n        y[0] = a[0];\n        y[1] = a[1];\n    }\n    splitMult(y, x, a);\n    y[0] = a[0];\n    y[1] = a[1];\n    return y;\n}"
            ],
            [
                "format",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * Format a double.\n * @param d double number to format\n * @return formatted number\n */\nstatic String format(double d) {\n    if (d != d) {\n        return \"Double.NaN,\";\n    } else {\n        return ((d >= 0) ? \"+\" : \"\") + Double.toString(d) + \"d,\";\n    }\n}"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the square root of a number.\n * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n * @param a number on which evaluation is done\n * @return square root of a\n */\npublic static double sqrt(final double a) {\n    return Math.sqrt(a);\n}"
            ],
            [
                "cosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic cosine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic cosine of x\n */\npublic static double cosh(double x) {\n    if (x != x) {\n        return x;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        if (x >= LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(x);\n        }\n    } else if (x < -20) {\n        if (x <= -LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(-0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(-x);\n        }\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}"
            ],
            [
                "sinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic sine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic sine of x\n */\npublic static double sinh(double x) {\n    boolean negate = false;\n    if (x != x) {\n        return x;\n    }\n    // sinh[z] = (exp(z) - exp(-z) / 2\n    // for values of z larger than about 20,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        if (x >= LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(x);\n        }\n    } else if (x < -20) {\n        if (x <= -LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(-0.5 * x);\n            return (-0.5 * t) * t;\n        } else {\n            return -0.5 * exp(-x);\n        }\n    }\n    if (x == 0) {\n        return x;\n    }\n    if (x < 0.0) {\n        x = -x;\n        negate = true;\n    }\n    double result;\n    if (x > 0.25) {\n        double[] hiPrec = new double[2];\n        exp(x, 0.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n        // recip = 1/y\n        double recip = 1.0 / ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n        // Correct for rounding in division\n        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n        // Account for yb\n        recipb += -yb * recip * recip;\n        recipa = -recipa;\n        recipb = -recipb;\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n        result = ya + yb;\n        result *= 0.5;\n    } else {\n        double[] hiPrec = new double[2];\n        expm1(x, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n        double denom = 1.0 + ya;\n        double denomr = 1.0 / denom;\n        double denomb = -(denom - 1.0 - ya) + yb;\n        double ratio = ya * denomr;\n        double temp = ratio * HEX_40000000;\n        double ra = ratio + temp - temp;\n        double rb = ratio - ra;\n        temp = denom * HEX_40000000;\n        double za = denom + temp - temp;\n        double zb = denom - za;\n        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n        // Adjust for yb\n        // numerator\n        rb += yb * denomr;\n        // denominator\n        rb += -ya * denomb * denomr * denomr;\n        // y = y - 1/y\n        temp = ya + ra;\n        yb += -(temp - ya - ra);\n        ya = temp;\n        temp = ya + rb;\n        yb += -(temp - ya - rb);\n        ya = temp;\n        result = ya + yb;\n        result *= 0.5;\n    }\n    if (negate) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "tanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic tangent of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic tangent of x\n */\npublic static double tanh(double x) {\n    boolean negate = false;\n    if (x != x) {\n        return x;\n    }\n    // tanh[z] = sinh[z] / cosh[z]\n    // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n    // = (exp(2x) - 1) / (exp(2x) + 1)\n    // for magnitude > 20, sinh[z] == cosh[z] in double precision\n    if (x > 20.0) {\n        return 1.0;\n    }\n    if (x < -20) {\n        return -1.0;\n    }\n    if (x == 0) {\n        return x;\n    }\n    if (x < 0.0) {\n        x = -x;\n        negate = true;\n    }\n    double result;\n    if (x >= 0.5) {\n        double[] hiPrec = new double[2];\n        // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n        exp(x * 2.0, 0.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Numerator */\n        double na = -1.0 + ya;\n        double nb = -(na + 1.0 - ya);\n        double temp = na + yb;\n        nb += -(temp - na - yb);\n        na = temp;\n        /* Denominator */\n        double da = 1.0 + ya;\n        double db = -(da - 1.0 - ya);\n        temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n        result = ratioa + ratiob;\n    } else {\n        double[] hiPrec = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x * 2.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n        result = ratioa + ratiob;\n    }\n    if (negate) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "acosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic cosine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic cosine of a\n */\npublic static double acosh(final double a) {\n    return FastMath.log(a + FastMath.sqrt(a * a - 1));\n}"
            ],
            [
                "asinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic sine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic sine of a\n */\npublic static double asinh(double a) {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAsinh;\n    if (a > 0.167) {\n        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);\n        }\n    }\n    return negative ? -absAsinh : absAsinh;\n}"
            ],
            [
                "atanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic tangent of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic tangent of a\n */\npublic static double atanh(double a) {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.15) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n    return negative ? -absAtanh : absAtanh;\n}"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the signum of a number.\n * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\npublic static double signum(final double a) {\n    // return +0.0/-0.0/NaN depending on a\n    return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a);\n}"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the signum of a number.\n * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\npublic static float signum(final float a) {\n    // return +0.0/-0.0/NaN depending on a\n    return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a);\n}"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\npublic static double nextUp(final double a) {\n    return nextAfter(a, Double.POSITIVE_INFINITY);\n}"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\npublic static float nextUp(final float a) {\n    return nextAfter(a, Float.POSITIVE_INFINITY);\n}"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards negative infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards negative infinity\n * @since 3.4\n */\npublic static double nextDown(final double a) {\n    return nextAfter(a, Double.NEGATIVE_INFINITY);\n}"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards negative infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards negative infinity\n * @since 3.4\n */\npublic static float nextDown(final float a) {\n    return nextAfter(a, Float.NEGATIVE_INFINITY);\n}"
            ],
            [
                "random",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns a pseudo-random number between 0.0 and 1.0.\n * <p><b>Note:</b> this implementation currently delegates to {@link Math#random}\n * @return a random number between 0.0 and 1.0\n */\npublic static double random() {\n    return Math.random();\n}"
            ],
            [
                "exp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Exponential function.\n *\n * Computes exp(x), function result is nearly rounded.   It will be correctly\n * rounded to the theoretical value for 99.9% of input values, otherwise it will\n * have a 1 ULP error.\n *\n * Method:\n *    Lookup intVal = exp(int(x))\n *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );\n *    Compute z as the exponential of the remaining bits by a polynomial minus one\n *    exp(x) = intVal * fracVal * (1 + z)\n *\n * Accuracy:\n *    Calculation is done with 63 bits of precision, so result should be correctly\n *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n *\n * @param x   a double\n * @return double e<sup>x</sup>\n */\npublic static double exp(double x) {\n    return exp(x, 0.0, null);\n}"
            ],
            [
                "expm1",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute exp(x) - 1\n * @param x number to compute shifted exponential\n * @return exp(x) - 1\n */\npublic static double expm1(double x) {\n    return expm1(x, null);\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Natural logarithm.\n *\n * @param x   a double\n * @return log(x)\n */\npublic static double log(final double x) {\n    return log(x, null);\n}"
            ],
            [
                "log1p",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes log(1 + x).\n *\n * @param x Number.\n * @return {@code log(1 + x)}.\n */\npublic static double log1p(final double x) {\n    if (x == -1) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (x == Double.POSITIVE_INFINITY) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (x > 1e-6 || x < -1e-6) {\n        final double xpa = 1 + x;\n        final double xpb = -(xpa - 1 - x);\n        final double[] hiPrec = new double[2];\n        final double lores = log(xpa, hiPrec);\n        if (Double.isInfinite(lores)) {\n            // Don't allow this to be converted to NaN\n            return lores;\n        }\n        // Do a taylor series expansion around xpa:\n        //   f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2\n        final double fx1 = xpb / xpa;\n        final double epsilon = 0.5 * fx1 + 1;\n        return epsilon * fx1 + hiPrec[1] + hiPrec[0];\n    } else {\n        // Value is small |x| < 1e6, do a Taylor series centered on 1.\n        final double y = (x * F_1_3 - F_1_2) * x + 1;\n        return y * x;\n    }\n}"
            ],
            [
                "log10",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the base 10 logarithm.\n * @param x a number\n * @return log10(x)\n */\npublic static double log10(final double x) {\n    final double[] hiPrec = new double[2];\n    final double lores = log(x, hiPrec);\n    if (Double.isInfinite(lores)) {\n        // don't allow this to be converted to NaN\n        return lores;\n    }\n    final double tmp = hiPrec[0] * HEX_40000000;\n    final double lna = hiPrec[0] + tmp - tmp;\n    final double lnb = hiPrec[0] - lna + hiPrec[1];\n    final double rln10a = 0.4342944622039795;\n    final double rln10b = 1.9699272335463627E-8;\n    return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes the <a href=\"http://mathworld.wolfram.com/Logarithm.html\">\n * logarithm</a> in a given base.\n *\n * Returns {@code NaN} if either argument is negative.\n * If {@code base} is 0 and {@code x} is positive, 0 is returned.\n * If {@code base} is positive and {@code x} is 0,\n * {@code Double.NEGATIVE_INFINITY} is returned.\n * If both arguments are 0, the result is {@code NaN}.\n *\n * @param base Base of the logarithm, must be greater than 0.\n * @param x Argument, must be greater than 0.\n * @return the value of the logarithm, i.e. the number {@code y} such that\n * <code>base<sup>y</sup> = x</code>.\n * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double log(double base, double x) {\n    return log(x) / log(base);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Power function.  Compute x^y.\n *\n * @param x   a double\n * @param y   a double\n * @return double\n */\npublic static double pow(final double x, final double y) {\n    if (y == 0) {\n        // y = -0 or y = +0\n        return 1.0;\n    } else {\n        final long yBits = Double.doubleToRawLongBits(y);\n        final int yRawExp = (int) ((yBits & MASK_DOUBLE_EXPONENT) >> 52);\n        final long yRawMantissa = yBits & MASK_DOUBLE_MANTISSA;\n        final long xBits = Double.doubleToRawLongBits(x);\n        final int xRawExp = (int) ((xBits & MASK_DOUBLE_EXPONENT) >> 52);\n        final long xRawMantissa = xBits & MASK_DOUBLE_MANTISSA;\n        if (yRawExp > 1085) {\n            // y is either a very large integral value that does not fit in a long or it is a special number\n            if ((yRawExp == 2047 && yRawMantissa != 0) || (xRawExp == 2047 && xRawMantissa != 0)) {\n                // NaN\n                return Double.NaN;\n            } else if (xRawExp == 1023 && xRawMantissa == 0) {\n                // x = -1.0 or x = +1.0\n                if (yRawExp == 2047) {\n                    // y is infinite\n                    return Double.NaN;\n                } else {\n                    // y is a large even integer\n                    return 1.0;\n                }\n            } else {\n                // the absolute value of x is either greater or smaller than 1.0\n                // if yRawExp == 2047 and mantissa is 0, y = -infinity or y = +infinity\n                // if 1085 < yRawExp < 2047, y is simply a large number, however, due to limited\n                // accuracy, at this magnitude it behaves just like infinity with regards to x\n                if ((y > 0) ^ (xRawExp < 1023)) {\n                    // either y = +infinity (or large engouh) and abs(x) > 1.0\n                    // or     y = -infinity (or large engouh) and abs(x) < 1.0\n                    return Double.POSITIVE_INFINITY;\n                } else {\n                    // either y = +infinity (or large engouh) and abs(x) < 1.0\n                    // or     y = -infinity (or large engouh) and abs(x) > 1.0\n                    return +0.0;\n                }\n            }\n        } else {\n            // y is a regular non-zero number\n            if (yRawExp >= 1023) {\n                // y may be an integral value, which should be handled specifically\n                final long yFullMantissa = IMPLICIT_HIGH_BIT | yRawMantissa;\n                if (yRawExp < 1075) {\n                    // normal number with negative shift that may have a fractional part\n                    final long integralMask = (-1L) << (1075 - yRawExp);\n                    if ((yFullMantissa & integralMask) == yFullMantissa) {\n                        // all fractional bits are 0, the number is really integral\n                        final long l = yFullMantissa >> (1075 - yRawExp);\n                        return FastMath.pow(x, (y < 0) ? -l : l);\n                    }\n                } else {\n                    // normal number with positive shift, always an integral value\n                    // we know it fits in a primitive long because yRawExp > 1085 has been handled above\n                    final long l = yFullMantissa << (yRawExp - 1075);\n                    return FastMath.pow(x, (y < 0) ? -l : l);\n                }\n            }\n            // y is a non-integral value\n            if (x == 0) {\n                // x = -0 or x = +0\n                // the integer powers have already been handled above\n                return y < 0 ? Double.POSITIVE_INFINITY : +0.0;\n            } else if (xRawExp == 2047) {\n                if (xRawMantissa == 0) {\n                    // x = -infinity or x = +infinity\n                    return (y < 0) ? +0.0 : Double.POSITIVE_INFINITY;\n                } else {\n                    // NaN\n                    return Double.NaN;\n                }\n            } else if (x < 0) {\n                // the integer powers have already been handled above\n                return Double.NaN;\n            } else {\n                // this is the general case, for regular fractional numbers x and y\n                // Split y into ya and yb such that y = ya+yb\n                final double tmp = y * HEX_40000000;\n                final double ya = (y + tmp) - tmp;\n                final double yb = y - ya;\n                /* Compute ln(x) */\n                final double[] lns = new double[2];\n                final double lores = log(x, lns);\n                if (Double.isInfinite(lores)) {\n                    // don't allow this to be converted to NaN\n                    return lores;\n                }\n                double lna = lns[0];\n                double lnb = lns[1];\n                /* resplit lns */\n                final double tmp1 = lna * HEX_40000000;\n                final double tmp2 = (lna + tmp1) - tmp1;\n                lnb += lna - tmp2;\n                lna = tmp2;\n                // y*ln(x) = (aa+ab)\n                final double aa = lna * ya;\n                final double ab = lna * yb + lnb * ya + lnb * yb;\n                lna = aa + ab;\n                lnb = -(lna - aa - ab);\n                double z = 1.0 / 120.0;\n                z = z * lnb + (1.0 / 24.0);\n                z = z * lnb + (1.0 / 6.0);\n                z = z * lnb + 0.5;\n                z = z * lnb + 1.0;\n                z *= lnb;\n                final double result = exp(lna, z, null);\n                //result = result + result * z;\n                return result;\n            }\n        }\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Raise a double to an int power.\n *\n * @param d Number to raise.\n * @param e Exponent.\n * @return d<sup>e</sup>\n * @since 3.1\n */\npublic static double pow(double d, int e) {\n    return pow(d, (long) e);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Raise a double to a long power.\n *\n * @param d Number to raise.\n * @param e Exponent.\n * @return d<sup>e</sup>\n * @since 3.6\n */\npublic static double pow(double d, long e) {\n    if (e == 0) {\n        return 1.0;\n    } else if (e > 0) {\n        return new Split(d).pow(e).full;\n    } else {\n        return new Split(d).reciprocal().pow(-e).full;\n    }\n}"
            ],
            [
                "sin",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Sine function.\n *\n * @param x Argument.\n * @return sin(x)\n */\npublic static double sin(double x) {\n    boolean negative = false;\n    int quadrant = 0;\n    double xa;\n    double xb = 0.0;\n    /* Take absolute value of the input */\n    xa = x;\n    if (x < 0) {\n        negative = true;\n        xa = -xa;\n    }\n    /* Check for zero and negative zero */\n    if (xa == 0.0) {\n        long bits = Double.doubleToRawLongBits(x);\n        if (bits < 0) {\n            return -0.0;\n        }\n        return 0.0;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    if (negative) {\n        // Flip bit 1\n        quadrant ^= 2;\n    }\n    switch(quadrant) {\n        case 0:\n            return sinQ(xa, xb);\n        case 1:\n            return cosQ(xa, xb);\n        case 2:\n            return -sinQ(xa, xb);\n        case 3:\n            return -cosQ(xa, xb);\n        default:\n            return Double.NaN;\n    }\n}"
            ],
            [
                "cos",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Cosine function.\n *\n * @param x Argument.\n * @return cos(x)\n */\npublic static double cos(double x) {\n    int quadrant = 0;\n    /* Take absolute value of the input */\n    double xa = x;\n    if (x < 0) {\n        xa = -xa;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    double xb = 0;\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    //if (negative)\n    //  quadrant = (quadrant + 2) % 4;\n    switch(quadrant) {\n        case 0:\n            return cosQ(xa, xb);\n        case 1:\n            return -sinQ(xa, xb);\n        case 2:\n            return -cosQ(xa, xb);\n        case 3:\n            return sinQ(xa, xb);\n        default:\n            return Double.NaN;\n    }\n}"
            ],
            [
                "tan",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Tangent function.\n *\n * @param x Argument.\n * @return tan(x)\n */\npublic static double tan(double x) {\n    boolean negative = false;\n    int quadrant = 0;\n    /* Take absolute value of the input */\n    double xa = x;\n    if (x < 0) {\n        negative = true;\n        xa = -xa;\n    }\n    /* Check for zero and negative zero */\n    if (xa == 0.0) {\n        long bits = Double.doubleToRawLongBits(x);\n        if (bits < 0) {\n            return -0.0;\n        }\n        return 0.0;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    double xb = 0;\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    if (xa > 1.5) {\n        // Accuracy suffers between 1.5 and PI/2\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n        xa = a + b;\n        xb = -(xa - a - b);\n        quadrant ^= 1;\n        negative ^= true;\n    }\n    double result;\n    if ((quadrant & 1) == 0) {\n        result = tanQ(xa, xb, false);\n    } else {\n        result = -tanQ(xa, xb, true);\n    }\n    if (negative) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "atan",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Arctangent function\n *  @param x a number\n *  @return atan(x)\n */\npublic static double atan(double x) {\n    return atan(x, 0.0, false);\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Two arguments arctangent function\n * @param y ordinate\n * @param x abscissa\n * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\n */\npublic static double atan2(double y, double x) {\n    if (x != x || y != y) {\n        return Double.NaN;\n    }\n    if (y == 0) {\n        final double result = x * y;\n        final double invx = 1d / x;\n        final double invy = 1d / y;\n        if (invx == 0) {\n            // X is infinite\n            if (x > 0) {\n                // return +/- 0.0\n                return y;\n            } else {\n                return copySign(Math.PI, y);\n            }\n        }\n        if (x < 0 || invx < 0) {\n            if (y < 0 || invy < 0) {\n                return -Math.PI;\n            } else {\n                return Math.PI;\n            }\n        } else {\n            return result;\n        }\n    }\n    // y cannot now be zero\n    if (y == Double.POSITIVE_INFINITY) {\n        if (x == Double.POSITIVE_INFINITY) {\n            return Math.PI * F_1_4;\n        }\n        if (x == Double.NEGATIVE_INFINITY) {\n            return Math.PI * F_3_4;\n        }\n        return Math.PI * F_1_2;\n    }\n    if (y == Double.NEGATIVE_INFINITY) {\n        if (x == Double.POSITIVE_INFINITY) {\n            return -Math.PI * F_1_4;\n        }\n        if (x == Double.NEGATIVE_INFINITY) {\n            return -Math.PI * F_3_4;\n        }\n        return -Math.PI * F_1_2;\n    }\n    if (x == Double.POSITIVE_INFINITY) {\n        if (y > 0 || 1 / y > 0) {\n            return 0d;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -0d;\n        }\n    }\n    if (x == Double.NEGATIVE_INFINITY) {\n        if (y > 0.0 || 1 / y > 0.0) {\n            return Math.PI;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -Math.PI;\n        }\n    }\n    // Neither y nor x can be infinite or NAN here\n    if (x == 0) {\n        if (y > 0 || 1 / y > 0) {\n            return Math.PI * F_1_2;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -Math.PI * F_1_2;\n        }\n    }\n    // Compute ratio r = y/x\n    final double r = y / x;\n    if (Double.isInfinite(r)) {\n        // bypass calculations that can create NaN\n        return atan(r, 0, x < 0);\n    }\n    double ra = doubleHighPart(r);\n    double rb = r - ra;\n    // Split x\n    final double xa = doubleHighPart(x);\n    final double xb = x - xa;\n    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n    final double temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    if (ra == 0) {\n        // Fix up the sign so atan works correctly\n        ra = copySign(0d, y);\n    }\n    // Call atan\n    final double result = atan(ra, rb, x < 0);\n    return result;\n}"
            ],
            [
                "asin",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the arc sine of a number.\n * @param x number on which evaluation is done\n * @return arc sine of x\n */\npublic static double asin(double x) {\n    if (x != x) {\n        return Double.NaN;\n    }\n    if (x > 1.0 || x < -1.0) {\n        return Double.NaN;\n    }\n    if (x == 1.0) {\n        return Math.PI / 2.0;\n    }\n    if (x == -1.0) {\n        return -Math.PI / 2.0;\n    }\n    if (x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n    /* Split x */\n    double temp = x * HEX_40000000;\n    final double xa = x + temp - temp;\n    final double xb = x - xa;\n    /* Square it */\n    double ya = xa * xa;\n    double yb = xa * xb * 2.0 + xb * xb;\n    /* Subtract from 1 */\n    ya = -ya;\n    yb = -yb;\n    double za = 1.0 + ya;\n    double zb = -(za - 1.0 - ya);\n    temp = za + yb;\n    zb += -(temp - za - yb);\n    za = temp;\n    /* Square root */\n    double y;\n    y = sqrt(za);\n    temp = y * HEX_40000000;\n    ya = y + temp - temp;\n    yb = y - ya;\n    /* Extend precision of sqrt */\n    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);\n    /* Contribution of zb to sqrt */\n    double dx = zb / (2.0 * y);\n    // Compute ratio r = x/y\n    double r = x / y;\n    temp = r * HEX_40000000;\n    double ra = r + temp - temp;\n    double rb = r - ra;\n    // Correct for rounding in division\n    rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y;\n    // Add in effect additional bits of sqrt.\n    rb += -x * dx / y / y;\n    temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    return atan(ra, rb, false);\n}"
            ],
            [
                "acos",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the arc cosine of a number.\n * @param x number on which evaluation is done\n * @return arc cosine of x\n */\npublic static double acos(double x) {\n    if (x != x) {\n        return Double.NaN;\n    }\n    if (x > 1.0 || x < -1.0) {\n        return Double.NaN;\n    }\n    if (x == -1.0) {\n        return Math.PI;\n    }\n    if (x == 1.0) {\n        return 0.0;\n    }\n    if (x == 0) {\n        return Math.PI / 2.0;\n    }\n    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n    /* Split x */\n    double temp = x * HEX_40000000;\n    final double xa = x + temp - temp;\n    final double xb = x - xa;\n    /* Square it */\n    double ya = xa * xa;\n    double yb = xa * xb * 2.0 + xb * xb;\n    /* Subtract from 1 */\n    ya = -ya;\n    yb = -yb;\n    double za = 1.0 + ya;\n    double zb = -(za - 1.0 - ya);\n    temp = za + yb;\n    zb += -(temp - za - yb);\n    za = temp;\n    /* Square root */\n    double y = sqrt(za);\n    temp = y * HEX_40000000;\n    ya = y + temp - temp;\n    yb = y - ya;\n    /* Extend precision of sqrt */\n    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);\n    /* Contribution of zb to sqrt */\n    yb += zb / (2.0 * y);\n    y = ya + yb;\n    yb = -(y - ya - yb);\n    // Compute ratio r = y/x\n    double r = y / x;\n    // Did r overflow?\n    if (Double.isInfinite(r)) {\n        // x is effectively zero\n        // so return the appropriate value\n        return Math.PI / 2;\n    }\n    double ra = doubleHighPart(r);\n    double rb = r - ra;\n    // Correct for rounding in division\n    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n    // Add in effect additional bits of sqrt.\n    rb += yb / x;\n    temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    return atan(ra, rb, x < 0);\n}"
            ],
            [
                "cbrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the cubic root of a number.\n * @param x number on which evaluation is done\n * @return cubic root of x\n */\npublic static double cbrt(double x) {\n    /* Convert input double to bits */\n    long inbits = Double.doubleToRawLongBits(x);\n    int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n    boolean subnormal = false;\n    if (exponent == -1023) {\n        if (x == 0) {\n            return x;\n        }\n        /* Subnormal, so normalize */\n        subnormal = true;\n        // 2^54\n        x *= 1.8014398509481984E16;\n        inbits = Double.doubleToRawLongBits(x);\n        exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n    }\n    if (exponent == 1024) {\n        // Nan or infinity.  Don't care which.\n        return x;\n    }\n    /* Divide the exponent by 3 */\n    int exp3 = exponent / 3;\n    /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\n    double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long) (((exp3 + 1023) & 0x7ff)) << 52);\n    /* This will be a number between 1 and 2 */\n    final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n    /* Estimate the cube root of mant by polynomial */\n    double est = -0.010714690733195933;\n    est = est * mant + 0.0875862700108075;\n    est = est * mant + -0.3058015757857271;\n    est = est * mant + 0.7249995199969751;\n    est = est * mant + 0.5039018405998233;\n    est *= CBRTTWO[exponent % 3 + 2];\n    // est should now be good to about 15 bits of precision.   Do 2 rounds of\n    // Newton's method to get closer,  this should get us full double precision\n    // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n    final double xs = x / (p2 * p2 * p2);\n    est += (xs - est * est * est) / (3 * est * est);\n    est += (xs - est * est * est) / (3 * est * est);\n    // Do one round of Newton's method in extended precision to get the last bit right.\n    double temp = est * HEX_40000000;\n    double ya = est + temp - temp;\n    double yb = est - ya;\n    double za = ya * ya;\n    double zb = ya * yb * 2.0 + yb * yb;\n    temp = za * HEX_40000000;\n    double temp2 = za + temp - temp;\n    zb += za - temp2;\n    za = temp2;\n    zb = za * yb + ya * zb + zb * yb;\n    za *= ya;\n    double na = xs - za;\n    double nb = -(na - xs + za);\n    nb -= zb;\n    est += (na + nb) / (3 * est * est);\n    /* Scale by a power of two, so this is exact. */\n    est *= p2;\n    if (subnormal) {\n        // 2^-18\n        est *= 3.814697265625E-6;\n    }\n    return est;\n}"
            ],
            [
                "toRadians",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n *  Convert degrees to radians, with error of less than 0.5 ULP\n *  @param x angle in degrees\n *  @return x converted into radians\n */\npublic static double toRadians(double x) {\n    if (Double.isInfinite(x) || x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    // These are PI/180 split into high and low order bits\n    final double facta = 0.01745329052209854;\n    final double factb = 1.997844754509471E-9;\n    double xa = doubleHighPart(x);\n    double xb = x - xa;\n    double result = xb * factb + xb * facta + xa * factb + xa * facta;\n    if (result == 0) {\n        // ensure correct sign if calculation underflows\n        result *= x;\n    }\n    return result;\n}"
            ],
            [
                "toDegrees",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n *  Convert radians to degrees, with error of less than 0.5 ULP\n *  @param x angle in radians\n *  @return x converted into degrees\n */\npublic static double toDegrees(double x) {\n    if (Double.isInfinite(x) || x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    // These are 180/PI split into high and low order bits\n    final double facta = 57.2957763671875;\n    final double factb = 3.145894820876798E-6;\n    double xa = doubleHighPart(x);\n    double xb = x - xa;\n    return xb * factb + xb * facta + xa * factb + xa * facta;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static int abs(final int x) {\n    final int i = x >>> 31;\n    return (x ^ (~i + 1)) + i;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static long abs(final long x) {\n    final long l = x >>> 63;\n    // l is one if x negative zero else\n    // ~l+1 is zero if x is positive, -1 if x is negative\n    // x^(~l+1) is x is x is positive, ~x if x is negative\n    // add around\n    return (x ^ (~l + 1)) + l;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static float abs(final float x) {\n    return Float.intBitsToFloat(MASK_NON_SIGN_INT & Float.floatToRawIntBits(x));\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static double abs(double x) {\n    return Double.longBitsToDouble(MASK_NON_SIGN_LONG & Double.doubleToRawLongBits(x));\n}"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\npublic static double ulp(double x) {\n    if (Double.isInfinite(x)) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1));\n}"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\npublic static float ulp(float x) {\n    if (Float.isInfinite(x)) {\n        return Float.POSITIVE_INFINITY;\n    }\n    return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));\n}"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply a double number by a power of 2.\n * @param d number to multiply\n * @param n power of 2\n * @return d &times; 2<sup>n</sup>\n */\npublic static double scalb(final double d, final int n) {\n    // first simple and fast handling when 2^n can be represented using normal numbers\n    if ((n > -1023) && (n < 1024)) {\n        return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n    }\n    // handle special cases\n    if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n        return d;\n    }\n    if (n < -2098) {\n        return (d > 0) ? 0.0 : -0.0;\n    }\n    if (n > 2097) {\n        return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n    }\n    // decompose d\n    final long bits = Double.doubleToRawLongBits(d);\n    final long sign = bits & 0x8000000000000000L;\n    int exponent = ((int) (bits >>> 52)) & 0x7ff;\n    long mantissa = bits & 0x000fffffffffffffL;\n    // compute scaled exponent\n    int scaledExponent = exponent + n;\n    if (n < 0) {\n        // we are really in the case n <= -1023\n        if (scaledExponent > 0) {\n            // both the input and the result are normal numbers, we only adjust the exponent\n            return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n        } else if (scaledExponent > -53) {\n            // the input is a normal number and the result is a subnormal number\n            // recover the hidden mantissa bit\n            mantissa |= 1L << 52;\n            // scales down complete mantissa, hence losing least significant bits\n            final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n            mantissa >>>= 1 - scaledExponent;\n            if (mostSignificantLostBit != 0) {\n                // we need to add 1 bit to round up the result\n                mantissa++;\n            }\n            return Double.longBitsToDouble(sign | mantissa);\n        } else {\n            // no need to compute the mantissa, the number scales down to 0\n            return (sign == 0L) ? 0.0 : -0.0;\n        }\n    } else {\n        // we are really in the case n >= 1024\n        if (exponent == 0) {\n            // the input number is subnormal, normalize it\n            while ((mantissa >>> 52) != 1) {\n                mantissa <<= 1;\n                --scaledExponent;\n            }\n            ++scaledExponent;\n            mantissa &= 0x000fffffffffffffL;\n            if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        } else if (scaledExponent < 2047) {\n            return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n        } else {\n            return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n    }\n}"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply a float number by a power of 2.\n * @param f number to multiply\n * @param n power of 2\n * @return f &times; 2<sup>n</sup>\n */\npublic static float scalb(final float f, final int n) {\n    // first simple and fast handling when 2^n can be represented using normal numbers\n    if ((n > -127) && (n < 128)) {\n        return f * Float.intBitsToFloat((n + 127) << 23);\n    }\n    // handle special cases\n    if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n        return f;\n    }\n    if (n < -277) {\n        return (f > 0) ? 0.0f : -0.0f;\n    }\n    if (n > 276) {\n        return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n    }\n    // decompose f\n    final int bits = Float.floatToIntBits(f);\n    final int sign = bits & 0x80000000;\n    int exponent = (bits >>> 23) & 0xff;\n    int mantissa = bits & 0x007fffff;\n    // compute scaled exponent\n    int scaledExponent = exponent + n;\n    if (n < 0) {\n        // we are really in the case n <= -127\n        if (scaledExponent > 0) {\n            // both the input and the result are normal numbers, we only adjust the exponent\n            return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n        } else if (scaledExponent > -24) {\n            // the input is a normal number and the result is a subnormal number\n            // recover the hidden mantissa bit\n            mantissa |= 1 << 23;\n            // scales down complete mantissa, hence losing least significant bits\n            final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n            mantissa >>>= 1 - scaledExponent;\n            if (mostSignificantLostBit != 0) {\n                // we need to add 1 bit to round up the result\n                mantissa++;\n            }\n            return Float.intBitsToFloat(sign | mantissa);\n        } else {\n            // no need to compute the mantissa, the number scales down to 0\n            return (sign == 0) ? 0.0f : -0.0f;\n        }\n    } else {\n        // we are really in the case n >= 128\n        if (exponent == 0) {\n            // the input number is subnormal, normalize it\n            while ((mantissa >>> 23) != 1) {\n                mantissa <<= 1;\n                --scaledExponent;\n            }\n            ++scaledExponent;\n            mantissa &= 0x007fffff;\n            if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        } else if (scaledExponent < 255) {\n            return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n        } else {\n            return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n    }\n}"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the next machine representable number after a number, moving\n * in the direction of another number.\n * <p>\n * The ordering is as follows (increasing):\n * <ul>\n * <li>-INFINITY</li>\n * <li>-MAX_VALUE</li>\n * <li>-MIN_VALUE</li>\n * <li>-0.0</li>\n * <li>+0.0</li>\n * <li>+MIN_VALUE</li>\n * <li>+MAX_VALUE</li>\n * <li>+INFINITY</li>\n * <li></li>\n * <p>\n * If arguments compare equal, then the second argument is returned.\n * <p>\n * If {@code direction} is greater than {@code d},\n * the smallest machine representable number strictly greater than\n * {@code d} is returned; if less, then the largest representable number\n * strictly less than {@code d} is returned.</p>\n * <p>\n * If {@code d} is infinite and direction does not\n * bring it back to finite numbers, it is returned unchanged.</p>\n *\n * @param d base number\n * @param direction (the only important thing is whether\n * {@code direction} is greater or smaller than {@code d})\n * @return the next machine representable number in the specified direction\n */\npublic static double nextAfter(double d, double direction) {\n    // handling of some important special cases\n    if (Double.isNaN(d) || Double.isNaN(direction)) {\n        return Double.NaN;\n    } else if (d == direction) {\n        return direction;\n    } else if (Double.isInfinite(d)) {\n        return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n    } else if (d == 0) {\n        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n    }\n    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n    // are handled just as normal numbers\n    // can use raw bits since already dealt with infinity and NaN\n    final long bits = Double.doubleToRawLongBits(d);\n    final long sign = bits & 0x8000000000000000L;\n    if ((direction < d) ^ (sign == 0L)) {\n        return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n    } else {\n        return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n    }\n}"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the next machine representable number after a number, moving\n * in the direction of another number.\n * <p>\n * The ordering is as follows (increasing):\n * <ul>\n * <li>-INFINITY</li>\n * <li>-MAX_VALUE</li>\n * <li>-MIN_VALUE</li>\n * <li>-0.0</li>\n * <li>+0.0</li>\n * <li>+MIN_VALUE</li>\n * <li>+MAX_VALUE</li>\n * <li>+INFINITY</li>\n * <li></li>\n * <p>\n * If arguments compare equal, then the second argument is returned.\n * <p>\n * If {@code direction} is greater than {@code f},\n * the smallest machine representable number strictly greater than\n * {@code f} is returned; if less, then the largest representable number\n * strictly less than {@code f} is returned.</p>\n * <p>\n * If {@code f} is infinite and direction does not\n * bring it back to finite numbers, it is returned unchanged.</p>\n *\n * @param f base number\n * @param direction (the only important thing is whether\n * {@code direction} is greater or smaller than {@code f})\n * @return the next machine representable number in the specified direction\n */\npublic static float nextAfter(final float f, final double direction) {\n    // handling of some important special cases\n    if (Double.isNaN(f) || Double.isNaN(direction)) {\n        return Float.NaN;\n    } else if (f == direction) {\n        return (float) direction;\n    } else if (Float.isInfinite(f)) {\n        return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n    } else if (f == 0f) {\n        return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n    }\n    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n    // are handled just as normal numbers\n    final int bits = Float.floatToIntBits(f);\n    final int sign = bits & 0x80000000;\n    if ((direction < f) ^ (sign == 0)) {\n        return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n    } else {\n        return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1));\n    }\n}"
            ],
            [
                "floor",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the largest whole number smaller than x.\n * @param x number from which floor is requested\n * @return a double number f such that f is an integer f <= x < f + 1.0\n */\npublic static double floor(double x) {\n    long y;\n    if (x != x) {\n        // NaN\n        return x;\n    }\n    if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n        return x;\n    }\n    y = (long) x;\n    if (x < 0 && y != x) {\n        y--;\n    }\n    if (y == 0) {\n        return x * y;\n    }\n    return y;\n}"
            ],
            [
                "ceil",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the smallest whole number larger than x.\n * @param x number from which ceil is requested\n * @return a double number c such that c is an integer c - 1.0 < x <= c\n */\npublic static double ceil(double x) {\n    double y;\n    if (x != x) {\n        // NaN\n        return x;\n    }\n    y = floor(x);\n    if (y == x) {\n        return y;\n    }\n    y += 1.0;\n    if (y == 0) {\n        return x * y;\n    }\n    return y;\n}"
            ],
            [
                "rint",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\n * @param x number from which nearest whole number is requested\n * @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5\n */\npublic static double rint(double x) {\n    double y = floor(x);\n    double d = x - y;\n    if (d > 0.5) {\n        if (y == -1.0) {\n            // Preserve sign of operand\n            return -0.0;\n        }\n        return y + 1.0;\n    }\n    if (d < 0.5) {\n        return y;\n    }\n    /* half way, round to even */\n    long z = (long) y;\n    return (z & 1) == 0 ? y : y + 1.0;\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the closest long to x.\n * @param x number from which closest long is requested\n * @return closest long to x\n */\npublic static long round(double x) {\n    return (long) floor(x + 0.5);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the closest int to x.\n * @param x number from which closest int is requested\n * @return closest int to x\n */\npublic static int round(final float x) {\n    return (int) floor(x + 0.5f);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static int min(final int a, final int b) {\n    return (a <= b) ? a : b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static long min(final long a, final long b) {\n    return (a <= b) ? a : b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static float min(final float a, final float b) {\n    if (a > b) {\n        return b;\n    }\n    if (a < b) {\n        return a;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Float.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */\n    int bits = Float.floatToRawIntBits(a);\n    if (bits == 0x80000000) {\n        return a;\n    }\n    return b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static double min(final double a, final double b) {\n    if (a > b) {\n        return b;\n    }\n    if (a < b) {\n        return a;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Double.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n    long bits = Double.doubleToRawLongBits(a);\n    if (bits == 0x8000000000000000L) {\n        return a;\n    }\n    return b;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static int max(final int a, final int b) {\n    return (a <= b) ? b : a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static long max(final long a, final long b) {\n    return (a <= b) ? b : a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static float max(final float a, final float b) {\n    if (a > b) {\n        return a;\n    }\n    if (a < b) {\n        return b;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Float.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */\n    int bits = Float.floatToRawIntBits(a);\n    if (bits == 0x80000000) {\n        return b;\n    }\n    return a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static double max(final double a, final double b) {\n    if (a > b) {\n        return a;\n    }\n    if (a < b) {\n        return b;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Double.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n    long bits = Double.doubleToRawLongBits(a);\n    if (bits == 0x8000000000000000L) {\n        return b;\n    }\n    return a;\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n */\npublic static double hypot(final double x, final double y) {\n    if (Double.isInfinite(x) || Double.isInfinite(y)) {\n        return Double.POSITIVE_INFINITY;\n    } else if (Double.isNaN(x) || Double.isNaN(y)) {\n        return Double.NaN;\n    } else {\n        final int expX = getExponent(x);\n        final int expY = getExponent(y);\n        if (expX > expY + 27) {\n            // y is neglectible with respect to x\n            return abs(x);\n        } else if (expY > expX + 27) {\n            // x is neglectible with respect to y\n            return abs(y);\n        } else {\n            // find an intermediate scale to avoid both overflow and underflow\n            final int middleExp = (expX + expY) / 2;\n            // scale parameters without losing precision\n            final double scaledX = scalb(x, -middleExp);\n            final double scaledY = scalb(y, -middleExp);\n            // compute scaled hypotenuse\n            final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n            // remove scaling\n            return scalb(scaledH, middleExp);\n        }\n    }\n}"
            ],
            [
                "IEEEremainder",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes the remainder as prescribed by the IEEE 754 standard.\n * The remainder value is mathematically equal to {@code x - y*n}\n * where {@code n} is the mathematical integer closest to the exact mathematical value\n * of the quotient {@code x/y}.\n * If two mathematical integers are equally close to {@code x/y} then\n * {@code n} is the integer that is even.\n * <p>\n * <ul>\n * <li>If either operand is NaN, the result is NaN.</li>\n * <li>If the result is not NaN, the sign of the result equals the sign of the dividend.</li>\n * <li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.</li>\n * <li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</li>\n * <li>If the dividend is a zero and the divisor is finite, the result equals the dividend.</li>\n * </ul>\n * <p><b>Note:</b> this implementation currently delegates to {@link StrictMath#IEEEremainder}\n * @param dividend the number to be divided\n * @param divisor the number by which to divide\n * @return the remainder, rounded\n */\npublic static double IEEEremainder(double dividend, double divisor) {\n    // TODO provide our own implementation\n    return StrictMath.IEEEremainder(dividend, divisor);\n}"
            ],
            [
                "toIntExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Convert a long to interger, detecting overflows\n * @param n number to convert to int\n * @return integer with same valie as n if no overflows occur\n * @exception MathArithmeticException if n cannot fit into an int\n * @since 3.4\n */\npublic static int toIntExact(final long n) throws MathArithmeticException {\n    if (n < Integer.MIN_VALUE || n > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    }\n    return (int) n;\n}"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Increment a number, detecting overflows.\n * @param n number to increment\n * @return n+1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int incrementExact(final int n) throws MathArithmeticException {\n    if (n == Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);\n    }\n    return n + 1;\n}"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Increment a number, detecting overflows.\n * @param n number to increment\n * @return n+1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long incrementExact(final long n) throws MathArithmeticException {\n    if (n == Long.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);\n    }\n    return n + 1;\n}"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Decrement a number, detecting overflows.\n * @param n number to decrement\n * @return n-1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int decrementExact(final int n) throws MathArithmeticException {\n    if (n == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);\n    }\n    return n - 1;\n}"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Decrement a number, detecting overflows.\n * @param n number to decrement\n * @return n-1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long decrementExact(final long n) throws MathArithmeticException {\n    if (n == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);\n    }\n    return n - 1;\n}"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Add two numbers, detecting overflows.\n * @param a first number to add\n * @param b second number to add\n * @return a+b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int addExact(final int a, final int b) throws MathArithmeticException {\n    // compute sum\n    final int sum = a + b;\n    // check for overflow\n    if ((a ^ b) >= 0 && (sum ^ b) < 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);\n    }\n    return sum;\n}"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Add two numbers, detecting overflows.\n * @param a first number to add\n * @param b second number to add\n * @return a+b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long addExact(final long a, final long b) throws MathArithmeticException {\n    // compute sum\n    final long sum = a + b;\n    // check for overflow\n    if ((a ^ b) >= 0 && (sum ^ b) < 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);\n    }\n    return sum;\n}"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Subtract two numbers, detecting overflows.\n * @param a first number\n * @param b second number to subtract from a\n * @return a-b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int subtractExact(final int a, final int b) {\n    // compute subtraction\n    final int sub = a - b;\n    // check for overflow\n    if ((a ^ b) < 0 && (sub ^ b) >= 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);\n    }\n    return sub;\n}"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Subtract two numbers, detecting overflows.\n * @param a first number\n * @param b second number to subtract from a\n * @return a-b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long subtractExact(final long a, final long b) {\n    // compute subtraction\n    final long sub = a - b;\n    // check for overflow\n    if ((a ^ b) < 0 && (sub ^ b) >= 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);\n    }\n    return sub;\n}"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply two numbers, detecting overflows.\n * @param a first number to multiply\n * @param b second number to multiply\n * @return a*b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int multiplyExact(final int a, final int b) {\n    if (((b > 0) && (a > Integer.MAX_VALUE / b || a < Integer.MIN_VALUE / b)) || ((b < -1) && (a > Integer.MIN_VALUE / b || a < Integer.MAX_VALUE / b)) || ((b == -1) && (a == Integer.MIN_VALUE))) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);\n    }\n    return a * b;\n}"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply two numbers, detecting overflows.\n * @param a first number to multiply\n * @param b second number to multiply\n * @return a*b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long multiplyExact(final long a, final long b) {\n    if (((b > 0l) && (a > Long.MAX_VALUE / b || a < Long.MIN_VALUE / b)) || ((b < -1l) && (a > Long.MIN_VALUE / b || a < Long.MAX_VALUE / b)) || ((b == -1l) && (a == Long.MIN_VALUE))) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);\n    }\n    return a * b;\n}"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer division when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorMod(int, int)\n * @since 3.4\n */\npublic static int floorDiv(final int a, final int b) throws MathArithmeticException {\n    if (b == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final int m = a % b;\n    if ((a ^ b) >= 0 || m == 0) {\n        // a an b have same sign, or division is exact\n        return a / b;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return (a / b) - 1;\n    }\n}"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer division when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorMod(long, long)\n * @since 3.4\n */\npublic static long floorDiv(final long a, final long b) throws MathArithmeticException {\n    if (b == 0l) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final long m = a % b;\n    if ((a ^ b) >= 0l || m == 0l) {\n        // a an b have same sign, or division is exact\n        return a / b;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return (a / b) - 1l;\n    }\n}"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer modulo when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorDiv(int, int)\n * @since 3.4\n */\npublic static int floorMod(final int a, final int b) throws MathArithmeticException {\n    if (b == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final int m = a % b;\n    if ((a ^ b) >= 0 || m == 0) {\n        // a an b have same sign, or division is exact\n        return m;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return b + m;\n    }\n}"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer modulo when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorDiv(long, long)\n * @since 3.4\n */\npublic static long floorMod(final long a, final long b) {\n    if (b == 0l) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final long m = a % b;\n    if ((a ^ b) >= 0l || m == 0l) {\n        // a an b have same sign, or division is exact\n        return m;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return b + m;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the first argument with the sign of the second argument.\n * A NaN {@code sign} argument is treated as positive.\n *\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\npublic static double copySign(double magnitude, double sign) {\n    // The highest order bit is going to be zero if the\n    // highest order bit of m and s is the same and one otherwise.\n    // So (m^s) will be positive if both m and s have the same sign\n    // and negative otherwise.\n    // don't care about NaN\n    final long m = Double.doubleToRawLongBits(magnitude);\n    final long s = Double.doubleToRawLongBits(sign);\n    if ((m ^ s) >= 0) {\n        return magnitude;\n    }\n    // flip sign\n    return -magnitude;\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the first argument with the sign of the second argument.\n * A NaN {@code sign} argument is treated as positive.\n *\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\npublic static float copySign(float magnitude, float sign) {\n    // The highest order bit is going to be zero if the\n    // highest order bit of m and s is the same and one otherwise.\n    // So (m^s) will be positive if both m and s have the same sign\n    // and negative otherwise.\n    final int m = Float.floatToRawIntBits(magnitude);\n    final int s = Float.floatToRawIntBits(sign);\n    if ((m ^ s) >= 0) {\n        return magnitude;\n    }\n    // flip sign\n    return -magnitude;\n}"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Return the exponent of a double number, removing the bias.\n * <p>\n * For double numbers of the form 2<sup>x</sup>, the unbiased\n * exponent is exactly x.\n * </p>\n * @param d number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\npublic static int getExponent(final double d) {\n    // NaN and Infinite will return 1024 anywho so can use raw bits\n    return (int) ((Double.doubleToRawLongBits(d) >>> 52) & 0x7ff) - 1023;\n}"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Return the exponent of a float number, removing the bias.\n * <p>\n * For float numbers of the form 2<sup>x</sup>, the unbiased\n * exponent is exactly x.\n * </p>\n * @param f number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\npublic static int getExponent(final float f) {\n    // NaN and Infinite will return the same exponent anywho so can use raw bits\n    return ((Float.floatToRawIntBits(f) >>> 23) & 0xff) - 127;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "BigRealField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static BigRealField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "Decimal64Field",
                "/**\n * Returns the unique instance of this class.\n *\n * @return the unique instance of this class\n */\npublic static final Decimal64Field getInstance() {\n    return INSTANCE;\n}"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns an integer hash code representing the given double value.\n *\n * @param value the value to be hashed\n * @return the hash code\n */\npublic static int hash(double value) {\n    return new Double(value).hashCode();\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns {@code true} if the values are equal according to semantics of\n * {@link Double#equals(Object)}.\n *\n * @param x Value\n * @param y Value\n * @return {@code new Double(x).equals(new Double(y))}\n */\npublic static boolean equals(double x, double y) {\n    return new Double(x).equals(new Double(y));\n}"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns an integer hash code representing the given double array.\n *\n * @param value the value to be hashed (may be null)\n * @return the hash code\n * @since 1.2\n */\npublic static int hash(double[] value) {\n    return Arrays.hashCode(value);\n}"
            ],
            [
                "normalizeAngle",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Normalize an angle in a 2&pi; wide interval around a center value.\n * <p>This method has three main uses:</p>\n * <ul>\n *   <li>normalize an angle between 0 and 2&pi;:<br/>\n *       {@code a = MathUtils.normalizeAngle(a, FastMath.PI);}</li>\n *   <li>normalize an angle between -&pi; and +&pi;<br/>\n *       {@code a = MathUtils.normalizeAngle(a, 0.0);}</li>\n *   <li>compute the angle between two defining angular positions:<br>\n *       {@code angle = MathUtils.normalizeAngle(end, start) - start;}</li>\n * </ul>\n * <p>Note that due to numerical accuracy and since &pi; cannot be represented\n * exactly, the result interval is <em>closed</em>, it cannot be half-closed\n * as would be more satisfactory in a purely mathematical view.</p>\n * @param a angle to normalize\n * @param center center of the desired 2&pi; interval for the result\n * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;\n * @since 1.2\n */\npublic static double normalizeAngle(double a, double center) {\n    return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Find the maximum of two field elements.\n * @param <T> the type of the field elements\n * @param e1 first element\n * @param e2 second element\n * @return max(a1, e2)\n * @since 3.6\n */\npublic static <T extends RealFieldElement<T>> T max(final T e1, final T e2) {\n    return e1.subtract(e2).getReal() >= 0 ? e1 : e2;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Find the minimum of two field elements.\n * @param <T> the type of the field elements\n * @param e1 first element\n * @param e2 second element\n * @return min(a1, e2)\n * @since 3.6\n */\npublic static <T extends RealFieldElement<T>> T min(final T e1, final T e2) {\n    return e1.subtract(e2).getReal() >= 0 ? e2 : e1;\n}"
            ],
            [
                "reduce",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * <p>Reduce {@code |a - offset|} to the primary interval\n * {@code [0, |period|)}.</p>\n *\n * <p>Specifically, the value returned is <br/>\n * {@code a - |period| * floor((a - offset) / |period|) - offset}.</p>\n *\n * <p>If any of the parameters are {@code NaN} or infinite, the result is\n * {@code NaN}.</p>\n *\n * @param a Value to reduce.\n * @param period Period.\n * @param offset Value that will be mapped to {@code 0}.\n * @return the value, within the interval {@code [0 |period|)},\n * that corresponds to {@code a}.\n */\npublic static double reduce(double a, double period, double offset) {\n    final double p = FastMath.abs(period);\n    return a - p * FastMath.floor((a - offset) / p) - offset;\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Byte.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static byte copySign(byte magnitude, byte sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Byte.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return (byte) -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Short.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static short copySign(short magnitude, short sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Short.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return (short) -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Integer.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static int copySign(int magnitude, int sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Long.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static long copySign(long magnitude, long sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return -magnitude;\n    }\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getInstance()} with the only customizing that the\n * maximum number of fraction digits is set to 10.\n * @return the default number format.\n */\npublic static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n * customizing that the maximum number of fraction digits is set to 10.\n * @param locale the specific locale used by the format.\n * @return the default number format specific to the given locale.\n */\npublic static NumberFormat getDefaultNumberFormat(final Locale locale) {\n    final NumberFormat nf = NumberFormat.getInstance(locale);\n    nf.setMaximumFractionDigits(10);\n    return nf;\n}"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parses <code>source</code> until a non-whitespace character is found.\n *\n * @param source the string to parse\n * @param pos input/output parsing parameter.\n * @return the first non-whitespace character.\n */\npublic static char parseNextCharacter(final String source, final ParsePosition pos) {\n    int index = pos.getIndex();\n    final int n = source.length();\n    char ret = 0;\n    if (index < n) {\n        char c;\n        do {\n            c = source.charAt(index++);\n        } while (Character.isWhitespace(c) && index < n);\n        pos.setIndex(index);\n        if (index < n) {\n            ret = c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "parseNumber",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parses <code>source</code> for a number.  This method can parse normal,\n * numeric values as well as special values.  These special values include\n * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n *\n * @param source the string to parse\n * @param format the number format used to parse normal, numeric values.\n * @param pos input/output parsing parameter.\n * @return the parsed number.\n */\npublic static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos) {\n    final int startIndex = pos.getIndex();\n    Number number = format.parse(source, pos);\n    final int endIndex = pos.getIndex();\n    // check for error parsing number\n    if (startIndex == endIndex) {\n        // try parsing special numbers\n        final double[] special = { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY };\n        for (int i = 0; i < special.length; ++i) {\n            number = parseNumber(source, special[i], pos);\n            if (number != null) {\n                break;\n            }\n        }\n    }\n    return number;\n}"
            ],
            [
                "parseFixedstring",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parse <code>source</code> for an expected fixed string.\n * @param source the string to parse\n * @param expected expected string\n * @param pos input/output parsing parameter.\n * @return true if the expected string was there\n */\npublic static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos) {\n    final int startIndex = pos.getIndex();\n    final int endIndex = startIndex + expected.length();\n    if ((startIndex >= source.length()) || (endIndex > source.length()) || (source.substring(startIndex, endIndex).compareTo(expected) != 0)) {\n        // set index back to start, error index should be the start index\n        pos.setIndex(startIndex);\n        pos.setErrorIndex(startIndex);\n        return false;\n    }\n    // the string was here\n    pos.setIndex(endIndex);\n    return true;\n}"
            ],
            [
                "formatDouble",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Formats a double value to produce a string.  In general, the value is\n * formatted using the formatting rules of <code>format</code>.  There are\n * three exceptions to this:\n * <ol>\n * <li>NaN is formatted as '(NaN)'</li>\n * <li>Positive infinity is formatted as '(Infinity)'</li>\n * <li>Negative infinity is formatted as '(-Infinity)'</li>\n * </ol>\n *\n * @param value the double to format.\n * @param format the format used.\n * @param toAppendTo where the text is to be appended\n * @param pos On input: an alignment field, if desired. On output: the\n *            offsets of the alignment field\n * @return the value passed in as toAppendTo.\n */\npublic static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos) {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n        toAppendTo.append('(');\n        toAppendTo.append(value);\n        toAppendTo.append(')');\n    } else {\n        format.format(value, toAppendTo, pos);\n    }\n    return toAppendTo;\n}"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Creates a sequence {@code [start .. end]}.\n * It calls {@link #range(int,int,int) range(start, end, 1)}.\n *\n * @param start First value of the range.\n * @param end Last value of the range.\n * @return a range.\n */\npublic static Range range(int start, int end) {\n    return range(start, end, 1);\n}"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Creates a sequence \\( a_i, i < 0 <= n \\)\n * where \\( a_i = start + i * step \\)\n * and \\( n \\) is such that \\( a_n <= max \\) and \\( a_{n+1} > max \\).\n *\n * @param start First value of the range.\n * @param max Last value of the range that satisfies the above\n * construction rule.\n * @param step Increment.\n * @return a range.\n */\npublic static Range range(final int start, final int max, final int step) {\n    return new Range(start, max, step);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Factory method that creates a default instance.\n * The initial and maximal values are set to 0.\n * For the new instance to be useful, the maximal count must be set\n * by calling {@link #withMaximalCount(int) withMaximalCount}.\n *\n * @return an new instance.\n */\npublic static Incrementor create() {\n    return new Incrementor(0, 0, 1, CALLBACK);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Incrementor",
                "/**\n * Factory method that creates a default instance.\n * The initial and maximal values are set to 0.\n * For the new instance to be useful, the maximal count must be set\n * by calling {@link #withMaximalCount(int) withMaximalCount}.\n *\n * @return an new instance.\n */\npublic static Incrementor create() {\n    return new Incrementor(0, 0, 1, CALLBACK);\n}"
            ],
            [
                "loadExpIntA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_INT_A\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpIntA() {\n    return EXP_INT_A.clone();\n}"
            ],
            [
                "loadExpIntB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_INT_B\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpIntB() {\n    return EXP_INT_B.clone();\n}"
            ],
            [
                "loadExpFracA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_FRAC_A\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpFracA() {\n    return EXP_FRAC_A.clone();\n}"
            ],
            [
                "loadExpFracB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_FRAC_B\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpFracB() {\n    return EXP_FRAC_B.clone();\n}"
            ],
            [
                "loadLnMant",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"LN_MANT\".\n *\n * @return a clone of the data array.\n */\nstatic double[][] loadLnMant() {\n    return LN_MANT.clone();\n}"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns an exact representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which all coefficients are\n * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n * {@code Long.MAX_VALUE} a {@code MathArithMeticException} is\n * thrown.</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    // Use symmetry for large k\n    if (k > n / 2) {\n        return binomialCoefficient(n, n - k);\n    }\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    long result = 1;\n    if (n <= 61) {\n        // For n <= 61, the naive implementation cannot overflow.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            result = result * i / j;\n            i++;\n        }\n    } else if (n <= 66) {\n        // For n > 61 but n <= 66, the result cannot overflow,\n        // but we must take care not to overflow intermediate values.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            // We know that (result * i) is divisible by j,\n            // but (result * i) may overflow, so we split j:\n            // Filter out the gcd, d, so j/d and i/d are integer.\n            // result is divisible by (j/d) because (j/d)\n            // is relative prime to (i/d) and is a divisor of\n            // result * (i/d).\n            final long d = ArithmeticUtils.gcd(i, j);\n            result = (result / (j / d)) * (i / d);\n            i++;\n        }\n    } else {\n        // For n > 66, a result overflow might occur, so we check\n        // the multiplication, taking care to not overflow\n        // unnecessary.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            final long d = ArithmeticUtils.gcd(i, j);\n            result = ArithmeticUtils.mulAndCheck(result / (j / d), i / d);\n            i++;\n        }\n    }\n    return result;\n}"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns a {@code double} representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code double}. The\n * largest value of {@code n} for which all coefficients are less than\n * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n * Double.POSITIVE_INFINITY is returned</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 1d;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    if (k > n / 2) {\n        return binomialCoefficientDouble(n, n - k);\n    }\n    if (n < 67) {\n        return binomialCoefficient(n, k);\n    }\n    double result = 1d;\n    for (int i = 1; i <= k; i++) {\n        result *= (double) (n - k + i) / (double) i;\n    }\n    return FastMath.floor(result + 0.5);\n}"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns the natural {@code log} of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 0;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return FastMath.log(n);\n    }\n    /*\n         * For values small enough to do exact integer computation,\n         * return the log of the exact value\n         */\n    if (n < 67) {\n        return FastMath.log(binomialCoefficient(n, k));\n    }\n    /*\n         * Return the log of binomialCoefficientDouble for values that will not\n         * overflow binomialCoefficientDouble\n         */\n    if (n < 1030) {\n        return FastMath.log(binomialCoefficientDouble(n, k));\n    }\n    if (k > n / 2) {\n        return binomialCoefficientLog(n, n - k);\n    }\n    /*\n         * Sum logs for values that could overflow\n         */\n    double logSum = 0;\n    // n!/(n-k)!\n    for (int i = n - k + 1; i <= n; i++) {\n        logSum += FastMath.log(i);\n    }\n    // divide by k!\n    for (int i = 2; i <= k; i++) {\n        logSum -= FastMath.log(i);\n    }\n    return logSum;\n}"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns n!. Shorthand for {@code n} <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers {@code 1,...,n}.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code n >= 0} (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which {@code n!} does not exceed\n * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n * an {@code MathArithMeticException } is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return {@code n!}\n * @throws MathArithmeticException if the result is too large to be represented\n * by a {@code long}.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n * large to fit in a {@code long}.\n */\npublic static long factorial(final int n) throws NotPositiveException, MathArithmeticException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n > 20) {\n        throw new MathArithmeticException();\n    }\n    return FACTORIALS[n];\n}"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n * {@code double}.\n * The result should be small enough to fit into a {@code double}: The\n * largest {@code n} for which {@code n!} does not exceed\n * {@code Double.MAX_VALUE} is 170. If the computed value exceeds\n * {@code Double.MAX_VALUE}, {@code Double.POSITIVE_INFINITY} is returned.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n */\npublic static double factorialDouble(final int n) throws NotPositiveException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n < 21) {\n        return FACTORIALS[n];\n    }\n    return FastMath.floor(FastMath.exp(CombinatoricsUtils.factorialLog(n)) + 0.5);\n}"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Compute the natural logarithm of the factorial of {@code n}.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n */\npublic static double factorialLog(final int n) throws NotPositiveException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n < 21) {\n        return FastMath.log(FACTORIALS[n]);\n    }\n    double logSum = 0;\n    for (int i = 2; i <= n; i++) {\n        logSum += FastMath.log(i);\n    }\n    return logSum;\n}"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns the <a\n * href=\"http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html\">\n * Stirling number of the second kind</a>, \"{@code S(n,k)}\", the number of\n * ways of partitioning an {@code n}-element set into {@code k} non-empty\n * subsets.\n * <p>\n * The preconditions are {@code 0 <= k <= n } (otherwise\n * {@code NotPositiveException} is thrown)\n * </p>\n * @param n the size of the set\n * @param k the number of non-empty subsets\n * @return {@code S(n,k)}\n * @throws NotPositiveException if {@code k < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\n * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)\n * @since 3.1\n */\npublic static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    if (k < 0) {\n        throw new NotPositiveException(k);\n    }\n    if (k > n) {\n        throw new NumberIsTooLargeException(k, n, true);\n    }\n    long[][] stirlingS2 = STIRLING_S2.get();\n    if (stirlingS2 == null) {\n        // the cache has never been initialized, compute the first numbers\n        // by direct recurrence relation\n        // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n        // we must stop computation at row 26\n        final int maxIndex = 26;\n        stirlingS2 = new long[maxIndex][];\n        stirlingS2[0] = new long[] { 1l };\n        for (int i = 1; i < stirlingS2.length; ++i) {\n            stirlingS2[i] = new long[i + 1];\n            stirlingS2[i][0] = 0;\n            stirlingS2[i][1] = 1;\n            stirlingS2[i][i] = 1;\n            for (int j = 2; j < i; ++j) {\n                stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n            }\n        }\n        // atomically save the cache\n        STIRLING_S2.compareAndSet(null, stirlingS2);\n    }\n    if (n < stirlingS2.length) {\n        // the number is in the small cache\n        return stirlingS2[n][k];\n    } else {\n        // use explicit formula to compute the number without caching it\n        if (k == 0) {\n            return 0;\n        } else if (k == 1 || k == n) {\n            return 1;\n        } else if (k == 2) {\n            return (1l << (n - 1)) - 1l;\n        } else if (k == n - 1) {\n            return binomialCoefficient(n, 2);\n        } else {\n            // definition formula: note that this may trigger some overflow\n            long sum = 0;\n            long sign = ((k & 0x1) == 0) ? 1 : -1;\n            for (int j = 1; j <= k; ++j) {\n                sign = -sign;\n                sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                if (sum < 0) {\n                    // there was an overflow somewhere\n                    throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN, n, 0, stirlingS2.length - 1);\n                }\n            }\n            return sum / factorial(k);\n        }\n    }\n}"
            ],
            [
                "combinationsIterator",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns an iterator whose range is the k-element subsets of {0, ..., n - 1}\n * represented as {@code int[]} arrays.\n * <p>\n * The arrays returned by the iterator are sorted in descending order and\n * they are visited in lexicographic order with significance from right to\n * left. For example, combinationsIterator(4, 2) returns an Iterator that\n * will generate the following sequence of arrays on successive calls to\n * {@code next()}:</p><p>\n * {@code [0, 1], [0, 2], [1, 2], [0, 3], [1, 3], [2, 3]}\n * </p><p>\n * If {@code k == 0} an Iterator containing an empty array is returned and\n * if {@code k == n} an Iterator containing [0, ..., n -1] is returned.</p>\n *\n * @param n Size of the set from which subsets are selected.\n * @param k Size of the subsets to be enumerated.\n * @return an {@link Iterator iterator} over the k-sets in n.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n */\npublic static Iterator<int[]> combinationsIterator(int n, int k) {\n    return new Combinations(n, k).iterator();\n}"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Add two integers, checking for overflow.\n *\n * @param x an addend\n * @param y an addend\n * @return the sum {@code x+y}\n * @throws MathArithmeticException if the result can not be represented\n * as an {@code int}.\n * @since 1.1\n */\npublic static int addAndCheck(int x, int y) throws MathArithmeticException {\n    long s = (long) x + (long) y;\n    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n    }\n    return (int) s;\n}"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Add two long integers, checking for overflow.\n *\n * @param a an addend\n * @param b an addend\n * @return the sum {@code a+b}\n * @throws MathArithmeticException if the result can not be represented as an long\n * @since 1.2\n */\npublic static long addAndCheck(long a, long b) throws MathArithmeticException {\n    return addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n}"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns an exact representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which all coefficients are\n * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n * {@code Long.MAX_VALUE} an {@code ArithMeticException} is\n * thrown.</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficient(int, int)}\n */\n@Deprecated\npublic static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficient(n, k);\n}"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns a {@code double} representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code double}. The\n * largest value of {@code n} for which all coefficients are <\n * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n * Double.POSITIVE_INFINITY is returned</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficientDouble(int, int)}\n */\n@Deprecated\npublic static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficientDouble(n, k);\n}"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns the natural {@code log} of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficientLog(int, int)}\n */\n@Deprecated\npublic static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficientLog(n, k);\n}"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns n!. Shorthand for {@code n} <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers {@code 1,...,n}.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code n >= 0} (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which {@code n!} <\n * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n * an {@code ArithMeticException } is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return {@code n!}\n * @throws MathArithmeticException if the result is too large to be represented\n * by a {@code long}.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n * large to fit in a {@code long}.\n * @deprecated use {@link CombinatoricsUtils#factorial(int)}\n */\n@Deprecated\npublic static long factorial(final int n) throws NotPositiveException, MathArithmeticException {\n    return CombinatoricsUtils.factorial(n);\n}"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n * {@code double}.\n * The result should be small enough to fit into a {@code double}: The\n * largest {@code n} for which {@code n! < Double.MAX_VALUE} is 170.\n * If the computed value exceeds {@code Double.MAX_VALUE},\n * {@code Double.POSITIVE_INFINITY} is returned.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n * @deprecated use {@link CombinatoricsUtils#factorialDouble(int)}\n */\n@Deprecated\npublic static double factorialDouble(final int n) throws NotPositiveException {\n    return CombinatoricsUtils.factorialDouble(n);\n}"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Compute the natural logarithm of the factorial of {@code n}.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n * @deprecated use {@link CombinatoricsUtils#factorialLog(int)}\n */\n@Deprecated\npublic static double factorialLog(final int n) throws NotPositiveException {\n    return CombinatoricsUtils.factorialLog(n);\n}"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Computes the greatest common divisor of the absolute value of two\n * numbers, using a modified version of the \"binary gcd\" method.\n * See Knuth 4.5.2 algorithm B.\n * The algorithm is due to Josef Stein (1961).\n * <br/>\n * Special cases:\n * <ul>\n *  <li>The invocations\n *   {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n *   {@code gcd(Integer.MIN_VALUE, 0)} and\n *   {@code gcd(0, Integer.MIN_VALUE)} throw an\n *   {@code ArithmeticException}, because the result would be 2^31, which\n *   is too large for an int value.</li>\n *  <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n *   {@code gcd(x, 0)} is the absolute value of {@code x}, except\n *   for the special cases above.</li>\n *  <li>The invocation {@code gcd(0, 0)} is the only one which returns\n *   {@code 0}.</li>\n * </ul>\n *\n * @param p Number.\n * @param q Number.\n * @return the greatest common divisor (never negative).\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code int} value.\n * @since 1.1\n */\npublic static int gcd(int p, int q) throws MathArithmeticException {\n    int a = p;\n    int b = q;\n    if (a == 0 || b == 0) {\n        if (a == Integer.MIN_VALUE || b == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return FastMath.abs(a + b);\n    }\n    long al = a;\n    long bl = b;\n    boolean useLong = false;\n    if (a < 0) {\n        if (Integer.MIN_VALUE == a) {\n            useLong = true;\n        } else {\n            a = -a;\n        }\n        al = -al;\n    }\n    if (b < 0) {\n        if (Integer.MIN_VALUE == b) {\n            useLong = true;\n        } else {\n            b = -b;\n        }\n        bl = -bl;\n    }\n    if (useLong) {\n        if (al == bl) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        long blbu = bl;\n        bl = al;\n        al = blbu % al;\n        if (al == 0) {\n            if (bl > Integer.MAX_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n            }\n            return (int) bl;\n        }\n        blbu = bl;\n        // Now \"al\" and \"bl\" fit in an \"int\".\n        b = (int) al;\n        a = (int) (blbu % al);\n    }\n    return gcdPositive(a, b);\n}"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Gets the greatest common divisor of the absolute value of two numbers,\n * using the \"binary gcd\" method which avoids division and modulo\n * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n * Stein (1961).\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations\n * {@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)},\n * {@code gcd(Long.MIN_VALUE, 0L)} and\n * {@code gcd(0L, Long.MIN_VALUE)} throw an\n * {@code ArithmeticException}, because the result would be 2^63, which\n * is too large for a long value.</li>\n * <li>The result of {@code gcd(x, x)}, {@code gcd(0L, x)} and\n * {@code gcd(x, 0L)} is the absolute value of {@code x}, except\n * for the special cases above.\n * <li>The invocation {@code gcd(0L, 0L)} is the only one which returns\n * {@code 0L}.</li>\n * </ul>\n *\n * @param p Number.\n * @param q Number.\n * @return the greatest common divisor, never negative.\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code long} value.\n * @since 2.1\n */\npublic static long gcd(final long p, final long q) throws MathArithmeticException {\n    long u = p;\n    long v = q;\n    if ((u == 0) || (v == 0)) {\n        if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);\n        }\n        return FastMath.abs(u) + FastMath.abs(v);\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^63, while positive numbers can only be as large as 2^63-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    /* assert u!=0 && v!=0; */\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 63) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 63) {\n        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    long t = ((u & 1) == 1) ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1L << k);\n}"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Returns the least common multiple of the absolute value of two numbers,\n * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations {@code lcm(Integer.MIN_VALUE, n)} and\n * {@code lcm(n, Integer.MIN_VALUE)}, where {@code abs(n)} is a\n * power of 2, throw an {@code ArithmeticException}, because the result\n * would be 2^31, which is too large for an int value.</li>\n * <li>The result of {@code lcm(0, x)} and {@code lcm(x, 0)} is\n * {@code 0} for any {@code x}.\n * </ul>\n *\n * @param a Number.\n * @param b Number.\n * @return the least common multiple, never negative.\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code int} value.\n * @since 1.1\n */\npublic static int lcm(int a, int b) throws MathArithmeticException {\n    if (a == 0 || b == 0) {\n        return 0;\n    }\n    int lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));\n    if (lcm == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS, a, b);\n    }\n    return lcm;\n}"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Returns the least common multiple of the absolute value of two numbers,\n * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations {@code lcm(Long.MIN_VALUE, n)} and\n * {@code lcm(n, Long.MIN_VALUE)}, where {@code abs(n)} is a\n * power of 2, throw an {@code ArithmeticException}, because the result\n * would be 2^63, which is too large for an int value.</li>\n * <li>The result of {@code lcm(0L, x)} and {@code lcm(x, 0L)} is\n * {@code 0L} for any {@code x}.\n * </ul>\n *\n * @param a Number.\n * @param b Number.\n * @return the least common multiple, never negative.\n * @throws MathArithmeticException if the result cannot be represented\n * as a non-negative {@code long} value.\n * @since 2.1\n */\npublic static long lcm(long a, long b) throws MathArithmeticException {\n    if (a == 0 || b == 0) {\n        return 0;\n    }\n    long lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));\n    if (lcm == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS, a, b);\n    }\n    return lcm;\n}"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Multiply two integers, checking for overflow.\n *\n * @param x Factor.\n * @param y Factor.\n * @return the product {@code x * y}.\n * @throws MathArithmeticException if the result can not be\n * represented as an {@code int}.\n * @since 1.1\n */\npublic static int mulAndCheck(int x, int y) throws MathArithmeticException {\n    long m = ((long) x) * ((long) y);\n    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n        throw new MathArithmeticException();\n    }\n    return (int) m;\n}"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Multiply two long integers, checking for overflow.\n *\n * @param a Factor.\n * @param b Factor.\n * @return the product {@code a * b}.\n * @throws MathArithmeticException if the result can not be represented\n * as a {@code long}.\n * @since 1.2\n */\npublic static long mulAndCheck(long a, long b) throws MathArithmeticException {\n    long ret;\n    if (a > b) {\n        // use symmetry to reduce boundary cases\n        ret = mulAndCheck(b, a);\n    } else {\n        if (a < 0) {\n            if (b < 0) {\n                // check for positive overflow with negative a, negative b\n                if (a >= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new MathArithmeticException();\n                }\n            } else if (b > 0) {\n                // check for negative overflow with negative a, positive b\n                if (Long.MIN_VALUE / b <= a) {\n                    ret = a * b;\n                } else {\n                    throw new MathArithmeticException();\n                }\n            } else {\n                // assert b == 0\n                ret = 0;\n            }\n        } else if (a > 0) {\n            // assert a > 0\n            // assert b > 0\n            // check for positive overflow with positive a, positive b\n            if (a <= Long.MAX_VALUE / b) {\n                ret = a * b;\n            } else {\n                throw new MathArithmeticException();\n            }\n        } else {\n            // assert a == 0\n            ret = 0;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Subtract two integers, checking for overflow.\n *\n * @param x Minuend.\n * @param y Subtrahend.\n * @return the difference {@code x - y}.\n * @throws MathArithmeticException if the result can not be represented\n * as an {@code int}.\n * @since 1.1\n */\npublic static int subAndCheck(int x, int y) throws MathArithmeticException {\n    long s = (long) x - (long) y;\n    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n    }\n    return (int) s;\n}"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Subtract two long integers, checking for overflow.\n *\n * @param a Value.\n * @param b Value.\n * @return the difference {@code a - b}.\n * @throws MathArithmeticException if the result can not be represented as a\n * {@code long}.\n * @since 1.2\n */\npublic static long subAndCheck(long a, long b) throws MathArithmeticException {\n    long ret;\n    if (b == Long.MIN_VALUE) {\n        if (a < 0) {\n            ret = a - b;\n        } else {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);\n        }\n    } else {\n        // use additive inverse\n        ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n    }\n    return ret;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise an int to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return \\( k^e \\)\n * @throws NotPositiveException if {@code e < 0}.\n * @throws MathArithmeticException if the result would overflow.\n */\npublic static int pow(final int k, final int e) throws NotPositiveException, MathArithmeticException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    try {\n        int exp = e;\n        int result = 1;\n        int k2p = k;\n        while (true) {\n            if ((exp & 0x1) != 0) {\n                result = mulAndCheck(result, k2p);\n            }\n            exp >>= 1;\n            if (exp == 0) {\n                break;\n            }\n            k2p = mulAndCheck(k2p, k2p);\n        }\n        return result;\n    } catch (MathArithmeticException mae) {\n        // Add context information.\n        mae.getContext().addMessage(LocalizedFormats.OVERFLOW);\n        mae.getContext().addMessage(LocalizedFormats.BASE, k);\n        mae.getContext().addMessage(LocalizedFormats.EXPONENT, e);\n        // Rethrow.\n        throw mae;\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise an int to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n * @deprecated As of 3.3. Please use {@link #pow(int,int)} instead.\n */\n@Deprecated\npublic static int pow(final int k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    int result = 1;\n    int k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result *= k2p;\n        }\n        k2p *= k2p;\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a long to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return \\( k^e \\)\n * @throws NotPositiveException if {@code e < 0}.\n * @throws MathArithmeticException if the result would overflow.\n */\npublic static long pow(final long k, final int e) throws NotPositiveException, MathArithmeticException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    try {\n        int exp = e;\n        long result = 1;\n        long k2p = k;\n        while (true) {\n            if ((exp & 0x1) != 0) {\n                result = mulAndCheck(result, k2p);\n            }\n            exp >>= 1;\n            if (exp == 0) {\n                break;\n            }\n            k2p = mulAndCheck(k2p, k2p);\n        }\n        return result;\n    } catch (MathArithmeticException mae) {\n        // Add context information.\n        mae.getContext().addMessage(LocalizedFormats.OVERFLOW);\n        mae.getContext().addMessage(LocalizedFormats.BASE, k);\n        mae.getContext().addMessage(LocalizedFormats.EXPONENT, e);\n        // Rethrow.\n        throw mae;\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a long to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n * @deprecated As of 3.3. Please use {@link #pow(long,int)} instead.\n */\n@Deprecated\npublic static long pow(final long k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    long result = 1l;\n    long k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result *= k2p;\n        }\n        k2p *= k2p;\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, int e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    return k.pow(e);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    BigInteger result = BigInteger.ONE;\n    BigInteger k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result = result.multiply(k2p);\n        }\n        k2p = k2p.multiply(k2p);\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to a BigInteger power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException {\n    if (e.compareTo(BigInteger.ZERO) < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    BigInteger result = BigInteger.ONE;\n    BigInteger k2p = k;\n    while (!BigInteger.ZERO.equals(e)) {\n        if (e.testBit(0)) {\n            result = result.multiply(k2p);\n        }\n        k2p = k2p.multiply(k2p);\n        e = e.shiftRight(1);\n    }\n    return result;\n}"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns the <a\n * href=\"http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html\">\n * Stirling number of the second kind</a>, \"{@code S(n,k)}\", the number of\n * ways of partitioning an {@code n}-element set into {@code k} non-empty\n * subsets.\n * <p>\n * The preconditions are {@code 0 <= k <= n } (otherwise\n * {@code NotPositiveException} is thrown)\n * </p>\n * @param n the size of the set\n * @param k the number of non-empty subsets\n * @return {@code S(n,k)}\n * @throws NotPositiveException if {@code k < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\n * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)\n * @since 3.1\n * @deprecated use {@link CombinatoricsUtils#stirlingS2(int, int)}\n */\n@Deprecated\npublic static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.stirlingS2(n, k);\n}"
            ],
            [
                "isPowerOfTwo",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns true if the argument is a power of two.\n *\n * @param n the number to test\n * @return true if the argument is a power of two\n */\npublic static boolean isPowerOfTwo(long n) {\n    return (n > 0) && ((n & (n - 1)) == 0);\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Get the set of locales for which complex formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static ComplexFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static ComplexFormat getInstance(Locale locale) {\n    NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n    return new ComplexFormat(f);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @param imaginaryCharacter Imaginary character.\n * @return the complex format specific to the given locale.\n * @throws NullArgumentException if {@code imaginaryCharacter} is\n * {@code null}.\n * @throws NoDataException if {@code imaginaryCharacter} is an\n * empty string.\n */\npublic static ComplexFormat getInstance(String imaginaryCharacter, Locale locale) throws NullArgumentException, NoDataException {\n    NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n    return new ComplexFormat(imaginaryCharacter, f);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static ComplexField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Returns the Hamilton product of two quaternions.\n *\n * @param q1 First quaternion.\n * @param q2 Second quaternion.\n * @return the product {@code q1} and {@code q2}, in that order.\n */\npublic static Quaternion multiply(final Quaternion q1, final Quaternion q2) {\n    // Components of the first quaternion.\n    final double q1a = q1.getQ0();\n    final double q1b = q1.getQ1();\n    final double q1c = q1.getQ2();\n    final double q1d = q1.getQ3();\n    // Components of the second quaternion.\n    final double q2a = q2.getQ0();\n    final double q2b = q2.getQ1();\n    final double q2c = q2.getQ2();\n    final double q2d = q2.getQ3();\n    // Components of the product.\n    final double w = q1a * q2a - q1b * q2b - q1c * q2c - q1d * q2d;\n    final double x = q1a * q2b + q1b * q2a + q1c * q2d - q1d * q2c;\n    final double y = q1a * q2c - q1b * q2d + q1c * q2a + q1d * q2b;\n    final double z = q1a * q2d + q1b * q2c - q1c * q2b + q1d * q2a;\n    return new Quaternion(w, x, y, z);\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Computes the sum of two quaternions.\n *\n * @param q1 Quaternion.\n * @param q2 Quaternion.\n * @return the sum of {@code q1} and {@code q2}.\n */\npublic static Quaternion add(final Quaternion q1, final Quaternion q2) {\n    return new Quaternion(q1.getQ0() + q2.getQ0(), q1.getQ1() + q2.getQ1(), q1.getQ2() + q2.getQ2(), q1.getQ3() + q2.getQ3());\n}"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Subtracts two quaternions.\n *\n * @param q1 First Quaternion.\n * @param q2 Second quaternion.\n * @return the difference between {@code q1} and {@code q2}.\n */\npublic static Quaternion subtract(final Quaternion q1, final Quaternion q2) {\n    return new Quaternion(q1.getQ0() - q2.getQ0(), q1.getQ1() - q2.getQ1(), q1.getQ2() - q2.getQ2(), q1.getQ3() - q2.getQ3());\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Computes the dot-product of two quaternions.\n *\n * @param q1 Quaternion.\n * @param q2 Quaternion.\n * @return the dot product of {@code q1} and {@code q2}.\n */\npublic static double dotProduct(final Quaternion q1, final Quaternion q2) {\n    return q1.getQ0() * q2.getQ0() + q1.getQ1() * q2.getQ1() + q1.getQ2() * q2.getQ2() + q1.getQ3() * q2.getQ3();\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Test for the floating-point equality between Complex objects.\n * It returns {@code true} if both arguments are equal or within the\n * range of allowed error (inclusive).\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between the real (resp. imaginary) parts of {@code x} and\n * {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between the real (resp. imaginary) parts of {@code x}\n * and {@code y}.\n *\n * @see Precision#equals(double,double,int)\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y, int maxUlps) {\n    return Precision.equals(x.real, y.real, maxUlps) && Precision.equals(x.imaginary, y.imaginary, maxUlps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} iff the values are equal as defined by\n * {@link #equals(Complex,Complex,int) equals(x, y, 1)}.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @return {@code true} if the values are equal.\n *\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} if, both for the real part and for the imaginary\n * part, there is no double value strictly between the arguments or the\n * difference between them is within the range of allowed error\n * (inclusive).  Returns {@code false} if either of the arguments is NaN.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param eps Amount of allowed absolute error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n *\n * @see Precision#equals(double,double,double)\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y, double eps) {\n    return Precision.equals(x.real, y.real, eps) && Precision.equals(x.imaginary, y.imaginary, eps);\n}"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} if, both for the real part and for the imaginary\n * part, there is no double value strictly between the arguments or the\n * relative difference between them is smaller or equal to the given\n * tolerance. Returns {@code false} if either of the arguments is NaN.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param eps Amount of allowed relative error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n *\n * @see Precision#equalsWithRelativeTolerance(double,double,double)\n * @since 3.3\n */\npublic static boolean equalsWithRelativeTolerance(Complex x, Complex y, double eps) {\n    return Precision.equalsWithRelativeTolerance(x.real, y.real, eps) && Precision.equalsWithRelativeTolerance(x.imaginary, y.imaginary, eps);\n}"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Create a complex number given the real and imaginary parts.\n *\n * @param realPart Real part.\n * @param imaginaryPart Imaginary part.\n * @return a Complex instance.\n */\npublic static Complex valueOf(double realPart, double imaginaryPart) {\n    if (Double.isNaN(realPart) || Double.isNaN(imaginaryPart)) {\n        return NaN;\n    }\n    return new Complex(realPart, imaginaryPart);\n}"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Create a complex number given only the real part.\n *\n * @param realPart Real part.\n * @return a Complex instance.\n */\npublic static Complex valueOf(double realPart) {\n    if (Double.isNaN(realPart)) {\n        return NaN;\n    }\n    return new Complex(realPart);\n}"
            ],
            [
                "polar2Complex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "/**\n * Creates a complex number from the given polar representation.\n * <p>\n * The value returned is <code>r&middot;e<sup>i&middot;theta</sup></code>,\n * computed as <code>r&middot;cos(theta) + r&middot;sin(theta)i</code></p>\n * <p>\n * If either <code>r</code> or <code>theta</code> is NaN, or\n * <code>theta</code> is infinite, {@link Complex#NaN} is returned.</p>\n * <p>\n * If <code>r</code> is infinite and <code>theta</code> is finite,\n * infinite or NaN values may be returned in parts of the result, following\n * the rules for double arithmetic.<pre>\n * Examples:\n * <code>\n * polar2Complex(INFINITY, &pi;/4) = INFINITY + INFINITY i\n * polar2Complex(INFINITY, 0) = INFINITY + NaN i\n * polar2Complex(INFINITY, -&pi;/4) = INFINITY - INFINITY i\n * polar2Complex(INFINITY, 5&pi;/4) = -INFINITY - INFINITY i </code></pre></p>\n *\n * @param r the modulus of the complex number to create\n * @param theta  the argument of the complex number to create\n * @return <code>r&middot;e<sup>i&middot;theta</sup></code>\n * @throws MathIllegalArgumentException if {@code r} is negative.\n * @since 1.1\n */\npublic static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException {\n    if (r < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_COMPLEX_MODULE, r);\n    }\n    return new Complex(r * FastMath.cos(theta), r * FastMath.sin(theta));\n}"
            ],
            [
                "convertToComplex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "/**\n * Convert an array of primitive doubles to an array of {@code Complex} objects.\n *\n * @param real Array of numbers to be converted to their {@code Complex}\n * equivalent.\n * @return an array of {@code Complex} objects.\n *\n * @since 3.1\n */\npublic static Complex[] convertToComplex(double[] real) {\n    final Complex[] c = new Complex[real.length];\n    for (int i = 0; i < real.length; i++) {\n        c[i] = new Complex(real[i], 0);\n    }\n    return c;\n}"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optimization.linear",
                "SimplexTableau",
                "/**\n * Get the -1 times the sum of all coefficients in the given array.\n * @param coefficients coefficients to sum\n * @return the -1 times the sum of all coefficients in the given array.\n */\nprotected static double getInvertedCoefficientSum(final RealVector coefficients) {\n    double sum = 0;\n    for (double coefficient : coefficients.toArray()) {\n        sum -= coefficient;\n    }\n    return sum;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Get the set of locales for which real vectors formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available real vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Returns the default real vector format for the current locale.\n * @return the default real vector format.\n */\npublic static RealMatrixFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Returns the default real vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the real vector format specific to the given locale.\n */\npublic static RealMatrixFormat getInstance(final Locale locale) {\n    return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link RealMatrix} with specified dimensions.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix) which can be stored in a 32kB array, a {@link\n * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n * BlockRealMatrix} instance is built.</p>\n * <p>The matrix elements are all set to 0.0.</p>\n * @param rows number of rows of the matrix\n * @param columns number of columns of the matrix\n * @return  RealMatrix with specified dimensions\n * @see #createRealMatrix(double[][])\n */\npublic static RealMatrix createRealMatrix(final int rows, final int columns) {\n    return (rows * columns <= 4096) ? new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n}"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link FieldMatrix} with specified dimensions.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix), a {@link FieldMatrix} instance is built. Above\n * this threshold a {@link BlockFieldMatrix} instance is built.</p>\n * <p>The matrix elements are all set to field.getZero().</p>\n * @param <T> the type of the field elements\n * @param field field to which the matrix elements belong\n * @param rows number of rows of the matrix\n * @param columns number of columns of the matrix\n * @return  FieldMatrix with specified dimensions\n * @see #createFieldMatrix(FieldElement[][])\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field, final int rows, final int columns) {\n    return (rows * columns <= 4096) ? new Array2DRowFieldMatrix<T>(field, rows, columns) : new BlockFieldMatrix<T>(field, rows, columns);\n}"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link RealMatrix} whose entries are the the values in the\n * the input array.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix) which can be stored in a 32kB array, a {@link\n * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n * BlockRealMatrix} instance is built.</p>\n * <p>The input array is copied, not referenced.</p>\n *\n * @param data input array\n * @return  RealMatrix containing the values of the array\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if {@code data} is not rectangular (not all rows have the same length).\n * @throws NoDataException if a row or column is empty.\n * @throws NullArgumentException if either {@code data} or {@code data[0]}\n * is {@code null}.\n * @throws DimensionMismatchException if {@code data} is not rectangular.\n * @see #createRealMatrix(int, int)\n */\npublic static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException {\n    if (data == null || data[0] == null) {\n        throw new NullArgumentException();\n    }\n    return (data.length * data[0].length <= 4096) ? new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n}"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link FieldMatrix} whose entries are the the values in the\n * the input array.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix), a {@link FieldMatrix} instance is built. Above\n * this threshold a {@link BlockFieldMatrix} instance is built.</p>\n * <p>The input array is copied, not referenced.</p>\n * @param <T> the type of the field elements\n * @param data input array\n * @return a matrix containing the values of the array.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if {@code data} is not rectangular (not all rows have the same length).\n * @throws NoDataException if a row or column is empty.\n * @throws NullArgumentException if either {@code data} or {@code data[0]}\n * is {@code null}.\n * @see #createFieldMatrix(Field, int, int)\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) throws DimensionMismatchException, NoDataException, NullArgumentException {\n    if (data == null || data[0] == null) {\n        throw new NullArgumentException();\n    }\n    return (data.length * data[0].length <= 4096) ? new Array2DRowFieldMatrix<T>(data) : new BlockFieldMatrix<T>(data);\n}"
            ],
            [
                "createRealIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns <code>dimension x dimension</code> identity matrix.\n *\n * @param dimension dimension of identity matrix to generate\n * @return identity matrix\n * @throws IllegalArgumentException if dimension is not positive\n * @since 1.1\n */\npublic static RealMatrix createRealIdentityMatrix(int dimension) {\n    final RealMatrix m = createRealMatrix(dimension, dimension);\n    for (int i = 0; i < dimension; ++i) {\n        m.setEntry(i, i, 1.0);\n    }\n    return m;\n}"
            ],
            [
                "createFieldIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns <code>dimension x dimension</code> identity matrix.\n *\n * @param <T> the type of the field elements\n * @param field field to which the elements belong\n * @param dimension dimension of identity matrix to generate\n * @return identity matrix\n * @throws IllegalArgumentException if dimension is not positive\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(final Field<T> field, final int dimension) {\n    final T zero = field.getZero();\n    final T one = field.getOne();\n    final T[][] d = MathArrays.buildArray(field, dimension, dimension);\n    for (int row = 0; row < dimension; row++) {\n        final T[] dRow = d[row];\n        Arrays.fill(dRow, zero);\n        dRow[row] = one;\n    }\n    return new Array2DRowFieldMatrix<T>(field, d, false);\n}"
            ],
            [
                "createRealDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a diagonal matrix with specified elements.\n *\n * @param diagonal diagonal elements of the matrix (the array elements\n * will be copied)\n * @return diagonal matrix\n * @since 2.0\n */\npublic static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n    final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n    for (int i = 0; i < diagonal.length; ++i) {\n        m.setEntry(i, i, diagonal[i]);\n    }\n    return m;\n}"
            ],
            [
                "createFieldDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a diagonal matrix with specified elements.\n *\n * @param <T> the type of the field elements\n * @param diagonal diagonal elements of the matrix (the array elements\n * will be copied)\n * @return diagonal matrix\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(final T[] diagonal) {\n    final FieldMatrix<T> m = createFieldMatrix(diagonal[0].getField(), diagonal.length, diagonal.length);\n    for (int i = 0; i < diagonal.length; ++i) {\n        m.setEntry(i, i, diagonal[i]);\n    }\n    return m;\n}"
            ],
            [
                "createRealVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a {@link RealVector} using the data from the input array.\n *\n * @param data the input data\n * @return a data.length RealVector\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code data} is {@code null}.\n */\npublic static RealVector createRealVector(double[] data) throws NoDataException, NullArgumentException {\n    if (data == null) {\n        throw new NullArgumentException();\n    }\n    return new ArrayRealVector(data, true);\n}"
            ],
            [
                "createFieldVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a {@link FieldVector} using the data from the input array.\n *\n * @param <T> the type of the field elements\n * @param data the input data\n * @return a data.length FieldVector\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code data} is {@code null}.\n * @throws ZeroException if {@code data} has 0 elements\n */\npublic static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) throws NoDataException, NullArgumentException, ZeroException {\n    if (data == null) {\n        throw new NullArgumentException();\n    }\n    if (data.length == 0) {\n        throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n    }\n    return new ArrayFieldVector<T>(data[0].getField(), data, true);\n}"
            ],
            [
                "createRowRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Create a row {@link RealMatrix} using the data from the input\n * array.\n *\n * @param rowData the input row data\n * @return a 1 x rowData.length RealMatrix\n * @throws NoDataException if {@code rowData} is empty.\n * @throws NullArgumentException if {@code rowData} is {@code null}.\n */\npublic static RealMatrix createRowRealMatrix(double[] rowData) throws NoDataException, NullArgumentException {\n    if (rowData == null) {\n        throw new NullArgumentException();\n    }\n    final int nCols = rowData.length;\n    final RealMatrix m = createRealMatrix(1, nCols);\n    for (int i = 0; i < nCols; ++i) {\n        m.setEntry(0, i, rowData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createRowFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Create a row {@link FieldMatrix} using the data from the input\n * array.\n *\n * @param <T> the type of the field elements\n * @param rowData the input row data\n * @return a 1 x rowData.length FieldMatrix\n * @throws NoDataException if {@code rowData} is empty.\n * @throws NullArgumentException if {@code rowData} is {@code null}.\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(final T[] rowData) throws NoDataException, NullArgumentException {\n    if (rowData == null) {\n        throw new NullArgumentException();\n    }\n    final int nCols = rowData.length;\n    if (nCols == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n    for (int i = 0; i < nCols; ++i) {\n        m.setEntry(0, i, rowData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createColumnRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a column {@link RealMatrix} using the data from the input\n * array.\n *\n * @param columnData  the input column data\n * @return a columnData x 1 RealMatrix\n * @throws NoDataException if {@code columnData} is empty.\n * @throws NullArgumentException if {@code columnData} is {@code null}.\n */\npublic static RealMatrix createColumnRealMatrix(double[] columnData) throws NoDataException, NullArgumentException {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createColumnFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a column {@link FieldMatrix} using the data from the input\n * array.\n *\n * @param <T> the type of the field elements\n * @param columnData  the input column data\n * @return a columnData x 1 FieldMatrix\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code columnData} is {@code null}.\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) throws NoDataException, NullArgumentException {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final FieldMatrix<T> m = createFieldMatrix(columnData[0].getField(), nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
            ],
            [
                "isSymmetric",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Checks whether a matrix is symmetric.\n *\n * @param matrix Matrix to check.\n * @param eps Relative tolerance.\n * @return {@code true} if {@code matrix} is symmetric.\n * @since 3.1\n */\npublic static boolean isSymmetric(RealMatrix matrix, double eps) {\n    return isSymmetricInternal(matrix, eps, false);\n}"
            ],
            [
                "fractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Convert a {@link FieldMatrix}/{@link Fraction} matrix to a {@link RealMatrix}.\n * @param m Matrix to convert.\n * @return the converted matrix.\n */\npublic static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m) {\n    final FractionMatrixConverter converter = new FractionMatrixConverter();\n    m.walkInOptimizedOrder(converter);\n    return converter.getConvertedMatrix();\n}"
            ],
            [
                "bigFractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Convert a {@link FieldMatrix}/{@link BigFraction} matrix to a {@link RealMatrix}.\n *\n * @param m Matrix to convert.\n * @return the converted matrix.\n */\npublic static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m) {\n    final BigFractionMatrixConverter converter = new BigFractionMatrixConverter();\n    m.walkInOptimizedOrder(converter);\n    return converter.getConvertedMatrix();\n}"
            ],
            [
                "blockInverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix by splitting it into\n * 4 sub-matrices.\n *\n * @param m Matrix whose inverse must be computed.\n * @param splitIndex Index that determines the \"split\" line and\n * column.\n * The element corresponding to this index will part of the\n * upper-left sub-matrix.\n * @return the inverse of {@code m}.\n * @throws NonSquareMatrixException if {@code m} is not square.\n */\npublic static RealMatrix blockInverse(RealMatrix m, int splitIndex) {\n    final int n = m.getRowDimension();\n    if (m.getColumnDimension() != n) {\n        throw new NonSquareMatrixException(m.getRowDimension(), m.getColumnDimension());\n    }\n    final int splitIndex1 = splitIndex + 1;\n    final RealMatrix a = m.getSubMatrix(0, splitIndex, 0, splitIndex);\n    final RealMatrix b = m.getSubMatrix(0, splitIndex, splitIndex1, n - 1);\n    final RealMatrix c = m.getSubMatrix(splitIndex1, n - 1, 0, splitIndex);\n    final RealMatrix d = m.getSubMatrix(splitIndex1, n - 1, splitIndex1, n - 1);\n    final SingularValueDecomposition aDec = new SingularValueDecomposition(a);\n    final DecompositionSolver aSolver = aDec.getSolver();\n    if (!aSolver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix aInv = aSolver.getInverse();\n    final SingularValueDecomposition dDec = new SingularValueDecomposition(d);\n    final DecompositionSolver dSolver = dDec.getSolver();\n    if (!dSolver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix dInv = dSolver.getInverse();\n    final RealMatrix tmp1 = a.subtract(b.multiply(dInv).multiply(c));\n    final SingularValueDecomposition tmp1Dec = new SingularValueDecomposition(tmp1);\n    final DecompositionSolver tmp1Solver = tmp1Dec.getSolver();\n    if (!tmp1Solver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix result00 = tmp1Solver.getInverse();\n    final RealMatrix tmp2 = d.subtract(c.multiply(aInv).multiply(b));\n    final SingularValueDecomposition tmp2Dec = new SingularValueDecomposition(tmp2);\n    final DecompositionSolver tmp2Solver = tmp2Dec.getSolver();\n    if (!tmp2Solver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix result11 = tmp2Solver.getInverse();\n    final RealMatrix result01 = aInv.multiply(b).multiply(result11).scalarMultiply(-1);\n    final RealMatrix result10 = dInv.multiply(c).multiply(result00).scalarMultiply(-1);\n    final RealMatrix result = new Array2DRowRealMatrix(n, n);\n    result.setSubMatrix(result00.getData(), 0, 0);\n    result.setSubMatrix(result01.getData(), 0, splitIndex1);\n    result.setSubMatrix(result10.getData(), splitIndex1, 0);\n    result.setSubMatrix(result11.getData(), splitIndex1, splitIndex1);\n    return result;\n}"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix.\n * <p>\n * By default, the inverse of the matrix is computed using the QR-decomposition,\n * unless a more efficient method can be determined for the input matrix.\n * <p>\n * Note: this method will use a singularity threshold of 0,\n * use {@link #inverse(RealMatrix, double)} if a different threshold is needed.\n *\n * @param matrix Matrix whose inverse shall be computed\n * @return the inverse of {@code matrix}\n * @throws NullArgumentException if {@code matrix} is {@code null}\n * @throws SingularMatrixException if m is singular\n * @throws NonSquareMatrixException if matrix is not square\n * @since 3.3\n */\npublic static RealMatrix inverse(RealMatrix matrix) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException {\n    return inverse(matrix, 0);\n}"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix.\n * <p>\n * By default, the inverse of the matrix is computed using the QR-decomposition,\n * unless a more efficient method can be determined for the input matrix.\n *\n * @param matrix Matrix whose inverse shall be computed\n * @param threshold Singularity threshold\n * @return the inverse of {@code m}\n * @throws NullArgumentException if {@code matrix} is {@code null}\n * @throws SingularMatrixException if matrix is singular\n * @throws NonSquareMatrixException if matrix is not square\n * @since 3.3\n */\npublic static RealMatrix inverse(RealMatrix matrix, double threshold) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException {\n    MathUtils.checkNotNull(matrix);\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n    }\n    if (matrix instanceof DiagonalMatrix) {\n        return ((DiagonalMatrix) matrix).inverse(threshold);\n    } else {\n        QRDecomposition decomposition = new QRDecomposition(matrix, threshold);\n        return decomposition.getSolver().getInverse();\n    }\n}"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Convert a data array from raw layout to blocks layout.\n * <p>\n * Raw layout is the straightforward layout where element at row i and\n * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n * is the layout used in {@link BlockFieldMatrix} instances, where the matrix\n * is split in square blocks (except at right and bottom side where blocks may\n * be rectangular to fit matrix size) and each block is stored in a flattened\n * one-dimensional array.\n * </p>\n * <p>\n * This method creates an array in blocks layout from an input array in raw layout.\n * It can be used to provide the array argument of the {@link\n * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n * constructor.\n * </p>\n * @param <T> Type of the field elements.\n * @param rawData Data array in raw layout.\n * @return a new data array containing the same entries but in blocks layout\n * @throws DimensionMismatchException if {@code rawData} is not rectangular\n *  (not all rows have the same length).\n * @see #createBlocksLayout(Field, int, int)\n * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n */\npublic static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n    // convert array\n    final Field<T> field = extractField(rawData);\n    final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            // allocate new block\n            final T[] block = MathArrays.buildArray(field, iHeight * jWidth);\n            blocks[blockIndex] = block;\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Create a data array in blocks layout.\n * <p>\n * This method can be used to create the array argument of the {@link\n * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n * constructor.\n * </p>\n * @param <T> Type of the field elements.\n * @param field Field to which the elements belong.\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(FieldElement[][])\n * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n */\npublic static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns) {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = MathArrays.buildArray(field, iHeight * jWidth);\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Convert a data array from raw layout to blocks layout.\n * <p>\n * Raw layout is the straightforward layout where element at row i and\n * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n * is the layout used in {@link BlockRealMatrix} instances, where the matrix\n * is split in square blocks (except at right and bottom side where blocks may\n * be rectangular to fit matrix size) and each block is stored in a flattened\n * one-dimensional array.\n * </p>\n * <p>\n * This method creates an array in blocks layout from an input array in raw layout.\n * It can be used to provide the array argument of the {@link\n * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n * </p>\n * @param rawData Data array in raw layout.\n * @return a new data array containing the same entries but in blocks layout.\n * @throws DimensionMismatchException if {@code rawData} is not rectangular.\n * @see #createBlocksLayout(int, int)\n * @see #BlockRealMatrix(int, int, double[][], boolean)\n */\npublic static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Create a data array in blocks layout.\n * <p>\n * This method can be used to create the array argument of the {@link\n * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n * </p>\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(double[][])\n * @see #BlockRealMatrix(int, int, double[][], boolean)\n */\npublic static double[][] createBlocksLayout(final int rows, final int columns) {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "unmodifiableRealVector",
                "org.apache.commons.math3.linear",
                "RealVector",
                "/**\n * Returns an unmodifiable view of the specified vector.\n * The returned vector has read-only access. An attempt to modify it will\n * result in a {@link MathUnsupportedOperationException}. However, the\n * returned vector is <em>not</em> immutable, since any modification of\n * {@code v} will also change the returned view.\n * For example, in the following piece of code\n * <pre>\n *     RealVector v = new ArrayRealVector(2);\n *     RealVector w = RealVector.unmodifiableRealVector(v);\n *     v.setEntry(0, 1.2);\n *     v.setEntry(1, -3.4);\n * </pre>\n * the changes will be seen in the {@code w} view of {@code v}.\n *\n * @param v Vector for which an unmodifiable view is to be returned.\n * @return an unmodifiable view of {@code v}.\n */\npublic static RealVector unmodifiableRealVector(final RealVector v) {\n    /**\n     * This anonymous class is an implementation of {@link RealVector}\n     * with read-only access.\n     * It wraps any {@link RealVector}, and exposes all methods which\n     * do not modify it. Invoking methods which should normally result\n     * in the modification of the calling {@link RealVector} results in\n     * a {@link MathUnsupportedOperationException}. It should be noted\n     * that {@link UnmodifiableVector} is <em>not</em> immutable.\n     */\n    return new RealVector() {\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all circumstances.\n         */\n        @Override\n        public RealVector mapToSelf(UnivariateFunction function) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector map(UnivariateFunction function) {\n            return v.map(function);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Iterator<Entry> iterator() {\n            final Iterator<Entry> i = v.iterator();\n            return new Iterator<Entry>() {\n\n                /**\n                 * The current entry.\n                 */\n                private final UnmodifiableEntry e = new UnmodifiableEntry();\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public boolean hasNext() {\n                    return i.hasNext();\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public Entry next() {\n                    e.setIndex(i.next().getIndex());\n                    return e;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 *\n                 * @throws MathUnsupportedOperationException in all\n                 * circumstances.\n                 */\n                public void remove() throws MathUnsupportedOperationException {\n                    throw new MathUnsupportedOperationException();\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Iterator<Entry> sparseIterator() {\n            final Iterator<Entry> i = v.sparseIterator();\n            return new Iterator<Entry>() {\n\n                /**\n                 * The current entry.\n                 */\n                private final UnmodifiableEntry e = new UnmodifiableEntry();\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public boolean hasNext() {\n                    return i.hasNext();\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public Entry next() {\n                    e.setIndex(i.next().getIndex());\n                    return e;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 *\n                 * @throws MathUnsupportedOperationException in all\n                 * circumstances.\n                 */\n                public void remove() throws MathUnsupportedOperationException {\n                    throw new MathUnsupportedOperationException();\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector copy() {\n            return v.copy();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector add(RealVector w) throws DimensionMismatchException {\n            return v.add(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector subtract(RealVector w) throws DimensionMismatchException {\n            return v.subtract(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapAdd(double d) {\n            return v.mapAdd(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapAddToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapSubtract(double d) {\n            return v.mapSubtract(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapSubtractToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapMultiply(double d) {\n            return v.mapMultiply(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapMultiplyToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapDivide(double d) {\n            return v.mapDivide(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapDivideToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector ebeMultiply(RealVector w) throws DimensionMismatchException {\n            return v.ebeMultiply(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector ebeDivide(RealVector w) throws DimensionMismatchException {\n            return v.ebeDivide(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double dotProduct(RealVector w) throws DimensionMismatchException {\n            return v.dotProduct(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double cosine(RealVector w) throws DimensionMismatchException, MathArithmeticException {\n            return v.cosine(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getNorm() {\n            return v.getNorm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getL1Norm() {\n            return v.getL1Norm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getLInfNorm() {\n            return v.getLInfNorm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getDistance(RealVector w) throws DimensionMismatchException {\n            return v.getDistance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getL1Distance(RealVector w) throws DimensionMismatchException {\n            return v.getL1Distance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getLInfDistance(RealVector w) throws DimensionMismatchException {\n            return v.getLInfDistance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector unitVector() throws MathArithmeticException {\n            return v.unitVector();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void unitize() throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealMatrix outerProduct(RealVector w) {\n            return v.outerProduct(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getEntry(int index) throws OutOfRangeException {\n            return v.getEntry(index);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void setEntry(int index, double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void addToEntry(int index, double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getDimension() {\n            return v.getDimension();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector append(RealVector w) {\n            return v.append(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector append(double d) {\n            return v.append(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector getSubVector(int index, int n) throws OutOfRangeException, NotPositiveException {\n            return v.getSubVector(index, n);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void setSubVector(int index, RealVector w) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void set(double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double[] toArray() {\n            return v.toArray();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isNaN() {\n            return v.isNaN();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isInfinite() {\n            return v.isInfinite();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector combine(double a, double b, RealVector y) throws DimensionMismatchException {\n            return v.combine(a, b, y);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector combineToSelf(double a, double b, RealVector y) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * An entry in the vector.\n         */\n        class UnmodifiableEntry extends Entry {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public double getValue() {\n                return v.getEntry(getIndex());\n            }\n\n            /**\n             * {@inheritDoc}\n             *\n             * @throws MathUnsupportedOperationException in all\n             * circumstances.\n             */\n            @Override\n            public void setValue(double value) throws MathUnsupportedOperationException {\n                throw new MathUnsupportedOperationException();\n            }\n        }\n    };\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Get the set of locales for which real vectors formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available real vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Returns the default real vector format for the current locale.\n * @return the default real vector format.\n */\npublic static RealVectorFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Returns the default real vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the real vector format specific to the given locale.\n */\npublic static RealVectorFormat getInstance(final Locale locale) {\n    return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.linear",
                "JacobiPreconditioner",
                "/**\n * Creates a new instance of this class. This method extracts the diagonal\n * coefficients of the specified linear operator. If {@code a} does not\n * extend {@link AbstractRealMatrix}, then the coefficients of the\n * underlying matrix are not accessible, coefficient extraction is made by\n * matrix-vector products with the basis vectors (and might therefore take\n * some time). With matrices, direct entry access is carried out.\n *\n * @param a the linear operator for which the preconditioner should be built\n * @return the diagonal preconditioner made of the inverse of the diagonal\n * coefficients of the specified linear operator\n * @throws NonSquareOperatorException if {@code a} is not square\n */\npublic static JacobiPreconditioner create(final RealLinearOperator a) throws NonSquareOperatorException {\n    final int n = a.getColumnDimension();\n    if (a.getRowDimension() != n) {\n        throw new NonSquareOperatorException(a.getRowDimension(), n);\n    }\n    final double[] diag = new double[n];\n    if (a instanceof AbstractRealMatrix) {\n        final AbstractRealMatrix m = (AbstractRealMatrix) a;\n        for (int i = 0; i < n; i++) {\n            diag[i] = m.getEntry(i, i);\n        }\n    } else {\n        final ArrayRealVector x = new ArrayRealVector(n);\n        for (int i = 0; i < n; i++) {\n            x.set(0.);\n            x.setEntry(i, 1.);\n            diag[i] = a.operate(x).getEntry(i);\n        }\n    }\n    return new JacobiPreconditioner(diag, false);\n}"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Get the elements type from an array.\n *\n * @param <T> Type of the field elements.\n * @param d Data array.\n * @return the field to which the array elements belong.\n * @throws NullArgumentException if the array is {@code null}.\n * @throws NoDataException if the array is empty.\n */\nprotected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException {\n    if (d == null) {\n        throw new NullArgumentException();\n    }\n    if (d.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    if (d[0].length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    return d[0][0].getField();\n}"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Get the elements type from an array.\n *\n * @param <T> Type of the field elements.\n * @param d Data array.\n * @return the field to which the array elements belong.\n * @throws NoDataException if array is empty.\n */\nprotected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException {\n    if (d.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    return d[0].getField();\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Build an array of elements.\n * <p>\n * Complete arrays are filled with field.getZero()\n * </p>\n * @param <T> Type of the field elements\n * @param field field to which array elements belong\n * @param rows number of rows\n * @param columns number of columns (may be negative to build partial\n * arrays in the same way <code>new Field[rows][]</code> works)\n * @return a new array\n * @deprecated as of 3.2, replaced by {@link MathArrays#buildArray(Field, int, int)}\n */\n@Deprecated\nprotected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n    return MathArrays.buildArray(field, rows, columns);\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Build an array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n * </p>\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param length of the array\n * @return a new array\n * @deprecated as of 3.2, replaced by {@link MathArrays#buildArray(Field, int)}\n */\n@Deprecated\nprotected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length) {\n    return MathArrays.buildArray(field, length);\n}"
            ],
            [
                "estimate",
                "org.apache.commons.math3.distribution.fitting",
                "MultivariateNormalMixtureExpectationMaximization",
                "/**\n * Helper method to create a multivariate normal mixture model which can be\n * used to initialize {@link #fit(MixtureMultivariateNormalDistribution)}.\n *\n * This method uses the data supplied to the constructor to try to determine\n * a good mixture model at which to start the fit, but it is not guaranteed\n * to supply a model which will find the optimal solution or even converge.\n *\n * @param data Data to estimate distribution\n * @param numComponents Number of components for estimated mixture\n * @return Multivariate normal mixture model estimated from the data\n * @throws NumberIsTooLargeException if {@code numComponents} is greater\n * than the number of data rows.\n * @throws NumberIsTooSmallException if {@code numComponents < 2}.\n * @throws NotStrictlyPositiveException if data has less than 2 rows\n * @throws DimensionMismatchException if rows of data have different numbers\n *             of columns\n */\npublic static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException {\n    if (data.length < 2) {\n        throw new NotStrictlyPositiveException(data.length);\n    }\n    if (numComponents < 2) {\n        throw new NumberIsTooSmallException(numComponents, 2, true);\n    }\n    if (numComponents > data.length) {\n        throw new NumberIsTooLargeException(numComponents, data.length, true);\n    }\n    final int numRows = data.length;\n    final int numCols = data[0].length;\n    // sort the data\n    final DataRow[] sortedData = new DataRow[numRows];\n    for (int i = 0; i < numRows; i++) {\n        sortedData[i] = new DataRow(data[i]);\n    }\n    Arrays.sort(sortedData);\n    // uniform weight for each bin\n    final double weight = 1d / numComponents;\n    // components of mixture model to be created\n    final List<Pair<Double, MultivariateNormalDistribution>> components = new ArrayList<Pair<Double, MultivariateNormalDistribution>>(numComponents);\n    // create a component based on data in each bin\n    for (int binIndex = 0; binIndex < numComponents; binIndex++) {\n        // minimum index (inclusive) from sorted data for this bin\n        final int minIndex = (binIndex * numRows) / numComponents;\n        // maximum index (exclusive) from sorted data for this bin\n        final int maxIndex = ((binIndex + 1) * numRows) / numComponents;\n        // number of data records that will be in this bin\n        final int numBinRows = maxIndex - minIndex;\n        // data for this bin\n        final double[][] binData = new double[numBinRows][numCols];\n        // mean of each column for the data in the this bin\n        final double[] columnMeans = new double[numCols];\n        // populate bin and create component\n        for (int i = minIndex, iBin = 0; i < maxIndex; i++, iBin++) {\n            for (int j = 0; j < numCols; j++) {\n                final double val = sortedData[i].getRow()[j];\n                columnMeans[j] += val;\n                binData[iBin][j] = val;\n            }\n        }\n        MathArrays.scaleInPlace(1d / numBinRows, columnMeans);\n        // covariance matrix for this bin\n        final double[][] covMat = new Covariance(binData).getCovarianceMatrix().getData();\n        final MultivariateNormalDistribution mvn = new MultivariateNormalDistribution(columnMeans, covMat);\n        components.add(new Pair<Double, MultivariateNormalDistribution>(weight, mvn));\n    }\n    return new MixtureMultivariateNormalDistribution(components);\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "/**\n * Returns one sample using Cheng's sampling algorithm.\n * @param random random generator to use\n * @param alpha distribution first shape parameter\n * @param beta distribution second shape parameter\n * @return sampled value\n */\nstatic double sample(RandomGenerator random, final double alpha, final double beta) {\n    final double a = FastMath.min(alpha, beta);\n    final double b = FastMath.max(alpha, beta);\n    if (a > 1) {\n        return algorithmBB(random, alpha, a, b);\n    } else {\n        return algorithmBC(random, alpha, b, a);\n    }\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "ChengBetaSampler",
                "/**\n * Returns one sample using Cheng's sampling algorithm.\n * @param random random generator to use\n * @param alpha distribution first shape parameter\n * @param beta distribution second shape parameter\n * @return sampled value\n */\nstatic double sample(RandomGenerator random, final double alpha, final double beta) {\n    final double a = FastMath.min(alpha, beta);\n    final double b = FastMath.max(alpha, beta);\n    if (a > 1) {\n        return algorithmBB(random, alpha, a, b);\n    } else {\n        return algorithmBC(random, alpha, b, a);\n    }\n}"
            ],
            [
                "getStirlingError",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * Compute the error of Stirling's series at the given value.\n * <p>\n * References:\n * <ol>\n * <li>Eric W. Weisstein. \"Stirling's Series.\" From MathWorld--A Wolfram Web\n * Resource. <a target=\"_blank\"\n * href=\"http://mathworld.wolfram.com/StirlingsSeries.html\">\n * http://mathworld.wolfram.com/StirlingsSeries.html</a></li>\n * </ol>\n * </p>\n *\n * @param z the value.\n * @return the Striling's series error.\n */\nstatic double getStirlingError(double z) {\n    double ret;\n    if (z < 15.0) {\n        double z2 = 2.0 * z;\n        if (FastMath.floor(z2) == z2) {\n            ret = EXACT_STIRLING_ERRORS[(int) z2];\n        } else {\n            ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * FastMath.log(z) + z - HALF_LOG_2_PI;\n        }\n    } else {\n        double z2 = z * z;\n        ret = (0.083333333333333333333 - (0.00277777777777777777778 - (0.00079365079365079365079365 - (0.000595238095238095238095238 - 0.0008417508417508417508417508 / z2) / z2) / z2) / z2) / z;\n    }\n    return ret;\n}"
            ],
            [
                "getDeviancePart",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * A part of the deviance portion of the saddle point approximation.\n * <p>\n * References:\n * <ol>\n * <li>Catherine Loader (2000). \"Fast and Accurate Computation of Binomial\n * Probabilities.\". <a target=\"_blank\"\n * href=\"http://www.herine.net/stat/papers/dbinom.pdf\">\n * http://www.herine.net/stat/papers/dbinom.pdf</a></li>\n * </ol>\n * </p>\n *\n * @param x the x value.\n * @param mu the average.\n * @return a part of the deviance.\n */\nstatic double getDeviancePart(double x, double mu) {\n    double ret;\n    if (FastMath.abs(x - mu) < 0.1 * (x + mu)) {\n        double d = x - mu;\n        double v = d / (x + mu);\n        double s1 = v * d;\n        double s = Double.NaN;\n        double ej = 2.0 * x * v;\n        v *= v;\n        int j = 1;\n        while (s1 != s) {\n            s = s1;\n            ej *= v;\n            s1 = s + ej / ((j * 2) + 1);\n            ++j;\n        }\n        ret = s1;\n    } else {\n        ret = x * FastMath.log(x / mu) + mu - x;\n    }\n    return ret;\n}"
            ],
            [
                "logBinomialProbability",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * Compute the logarithm of the PMF for a binomial distribution\n * using the saddle point expansion.\n *\n * @param x the value at which the probability is evaluated.\n * @param n the number of trials.\n * @param p the probability of success.\n * @param q the probability of failure (1 - p).\n * @return log(p(x)).\n */\nstatic double logBinomialProbability(int x, int n, double p, double q) {\n    double ret;\n    if (x == 0) {\n        if (p < 0.1) {\n            ret = -getDeviancePart(n, n * q) - n * p;\n        } else {\n            ret = n * FastMath.log(q);\n        }\n    } else if (x == n) {\n        if (q < 0.1) {\n            ret = -getDeviancePart(n, n * p) - n * q;\n        } else {\n            ret = n * FastMath.log(p);\n        }\n    } else {\n        ret = getStirlingError(n) - getStirlingError(x) - getStirlingError(n - x) - getDeviancePart(x, n * p) - getDeviancePart(n - x, n * q);\n        double f = (MathUtils.TWO_PI * x * (n - x)) / n;\n        ret = -0.5 * FastMath.log(f) + ret;\n    }\n    return ret;\n}"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "/**\n * Helper function that calculates {@code log(1+x)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x a value larger than or equal to -1\n * @return {@code log(1+x)/x}\n */\nstatic double helper1(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.log1p(x) / x;\n    } else {\n        return 1. - x * ((1. / 2.) - x * ((1. / 3.) - x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "/**\n * Helper function to calculate {@code (exp(x)-1)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x free parameter\n * @return {@code (exp(x)-1)/x} if x is non-zero, or 1 if x=0\n */\nstatic double helper2(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.expm1(x) / x;\n    } else {\n        return 1. + x * (1. / 2.) * (1. + x * (1. / 3.) * (1. + x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "/**\n * Helper function that calculates {@code log(1+x)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x a value larger than or equal to -1\n * @return {@code log(1+x)/x}\n */\nstatic double helper1(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.log1p(x) / x;\n    } else {\n        return 1. - x * ((1. / 2.) - x * ((1. / 3.) - x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "/**\n * Helper function to calculate {@code (exp(x)-1)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x free parameter\n * @return {@code (exp(x)-1)/x} if x is non-zero, or 1 if x=0\n */\nstatic double helper2(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.expm1(x) / x;\n    } else {\n        return 1. + x * (1. / 2.) * (1. + x * (1. / 3.) * (1. + x * (1. / 4.)));\n    }\n}"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxIter",
                "/**\n * Factory method that creates instance of this class that represents\n * a virtually unlimited number of iterations.\n *\n * @return a new instance suitable for allowing {@link Integer#MAX_VALUE}\n * evaluations.\n */\npublic static MaxIter unlimited() {\n    return new MaxIter(Integer.MAX_VALUE);\n}"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optim.linear",
                "SimplexTableau",
                "/**\n * Get the -1 times the sum of all coefficients in the given array.\n * @param coefficients coefficients to sum\n * @return the -1 times the sum of all coefficients in the given array.\n */\nprotected static double getInvertedCoefficientSum(final RealVector coefficients) {\n    double sum = 0;\n    for (double coefficient : coefficients.toArray()) {\n        sum -= coefficient;\n    }\n    return sum;\n}"
            ],
            [
                "unbounded",
                "org.apache.commons.math3.optim",
                "SimpleBounds",
                "/**\n * Factory method that creates instance of this class that represents\n * unbounded ranges.\n *\n * @param dim Number of parameters.\n * @return a new instance suitable for passing to an optimizer that\n * requires bounds specification.\n */\npublic static SimpleBounds unbounded(int dim) {\n    final double[] lB = new double[dim];\n    Arrays.fill(lB, Double.NEGATIVE_INFINITY);\n    final double[] uB = new double[dim];\n    Arrays.fill(uB, Double.POSITIVE_INFINITY);\n    return new SimpleBounds(lB, uB);\n}"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxEval",
                "/**\n * Factory method that creates instance of this class that represents\n * a virtually unlimited number of evaluations.\n *\n * @return a new instance suitable for allowing {@link Integer#MAX_VALUE}\n * evaluations.\n */\npublic static MaxEval unlimited() {\n    return new MaxEval(Integer.MAX_VALUE);\n}"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the error function.\n *\n * <p>erf(x) = 2/&radic;&pi; <sub>0</sub>&int;<sup>x</sup> e<sup>-t<sup>2</sup></sup>dt </p>\n *\n * <p>This implementation computes erf(x) using the\n * {@link Gamma#regularizedGammaP(double, double, double, int) regularized gamma function},\n * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3)</p>\n *\n * <p>The value returned is always between -1 and 1 (inclusive).\n * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from\n * either 1 or -1 as a double, so the appropriate extreme value is returned.\n * </p>\n *\n * @param x the value.\n * @return the error function erf(x)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n * @see Gamma#regularizedGammaP(double, double, double, int)\n */\npublic static double erf(double x) {\n    if (FastMath.abs(x) > 40) {\n        return x > 0 ? 1 : -1;\n    }\n    final double ret = Gamma.regularizedGammaP(0.5, x * x, 1.0e-15, 10000);\n    return x < 0 ? -ret : ret;\n}"
            ],
            [
                "erfc",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the complementary error function.\n *\n * <p>erfc(x) = 2/&radic;&pi; <sub>x</sub>&int;<sup>&infin;</sup> e<sup>-t<sup>2</sup></sup>dt\n * <br/>\n *    = 1 - {@link #erf(double) erf(x)} </p>\n *\n * <p>This implementation computes erfc(x) using the\n * {@link Gamma#regularizedGammaQ(double, double, double, int) regularized gamma function},\n * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3).</p>\n *\n * <p>The value returned is always between 0 and 2 (inclusive).\n * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from\n * either 0 or 2 as a double, so the appropriate extreme value is returned.\n * </p>\n *\n * @param x the value\n * @return the complementary error function erfc(x)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n * @see Gamma#regularizedGammaQ(double, double, double, int)\n * @since 2.2\n */\npublic static double erfc(double x) {\n    if (FastMath.abs(x) > 40) {\n        return x > 0 ? 0 : 2;\n    }\n    final double ret = Gamma.regularizedGammaQ(0.5, x * x, 1.0e-15, 10000);\n    return x < 0 ? 2 - ret : ret;\n}"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the difference between erf(x1) and erf(x2).\n *\n * The implementation uses either erf(double) or erfc(double)\n * depending on which provides the most precise result.\n *\n * @param x1 the first value\n * @param x2 the second value\n * @return erf(x2) - erf(x1)\n */\npublic static double erf(double x1, double x2) {\n    if (x1 > x2) {\n        return -erf(x2, x1);\n    }\n    return x1 < -X_CRIT ? x2 < 0.0 ? erfc(-x2) - erfc(-x1) : erf(x2) - erf(x1) : x2 > X_CRIT && x1 > 0.0 ? erfc(x1) - erfc(x2) : erf(x2) - erf(x1);\n}"
            ],
            [
                "erfInv",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the inverse erf.\n * <p>\n * This implementation is described in the paper:\n * <a href=\"http://people.maths.ox.ac.uk/gilesm/files/gems_erfinv.pdf\">Approximating\n * the erfinv function</a> by Mike Giles, Oxford-Man Institute of Quantitative Finance,\n * which was published in GPU Computing Gems, volume 2, 2010.\n * The source code is available <a href=\"http://gpucomputing.net/?q=node/1828\">here</a>.\n * </p>\n * @param x the value\n * @return t such that x = erf(t)\n * @since 3.2\n */\npublic static double erfInv(final double x) {\n    // beware that the logarithm argument must be\n    // commputed as (1.0 - x) * (1.0 + x),\n    // it must NOT be simplified as 1.0 - x * x as this\n    // would induce rounding errors near the boundaries +/-1\n    double w = -FastMath.log((1.0 - x) * (1.0 + x));\n    double p;\n    if (w < 6.25) {\n        w -= 3.125;\n        p = -3.6444120640178196996e-21;\n        p = -1.685059138182016589e-19 + p * w;\n        p = 1.2858480715256400167e-18 + p * w;\n        p = 1.115787767802518096e-17 + p * w;\n        p = -1.333171662854620906e-16 + p * w;\n        p = 2.0972767875968561637e-17 + p * w;\n        p = 6.6376381343583238325e-15 + p * w;\n        p = -4.0545662729752068639e-14 + p * w;\n        p = -8.1519341976054721522e-14 + p * w;\n        p = 2.6335093153082322977e-12 + p * w;\n        p = -1.2975133253453532498e-11 + p * w;\n        p = -5.4154120542946279317e-11 + p * w;\n        p = 1.051212273321532285e-09 + p * w;\n        p = -4.1126339803469836976e-09 + p * w;\n        p = -2.9070369957882005086e-08 + p * w;\n        p = 4.2347877827932403518e-07 + p * w;\n        p = -1.3654692000834678645e-06 + p * w;\n        p = -1.3882523362786468719e-05 + p * w;\n        p = 0.0001867342080340571352 + p * w;\n        p = -0.00074070253416626697512 + p * w;\n        p = -0.0060336708714301490533 + p * w;\n        p = 0.24015818242558961693 + p * w;\n        p = 1.6536545626831027356 + p * w;\n    } else if (w < 16.0) {\n        w = FastMath.sqrt(w) - 3.25;\n        p = 2.2137376921775787049e-09;\n        p = 9.0756561938885390979e-08 + p * w;\n        p = -2.7517406297064545428e-07 + p * w;\n        p = 1.8239629214389227755e-08 + p * w;\n        p = 1.5027403968909827627e-06 + p * w;\n        p = -4.013867526981545969e-06 + p * w;\n        p = 2.9234449089955446044e-06 + p * w;\n        p = 1.2475304481671778723e-05 + p * w;\n        p = -4.7318229009055733981e-05 + p * w;\n        p = 6.8284851459573175448e-05 + p * w;\n        p = 2.4031110387097893999e-05 + p * w;\n        p = -0.0003550375203628474796 + p * w;\n        p = 0.00095328937973738049703 + p * w;\n        p = -0.0016882755560235047313 + p * w;\n        p = 0.0024914420961078508066 + p * w;\n        p = -0.0037512085075692412107 + p * w;\n        p = 0.005370914553590063617 + p * w;\n        p = 1.0052589676941592334 + p * w;\n        p = 3.0838856104922207635 + p * w;\n    } else if (!Double.isInfinite(w)) {\n        w = FastMath.sqrt(w) - 5.0;\n        p = -2.7109920616438573243e-11;\n        p = -2.5556418169965252055e-10 + p * w;\n        p = 1.5076572693500548083e-09 + p * w;\n        p = -3.7894654401267369937e-09 + p * w;\n        p = 7.6157012080783393804e-09 + p * w;\n        p = -1.4960026627149240478e-08 + p * w;\n        p = 2.9147953450901080826e-08 + p * w;\n        p = -6.7711997758452339498e-08 + p * w;\n        p = 2.2900482228026654717e-07 + p * w;\n        p = -9.9298272942317002539e-07 + p * w;\n        p = 4.5260625972231537039e-06 + p * w;\n        p = -1.9681778105531670567e-05 + p * w;\n        p = 7.5995277030017761139e-05 + p * w;\n        p = -0.00021503011930044477347 + p * w;\n        p = -0.00013871931833623122026 + p * w;\n        p = 1.0103004648645343977 + p * w;\n        p = 4.8499064014085844221 + p * w;\n    } else {\n        // this branch does not appears in the original code, it\n        // was added because the previous branch does not handle\n        // x = +/-1 correctly. In this case, w is positive infinity\n        // and as the first coefficient (-2.71e-11) is negative.\n        // Once the first multiplication is done, p becomes negative\n        // infinity and remains so throughout the polynomial evaluation.\n        // So the branch above incorrectly returns negative infinity\n        // instead of the correct positive infinity.\n        p = Double.POSITIVE_INFINITY;\n    }\n    return p * x;\n}"
            ],
            [
                "erfcInv",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the inverse erfc.\n * @param x the value\n * @return t such that x = erfc(t)\n * @since 3.2\n */\npublic static double erfcInv(final double x) {\n    return erfInv(1 - x);\n}"
            ],
            [
                "value",
                "org.apache.commons.math3.special",
                "BesselJ",
                "/**\n * Returns the first Bessel function, \\(J_{order}(x)\\).\n *\n * @param order Order of the Bessel function\n * @param x Argument\n * @return Value of the Bessel function of the first kind, \\(J_{order}(x)\\)\n * @throws MathIllegalArgumentException if {@code x} is too large relative to {@code order}\n * @throws ConvergenceException if the algorithm fails to converge\n */\npublic static double value(double order, double x) throws MathIllegalArgumentException, ConvergenceException {\n    final int n = (int) order;\n    final double alpha = order - n;\n    final int nb = n + 1;\n    final BesselJResult res = rjBesl(x, alpha, nb);\n    if (res.nVals >= nb) {\n        return res.vals[n];\n    } else if (res.nVals < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.BESSEL_FUNCTION_BAD_ARGUMENT, order, x);\n    } else if (FastMath.abs(res.vals[res.nVals - 1]) < 1e-100) {\n        // underflow; return value (will be zero)\n        return res.vals[n];\n    }\n    throw new ConvergenceException(LocalizedFormats.BESSEL_FUNCTION_FAILED_CONVERGENCE, order, x);\n}"
            ],
            [
                "rjBesl",
                "org.apache.commons.math3.special",
                "BesselJ",
                "/**\n * Calculates Bessel functions \\(J_{n+alpha}(x)\\) for\n * non-negative argument x, and non-negative order n + alpha.\n * <p>\n * Before using the output vector, the user should check that\n * nVals = nb, i.e., all orders have been calculated to the desired accuracy.\n * See BesselResult class javadoc for details on return values.\n * </p>\n * @param x non-negative real argument for which J's are to be calculated\n * @param alpha fractional part of order for which J's or exponentially\n * scaled J's (\\(J\\cdot e^{x}\\)) are to be calculated. 0 <= alpha < 1.0.\n * @param nb integer number of functions to be calculated, nb > 0. The first\n * function calculated is of order alpha, and the last is of order\n * nb - 1 + alpha.\n * @return BesselJResult a vector of the functions\n * \\(J_{alpha}(x)\\) through \\(J_{nb-1+alpha}(x)\\), or the corresponding exponentially\n * scaled functions and an integer output variable indicating possible errors\n */\npublic static BesselJResult rjBesl(double x, double alpha, int nb) {\n    final double[] b = new double[nb];\n    int ncalc = 0;\n    double alpem = 0;\n    double alp2em = 0;\n    // ---------------------------------------------------------------------\n    // Check for out of range arguments.\n    // ---------------------------------------------------------------------\n    final int magx = (int) x;\n    if ((nb > 0) && (x >= X_MIN) && (x <= X_MAX) && (alpha >= 0) && (alpha < 1)) {\n        // ---------------------------------------------------------------------\n        // Initialize result array to zero.\n        // ---------------------------------------------------------------------\n        ncalc = nb;\n        for (int i = 0; i < nb; ++i) {\n            b[i] = 0;\n        }\n        // ---------------------------------------------------------------------\n        // Branch to use 2-term ascending series for small X and asymptotic\n        // form for large X when NB is not too large.\n        // ---------------------------------------------------------------------\n        double tempa;\n        double tempb;\n        double tempc;\n        double tover;\n        if (x < RTNSIG) {\n            // ---------------------------------------------------------------------\n            // Two-term ascending series for small X.\n            // ---------------------------------------------------------------------\n            tempa = 1;\n            alpem = 1 + alpha;\n            double halfx = 0;\n            if (x > ENMTEN) {\n                halfx = 0.5 * x;\n            }\n            if (alpha != 0) {\n                tempa = FastMath.pow(halfx, alpha) / (alpha * Gamma.gamma(alpha));\n            }\n            tempb = 0;\n            if (x + 1 > 1) {\n                tempb = -halfx * halfx;\n            }\n            b[0] = tempa + (tempa * tempb / alpem);\n            if ((x != 0) && (b[0] == 0)) {\n                ncalc = 0;\n            }\n            if (nb != 1) {\n                if (x <= 0) {\n                    for (int n = 1; n < nb; ++n) {\n                        b[n] = 0;\n                    }\n                } else {\n                    // ---------------------------------------------------------------------\n                    // Calculate higher order functions.\n                    // ---------------------------------------------------------------------\n                    tempc = halfx;\n                    tover = tempb != 0 ? ENMTEN / tempb : 2 * ENMTEN / x;\n                    for (int n = 1; n < nb; ++n) {\n                        tempa /= alpem;\n                        alpem += 1;\n                        tempa *= tempc;\n                        if (tempa <= tover * alpem) {\n                            tempa = 0;\n                        }\n                        b[n] = tempa + (tempa * tempb / alpem);\n                        if ((b[n] == 0) && (ncalc > n)) {\n                            ncalc = n;\n                        }\n                    }\n                }\n            }\n        } else if ((x > 25.0) && (nb <= magx + 1)) {\n            // ---------------------------------------------------------------------\n            // Asymptotic series for X > 25\n            // ---------------------------------------------------------------------\n            final double xc = FastMath.sqrt(PI2 / x);\n            final double mul = 0.125 / x;\n            final double xin = mul * mul;\n            int m = 0;\n            if (x >= 130.0) {\n                m = 4;\n            } else if (x >= 35.0) {\n                m = 8;\n            } else {\n                m = 11;\n            }\n            final double xm = 4.0 * m;\n            // ---------------------------------------------------------------------\n            // Argument reduction for SIN and COS routines.\n            // ---------------------------------------------------------------------\n            double t = (double) ((int) ((x / TWOPI) + 0.5));\n            final double z = x - t * TOWPI1 - t * TWOPI2 - (alpha + 0.5) / PI2;\n            double vsin = FastMath.sin(z);\n            double vcos = FastMath.cos(z);\n            double gnu = 2 * alpha;\n            double capq;\n            double capp;\n            double s;\n            double t1;\n            double xk;\n            for (int i = 1; i <= 2; i++) {\n                s = (xm - 1 - gnu) * (xm - 1 + gnu) * xin * 0.5;\n                t = (gnu - (xm - 3.0)) * (gnu + (xm - 3.0));\n                capp = (s * t) / FACT[2 * m];\n                t1 = (gnu - (xm + 1)) * (gnu + (xm + 1));\n                capq = (s * t1) / FACT[2 * m + 1];\n                xk = xm;\n                int k = 2 * m;\n                t1 = t;\n                for (int j = 2; j <= m; j++) {\n                    xk -= 4.0;\n                    s = (xk - 1 - gnu) * (xk - 1 + gnu);\n                    t = (gnu - (xk - 3.0)) * (gnu + (xk - 3.0));\n                    capp = (capp + 1 / FACT[k - 2]) * s * t * xin;\n                    capq = (capq + 1 / FACT[k - 1]) * s * t1 * xin;\n                    k -= 2;\n                    t1 = t;\n                }\n                capp += 1;\n                capq = (capq + 1) * ((gnu * gnu) - 1) * (0.125 / x);\n                b[i - 1] = xc * (capp * vcos - capq * vsin);\n                if (nb == 1) {\n                    return new BesselJResult(MathArrays.copyOf(b, b.length), ncalc);\n                }\n                t = vsin;\n                vsin = -vcos;\n                vcos = t;\n                gnu += 2.0;\n            }\n            // ---------------------------------------------------------------------\n            // If NB > 2, compute J(X,ORDER+I) I = 2, NB-1\n            // ---------------------------------------------------------------------\n            if (nb > 2) {\n                gnu = 2 * alpha + 2.0;\n                for (int j = 2; j < nb; ++j) {\n                    b[j] = gnu * b[j - 1] / x - b[j - 2];\n                    gnu += 2.0;\n                }\n            }\n        } else {\n            // ---------------------------------------------------------------------\n            // Use recurrence to generate results. First initialize the\n            // calculation of P*S.\n            // ---------------------------------------------------------------------\n            final int nbmx = nb - magx;\n            int n = magx + 1;\n            int nstart = 0;\n            int nend = 0;\n            double en = 2 * (n + alpha);\n            double plast = 1;\n            double p = en / x;\n            double pold;\n            // ---------------------------------------------------------------------\n            // Calculate general significance test.\n            // ---------------------------------------------------------------------\n            double test = 2 * ENSIG;\n            boolean readyToInitialize = false;\n            if (nbmx >= 3) {\n                // ---------------------------------------------------------------------\n                // Calculate P*S until N = NB-1. Check for possible\n                // overflow.\n                // ---------------------------------------------------------------------\n                tover = ENTEN / ENSIG;\n                nstart = magx + 2;\n                nend = nb - 1;\n                en = 2 * (nstart - 1 + alpha);\n                double psave;\n                double psavel;\n                for (int k = nstart; k <= nend; k++) {\n                    n = k;\n                    en += 2.0;\n                    pold = plast;\n                    plast = p;\n                    p = (en * plast / x) - pold;\n                    if (p > tover) {\n                        // ---------------------------------------------------------------------\n                        // To avoid overflow, divide P*S by TOVER. Calculate\n                        // P*S until\n                        // ABS(P) > 1.\n                        // ---------------------------------------------------------------------\n                        tover = ENTEN;\n                        p /= tover;\n                        plast /= tover;\n                        psave = p;\n                        psavel = plast;\n                        nstart = n + 1;\n                        do {\n                            n += 1;\n                            en += 2.0;\n                            pold = plast;\n                            plast = p;\n                            p = (en * plast / x) - pold;\n                        } while (p <= 1);\n                        tempb = en / x;\n                        // ---------------------------------------------------------------------\n                        // Calculate backward test and find NCALC, the\n                        // highest N such that\n                        // the test is passed.\n                        // ---------------------------------------------------------------------\n                        test = pold * plast * (0.5 - 0.5 / (tempb * tempb));\n                        test /= ENSIG;\n                        p = plast * tover;\n                        n -= 1;\n                        en -= 2.0;\n                        nend = FastMath.min(nb, n);\n                        for (int l = nstart; l <= nend; l++) {\n                            pold = psavel;\n                            psavel = psave;\n                            psave = (en * psavel / x) - pold;\n                            if (psave * psavel > test) {\n                                ncalc = l - 1;\n                                readyToInitialize = true;\n                                break;\n                            }\n                        }\n                        ncalc = nend;\n                        readyToInitialize = true;\n                        break;\n                    }\n                }\n                if (!readyToInitialize) {\n                    n = nend;\n                    en = 2 * (n + alpha);\n                    // ---------------------------------------------------------------------\n                    // Calculate special significance test for NBMX > 2.\n                    // ---------------------------------------------------------------------\n                    test = FastMath.max(test, FastMath.sqrt(plast * ENSIG) * FastMath.sqrt(2 * p));\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Calculate P*S until significance test passes.\n            // ---------------------------------------------------------------------\n            if (!readyToInitialize) {\n                do {\n                    n += 1;\n                    en += 2.0;\n                    pold = plast;\n                    plast = p;\n                    p = (en * plast / x) - pold;\n                } while (p < test);\n            }\n            // ---------------------------------------------------------------------\n            // Initialize the backward recursion and the normalization sum.\n            // ---------------------------------------------------------------------\n            n += 1;\n            en += 2.0;\n            tempb = 0;\n            tempa = 1 / p;\n            int m = (2 * n) - 4 * (n / 2);\n            double sum = 0;\n            double em = (double) (n / 2);\n            alpem = em - 1 + alpha;\n            alp2em = 2 * em + alpha;\n            if (m != 0) {\n                sum = tempa * alpem * alp2em / em;\n            }\n            nend = n - nb;\n            boolean readyToNormalize = false;\n            boolean calculatedB0 = false;\n            // ---------------------------------------------------------------------\n            // Recur backward via difference equation, calculating (but not\n            // storing) B(N), until N = NB.\n            // ---------------------------------------------------------------------\n            for (int l = 1; l <= nend; l++) {\n                n -= 1;\n                en -= 2.0;\n                tempc = tempb;\n                tempb = tempa;\n                tempa = (en * tempb / x) - tempc;\n                m = 2 - m;\n                if (m != 0) {\n                    em -= 1;\n                    alp2em = 2 * em + alpha;\n                    if (n == 1) {\n                        break;\n                    }\n                    alpem = em - 1 + alpha;\n                    if (alpem == 0) {\n                        alpem = 1;\n                    }\n                    sum = (sum + tempa * alp2em) * alpem / em;\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Store B(NB).\n            // ---------------------------------------------------------------------\n            b[n - 1] = tempa;\n            if (nend >= 0) {\n                if (nb <= 1) {\n                    alp2em = alpha;\n                    if (alpha + 1 == 1) {\n                        alp2em = 1;\n                    }\n                    sum += b[0] * alp2em;\n                    readyToNormalize = true;\n                } else {\n                    // ---------------------------------------------------------------------\n                    // Calculate and store B(NB-1).\n                    // ---------------------------------------------------------------------\n                    n -= 1;\n                    en -= 2.0;\n                    b[n - 1] = (en * tempa / x) - tempb;\n                    if (n == 1) {\n                        calculatedB0 = true;\n                    } else {\n                        m = 2 - m;\n                        if (m != 0) {\n                            em -= 1;\n                            alp2em = 2 * em + alpha;\n                            alpem = em - 1 + alpha;\n                            if (alpem == 0) {\n                                alpem = 1;\n                            }\n                            sum = (sum + (b[n - 1] * alp2em)) * alpem / em;\n                        }\n                    }\n                }\n            }\n            if (!readyToNormalize && !calculatedB0) {\n                nend = n - 2;\n                if (nend != 0) {\n                    // ---------------------------------------------------------------------\n                    // Calculate via difference equation and store B(N),\n                    // until N = 2.\n                    // ---------------------------------------------------------------------\n                    for (int l = 1; l <= nend; l++) {\n                        n -= 1;\n                        en -= 2.0;\n                        b[n - 1] = (en * b[n] / x) - b[n + 1];\n                        m = 2 - m;\n                        if (m != 0) {\n                            em -= 1;\n                            alp2em = 2 * em + alpha;\n                            alpem = em - 1 + alpha;\n                            if (alpem == 0) {\n                                alpem = 1;\n                            }\n                            sum = (sum + b[n - 1] * alp2em) * alpem / em;\n                        }\n                    }\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Calculate b[0]\n            // ---------------------------------------------------------------------\n            if (!readyToNormalize) {\n                if (!calculatedB0) {\n                    b[0] = 2.0 * (alpha + 1) * b[1] / x - b[2];\n                }\n                em -= 1;\n                alp2em = 2 * em + alpha;\n                if (alp2em == 0) {\n                    alp2em = 1;\n                }\n                sum += b[0] * alp2em;\n            }\n            // ---------------------------------------------------------------------\n            // Normalize. Divide all B(N) by sum.\n            // ---------------------------------------------------------------------\n            if (FastMath.abs(alpha) > 1e-16) {\n                sum *= Gamma.gamma(alpha) * FastMath.pow(x * 0.5, -alpha);\n            }\n            tempa = ENMTEN;\n            if (sum > 1) {\n                tempa *= sum;\n            }\n            for (n = 0; n < nb; n++) {\n                if (FastMath.abs(b[n]) < tempa) {\n                    b[n] = 0;\n                }\n                b[n] /= sum;\n            }\n        }\n        // ---------------------------------------------------------------------\n        // Error return -- X, NB, or ALPHA is out of range.\n        // ---------------------------------------------------------------------\n    } else {\n        if (b.length > 0) {\n            b[0] = 0;\n        }\n        ncalc = FastMath.min(nb, 0) - 1;\n    }\n    return new BesselJResult(MathArrays.copyOf(b, b.length), ncalc);\n}"
            ],
            [
                "logGamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>\n * Returns the value of log&nbsp;&Gamma;(x) for x&nbsp;&gt;&nbsp;0.\n * </p>\n * <p>\n * For x &le; 8, the implementation is based on the double precision\n * implementation in the <em>NSWC Library of Mathematics Subroutines</em>,\n * {@code DGAMLN}. For x &gt; 8, the implementation is based on\n * </p>\n * <ul>\n * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">Gamma\n *     Function</a>, equation (28).</li>\n * <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">\n *     Lanczos Approximation</a>, equations (1) through (5).</li>\n * <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on\n *     the computation of the convergent Lanczos complex Gamma\n *     approximation</a></li>\n * </ul>\n *\n * @param x Argument.\n * @return the value of {@code log(Gamma(x))}, {@code Double.NaN} if\n * {@code x <= 0.0}.\n */\npublic static double logGamma(double x) {\n    double ret;\n    if (Double.isNaN(x) || (x <= 0.0)) {\n        ret = Double.NaN;\n    } else if (x < 0.5) {\n        return logGamma1p(x) - FastMath.log(x);\n    } else if (x <= 2.5) {\n        return logGamma1p((x - 0.5) - 0.5);\n    } else if (x <= 8.0) {\n        final int n = (int) FastMath.floor(x - 1.5);\n        double prod = 1.0;\n        for (int i = 1; i <= n; i++) {\n            prod *= x - i;\n        }\n        return logGamma1p(x - (n + 1)) + FastMath.log(prod);\n    } else {\n        double sum = lanczos(x);\n        double tmp = x + LANCZOS_G + .5;\n        ret = ((x + .5) * FastMath.log(tmp)) - tmp + HALF_LOG_2_PI + FastMath.log(sum / x);\n    }\n    return ret;\n}"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function P(a, x).\n *\n * @param a Parameter.\n * @param x Value.\n * @return the regularized gamma function P(a, x).\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaP(double a, double x) {\n    return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function P(a, x).\n *\n * The implementation of this method is based on:\n * <ul>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n *   Regularized Gamma Function</a>, equation (1)\n *  </li>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n *   Incomplete Gamma Function</a>, equation (4).\n *  </li>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n *   Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n *  </li>\n * </ul>\n *\n * @param a the a parameter.\n * @param x the value.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized gamma function P(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n        ret = Double.NaN;\n    } else if (x == 0.0) {\n        ret = 0.0;\n    } else if (x >= a + 1) {\n        // use regularizedGammaQ because it should converge faster in this\n        // case.\n        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n    } else {\n        // calculate series\n        // current element index\n        double n = 0.0;\n        // n-th element in the series\n        double an = 1.0 / a;\n        // partial sum\n        double sum = an;\n        while (FastMath.abs(an / sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) {\n            // compute next element in the series\n            n += 1.0;\n            an *= x / (a + n);\n            // update partial sum\n            sum += an;\n        }\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(maxIterations);\n        } else if (Double.isInfinite(sum)) {\n            ret = 1.0;\n        } else {\n            ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * sum;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n *\n * @param a the a parameter.\n * @param x the value.\n * @return the regularized gamma function Q(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaQ(double a, double x) {\n    return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n *\n * The implementation of this method is based on:\n * <ul>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n *   Regularized Gamma Function</a>, equation (1).\n *  </li>\n *  <li>\n *   <a href=\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\">\n *   Regularized incomplete gamma function: Continued fraction representations\n *   (formula 06.08.10.0003)</a>\n *  </li>\n * </ul>\n *\n * @param a the a parameter.\n * @param x the value.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized gamma function P(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n        ret = Double.NaN;\n    } else if (x == 0.0) {\n        ret = 1.0;\n    } else if (x < a + 1.0) {\n        // use regularizedGammaP because it should converge faster in this\n        // case.\n        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        // create continued fraction\n        ContinuedFraction cf = new ContinuedFraction() {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}"
            ],
            [
                "digamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>Computes the digamma function of x.</p>\n *\n * <p>This is an independently written implementation of the algorithm described in\n * Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976.</p>\n *\n * <p>Some of the constants have been changed to increase accuracy at the moderate expense\n * of run-time.  The result should be accurate to within 10^-8 absolute tolerance for\n * x >= 10^-5 and within 10^-8 relative tolerance for x > 0.</p>\n *\n * <p>Performance for large negative values of x will be quite expensive (proportional to\n * |x|).  Accuracy for negative values of x should be about 10^-8 absolute for results\n * less than 10^5 and 10^-8 relative for results larger than that.</p>\n *\n * @param x Argument.\n * @return digamma(x) to within 10-8 relative or absolute error whichever is smaller.\n * @see <a href=\"http://en.wikipedia.org/wiki/Digamma_function\">Digamma</a>\n * @see <a href=\"http://www.uv.es/~bernardo/1976AppStatist.pdf\">Bernardo&apos;s original article </a>\n * @since 2.0\n */\npublic static double digamma(double x) {\n    if (Double.isNaN(x) || Double.isInfinite(x)) {\n        return x;\n    }\n    if (x > 0 && x <= S_LIMIT) {\n        // use method 5 from Bernardo AS103\n        // accurate to O(x)\n        return -GAMMA - 1 / x;\n    }\n    if (x >= C_LIMIT) {\n        // use method 4 (accurate to O(1/x^8)\n        double inv = 1 / (x * x);\n        //            1       1        1         1\n        // log(x) -  --- - ------ + ------- - -------\n        //           2 x   12 x^2   120 x^4   252 x^6\n        return FastMath.log(x) - 0.5 / x - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));\n    }\n    return digamma(x + 1) - 1 / x;\n}"
            ],
            [
                "trigamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Computes the trigamma function of x.\n * This function is derived by taking the derivative of the implementation\n * of digamma.\n *\n * @param x Argument.\n * @return trigamma(x) to within 10-8 relative or absolute error whichever is smaller\n * @see <a href=\"http://en.wikipedia.org/wiki/Trigamma_function\">Trigamma</a>\n * @see Gamma#digamma(double)\n * @since 2.0\n */\npublic static double trigamma(double x) {\n    if (Double.isNaN(x) || Double.isInfinite(x)) {\n        return x;\n    }\n    if (x > 0 && x <= S_LIMIT) {\n        return 1 / (x * x);\n    }\n    if (x >= C_LIMIT) {\n        double inv = 1 / (x * x);\n        //  1    1      1       1       1\n        //  - + ---- + ---- - ----- + -----\n        //  x      2      3       5       7\n        //      2 x    6 x    30 x    42 x\n        return 1 / x + inv / 2 + inv / x * (1.0 / 6 - inv * (1.0 / 30 + inv / 42));\n    }\n    return trigamma(x + 1) + 1 / (x * x);\n}"
            ],
            [
                "lanczos",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>\n * Returns the Lanczos approximation used to compute the gamma function.\n * The Lanczos approximation is related to the Gamma function by the\n * following equation\n * <center>\n * {@code gamma(x) = sqrt(2 * pi) / x * (x + g + 0.5) ^ (x + 0.5)\n *                   * exp(-x - g - 0.5) * lanczos(x)},\n * </center>\n * where {@code g} is the Lanczos constant.\n * </p>\n *\n * @param x Argument.\n * @return The Lanczos approximation.\n * @see <a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">Lanczos Approximation</a>\n * equations (1) through (5), and Paul Godfrey's\n * <a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Note on the computation\n * of the convergent Lanczos complex Gamma approximation</a>\n * @since 3.1\n */\npublic static double lanczos(final double x) {\n    double sum = 0.0;\n    for (int i = LANCZOS.length - 1; i > 0; --i) {\n        sum += LANCZOS[i] / (x + i);\n    }\n    return sum + LANCZOS[0];\n}"
            ],
            [
                "invGamma1pm1",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of 1 / &Gamma;(1 + x) - 1 for -0&#46;5 &le; x &le;\n * 1&#46;5. This implementation is based on the double precision\n * implementation in the <em>NSWC Library of Mathematics Subroutines</em>,\n * {@code DGAM1}.\n *\n * @param x Argument.\n * @return The value of {@code 1.0 / Gamma(1.0 + x) - 1.0}.\n * @throws NumberIsTooSmallException if {@code x < -0.5}\n * @throws NumberIsTooLargeException if {@code x > 1.5}\n * @since 3.1\n */\npublic static double invGamma1pm1(final double x) {\n    if (x < -0.5) {\n        throw new NumberIsTooSmallException(x, -0.5, true);\n    }\n    if (x > 1.5) {\n        throw new NumberIsTooLargeException(x, 1.5, true);\n    }\n    final double ret;\n    final double t = x <= 0.5 ? x : (x - 0.5) - 0.5;\n    if (t < 0.0) {\n        final double a = INV_GAMMA1P_M1_A0 + t * INV_GAMMA1P_M1_A1;\n        double b = INV_GAMMA1P_M1_B8;\n        b = INV_GAMMA1P_M1_B7 + t * b;\n        b = INV_GAMMA1P_M1_B6 + t * b;\n        b = INV_GAMMA1P_M1_B5 + t * b;\n        b = INV_GAMMA1P_M1_B4 + t * b;\n        b = INV_GAMMA1P_M1_B3 + t * b;\n        b = INV_GAMMA1P_M1_B2 + t * b;\n        b = INV_GAMMA1P_M1_B1 + t * b;\n        b = 1.0 + t * b;\n        double c = INV_GAMMA1P_M1_C13 + t * (a / b);\n        c = INV_GAMMA1P_M1_C12 + t * c;\n        c = INV_GAMMA1P_M1_C11 + t * c;\n        c = INV_GAMMA1P_M1_C10 + t * c;\n        c = INV_GAMMA1P_M1_C9 + t * c;\n        c = INV_GAMMA1P_M1_C8 + t * c;\n        c = INV_GAMMA1P_M1_C7 + t * c;\n        c = INV_GAMMA1P_M1_C6 + t * c;\n        c = INV_GAMMA1P_M1_C5 + t * c;\n        c = INV_GAMMA1P_M1_C4 + t * c;\n        c = INV_GAMMA1P_M1_C3 + t * c;\n        c = INV_GAMMA1P_M1_C2 + t * c;\n        c = INV_GAMMA1P_M1_C1 + t * c;\n        c = INV_GAMMA1P_M1_C + t * c;\n        if (x > 0.5) {\n            ret = t * c / x;\n        } else {\n            ret = x * ((c + 0.5) + 0.5);\n        }\n    } else {\n        double p = INV_GAMMA1P_M1_P6;\n        p = INV_GAMMA1P_M1_P5 + t * p;\n        p = INV_GAMMA1P_M1_P4 + t * p;\n        p = INV_GAMMA1P_M1_P3 + t * p;\n        p = INV_GAMMA1P_M1_P2 + t * p;\n        p = INV_GAMMA1P_M1_P1 + t * p;\n        p = INV_GAMMA1P_M1_P0 + t * p;\n        double q = INV_GAMMA1P_M1_Q4;\n        q = INV_GAMMA1P_M1_Q3 + t * q;\n        q = INV_GAMMA1P_M1_Q2 + t * q;\n        q = INV_GAMMA1P_M1_Q1 + t * q;\n        q = 1.0 + t * q;\n        double c = INV_GAMMA1P_M1_C13 + (p / q) * t;\n        c = INV_GAMMA1P_M1_C12 + t * c;\n        c = INV_GAMMA1P_M1_C11 + t * c;\n        c = INV_GAMMA1P_M1_C10 + t * c;\n        c = INV_GAMMA1P_M1_C9 + t * c;\n        c = INV_GAMMA1P_M1_C8 + t * c;\n        c = INV_GAMMA1P_M1_C7 + t * c;\n        c = INV_GAMMA1P_M1_C6 + t * c;\n        c = INV_GAMMA1P_M1_C5 + t * c;\n        c = INV_GAMMA1P_M1_C4 + t * c;\n        c = INV_GAMMA1P_M1_C3 + t * c;\n        c = INV_GAMMA1P_M1_C2 + t * c;\n        c = INV_GAMMA1P_M1_C1 + t * c;\n        c = INV_GAMMA1P_M1_C0 + t * c;\n        if (x > 0.5) {\n            ret = (t / x) * ((c - 0.5) - 0.5);\n        } else {\n            ret = x * c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "logGamma1p",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of log &Gamma;(1 + x) for -0&#46;5 &le; x &le; 1&#46;5.\n * This implementation is based on the double precision implementation in\n * the <em>NSWC Library of Mathematics Subroutines</em>, {@code DGMLN1}.\n *\n * @param x Argument.\n * @return The value of {@code log(Gamma(1 + x))}.\n * @throws NumberIsTooSmallException if {@code x < -0.5}.\n * @throws NumberIsTooLargeException if {@code x > 1.5}.\n * @since 3.1\n */\npublic static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException {\n    if (x < -0.5) {\n        throw new NumberIsTooSmallException(x, -0.5, true);\n    }\n    if (x > 1.5) {\n        throw new NumberIsTooLargeException(x, 1.5, true);\n    }\n    return -FastMath.log1p(invGamma1pm1(x));\n}"
            ],
            [
                "gamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of \u0393(x). Based on the <em>NSWC Library of\n * Mathematics Subroutines</em> double precision implementation,\n * {@code DGAMMA}.\n *\n * @param x Argument.\n * @return the value of {@code Gamma(x)}.\n * @since 3.1\n */\npublic static double gamma(final double x) {\n    if ((x == FastMath.rint(x)) && (x <= 0.0)) {\n        return Double.NaN;\n    }\n    final double ret;\n    final double absX = FastMath.abs(x);\n    if (absX <= 20.0) {\n        if (x >= 1.0) {\n            /*\n                 * From the recurrence relation\n                 * Gamma(x) = (x - 1) * ... * (x - n) * Gamma(x - n),\n                 * then\n                 * Gamma(t) = 1 / [1 + invGamma1pm1(t - 1)],\n                 * where t = x - n. This means that t must satisfy\n                 * -0.5 <= t - 1 <= 1.5.\n                 */\n            double prod = 1.0;\n            double t = x;\n            while (t > 2.5) {\n                t -= 1.0;\n                prod *= t;\n            }\n            ret = prod / (1.0 + invGamma1pm1(t - 1.0));\n        } else {\n            /*\n                 * From the recurrence relation\n                 * Gamma(x) = Gamma(x + n + 1) / [x * (x + 1) * ... * (x + n)]\n                 * then\n                 * Gamma(x + n + 1) = 1 / [1 + invGamma1pm1(x + n)],\n                 * which requires -0.5 <= x + n <= 1.5.\n                 */\n            double prod = x;\n            double t = x;\n            while (t < -0.5) {\n                t += 1.0;\n                prod *= t;\n            }\n            ret = 1.0 / (prod * (1.0 + invGamma1pm1(t)));\n        }\n    } else {\n        final double y = absX + LANCZOS_G + 0.5;\n        final double gammaAbs = SQRT_TWO_PI / absX * FastMath.pow(y, absX + 0.5) * FastMath.exp(-y) * lanczos(absX);\n        if (x > 0.0) {\n            ret = gammaAbs;\n        } else {\n            /*\n                 * From the reflection formula\n                 * Gamma(x) * Gamma(1 - x) * sin(pi * x) = pi,\n                 * and the recurrence relation\n                 * Gamma(1 - x) = -x * Gamma(-x),\n                 * it is found\n                 * Gamma(x) = -pi / [x * sin(pi * x) * Gamma(-x)].\n                 */\n            ret = -FastMath.PI / (x * FastMath.sin(FastMath.PI * x) * gammaAbs);\n        }\n    }\n    return ret;\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * regularized beta function</a> I(x, a, b).\n *\n * @param x Value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @return the regularized beta function I(x, a, b).\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b) {\n    return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * regularized beta function</a> I(x, a, b).\n *\n * @param x Value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b, double epsilon) {\n    return regularizedBeta(x, a, b, epsilon, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b, int maxIterations) {\n    return regularizedBeta(x, a, b, DEFAULT_EPSILON, maxIterations);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li>\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * Regularized Beta Function</a>.</li>\n * <li>\n * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n * Regularized Beta Function</a>.</li>\n * </ul>\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0 || b <= 0) {\n        ret = Double.NaN;\n    } else if (x > (a + 1) / (2 + b + a) && 1 - x <= (b + 1) / (2 + b + a)) {\n        ret = 1 - regularizedBeta(1 - x, b, a, epsilon, maxIterations);\n    } else {\n        ContinuedFraction fraction = new ContinuedFraction() {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getB(int n, double x) {\n                double ret;\n                double m;\n                if (n % 2 == 0) {\n                    // even\n                    m = n / 2.0;\n                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));\n                } else {\n                    m = (n - 1.0) / 2.0;\n                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                }\n                return ret;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getA(int n, double x) {\n                return 1.0;\n            }\n        };\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n    }\n    return ret;\n}"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the natural logarithm of the beta function B(a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n * Beta Function</a>, equation (1).</li>\n * </ul>\n *\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon This parameter is ignored.\n * @param maxIterations This parameter is ignored.\n * @return log(B(a, b)).\n * @deprecated as of version 3.1, this method is deprecated as the\n * computation of the beta function is no longer iterative; it will be\n * removed in version 4.0. Current implementation of this method\n * internally calls {@link #logBeta(double, double)}.\n */\n@Deprecated\npublic static double logBeta(double a, double b, double epsilon, int maxIterations) {\n    return logBeta(a, b);\n}"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the value of log B(p, q) for 0 \u2264 x \u2264 1 and p, q > 0. Based on the\n * <em>NSWC Library of Mathematics Subroutines</em> implementation,\n * {@code DBETLN}.\n *\n * @param p First argument.\n * @param q Second argument.\n * @return the value of {@code log(Beta(p, q))}, {@code NaN} if\n * {@code p <= 0} or {@code q <= 0}.\n */\npublic static double logBeta(final double p, final double q) {\n    if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n        return Double.NaN;\n    }\n    final double a = FastMath.min(p, q);\n    final double b = FastMath.max(p, q);\n    if (a >= 10.0) {\n        final double w = sumDeltaMinusDeltaSum(a, b);\n        final double h = a / b;\n        final double c = h / (1.0 + h);\n        final double u = -(a - 0.5) * FastMath.log(c);\n        final double v = b * FastMath.log1p(h);\n        if (u <= v) {\n            return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;\n        } else {\n            return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n        }\n    } else if (a > 2.0) {\n        if (b > 1000.0) {\n            final int n = (int) FastMath.floor(a - 1.0);\n            double prod = 1.0;\n            double ared = a;\n            for (int i = 0; i < n; i++) {\n                ared -= 1.0;\n                prod *= ared / (1.0 + ared / b);\n            }\n            return (FastMath.log(prod) - n * FastMath.log(b)) + (Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared, b));\n        } else {\n            double prod1 = 1.0;\n            double ared = a;\n            while (ared > 2.0) {\n                ared -= 1.0;\n                final double h = ared / b;\n                prod1 *= h / (1.0 + h);\n            }\n            if (b < 10.0) {\n                double prod2 = 1.0;\n                double bred = b;\n                while (bred > 2.0) {\n                    bred -= 1.0;\n                    prod2 *= bred / (ared + bred);\n                }\n                return FastMath.log(prod1) + FastMath.log(prod2) + (Gamma.logGamma(ared) + (Gamma.logGamma(bred) - logGammaSum(ared, bred)));\n            } else {\n                return FastMath.log(prod1) + Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared, b);\n            }\n        }\n    } else if (a >= 1.0) {\n        if (b > 2.0) {\n            if (b < 10.0) {\n                double prod = 1.0;\n                double bred = b;\n                while (bred > 2.0) {\n                    bred -= 1.0;\n                    prod *= bred / (a + bred);\n                }\n                return FastMath.log(prod) + (Gamma.logGamma(a) + (Gamma.logGamma(bred) - logGammaSum(a, bred)));\n            } else {\n                return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a, b);\n            }\n        } else {\n            return Gamma.logGamma(a) + Gamma.logGamma(b) - logGammaSum(a, b);\n        }\n    } else {\n        if (b >= 10.0) {\n            return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a, b);\n        } else {\n            // The following command is the original NSWC implementation.\n            // return Gamma.logGamma(a) +\n            // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n            // The following command turns out to be more accurate.\n            return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) / Gamma.gamma(a + b));\n        }\n    }\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.sampling",
                "DummyStepHandler",
                "/**\n * Get the only instance.\n * @return the only instance\n */\npublic static DummyStepHandler getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckTransformer",
                "/**\n * Get the Nordsieck transformer for a given number of steps.\n * @param nSteps number of steps of the multistep method\n * (excluding the one being computed)\n * @return Nordsieck transformer for the specified number of steps\n */\npublic static AdamsNordsieckTransformer getInstance(final int nSteps) {\n    synchronized (CACHE) {\n        AdamsNordsieckTransformer t = CACHE.get(nSteps);\n        if (t == null) {\n            t = new AdamsNordsieckTransformer(nSteps);\n            CACHE.put(nSteps, t);\n        }\n        return t;\n    }\n}"
            ],
            [
                "taylor",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsFieldStepInterpolator",
                "/**\n * Estimate state by applying Taylor formula.\n * @param reference reference state\n * @param time time at which state must be estimated\n * @param stepSize step size used in the scaled and Nordsieck arrays\n * @param scaled first scaled derivative\n * @param nordsieck Nordsieck vector\n * @return estimated state\n * @param <S> the type of the field elements\n */\npublic static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference, final S time, final S stepSize, final S[] scaled, final Array2DRowFieldMatrix<S> nordsieck) {\n    final S x = time.subtract(reference.getTime());\n    final S normalizedAbscissa = x.divide(stepSize);\n    S[] stateVariation = MathArrays.buildArray(time.getField(), scaled.length);\n    Arrays.fill(stateVariation, time.getField().getZero());\n    S[] estimatedDerivatives = MathArrays.buildArray(time.getField(), scaled.length);\n    Arrays.fill(estimatedDerivatives, time.getField().getZero());\n    // apply Taylor formula from high order to low order,\n    // for the sake of numerical accuracy\n    final S[][] nData = nordsieck.getDataRef();\n    for (int i = nData.length - 1; i >= 0; --i) {\n        final int order = i + 2;\n        final S[] nDataI = nData[i];\n        final S power = normalizedAbscissa.pow(order);\n        for (int j = 0; j < nDataI.length; ++j) {\n            final S d = nDataI[j].multiply(power);\n            stateVariation[j] = stateVariation[j].add(d);\n            estimatedDerivatives[j] = estimatedDerivatives[j].add(d.multiply(order));\n        }\n    }\n    S[] estimatedState = reference.getState();\n    for (int j = 0; j < stateVariation.length; ++j) {\n        stateVariation[j] = stateVariation[j].add(scaled[j].multiply(normalizedAbscissa));\n        estimatedState[j] = estimatedState[j].add(stateVariation[j]);\n        estimatedDerivatives[j] = estimatedDerivatives[j].add(scaled[j].multiply(normalizedAbscissa)).divide(x);\n    }\n    return new FieldODEStateAndDerivative<S>(time, estimatedState, estimatedDerivatives);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckFieldTransformer",
                "/**\n * Get the Nordsieck transformer for a given field and number of steps.\n * @param field field to which the time and state vector elements belong\n * @param nSteps number of steps of the multistep method\n * (excluding the one being computed)\n * @return Nordsieck transformer for the specified field and number of steps\n * @param <T> the type of the field elements\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T extends RealFieldElement<T>> AdamsNordsieckFieldTransformer<T> getInstance(final Field<T> field, final int nSteps) {\n    synchronized (CACHE) {\n        Map<Field<? extends RealFieldElement<?>>, AdamsNordsieckFieldTransformer<? extends RealFieldElement<?>>> map = CACHE.get(nSteps);\n        if (map == null) {\n            map = new HashMap<Field<? extends RealFieldElement<?>>, AdamsNordsieckFieldTransformer<? extends RealFieldElement<?>>>();\n            CACHE.put(nSteps, map);\n        }\n        // use rawtype to avoid compilation problems with java 1.5\n        @SuppressWarnings(\"rawtypes\")\n        AdamsNordsieckFieldTransformer t = map.get(field);\n        if (t == null) {\n            t = new AdamsNordsieckFieldTransformer<T>(field, nSteps);\n            map.put(field, (AdamsNordsieckFieldTransformer<T>) t);\n        }\n        return (AdamsNordsieckFieldTransformer<T>) t;\n    }\n}"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the values in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the input array\n * is null.</p>\n *\n * @param values  array of values to sum\n * @return the sum of the values or <code>Double.NaN</code> if the array\n * is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sum(final double[] values) throws MathIllegalArgumentException {\n    return SUM.evaluate(values);\n}"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double sum(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM.evaluate(values, begin, length);\n}"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the squares of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values  input array\n * @return the sum of the squared values or <code>Double.NaN</code> if the\n * array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sumSq(final double[] values) throws MathIllegalArgumentException {\n    return SUM_OF_SQUARES.evaluate(values);\n}"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the squares of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the squares of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double sumSq(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM_OF_SQUARES.evaluate(values, begin, length);\n}"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the product of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the product of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double product(final double[] values) throws MathIllegalArgumentException {\n    return PRODUCT.evaluate(values);\n}"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the product of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the product of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double product(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return PRODUCT.evaluate(values, begin, length);\n}"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the natural logs of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.summary.SumOfLogs}.\n * </p>\n *\n * @param values the input array\n * @return the sum of the natural logs of the values or Double.NaN if\n * the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sumLog(final double[] values) throws MathIllegalArgumentException {\n    return SUM_OF_LOGS.evaluate(values);\n}"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the natural logs of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.summary.SumOfLogs}.\n * </p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the natural logs of the values or Double.NaN if\n * length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double sumLog(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM_OF_LOGS.evaluate(values, begin, length);\n}"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the arithmetic mean of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Mean} for\n * details on the computing algorithm.</p>\n *\n * @param values the input array\n * @return the mean of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double mean(final double[] values) throws MathIllegalArgumentException {\n    return MEAN.evaluate(values);\n}"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the arithmetic mean of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Mean} for\n * details on the computing algorithm.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the mean of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double mean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MEAN.evaluate(values, begin, length);\n}"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the geometric mean of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.GeometricMean}\n * for details on the computing algorithm.</p>\n *\n * @param values the input array\n * @return the geometric mean of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double geometricMean(final double[] values) throws MathIllegalArgumentException {\n    return GEOMETRIC_MEAN.evaluate(values);\n}"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the geometric mean of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.GeometricMean}\n * for details on the computing algorithm.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the geometric mean of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double geometricMean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return GEOMETRIC_MEAN.evaluate(values, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[])} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double variance(final double[] values) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], int, int)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double variance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the specified portion of\n * the input array, using the precomputed mean value.  Returns\n * <code>Double.NaN</code> if the designated subarray is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], double, int, int)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double variance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, mean, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the input array, using the\n * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n * is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], double)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @return the variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double variance(final double[] values, final double mean) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, mean);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the formula and computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the population variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double populationVariance(final double[] values) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the population variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double populationVariance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, begin, length);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the specified portion of\n * the input array, using the precomputed mean value.  Returns\n * <code>Double.NaN</code> if the designated subarray is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the population variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double populationVariance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, mean, begin, length);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the input array, using the\n * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n * is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @return the population variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double populationVariance(final double[] values, final double mean) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, mean);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the maximum of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @return the maximum of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double max(final double[] values) throws MathIllegalArgumentException {\n    return MAX.evaluate(values);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the maximum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or\n * the array index parameters are not valid.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the maximum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double max(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MAX.evaluate(values, begin, length);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the minimum of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n * </ul> </p>\n *\n * @param values the input array\n * @return the minimum of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double min(final double[] values) throws MathIllegalArgumentException {\n    return MIN.evaluate(values);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the minimum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or\n * the array index parameters are not valid.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the minimum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double min(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MIN.evaluate(values, begin, length);\n}"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns an estimate of the <code>p</code>th percentile of the values\n * in the <code>values</code> array.\n * <p>\n * <ul>\n * <li>Returns <code>Double.NaN</code> if <code>values</code> has length\n * <code>0</code></li></p>\n * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n *  if <code>values</code> has length <code>1</code></li>\n * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n * is null  or p is not a valid quantile value (p must be greater than 0\n * and less than or equal to 100)</li>\n * </ul></p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n * a description of the percentile estimation algorithm used.</p>\n *\n * @param values input array of values\n * @param p the percentile value to compute\n * @return the percentile value or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if <code>values</code> is null\n * or p is invalid\n */\npublic static double percentile(final double[] values, final double p) throws MathIllegalArgumentException {\n    return PERCENTILE.evaluate(values, p);\n}"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns an estimate of the <code>p</code>th percentile of the values\n * in the <code>values</code> array, starting with the element in (0-based)\n * position <code>begin</code> in the array and including <code>length</code>\n * values.\n * <p>\n * <ul>\n * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n *  if <code>length = 1 </code></li>\n * <li>Throws <code>MathIllegalArgumentException</code> if <code>values</code>\n *  is null , <code>begin</code> or <code>length</code> is invalid, or\n * <code>p</code> is not a valid quantile value (p must be greater than 0\n * and less than or equal to 100)</li>\n * </ul></p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n * a description of the percentile estimation algorithm used.</p>\n *\n * @param values array of input values\n * @param p  the percentile to compute\n * @param begin  the first (0-based) element to include in the computation\n * @param length  the number of array elements to include\n * @return  the percentile value\n * @throws MathIllegalArgumentException if the parameters are not valid or the\n * input array is null\n */\npublic static double percentile(final double[] values, final int begin, final int length, final double p) throws MathIllegalArgumentException {\n    return PERCENTILE.evaluate(values, begin, length, p);\n}"
            ],
            [
                "sumDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., sum(sample1[i] - sample2[i]).\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @return sum of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * (positive) length.\n * @throws NoDataException if the sample arrays are empty.\n */\npublic static double sumDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n <= 0) {\n        throw new NoDataException(LocalizedFormats.INSUFFICIENT_DIMENSION);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        result += sample1[i] - sample2[i];\n    }\n    return result;\n}"
            ],
            [
                "meanDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the mean of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., sum(sample1[i] - sample2[i]) / sample1.length.\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @return mean of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * (positive) length.\n * @throws NoDataException if the sample arrays are empty.\n */\npublic static double meanDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException {\n    return sumDifference(sample1, sample2) / sample1.length;\n}"
            ],
            [
                "varianceDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., var(sample1[i] - sample2[i]).\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @param meanDifference   the mean difference between corresponding entries\n * @see #meanDifference(double[],double[])\n * @return variance of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * length.\n * @throws NumberIsTooSmallException if the arrays length is less than 2.\n */\npublic static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference) throws DimensionMismatchException, NumberIsTooSmallException {\n    double sum1 = 0d;\n    double sum2 = 0d;\n    double diff = 0d;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    for (int i = 0; i < n; i++) {\n        diff = sample1[i] - sample2[i];\n        sum1 += (diff - meanDifference) * (diff - meanDifference);\n        sum2 += diff - meanDifference;\n    }\n    return (sum1 - (sum2 * sum2 / n)) / (n - 1);\n}"
            ],
            [
                "normalize",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Normalize (standardize) the sample, so it is has a mean of 0 and a standard deviation of 1.\n *\n * @param sample Sample to normalize.\n * @return normalized (standardized) sample.\n * @since 2.2\n */\npublic static double[] normalize(final double[] sample) {\n    DescriptiveStatistics stats = new DescriptiveStatistics();\n    // Add the data from the series to stats\n    for (int i = 0; i < sample.length; i++) {\n        stats.addValue(sample[i]);\n    }\n    // Compute mean and standard deviation\n    double mean = stats.getMean();\n    double standardDeviation = stats.getStandardDeviation();\n    // initialize the standardizedSample, which has the same length as the sample\n    double[] standardizedSample = new double[sample.length];\n    for (int i = 0; i < sample.length; i++) {\n        // z = (x- mean)/standardDeviation\n        standardizedSample[i] = (sample[i] - mean) / standardDeviation;\n    }\n    return standardizedSample;\n}"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sample mode(s).  The mode is the most frequently occurring\n * value in the sample. If there is a unique value with maximum frequency,\n * this value is returned as the only element of the output array. Otherwise,\n * the returned array contains the maximum frequency elements in increasing\n * order.  For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},\n * the returned array will have length two, with 0 in the first element and\n * 5 in the second.\n *\n * <p>NaN values are ignored when computing the mode - i.e., NaNs will never\n * appear in the output array.  If the sample includes only NaNs or has\n * length 0, an empty array is returned.</p>\n *\n * @param sample input data\n * @return array of array of the most frequently occurring element(s) sorted in ascending order.\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static double[] mode(double[] sample) throws MathIllegalArgumentException {\n    if (sample == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    return getMode(sample, 0, sample.length);\n}"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sample mode(s).  The mode is the most frequently occurring\n * value in the sample. If there is a unique value with maximum frequency,\n * this value is returned as the only element of the output array. Otherwise,\n * the returned array contains the maximum frequency elements in increasing\n * order.  For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},\n * the returned array will have length two, with 0 in the first element and\n * 5 in the second.\n *\n * <p>NaN values are ignored when computing the mode - i.e., NaNs will never\n * appear in the output array.  If the sample includes only NaNs or has\n * length 0, an empty array is returned.</p>\n *\n * @param sample input data\n * @param begin index (0-based) of the first array element to include\n * @param length the number of elements to include\n *\n * @return array of array of the most frequently occurring element(s) sorted in ascending order.\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static double[] mode(double[] sample, final int begin, final int length) {\n    if (sample == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    if (begin < 0) {\n        throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));\n    }\n    if (length < 0) {\n        throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));\n    }\n    return getMode(sample, begin, length);\n}"
            ],
            [
                "getAgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create an Agresti-Coull binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getAgrestiCoullInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return AGRESTI_COULL.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a Clopper-Pearson binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n * <p>\n * Preconditions:\n * <ul>\n * <li>{@code numberOfTrials} must be positive</li>\n * <li>{@code numberOfSuccesses} may not exceed {@code numberOfTrials}</li>\n * <li>{@code confidenceLevel} must be strictly between 0 and 1 (exclusive)</li>\n * </ul>\n * </p>\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getClopperPearsonInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return CLOPPER_PEARSON.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getNormalApproximationInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a binomial confidence interval for the true probability of success\n * of an unknown binomial distribution with the given observed number of\n * trials, successes and confidence level using the Normal approximation to\n * the binomial distribution.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n */\npublic static ConfidenceInterval getNormalApproximationInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return NORMAL_APPROXIMATION.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getWilsonScoreInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a Wilson score binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getWilsonScoreInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return WILSON_SCORE.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "// CHECKSTYLE: stop JavadocMethodCheck\n/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticT(double[], double[])\n */\npublic static double homoscedasticT(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.homoscedasticT(sample1, sample2);\n}"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticT(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double homoscedasticT(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.homoscedasticT(sampleStats1, sampleStats2);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(double[], double[], double)\n */\npublic static boolean homoscedasticTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sample1, sample2, alpha);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(double[], double[])\n */\npublic static double homoscedasticTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sample1, sample2);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double homoscedasticTTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sampleStats1, sampleStats2);\n}"
            ],
            [
                "pairedT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedT(double[], double[])\n */\npublic static double pairedT(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException {\n    return T_TEST.pairedT(sample1, sample2);\n}"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedTTest(double[], double[], double)\n */\npublic static boolean pairedTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.pairedTTest(sample1, sample2, alpha);\n}"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedTTest(double[], double[])\n */\npublic static double pairedTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.pairedTTest(sample1, sample2);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double, double[])\n */\npublic static double t(final double mu, final double[] observed) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(mu, observed);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double t(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(mu, sampleStats);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double[], double[])\n */\npublic static double t(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(sample1, sample2);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double t(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(sampleStats1, sampleStats2);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, double[], double)\n */\npublic static boolean tTest(final double mu, final double[] sample, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sample, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, double[])\n */\npublic static double tTest(final double mu, final double[] sample) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sample);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary, double)\n */\npublic static boolean tTest(final double mu, final StatisticalSummary sampleStats, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sampleStats, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double tTest(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sampleStats);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double[], double[], double)\n */\npublic static boolean tTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(sample1, sample2, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double[], double[])\n */\npublic static double tTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(sample1, sample2);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary, double)\n */\npublic static boolean tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(sampleStats1, sampleStats2, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(sampleStats1, sampleStats2);\n}"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquare(double[], long[])\n */\npublic static double chiSquare(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException {\n    return CHI_SQUARE_TEST.chiSquare(expected, observed);\n}"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquare(long[][])\n */\npublic static double chiSquare(final long[][] counts) throws NullArgumentException, NotPositiveException, DimensionMismatchException {\n    return CHI_SQUARE_TEST.chiSquare(counts);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(double[], long[], double)\n */\npublic static boolean chiSquareTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(expected, observed, alpha);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(double[], long[])\n */\npublic static double chiSquareTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(expected, observed);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(long[][], double)\n */\npublic static boolean chiSquareTest(final long[][] counts, final double alpha) throws NullArgumentException, DimensionMismatchException, NotPositiveException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(counts, alpha);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(long[][])\n */\npublic static double chiSquareTest(final long[][] counts) throws NullArgumentException, DimensionMismatchException, NotPositiveException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(counts);\n}"
            ],
            [
                "chiSquareDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareDataSetsComparison(long[], long[])\n *\n * @since 1.2\n */\npublic static double chiSquareDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return CHI_SQUARE_TEST.chiSquareDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTestDataSetsComparison(long[], long[])\n *\n * @since 1.2\n */\npublic static double chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTestDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTestDataSetsComparison(long[], long[], double)\n *\n * @since 1.2\n */\npublic static boolean chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTestDataSetsComparison(observed1, observed2, alpha);\n}"
            ],
            [
                "oneWayAnovaFValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaFValue(Collection)\n *\n * @since 1.2\n */\npublic static double oneWayAnovaFValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException {\n    return ONE_WAY_ANANOVA.anovaFValue(categoryData);\n}"
            ],
            [
                "oneWayAnovaPValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaPValue(Collection)\n *\n * @since 1.2\n */\npublic static double oneWayAnovaPValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException, ConvergenceException, MaxCountExceededException {\n    return ONE_WAY_ANANOVA.anovaPValue(categoryData);\n}"
            ],
            [
                "oneWayAnovaTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaTest(Collection,double)\n *\n * @since 1.2\n */\npublic static boolean oneWayAnovaTest(final Collection<double[]> categoryData, final double alpha) throws NullArgumentException, DimensionMismatchException, OutOfRangeException, ConvergenceException, MaxCountExceededException {\n    return ONE_WAY_ANANOVA.anovaTest(categoryData, alpha);\n}"
            ],
            [
                "g",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#g(double[], long[])\n * @since 3.1\n */\npublic static double g(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException {\n    return G_TEST.g(expected, observed);\n}"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTest( double[],  long[] )\n * @since 3.1\n */\npublic static double gTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return G_TEST.gTest(expected, observed);\n}"
            ],
            [
                "gTestIntrinsic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestIntrinsic(double[], long[] )\n * @since 3.1\n */\npublic static double gTestIntrinsic(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return G_TEST.gTestIntrinsic(expected, observed);\n}"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTest( double[],long[],double)\n * @since 3.1\n */\npublic static boolean gTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException {\n    return G_TEST.gTest(expected, observed, alpha);\n}"
            ],
            [
                "gDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gDataSetsComparison(long[], long[])\n * @since 3.1\n */\npublic static double gDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return G_TEST.gDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "rootLogLikelihoodRatio",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#rootLogLikelihoodRatio(long, long, long, long)\n * @since 3.1\n */\npublic static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return G_TEST.rootLogLikelihoodRatio(k11, k12, k21, k22);\n}"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestDataSetsComparison(long[], long[])\n * @since 3.1\n */\npublic static double gTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException {\n    return G_TEST.gTestDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestDataSetsComparison(long[],long[],double)\n * @since 3.1\n */\npublic static boolean gTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException {\n    return G_TEST.gTestDataSetsComparison(observed1, observed2, alpha);\n}"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovStatistic(RealDistribution, double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovStatistic(dist, data);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[], boolean)\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data, strict);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[], double)\n * @since 3.3\n */\npublic static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data, alpha);\n}"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovStatistic(double[], double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovStatistic(double[] x, double[] y) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovStatistic(x, y);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(double[], double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(double[] x, double[] y) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(x, y);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(double[], double[], boolean)\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(double[] x, double[] y, boolean strict) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(x, y, strict);\n}"
            ],
            [
                "exactP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#exactP(double, int, int, boolean)\n * @since 3.3\n */\npublic static double exactP(double d, int m, int n, boolean strict) {\n    return KS_TEST.exactP(d, n, m, strict);\n}"
            ],
            [
                "approximateP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#approximateP(double, int, int)\n * @since 3.3\n */\npublic static double approximateP(double d, int n, int m) {\n    return KS_TEST.approximateP(d, n, m);\n}"
            ],
            [
                "monteCarloP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#monteCarloP(double, int, int, boolean, int)\n * @since 3.3\n */\npublic static double monteCarloP(double d, int n, int m, boolean strict, int iterations) {\n    return KS_TEST.monteCarloP(d, n, m, strict, iterations);\n}"
            ],
            [
                "aggregate",
                "org.apache.commons.math3.stat.descriptive",
                "AggregateSummaryStatistics",
                "/**\n * Computes aggregate summary statistics. This method can be used to combine statistics\n * computed over partitions or subsamples - i.e., the StatisticalSummaryValues returned\n * should contain the same values that would have been obtained by computing a single\n * StatisticalSummary over the combined dataset.\n * <p>\n * Returns null if the collection is empty or null.\n * </p>\n *\n * @param statistics collection of SummaryStatistics to aggregate\n * @return summary statistics for the combined dataset\n */\npublic static StatisticalSummaryValues aggregate(Collection<? extends StatisticalSummary> statistics) {\n    if (statistics == null) {\n        return null;\n    }\n    Iterator<? extends StatisticalSummary> iterator = statistics.iterator();\n    if (!iterator.hasNext()) {\n        return null;\n    }\n    StatisticalSummary current = iterator.next();\n    long n = current.getN();\n    double min = current.getMin();\n    double sum = current.getSum();\n    double max = current.getMax();\n    double var = current.getVariance();\n    double m2 = var * (n - 1d);\n    double mean = current.getMean();\n    while (iterator.hasNext()) {\n        current = iterator.next();\n        if (current.getMin() < min || Double.isNaN(min)) {\n            min = current.getMin();\n        }\n        if (current.getMax() > max || Double.isNaN(max)) {\n            max = current.getMax();\n        }\n        sum += current.getSum();\n        final double oldN = n;\n        final double curN = current.getN();\n        n += curN;\n        final double meanDiff = current.getMean() - mean;\n        mean = sum / n;\n        final double curM2 = current.getVariance() * (curN - 1d);\n        m2 = m2 + curM2 + meanDiff * meanDiff * oldN * curN / n;\n    }\n    final double variance;\n    if (n == 0) {\n        variance = Double.NaN;\n    } else if (n == 1) {\n        variance = 0d;\n    } else {\n        variance = m2 / (n - 1);\n    }\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}"
            ],
            [
                "newMarkers",
                "org.apache.commons.math3.stat.descriptive.rank",
                "PSquarePercentile",
                "/**\n * A creation method to build Markers\n *\n * @param initialFive list of initial five elements\n * @param p the quantile desired\n * @return an instance of PSquareMarkers\n */\npublic static PSquareMarkers newMarkers(final List<Double> initialFive, final double p) {\n    return new Markers(initialFive, p);\n}"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "/**\n * Creates an exponential decay {@link NeighbourhoodSizeFunction function}.\n * It will compute <code>a e<sup>-x / b</sup></code>,\n * where {@code x} is the (integer) independent variable and\n * <ul>\n *  <li><code>a = initValue</code>\n *  <li><code>b = -numCall / ln(valueAtNumCall / initValue)</code>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link NeighbourhoodSizeFunction#value(long) value(0)}.\n * @param valueAtNumCall Value of the function at {@code numCall}.\n * @param numCall Argument for which the function returns\n * {@code valueAtNumCall}.\n * @return the neighbourhood size function.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code initValue <= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code valueAtNumCall <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code valueAtNumCall >= initValue}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static NeighbourhoodSizeFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall) {\n    return new NeighbourhoodSizeFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final ExponentialDecayFunction decay = new ExponentialDecayFunction(initValue, valueAtNumCall, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public int value(long n) {\n            return (int) FastMath.rint(decay.value(n));\n        }\n    };\n}"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "/**\n * Creates an sigmoid-like {@code NeighbourhoodSizeFunction function}.\n * The function {@code f} will have the following properties:\n * <ul>\n *  <li>{@code f(0) = initValue}</li>\n *  <li>{@code numCall} is the inflexion point</li>\n *  <li>{@code slope = f'(numCall)}</li>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link NeighbourhoodSizeFunction#value(long) value(0)}.\n * @param slope Value of the function derivative at {@code numCall}.\n * @param numCall Inflexion point.\n * @return the neighbourhood size function.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code initValue <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code slope >= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static NeighbourhoodSizeFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall) {\n    return new NeighbourhoodSizeFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final QuasiSigmoidDecayFunction decay = new QuasiSigmoidDecayFunction(initValue, slope, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public int value(long n) {\n            return (int) FastMath.rint(decay.value(n));\n        }\n    };\n}"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "/**\n * Creates an exponential decay {@link LearningFactorFunction function}.\n * It will compute <code>a e<sup>-x / b</sup></code>,\n * where {@code x} is the (integer) independent variable and\n * <ul>\n *  <li><code>a = initValue</code>\n *  <li><code>b = -numCall / ln(valueAtNumCall / initValue)</code>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link LearningFactorFunction#value(long) value(0)}.\n * @param valueAtNumCall Value of the function at {@code numCall}.\n * @param numCall Argument for which the function returns\n * {@code valueAtNumCall}.\n * @return the learning factor function.\n * @throws org.apache.commons.math3.exception.OutOfRangeException\n * if {@code initValue <= 0} or {@code initValue > 1}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code valueAtNumCall <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code valueAtNumCall >= initValue}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static LearningFactorFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall) {\n    if (initValue <= 0 || initValue > 1) {\n        throw new OutOfRangeException(initValue, 0, 1);\n    }\n    return new LearningFactorFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final ExponentialDecayFunction decay = new ExponentialDecayFunction(initValue, valueAtNumCall, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(long n) {\n            return decay.value(n);\n        }\n    };\n}"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "/**\n * Creates an sigmoid-like {@code LearningFactorFunction function}.\n * The function {@code f} will have the following properties:\n * <ul>\n *  <li>{@code f(0) = initValue}</li>\n *  <li>{@code numCall} is the inflexion point</li>\n *  <li>{@code slope = f'(numCall)}</li>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link LearningFactorFunction#value(long) value(0)}.\n * @param slope Value of the function derivative at {@code numCall}.\n * @param numCall Inflexion point.\n * @return the learning factor function.\n * @throws org.apache.commons.math3.exception.OutOfRangeException\n * if {@code initValue <= 0} or {@code initValue > 1}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code slope >= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static LearningFactorFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall) {\n    if (initValue <= 0 || initValue > 1) {\n        throw new OutOfRangeException(initValue, 0, 1);\n    }\n    return new LearningFactorFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final QuasiSigmoidDecayFunction decay = new QuasiSigmoidDecayFunction(initValue, slope, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(long n) {\n            return decay.value(n);\n        }\n    };\n}"
            ],
            [
                "findBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Finds the neuron that best matches the given features.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If the list is empty\n * {@code null} will be returned.\n * @param distance Distance function. The neuron's features are\n * passed as the first argument to {@link DistanceMeasure#compute(double[],double[])}.\n * @return the neuron whose features are closest to the given data.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n */\npublic static Neuron findBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    Neuron best = null;\n    double min = Double.POSITIVE_INFINITY;\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        if (d < min) {\n            min = d;\n            best = n;\n        }\n    }\n    return best;\n}"
            ],
            [
                "findBestAndSecondBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Finds the two neurons that best match the given features.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If the list is empty\n * {@code null} will be returned.\n * @param distance Distance function. The neuron's features are\n * passed as the first argument to {@link DistanceMeasure#compute(double[],double[])}.\n * @return the two neurons whose features are closest to the given data.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n */\npublic static Pair<Neuron, Neuron> findBestAndSecondBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    Neuron[] best = { null, null };\n    double[] min = { Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY };\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        if (d < min[0]) {\n            // Replace second best with old best.\n            min[1] = min[0];\n            best[1] = best[0];\n            // Store current as new best.\n            min[0] = d;\n            best[0] = n;\n        } else if (d < min[1]) {\n            // Replace old second best with current.\n            min[1] = d;\n            best[1] = n;\n        }\n    }\n    return new Pair<Neuron, Neuron>(best[0], best[1]);\n}"
            ],
            [
                "sort",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Creates a list of neurons sorted in increased order of the distance\n * to the given {@code features}.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If it is empty, an empty array\n * will be returned.\n * @param distance Distance function.\n * @return the neurons, sorted in increasing order of distance in data\n * space.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n *\n * @see #findBest(double[],Iterable,DistanceMeasure)\n * @see #findBestAndSecondBest(double[],Iterable,DistanceMeasure)\n *\n * @since 3.6\n */\npublic static Neuron[] sort(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    final List<PairNeuronDouble> list = new ArrayList<PairNeuronDouble>();\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        list.add(new PairNeuronDouble(n, d));\n    }\n    Collections.sort(list, PairNeuronDouble.COMPARATOR);\n    final int len = list.size();\n    final Neuron[] sorted = new Neuron[len];\n    for (int i = 0; i < len; i++) {\n        sorted[i] = list.get(i).getNeuron();\n    }\n    return sorted;\n}"
            ],
            [
                "computeU",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the <a href=\"http://en.wikipedia.org/wiki/U-Matrix\">\n *  U-matrix</a> of a two-dimensional map.\n *\n * @param map Network.\n * @param distance Function to use for computing the average\n * distance from a neuron to its neighbours.\n * @return the matrix of average distances.\n */\npublic static double[][] computeU(NeuronSquareMesh2D map, DistanceMeasure distance) {\n    final int numRows = map.getNumberOfRows();\n    final int numCols = map.getNumberOfColumns();\n    final double[][] uMatrix = new double[numRows][numCols];\n    final Network net = map.getNetwork();\n    for (int i = 0; i < numRows; i++) {\n        for (int j = 0; j < numCols; j++) {\n            final Neuron neuron = map.getNeuron(i, j);\n            final Collection<Neuron> neighbours = net.getNeighbours(neuron);\n            final double[] features = neuron.getFeatures();\n            double d = 0;\n            int count = 0;\n            for (Neuron n : neighbours) {\n                ++count;\n                d += distance.compute(features, n.getFeatures());\n            }\n            uMatrix[i][j] = d / count;\n        }\n    }\n    return uMatrix;\n}"
            ],
            [
                "computeHitHistogram",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the \"hit\" histogram of a two-dimensional map.\n *\n * @param data Feature vectors.\n * @param map Network.\n * @param distance Function to use for determining the best matching unit.\n * @return the number of hits for each neuron in the map.\n */\npublic static int[][] computeHitHistogram(Iterable<double[]> data, NeuronSquareMesh2D map, DistanceMeasure distance) {\n    final HashMap<Neuron, Integer> hit = new HashMap<Neuron, Integer>();\n    final Network net = map.getNetwork();\n    for (double[] f : data) {\n        final Neuron best = findBest(f, net, distance);\n        final Integer count = hit.get(best);\n        if (count == null) {\n            hit.put(best, 1);\n        } else {\n            hit.put(best, count + 1);\n        }\n    }\n    // Copy the histogram data into a 2D map.\n    final int numRows = map.getNumberOfRows();\n    final int numCols = map.getNumberOfColumns();\n    final int[][] histo = new int[numRows][numCols];\n    for (int i = 0; i < numRows; i++) {\n        for (int j = 0; j < numCols; j++) {\n            final Neuron neuron = map.getNeuron(i, j);\n            final Integer count = hit.get(neuron);\n            if (count == null) {\n                histo[i][j] = 0;\n            } else {\n                histo[i][j] = count;\n            }\n        }\n    }\n    return histo;\n}"
            ],
            [
                "computeQuantizationError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the quantization error.\n * The quantization error is the average distance between a feature vector\n * and its \"best matching unit\" (closest neuron).\n *\n * @param data Feature vectors.\n * @param neurons List of neurons to scan.\n * @param distance Distance function.\n * @return the error.\n * @throws NoDataException if {@code data} is empty.\n */\npublic static double computeQuantizationError(Iterable<double[]> data, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    double d = 0;\n    int count = 0;\n    for (double[] f : data) {\n        ++count;\n        d += distance.compute(f, findBest(f, neurons, distance).getFeatures());\n    }\n    if (count == 0) {\n        throw new NoDataException();\n    }\n    return d / count;\n}"
            ],
            [
                "computeTopographicError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the topographic error.\n * The topographic error is the proportion of data for which first and\n * second best matching units are not adjacent in the map.\n *\n * @param data Feature vectors.\n * @param net Network.\n * @param distance Distance function.\n * @return the error.\n * @throws NoDataException if {@code data} is empty.\n */\npublic static double computeTopographicError(Iterable<double[]> data, Network net, DistanceMeasure distance) {\n    int notAdjacentCount = 0;\n    int count = 0;\n    for (double[] f : data) {\n        ++count;\n        final Pair<Neuron, Neuron> p = findBestAndSecondBest(f, net, distance);\n        if (!net.getNeighbours(p.getFirst()).contains(p.getSecond())) {\n            // Increment count if first and second best matching units\n            // are not neighbours.\n            ++notAdjacentCount;\n        }\n    }\n    if (count == 0) {\n        throw new NoDataException();\n    }\n    return ((double) notAdjacentCount) / count;\n}"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Uniform sampling of the given range.\n *\n * @param min Lower bound of the range.\n * @param max Upper bound of the range.\n * @param rng Random number generator used to draw samples from a\n * uniform distribution.\n * @return an initializer such that the features will be initialized with\n * values within the given range.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code min >= max}.\n */\npublic static FeatureInitializer uniform(final RandomGenerator rng, final double min, final double max) {\n    return randomize(new UniformRealDistribution(rng, min, max), function(new Constant(0), 0, 0));\n}"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Uniform sampling of the given range.\n *\n * @param min Lower bound of the range.\n * @param max Upper bound of the range.\n * @return an initializer such that the features will be initialized with\n * values within the given range.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code min >= max}.\n */\npublic static FeatureInitializer uniform(final double min, final double max) {\n    return randomize(new UniformRealDistribution(min, max), function(new Constant(0), 0, 0));\n}"
            ],
            [
                "function",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Creates an initializer from a univariate function {@code f(x)}.\n * The argument {@code x} is set to {@code init} at the first call\n * and will be incremented at each call.\n *\n * @param f Function.\n * @param init Initial value.\n * @param inc Increment\n * @return the initializer.\n */\npublic static FeatureInitializer function(final UnivariateFunction f, final double init, final double inc) {\n    return new FeatureInitializer() {\n\n        /**\n         * Argument.\n         */\n        private double arg = init;\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value() {\n            final double result = f.value(arg);\n            arg += inc;\n            return result;\n        }\n    };\n}"
            ],
            [
                "randomize",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Adds some amount of random data to the given initializer.\n *\n * @param random Random variable distribution.\n * @param orig Original initializer.\n * @return an initializer whose {@link FeatureInitializer#value() value}\n * method will return {@code orig.value() + random.sample()}.\n */\npublic static FeatureInitializer randomize(final RealDistribution random, final FeatureInitializer orig) {\n    return new FeatureInitializer() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value() {\n            return orig.value() + random.sample();\n        }\n    };\n}"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Breaks a string representation up into two dfp's.\n * <p>The two dfp are such that the sum of them is equivalent\n * to the input string, but has higher precision than using a\n * single dfp. This is useful for improving accuracy of\n * exponentiation and critical multiplies.\n * @param field field to which the Dfp must belong\n * @param a string representation to split\n * @return an array of two {@link Dfp} which sum is a\n */\nprotected static Dfp[] split(final DfpField field, final String a) {\n    Dfp[] result = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n    buf = new char[a.length()];\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n        if (sig == (field.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig++;\n        }\n    }\n    result[0] = field.newDfp(new String(buf, 0, sp));\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n    result[1] = field.newDfp(new String(buf));\n    return result;\n}"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Splits a {@link Dfp} into 2 {@link Dfp}'s such that their sum is equal to the input {@link Dfp}.\n * @param a number to split\n * @return two elements array containing the split number\n */\nprotected static Dfp[] split(final Dfp a) {\n    final Dfp[] result = new Dfp[2];\n    final Dfp shift = a.multiply(a.power10K(a.getRadixDigits() / 2));\n    result[0] = a.add(shift).subtract(shift);\n    result[1] = a.subtract(result[0]);\n    return result;\n}"
            ],
            [
                "splitMult",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Multiply two numbers that are split in to two pieces that are\n *  meant to be added together.\n *  Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1\n *  Store the first term in result0, the rest in result1\n *  @param a first factor of the multiplication, in split form\n *  @param b second factor of the multiplication, in split form\n *  @return a &times; b, in split form\n */\nprotected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b) {\n    final Dfp[] result = new Dfp[2];\n    result[1] = a[0].getZero();\n    result[0] = a[0].multiply(b[0]);\n    /* If result[0] is infinite or zero, don't compute result[1].\n         * Attempting to do so may produce NaNs.\n         */\n    if (result[0].classify() == Dfp.INFINITE || result[0].equals(result[1])) {\n        return result;\n    }\n    result[1] = a[0].multiply(b[1]).add(a[1].multiply(b[0])).add(a[1].multiply(b[1]));\n    return result;\n}"
            ],
            [
                "splitDiv",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Divide two numbers that are split in to two pieces that are meant to be added together.\n * Inverse of split multiply above:\n *  (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c**2+cd) )\n *  @param a dividend, in split form\n *  @param b divisor, in split form\n *  @return a / b, in split form\n */\nprotected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b) {\n    final Dfp[] result;\n    result = new Dfp[2];\n    result[0] = a[0].divide(b[0]);\n    result[1] = a[1].multiply(b[0]).subtract(a[0].multiply(b[1]));\n    result[1] = result[1].divide(b[0].multiply(b[0]).add(b[0].multiply(b[1])));\n    return result;\n}"
            ],
            [
                "splitPow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Raise a split base to the a power.\n * @param base number to raise\n * @param a power\n * @return base<sup>a</sup>\n */\nprotected static Dfp splitPow(final Dfp[] base, int a) {\n    boolean invert = false;\n    Dfp[] r = new Dfp[2];\n    Dfp[] result = new Dfp[2];\n    result[0] = base[0].getOne();\n    result[1] = base[0].getZero();\n    if (a == 0) {\n        // Special case a = 0\n        return result[0].add(result[1]);\n    }\n    if (a < 0) {\n        // If a is less than zero\n        invert = true;\n        a = -a;\n    }\n    // Exponentiate by successive squaring\n    do {\n        r[0] = new Dfp(base[0]);\n        r[1] = new Dfp(base[1]);\n        int trial = 1;\n        int prevtrial;\n        while (true) {\n            prevtrial = trial;\n            trial *= 2;\n            if (trial > a) {\n                break;\n            }\n            r = splitMult(r, r);\n        }\n        trial = prevtrial;\n        a -= trial;\n        result = splitMult(result, r);\n    } while (a >= 1);\n    result[0] = result[0].add(result[1]);\n    if (invert) {\n        result[0] = base[0].getOne().divide(result[0]);\n    }\n    return result[0];\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Raises base to the power a by successive squaring.\n * @param base number to raise\n * @param a power\n * @return base<sup>a</sup>\n */\npublic static Dfp pow(Dfp base, int a) {\n    boolean invert = false;\n    Dfp result = base.getOne();\n    if (a == 0) {\n        // Special case\n        return result;\n    }\n    if (a < 0) {\n        invert = true;\n        a = -a;\n    }\n    // Exponentiate by successive squaring\n    do {\n        Dfp r = new Dfp(base);\n        Dfp prevr;\n        int trial = 1;\n        int prevtrial;\n        do {\n            prevr = new Dfp(r);\n            prevtrial = trial;\n            r = r.multiply(r);\n            trial *= 2;\n        } while (a > trial);\n        r = prevr;\n        trial = prevtrial;\n        a -= trial;\n        result = result.multiply(r);\n    } while (a >= 1);\n    if (invert) {\n        result = base.getOne().divide(result);\n    }\n    return base.newInstance(result);\n}"
            ],
            [
                "exp",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes e to the given power.\n * a is broken into two parts, such that a = n+m  where n is an integer.\n * We use pow() to compute e<sup>n</sup> and a Taylor series to compute\n * e<sup>m</sup>.  We return e*<sup>n</sup> &times; e<sup>m</sup>\n * @param a power at which e should be raised\n * @return e<sup>a</sup>\n */\npublic static Dfp exp(final Dfp a) {\n    final Dfp inta = a.rint();\n    final Dfp fraca = a.subtract(inta);\n    final int ia = inta.intValue();\n    if (ia > 2147483646) {\n        // return +Infinity\n        return a.newInstance((byte) 1, Dfp.INFINITE);\n    }\n    if (ia < -2147483646) {\n        // return 0;\n        return a.newInstance();\n    }\n    final Dfp einta = splitPow(a.getField().getESplit(), ia);\n    final Dfp efraca = expInternal(fraca);\n    return einta.multiply(efraca);\n}"
            ],
            [
                "expInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes e to the given power.\n * Where -1 < a < 1.  Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...\n * @param a power at which e should be raised\n * @return e<sup>a</sup>\n */\nprotected static Dfp expInternal(final Dfp a) {\n    Dfp y = a.getOne();\n    Dfp x = a.getOne();\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n    for (int i = 1; i < 90; i++) {\n        x = x.multiply(a);\n        fact = fact.divide(i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Returns the natural logarithm of a.\n * a is first split into three parts such that  a = (10000^h)(2^j)k.\n * ln(a) is computed by ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k)\n * k is in the range 2/3 < k <4/3 and is passed on to a series expansion.\n * @param a number from which logarithm is requested\n * @return log(a)\n */\npublic static Dfp log(Dfp a) {\n    int lr;\n    Dfp x;\n    int ix;\n    int p2 = 0;\n    // Check the arguments somewhat here\n    if (a.equals(a.getZero()) || a.lessThan(a.getZero()) || a.isNaN()) {\n        // negative, zero or NaN\n        a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return a.dotrap(DfpField.FLAG_INVALID, \"ln\", a, a.newInstance((byte) 1, Dfp.QNAN));\n    }\n    if (a.classify() == Dfp.INFINITE) {\n        return a;\n    }\n    x = new Dfp(a);\n    lr = x.log10K();\n    x = x.divide(pow(a.newInstance(10000), lr));\n    /* This puts x in the range 0-10000 */\n    ix = x.floor().intValue();\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n    Dfp[] spx = split(x);\n    Dfp[] spy = new Dfp[2];\n    // use spy[0] temporarily as a divisor\n    spy[0] = pow(a.getTwo(), p2);\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n    // Use spy[0] for comparison\n    spy[0] = a.newInstance(\"1.33333\");\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n    // X is now in the range of 2/3 < x < 4/3\n    Dfp[] spz = logInternal(spx);\n    spx[0] = a.newInstance(new StringBuilder().append(p2 + 4 * lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn2Split(), spx);\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n    spx[0] = a.newInstance(new StringBuilder().append(4 * lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn5Split(), spx);\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n    return a.newInstance(spz[0].add(spz[1]));\n}"
            ],
            [
                "logInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes the natural log of a number between 0 and 2.\n *  Let f(x) = ln(x),\n *\n *  We know that f'(x) = 1/x, thus from Taylor's theorum we have:\n *\n *           -----          n+1         n\n *  f(x) =   \\           (-1)    (x - 1)\n *           /          ----------------    for 1 <= n <= infinity\n *           -----             n\n *\n *  or\n *                       2        3       4\n *                   (x-1)   (x-1)    (x-1)\n *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n *                     2       3        4\n *\n *  alternatively,\n *\n *                  2    3   4\n *                 x    x   x\n *  ln(x+1) =  x - -  + - - - + ...\n *                 2    3   4\n *\n *  This series can be used to compute ln(x), but it converges too slowly.\n *\n *  If we substitute -x for x above, we get\n *\n *                   2    3    4\n *                  x    x    x\n *  ln(1-x) =  -x - -  - -  - - + ...\n *                  2    3    4\n *\n *  Note that all terms are now negative.  Because the even powered ones\n *  absorbed the sign.  Now, subtract the series above from the previous\n *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n *  only the odd ones\n *\n *                             3     5      7\n *                           2x    2x     2x\n *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n *                            3     5      7\n *\n *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n *\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      x-1           \\          3        5        7          /\n *\n *  But now we want to find ln(a), so we need to find the value of x\n *  such that a = (x+1)/(x-1).   This is easily solved to find that\n *  x = (a-1)/(a+1).\n * @param a number from which logarithm is requested, in split form\n * @return log(a)\n */\nprotected static Dfp[] logInternal(final Dfp[] a) {\n    /* Now we want to compute x = (a-1)/(a+1) but this is prone to\n         * loss of precision.  So instead, compute x = (a/4 - 1/4) / (a/4 + 1/4)\n         */\n    Dfp t = a[0].divide(4).add(a[1].divide(4));\n    Dfp x = t.add(a[0].newInstance(\"-0.25\")).divide(t.add(a[0].newInstance(\"0.25\")));\n    Dfp y = new Dfp(x);\n    Dfp num = new Dfp(x);\n    Dfp py = new Dfp(y);\n    int den = 1;\n    for (int i = 0; i < 10000; i++) {\n        num = num.multiply(x);\n        num = num.multiply(x);\n        den += 2;\n        t = num.divide(den);\n        y = y.add(t);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    y = y.multiply(a[0].getTwo());\n    return split(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes x to the y power.<p>\n *\n *  Uses the following method:<p>\n *\n *  <ol>\n *  <li> Set u = rint(y), v = y-u\n *  <li> Compute a = v * ln(x)\n *  <li> Compute b = rint( a/ln(2) )\n *  <li> Compute c = a - b*ln(2)\n *  <li> x<sup>y</sup> = x<sup>u</sup>  *   2<sup>b</sup> * e<sup>c</sup>\n *  </ol>\n *  if |y| > 1e8, then we compute by exp(y*ln(x))   <p>\n *\n *  <b>Special Cases</b><p>\n *  <ul>\n *  <li>  if y is 0.0 or -0.0 then result is 1.0\n *  <li>  if y is 1.0 then result is x\n *  <li>  if y is NaN then result is NaN\n *  <li>  if x is NaN and y is not zero then result is NaN\n *  <li>  if |x| > 1.0 and y is +Infinity then result is +Infinity\n *  <li>  if |x| < 1.0 and y is -Infinity then result is +Infinity\n *  <li>  if |x| > 1.0 and y is -Infinity then result is +0\n *  <li>  if |x| < 1.0 and y is +Infinity then result is +0\n *  <li>  if |x| = 1.0 and y is +/-Infinity then result is NaN\n *  <li>  if x = +0 and y > 0 then result is +0\n *  <li>  if x = +Inf and y < 0 then result is +0\n *  <li>  if x = +0 and y < 0 then result is +Inf\n *  <li>  if x = +Inf and y > 0 then result is +Inf\n *  <li>  if x = -0 and y > 0, finite, not odd integer then result is +0\n *  <li>  if x = -0 and y < 0, finite, and odd integer then result is -Inf\n *  <li>  if x = -Inf and y > 0, finite, and odd integer then result is -Inf\n *  <li>  if x = -0 and y < 0, not finite odd integer then result is +Inf\n *  <li>  if x = -Inf and y > 0, not finite odd integer then result is +Inf\n *  <li>  if x < 0 and y > 0, finite, and odd integer then result is -(|x|<sup>y</sup>)\n *  <li>  if x < 0 and y > 0, finite, and not integer then result is NaN\n *  </ul>\n *  @param x base to be raised\n *  @param y power to which base should be raised\n *  @return x<sup>y</sup>\n */\npublic static Dfp pow(Dfp x, final Dfp y) {\n    // make sure we don't mix number with different precision\n    if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = x.newInstance(x.getZero());\n        result.nans = Dfp.QNAN;\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n    }\n    final Dfp zero = x.getZero();\n    final Dfp one = x.getOne();\n    final Dfp two = x.getTwo();\n    boolean invert = false;\n    int ui;\n    /* Check for special cases */\n    if (y.equals(zero)) {\n        return x.newInstance(one);\n    }\n    if (y.equals(one)) {\n        if (x.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n        }\n        return x;\n    }\n    if (x.isNaN() || y.isNaN()) {\n        // Test for NaNs\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    // X == 0\n    if (x.equals(zero)) {\n        if (Dfp.copysign(one, x).greaterThan(zero)) {\n            // X == +0\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n            }\n        } else {\n            // X == -0\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero.negate());\n                } else {\n                    return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE));\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n                }\n            }\n        }\n    }\n    if (x.lessThan(zero)) {\n        // Make x positive, but keep track of it\n        x = x.negate();\n        invert = true;\n    }\n    if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return y;\n        } else {\n            return x.newInstance(zero);\n        }\n    }\n    if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return x.newInstance(zero);\n        } else {\n            return x.newInstance(Dfp.copysign(y, one));\n        }\n    }\n    if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    if (x.classify() == Dfp.INFINITE) {\n        // x = +/- inf\n        if (invert) {\n            // negative infinity\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero.negate());\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        } else {\n            // positive infinity\n            if (y.greaterThan(zero)) {\n                return x;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n    }\n    if (invert && !y.rint().equals(y)) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    // End special cases\n    Dfp r;\n    if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) {\n        final Dfp u = y.rint();\n        ui = u.intValue();\n        final Dfp v = y.subtract(u);\n        if (v.unequal(zero)) {\n            final Dfp a = v.multiply(log(x));\n            final Dfp b = a.divide(x.getField().getLn2()).rint();\n            final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n            r = splitPow(split(x), ui);\n            r = r.multiply(pow(two, b.intValue()));\n            r = r.multiply(exp(c));\n        } else {\n            r = splitPow(split(x), ui);\n        }\n    } else {\n        // very large exponent.  |y| > 1e8\n        r = exp(log(x).multiply(y));\n    }\n    if (invert && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n        // if y is odd integer\n        r = r.negate();\n    }\n    return x.newInstance(r);\n}"
            ],
            [
                "sinInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes sin(a)  Used when 0 < a < pi/4.\n * Uses the classic Taylor series.  x - x**3/3! + x**5/5!  ...\n * @param a number from which sine is desired, in split form\n * @return sin(a)\n */\nprotected static Dfp sinInternal(Dfp[] a) {\n    Dfp c = a[0].add(a[1]);\n    Dfp y = c;\n    c = c.multiply(c);\n    Dfp x = y;\n    Dfp fact = a[0].getOne();\n    Dfp py = new Dfp(y);\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n        // 1 over fact\n        fact = fact.divide((i - 1) * i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "cosInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes cos(a)  Used when 0 < a < pi/4.\n * Uses the classic Taylor series for cosine.  1 - x**2/2! + x**4/4!  ...\n * @param a number from which cosine is desired, in split form\n * @return cos(a)\n */\nprotected static Dfp cosInternal(Dfp[] a) {\n    final Dfp one = a[0].getOne();\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a[0].add(a[1]);\n    c = c.multiply(c);\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n        // 1 over fact\n        fact = fact.divide((i - 1) * i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "sin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the sine of the argument.\n * @param a number from which sine is desired\n * @return sin(a)\n */\npublic static Dfp sin(final Dfp a) {\n    final Dfp pi = a.getField().getPi();\n    final Dfp zero = a.getField().getZero();\n    boolean neg = false;\n    /* First reduce the argument to the range of +/- PI */\n    Dfp x = a.remainder(pi.multiply(2));\n    /* if x < 0 then apply identity sin(-x) = -sin(x) */\n    /* This puts x in the range 0 < x < PI            */\n    if (x.lessThan(zero)) {\n        x = x.negate();\n        neg = true;\n    }\n    /* Since sine(x) = sine(pi - x) we can reduce the range to\n         * 0 < x < pi/2\n         */\n    if (x.greaterThan(pi.divide(2))) {\n        x = pi.subtract(x);\n    }\n    Dfp y;\n    if (x.lessThan(pi.divide(4))) {\n        y = sinInternal(split(x));\n    } else {\n        final Dfp[] c = new Dfp[2];\n        final Dfp[] piSplit = a.getField().getPiSplit();\n        c[0] = piSplit[0].divide(2).subtract(x);\n        c[1] = piSplit[1].divide(2);\n        y = cosInternal(c);\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "cos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the cosine of the argument.\n * @param a number from which cosine is desired\n * @return cos(a)\n */\npublic static Dfp cos(Dfp a) {\n    final Dfp pi = a.getField().getPi();\n    final Dfp zero = a.getField().getZero();\n    boolean neg = false;\n    /* First reduce the argument to the range of +/- PI */\n    Dfp x = a.remainder(pi.multiply(2));\n    /* if x < 0 then apply identity cos(-x) = cos(x) */\n    /* This puts x in the range 0 < x < PI           */\n    if (x.lessThan(zero)) {\n        x = x.negate();\n    }\n    /* Since cos(x) = -cos(pi - x) we can reduce the range to\n         * 0 < x < pi/2\n         */\n    if (x.greaterThan(pi.divide(2))) {\n        x = pi.subtract(x);\n        neg = true;\n    }\n    Dfp y;\n    if (x.lessThan(pi.divide(4))) {\n        Dfp[] c = new Dfp[2];\n        c[0] = x;\n        c[1] = zero;\n        y = cosInternal(c);\n    } else {\n        final Dfp[] c = new Dfp[2];\n        final Dfp[] piSplit = a.getField().getPiSplit();\n        c[0] = piSplit[0].divide(2).subtract(x);\n        c[1] = piSplit[1].divide(2);\n        y = sinInternal(c);\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "tan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the tangent of the argument.\n * @param a number from which tangent is desired\n * @return tan(a)\n */\npublic static Dfp tan(final Dfp a) {\n    return sin(a).divide(cos(a));\n}"
            ],
            [
                "atanInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-tangent of the argument.\n * @param a number from which arc-tangent is desired\n * @return atan(a)\n */\nprotected static Dfp atanInternal(final Dfp a) {\n    Dfp y = new Dfp(a);\n    Dfp x = new Dfp(y);\n    Dfp py = new Dfp(y);\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(a);\n        x = x.multiply(a);\n        x = x.negate();\n        y = y.add(x.divide(i));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "atan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc tangent of the argument\n *\n *  Uses the typical taylor series\n *\n *  but may reduce arguments using the following identity\n * tan(x+y) = (tan(x) + tan(y)) / (1 - tan(x)*tan(y))\n *\n * since tan(PI/8) = sqrt(2)-1,\n *\n * atan(x) = atan( (x - sqrt(2) + 1) / (1+x*sqrt(2) - x) + PI/8.0\n * @param a number from which arc-tangent is desired\n * @return atan(a)\n */\npublic static Dfp atan(final Dfp a) {\n    final Dfp zero = a.getField().getZero();\n    final Dfp one = a.getField().getOne();\n    final Dfp[] sqr2Split = a.getField().getSqr2Split();\n    final Dfp[] piSplit = a.getField().getPiSplit();\n    boolean recp = false;\n    boolean neg = false;\n    boolean sub = false;\n    final Dfp ty = sqr2Split[0].subtract(one).add(sqr2Split[1]);\n    Dfp x = new Dfp(a);\n    if (x.lessThan(zero)) {\n        neg = true;\n        x = x.negate();\n    }\n    if (x.greaterThan(one)) {\n        recp = true;\n        x = one.divide(x);\n    }\n    if (x.greaterThan(ty)) {\n        Dfp[] sty = new Dfp[2];\n        sub = true;\n        sty[0] = sqr2Split[0].subtract(one);\n        sty[1] = sqr2Split[1];\n        Dfp[] xs = split(x);\n        Dfp[] ds = splitMult(xs, sty);\n        ds[0] = ds[0].add(one);\n        xs[0] = xs[0].subtract(sty[0]);\n        xs[1] = xs[1].subtract(sty[1]);\n        xs = splitDiv(xs, ds);\n        x = xs[0].add(xs[1]);\n        //x = x.subtract(ty).divide(dfp.one.add(x.multiply(ty)));\n    }\n    Dfp y = atanInternal(x);\n    if (sub) {\n        y = y.add(piSplit[0].divide(8)).add(piSplit[1].divide(8));\n    }\n    if (recp) {\n        y = piSplit[0].divide(2).subtract(y).add(piSplit[1].divide(2));\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "asin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-sine of the argument.\n * @param a number from which arc-sine is desired\n * @return asin(a)\n */\npublic static Dfp asin(final Dfp a) {\n    return atan(a.divide(a.getOne().subtract(a.multiply(a)).sqrt()));\n}"
            ],
            [
                "acos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-cosine of the argument.\n * @param a number from which arc-cosine is desired\n * @return acos(a)\n */\npublic static Dfp acos(Dfp a) {\n    Dfp result;\n    boolean negative = false;\n    if (a.lessThan(a.getZero())) {\n        negative = true;\n    }\n    // absolute value\n    a = Dfp.copysign(a, a.getOne());\n    result = atan(a.getOne().subtract(a.multiply(a)).sqrt().divide(a));\n    if (negative) {\n        result = a.getField().getPi().subtract(result);\n    }\n    return a.newInstance(result);\n}"
            ],
            [
                "copysign",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Creates an instance that is the same as x except that it has the sign of y.\n * abs(x) = dfp.copysign(x, dfp.one)\n * @param x number to get the value from\n * @param y number to get the sign from\n * @return a number with the value of x and the sign of y\n */\npublic static Dfp copysign(final Dfp x, final Dfp y) {\n    Dfp result = x.newInstance(x);\n    result.sign = y.sign;\n    return result;\n}"
            ],
            [
                "computeExp",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * Compute exp(a).\n * @param a number for which we want the exponential\n * @param one constant with value 1 at desired precision\n * @return exp(a)\n */\npublic static Dfp computeExp(final Dfp a, final Dfp one) {\n    Dfp y = new Dfp(one);\n    Dfp py = new Dfp(one);\n    Dfp f = new Dfp(one);\n    Dfp fi = new Dfp(one);\n    Dfp x = new Dfp(one);\n    for (int i = 0; i < 10000; i++) {\n        x = x.multiply(a);\n        y = y.add(x.divide(f));\n        fi = fi.add(one);\n        f = f.multiply(fi);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "computeLn",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * Compute ln(a).\n *\n *  Let f(x) = ln(x),\n *\n *  We know that f'(x) = 1/x, thus from Taylor's theorem we have:\n *\n *           -----          n+1         n\n *  f(x) =   \\           (-1)    (x - 1)\n *           /          ----------------    for 1 <= n <= infinity\n *           -----             n\n *\n *  or\n *                       2        3       4\n *                   (x-1)   (x-1)    (x-1)\n *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n *                     2       3        4\n *\n *  alternatively,\n *\n *                  2    3   4\n *                 x    x   x\n *  ln(x+1) =  x - -  + - - - + ...\n *                 2    3   4\n *\n *  This series can be used to compute ln(x), but it converges too slowly.\n *\n *  If we substitute -x for x above, we get\n *\n *                   2    3    4\n *                  x    x    x\n *  ln(1-x) =  -x - -  - -  - - + ...\n *                  2    3    4\n *\n *  Note that all terms are now negative.  Because the even powered ones\n *  absorbed the sign.  Now, subtract the series above from the previous\n *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n *  only the odd ones\n *\n *                             3     5      7\n *                           2x    2x     2x\n *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n *                            3     5      7\n *\n *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n *\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      x-1           \\          3        5        7          /\n *\n *  But now we want to find ln(a), so we need to find the value of x\n *  such that a = (x+1)/(x-1).   This is easily solved to find that\n *  x = (a-1)/(a+1).\n * @param a number for which we want the exponential\n * @param one constant with value 1 at desired precision\n * @param two constant with value 2 at desired precision\n * @return ln(a)\n */\npublic static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two) {\n    int den = 1;\n    Dfp x = a.add(new Dfp(a.getField(), -1)).divide(a.add(one));\n    Dfp y = new Dfp(x);\n    Dfp num = new Dfp(x);\n    Dfp py = new Dfp(y);\n    for (int i = 0; i < 10000; i++) {\n        num = num.multiply(x);\n        num = num.multiply(x);\n        den += 2;\n        Dfp t = num.divide(den);\n        y = y.add(t);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y.multiply(two);\n}"
            ],
            [
                "getRandomGenerator",
                "org.apache.commons.math3.genetics",
                "GeneticAlgorithm",
                "/**\n * Returns the (static) random generator.\n *\n * @return the static random generator shared by GA implementation classes\n */\npublic static synchronized RandomGenerator getRandomGenerator() {\n    return randomGenerator;\n}"
            ],
            [
                "randomPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation corresponding to a random permutation of\n * length l which can be passed to the RandomKey constructor.\n *\n * @param l length of the permutation\n * @return representation of a random permutation\n */\npublic static final List<Double> randomPermutation(final int l) {\n    List<Double> repr = new ArrayList<Double>(l);\n    for (int i = 0; i < l; i++) {\n        repr.add(GeneticAlgorithm.getRandomGenerator().nextDouble());\n    }\n    return repr;\n}"
            ],
            [
                "identityPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation corresponding to an identity permutation of\n * length l which can be passed to the RandomKey constructor.\n *\n * @param l length of the permutation\n * @return representation of an identity permutation\n */\npublic static final List<Double> identityPermutation(final int l) {\n    List<Double> repr = new ArrayList<Double>(l);\n    for (int i = 0; i < l; i++) {\n        repr.add((double) i / l);\n    }\n    return repr;\n}"
            ],
            [
                "comparatorPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation of a permutation corresponding to the\n * <code>data</code> sorted by <code>comparator</code>. The\n * <code>data</code> is not modified during the process.\n *\n * This is useful if you want to inject some permutations to the initial\n * population.\n *\n * @param <S> type of the data\n * @param data list of data determining the order\n * @param comparator how the data will be compared\n * @return list representation of the permutation corresponding to the parameters\n */\npublic static <S> List<Double> comparatorPermutation(final List<S> data, final Comparator<S> comparator) {\n    List<S> sortedData = new ArrayList<S>(data);\n    Collections.sort(sortedData, comparator);\n    return inducedPermutation(data, sortedData);\n}"
            ],
            [
                "inducedPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation of a permutation corresponding to a\n * permutation which yields <code>permutedData</code> when applied to\n * <code>originalData</code>.\n *\n * This method can be viewed as an inverse to {@link #decode(List)}.\n *\n * @param <S> type of the data\n * @param originalData the original, unpermuted data\n * @param permutedData the data, somehow permuted\n * @return representation of a permutation corresponding to the permutation\n *   <code>originalData -> permutedData</code>\n * @throws DimensionMismatchException iff the length of <code>originalData</code>\n *   and <code>permutedData</code> lists are not equal\n * @throws MathIllegalArgumentException iff the <code>permutedData</code> and\n *   <code>originalData</code> lists contain different data\n */\npublic static <S> List<Double> inducedPermutation(final List<S> originalData, final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException {\n    if (originalData.size() != permutedData.size()) {\n        throw new DimensionMismatchException(permutedData.size(), originalData.size());\n    }\n    int l = originalData.size();\n    List<S> origDataCopy = new ArrayList<S>(originalData);\n    Double[] res = new Double[l];\n    for (int i = 0; i < l; i++) {\n        int index = origDataCopy.indexOf(permutedData.get(i));\n        if (index == -1) {\n            throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_ORIG_AND_PERMUTED_DATA);\n        }\n        res[index] = (double) i / l;\n        origDataCopy.set(index, null);\n    }\n    return Arrays.asList(res);\n}"
            ],
            [
                "randomBinaryRepresentation",
                "org.apache.commons.math3.genetics",
                "BinaryChromosome",
                "/**\n * Returns a representation of a random binary array of length <code>length</code>.\n * @param length length of the array\n * @return a random binary array of length <code>length</code>\n */\npublic static List<Integer> randomBinaryRepresentation(int length) {\n    // random binary list\n    List<Integer> rList = new ArrayList<Integer>(length);\n    for (int j = 0; j < length; j++) {\n        rList.add(GeneticAlgorithm.getRandomGenerator().nextInt(2));\n    }\n    return rList;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * Get the set of locales for which point/vector formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available point/vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "/**\n * Returns the default 3D vector format for the current locale.\n * @return the default 3D vector format.\n */\npublic static Vector3DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "/**\n * Returns the default 3D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 3D vector format specific to the given locale.\n */\npublic static Vector3DFormat getInstance(final Locale locale) {\n    return new Vector3DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2) throws MathArithmeticException {\n    final T normProduct = v1.getNorm().multiply(v2.getNorm());\n    if (normProduct.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    final T dot = dotProduct(v1, v2);\n    final double threshold = normProduct.getReal() * 0.9999;\n    if ((dot.getReal() < -threshold) || (dot.getReal() > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        FieldVector3D<T> v3 = crossProduct(v1, v2);\n        if (dot.getReal() >= 0) {\n            return v3.getNorm().divide(normProduct).asin();\n        }\n        return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return dot.divide(normProduct).acos();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2) throws MathArithmeticException {\n    final T normProduct = v1.getNorm().multiply(v2.getNorm());\n    if (normProduct.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    final T dot = dotProduct(v1, v2);\n    final double threshold = normProduct.getReal() * 0.9999;\n    if ((dot.getReal() < -threshold) || (dot.getReal() > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        FieldVector3D<T> v3 = crossProduct(v1, v2);\n        if (dot.getReal() >= 0) {\n            return v3.getNorm().divide(normProduct).asin();\n        }\n        return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return dot.divide(normProduct).acos();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2) throws MathArithmeticException {\n    return angle(v2, v1);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.dotProduct(v1);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1, final FieldVector3D<T> v2) {\n    return new FieldVector3D<T>(v2.x.linearCombination(v1.getY(), v2.z, -v1.getZ(), v2.y), v2.y.linearCombination(v1.getZ(), v2.x, -v1.getX(), v2.z), v2.z.linearCombination(v1.getX(), v2.y, -v1.getY(), v2.x));\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distance1(v1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distance(v1);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distanceInf(v1);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distanceSq(v1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "/**\n * Compute the <i>distance</i> between two rotations.\n * <p>The <i>distance</i> is intended here as a way to check if two\n * rotations are almost similar (i.e. they transform vectors the same way)\n * or very different. It is mathematically defined as the angle of\n * the rotation r that prepended to one of the rotations gives the other\n * one:</p>\n * <pre>\n *        r<sub>1</sub>(r) = r<sub>2</sub>\n * </pre>\n * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n * reached for some v. The distance is equal to 0 if and only if the two\n * rotations are identical.</p>\n * <p>Comparing two rotations should always be done using this value rather\n * than for example comparing the components of the quaternions. It is much\n * more stable, and has a geometric meaning. Also comparing quaternions\n * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n * their components are different (they are exact opposites).</p>\n * @param r1 first rotation\n * @param r2 second rotation\n * @return <i>distance</i> between r1 and r2\n */\npublic static double distance(Rotation r1, Rotation r2) {\n    return r1.composeInverseInternal(r2).getAngle();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Euclidean3D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean3D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply a rotation to a vector.\n * @param r rotation to apply\n * @param u vector to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new vector which is the image of u by the rotation\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n    final T x = u.getX();\n    final T y = u.getY();\n    final T z = u.getZ();\n    final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n    return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x), y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y), z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n}"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply the inverse of a rotation to a vector.\n * @param r rotation to apply\n * @param u vector to apply the inverse of the rotation to\n * @param <T> the type of the field elements\n * @return a new vector which such that u is its image by the rotation\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n    final T x = u.getX();\n    final T y = u.getY();\n    final T z = u.getZ();\n    final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n    final double m0 = -r.getQ0();\n    return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x), y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y), z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n}"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply a rotation to another rotation.\n * Applying a rotation to another rotation is computing the composition\n * in an order compliant with the following rule : let u be any\n * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n * where comp = applyTo(rOuter, rInner).\n * @param r1 rotation to apply\n * @param rInner rotation to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new rotation which is the composition of r by the instance\n */\npublic static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n    return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))), rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))), rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))), rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))), false);\n}"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply the inverse of a rotation to another rotation.\n * Applying the inverse of a rotation to another rotation is computing\n * the composition in an order compliant with the following rule :\n * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n * let w be the inverse image of v by rOuter\n * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n * comp = applyInverseTo(rOuter, rInner).\n * @param rOuter rotation to apply the rotation to\n * @param rInner rotation to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new rotation which is the composition of r by the inverse\n * of the instance\n */\npublic static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n    return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(), rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())), rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())), rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())), false);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Compute the <i>distance</i> between two rotations.\n * <p>The <i>distance</i> is intended here as a way to check if two\n * rotations are almost similar (i.e. they transform vectors the same way)\n * or very different. It is mathematically defined as the angle of\n * the rotation r that prepended to one of the rotations gives the other\n * one:</p>\n * <pre>\n *        r<sub>1</sub>(r) = r<sub>2</sub>\n * </pre>\n * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n * reached for some v. The distance is equal to 0 if and only if the two\n * rotations are identical.</p>\n * <p>Comparing two rotations should always be done using this value rather\n * than for example comparing the components of the quaternions. It is much\n * more stable, and has a geometric meaning. Also comparing quaternions\n * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n * their components are different (they are exact opposites).</p>\n * @param r1 first rotation\n * @param r2 second rotation\n * @param <T> the type of the field elements\n * @return <i>distance</i> between r1 and r2\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n    return r1.composeInverseInternal(r2).getAngle();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException {\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    double dot = v1.dotProduct(v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        Vector3D v3 = crossProduct(v1, v2);\n        if (dot >= 0) {\n            return FastMath.asin(v3.getNorm() / normProduct);\n        }\n        return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return FastMath.acos(dot / normProduct);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the dot product v1.v2\n */\npublic static double dotProduct(Vector3D v1, Vector3D v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static double distance1(Vector3D v1, Vector3D v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector3D v1, Vector3D v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector3D v1, Vector3D v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the square of the distance between v1 and v2\n */\npublic static double distanceSq(Vector3D v1, Vector3D v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "intersection",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Plane",
                "/**\n * Get the intersection point of three planes.\n * @param plane1 first plane1\n * @param plane2 second plane2\n * @param plane3 third plane2\n * @return intersection point of three planes, null if some planes are parallel\n */\npublic static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3) {\n    // coefficients of the three planes linear equations\n    final double a1 = plane1.w.getX();\n    final double b1 = plane1.w.getY();\n    final double c1 = plane1.w.getZ();\n    final double d1 = plane1.originOffset;\n    final double a2 = plane2.w.getX();\n    final double b2 = plane2.w.getY();\n    final double c2 = plane2.w.getZ();\n    final double d2 = plane2.originOffset;\n    final double a3 = plane3.w.getX();\n    final double b3 = plane3.w.getY();\n    final double c3 = plane3.w.getZ();\n    final double d3 = plane3.originOffset;\n    // direct Cramer resolution of the linear system\n    // (this is still feasible for a 3x3 system)\n    final double a23 = b2 * c3 - b3 * c2;\n    final double b23 = c2 * a3 - c3 * a2;\n    final double c23 = a2 * b3 - a3 * b2;\n    final double determinant = a1 * a23 + b1 * b23 + c1 * c23;\n    if (FastMath.abs(determinant) < 1.0e-10) {\n        return null;\n    }\n    final double r = 1.0 / determinant;\n    return new Vector3D((-a23 * d1 - (c1 * b3 - c3 * b1) * d2 - (c2 * b1 - c1 * b2) * d3) * r, (-b23 * d1 - (c3 * a1 - c1 * a3) * d2 - (c1 * a2 - c2 * a1) * d3) * r, (-c23 * d1 - (b1 * a3 - b3 * a1) * d2 - (b2 * a1 - b1 * a2) * d3) * r);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Euclidean1D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean1D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "/**\n * Returns the default 1D vector format for the current locale.\n * @return the default 1D vector format.\n */\npublic static Vector1DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "/**\n * Returns the default 1D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 1D vector format specific to the given locale.\n */\npublic static Vector1DFormat getInstance(final Locale locale) {\n    return new Vector1DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector1D p1, Vector1D p2) {\n    return p1.distance(p2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector1D p1, Vector1D p2) {\n    return p1.distanceInf(p2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\npublic static double distanceSq(Vector1D p1, Vector1D p2) {\n    return p1.distanceSq(p2);\n}"
            ],
            [
                "reducePoints",
                "org.apache.commons.math3.geometry.euclidean.twod.hull",
                "AklToussaintHeuristic",
                "/**\n * Returns a point set that is reduced by all points for which it is safe to assume\n * that they are not part of the convex hull.\n *\n * @param points the original point set\n * @return a reduced point set, useful as input for convex hull algorithms\n */\npublic static Collection<Vector2D> reducePoints(final Collection<Vector2D> points) {\n    // find the leftmost point\n    int size = 0;\n    Vector2D minX = null;\n    Vector2D maxX = null;\n    Vector2D minY = null;\n    Vector2D maxY = null;\n    for (Vector2D p : points) {\n        if (minX == null || p.getX() < minX.getX()) {\n            minX = p;\n        }\n        if (maxX == null || p.getX() > maxX.getX()) {\n            maxX = p;\n        }\n        if (minY == null || p.getY() < minY.getY()) {\n            minY = p;\n        }\n        if (maxY == null || p.getY() > maxY.getY()) {\n            maxY = p;\n        }\n        size++;\n    }\n    if (size < 4) {\n        return points;\n    }\n    final List<Vector2D> quadrilateral = buildQuadrilateral(minY, maxX, maxY, minX);\n    // if the quadrilateral is not well formed, e.g. only 2 points, do not attempt to reduce\n    if (quadrilateral.size() < 3) {\n        return points;\n    }\n    final List<Vector2D> reducedPoints = new ArrayList<Vector2D>(quadrilateral);\n    for (final Vector2D p : points) {\n        // check all points if they are within the quadrilateral\n        // in which case they can not be part of the convex hull\n        if (!insideQuadrilateral(p, quadrilateral)) {\n            reducedPoints.add(p);\n        }\n    }\n    return reducedPoints;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "/**\n * Returns the default 2D vector format for the current locale.\n * @return the default 2D vector format.\n */\npublic static Vector2DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "/**\n * Returns the default 2D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 2D vector format specific to the given locale.\n */\npublic static Vector2DFormat getInstance(final Locale locale) {\n    return new Vector2DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException {\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    double dot = v1.dotProduct(v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        final double n = FastMath.abs(MathArrays.linearCombination(v1.x, v2.y, -v1.y, v2.x));\n        if (dot >= 0) {\n            return FastMath.asin(n / normProduct);\n        }\n        return FastMath.PI - FastMath.asin(n / normProduct);\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return FastMath.acos(dot / normProduct);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector2D p1, Vector2D p2) {\n    return p1.distance(p2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector2D p1, Vector2D p2) {\n    return p1.distanceInf(p2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\npublic static double distanceSq(Vector2D p1, Vector2D p2) {\n    return p1.distanceSq(p2);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Euclidean2D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean2D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding an affine transform.\n * @param transform affine transform to embed (must be inversible\n * otherwise the {@link\n * org.apache.commons.math3.geometry.partitioning.Transform#apply(Hyperplane)\n * apply(Hyperplane)} method would work only for some lines, and\n * fail for other ones)\n * @return a new transform that can be applied to either {@link\n * Vector2D Vector2D}, {@link Line Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n * @exception MathIllegalArgumentException if the transform is non invertible\n * @deprecated as of 3.6, replaced with {@link #getTransform(double, double, double, double, double, double)}\n */\n@Deprecated\npublic static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException {\n    final double[] m = new double[6];\n    transform.getMatrix(m);\n    return new LineTransform(m[0], m[1], m[2], m[3], m[4], m[5]);\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding an affine transform.\n * @param cXX transform factor between input abscissa and output abscissa\n * @param cYX transform factor between input abscissa and output ordinate\n * @param cXY transform factor between input ordinate and output abscissa\n * @param cYY transform factor between input ordinate and output ordinate\n * @param cX1 transform addendum for output abscissa\n * @param cY1 transform addendum for output ordinate\n * @return a new transform that can be applied to either {@link\n * Vector2D Vector2D}, {@link Line Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n * @exception MathIllegalArgumentException if the transform is non invertible\n * @since 3.6\n */\npublic static Transform<Euclidean2D, Euclidean1D> getTransform(final double cXX, final double cYX, final double cXY, final double cYY, final double cX1, final double cY1) throws MathIllegalArgumentException {\n    return new LineTransform(cXX, cYX, cXY, cYY, cX1, cY1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "/**\n * Compute the distance (angular separation) between two points.\n * @param p1 first vector\n * @param p2 second vector\n * @return the angular separation between p1 and p2\n */\npublic static double distance(S1Point p1, S1Point p2) {\n    return Vector2D.angle(p1.vector, p2.vector);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "Sphere1D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Sphere1D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Sphere2D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Sphere2D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Circle",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding a 3D rotation.\n * @param rotation rotation to use\n * @return a new transform that can be applied to either {@link\n * Point Point}, {@link Circle Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n */\npublic static Transform<Sphere2D, Sphere1D> getTransform(final Rotation rotation) {\n    return new CircleTransform(rotation);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * Compute the distance (angular separation) between two points.\n * @param p1 first vector\n * @param p2 second vector\n * @return the angular separation between p1 and p2\n */\npublic static double distance(S2Point p1, S2Point p2) {\n    return Vector3D.angle(p1.vector, p2.vector);\n}"
            ],
            [
                "createAdaptor",
                "org.apache.commons.math3.random",
                "RandomAdaptor",
                "/**\n * Factory method to create a <code>Random</code> using the supplied\n * <code>RandomGenerator</code>.\n *\n * @param randomGenerator  wrapped RandomGenerator instance\n * @return a Random instance wrapping the RandomGenerator\n */\npublic static Random createAdaptor(RandomGenerator randomGenerator) {\n    return new RandomAdaptor(randomGenerator);\n}"
            ],
            [
                "createRandomGenerator",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "/**\n * Creates a {@link RandomDataGenerator} instance that wraps a\n * {@link Random} instance.\n *\n * @param rng JDK {@link Random} instance that will generate the\n * the random data.\n * @return the given RNG, wrapped in a {@link RandomGenerator}.\n */\npublic static RandomGenerator createRandomGenerator(final Random rng) {\n    return new RandomGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(int seed) {\n            rng.setSeed((long) seed);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(int[] seed) {\n            rng.setSeed(convertToLong(seed));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(long seed) {\n            rng.setSeed(seed);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void nextBytes(byte[] bytes) {\n            rng.nextBytes(bytes);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int nextInt() {\n            return rng.nextInt();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int nextInt(int n) {\n            if (n <= 0) {\n                throw new NotStrictlyPositiveException(n);\n            }\n            return rng.nextInt(n);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public long nextLong() {\n            return rng.nextLong();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean nextBoolean() {\n            return rng.nextBoolean();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public float nextFloat() {\n            return rng.nextFloat();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public double nextDouble() {\n            return rng.nextDouble();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public double nextGaussian() {\n            return rng.nextGaussian();\n        }\n    };\n}"
            ],
            [
                "convertToLong",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "/**\n * Converts seed from one representation to another.\n *\n * @param seed Original seed.\n * @return the converted seed.\n */\npublic static long convertToLong(int[] seed) {\n    // The following number is the largest prime that fits\n    // in 32 bits (i.e. 2^32 - 5).\n    final long prime = 4294967291l;\n    long combined = 0l;\n    for (int s : seed) {\n        combined = combined * prime + s;\n    }\n    return combined;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Get the set of locales for which complex formats are available.  This\n * is the same set as the {@link NumberFormat} set.\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "formatBigFraction",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * This static method calls formatBigFraction() on a default instance of\n * BigFractionFormat.\n *\n * @param f BigFraction object to format\n * @return A formatted BigFraction in proper form.\n */\npublic static String formatBigFraction(final BigFraction f) {\n    return getImproperInstance().format(f);\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static BigFractionFormat getImproperInstance() {\n    return getImproperInstance(Locale.getDefault());\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static BigFractionFormat getImproperInstance(final Locale locale) {\n    return new BigFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static BigFractionFormat getProperInstance() {\n    return getProperInstance(Locale.getDefault());\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static BigFractionFormat getProperInstance(final Locale locale) {\n    return new ProperBigFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * <p>Creates a {@code Fraction} instance with the 2 parts\n * of a fraction Y/Z.</p>\n *\n * <p>Any negative signs are resolved to be on the numerator.</p>\n *\n * @param numerator  the numerator, for example the three in 'three sevenths'\n * @param denominator  the denominator, for example the seven in 'three sevenths'\n * @return a new fraction instance, with the numerator and denominator reduced\n * @throws MathArithmeticException if the denominator is {@code zero}\n */\npublic static Fraction getReducedFraction(int numerator, int denominator) {\n    if (denominator == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, numerator, denominator);\n    }\n    if (numerator == 0) {\n        // normalize zero.\n        return ZERO;\n    }\n    // allow 2^k/-2^31 as a valid fraction (where k>0)\n    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n        numerator /= 2;\n        denominator /= 2;\n    }\n    if (denominator < 0) {\n        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n        }\n        numerator = -numerator;\n        denominator = -denominator;\n    }\n    // simplify fraction.\n    int gcd = ArithmeticUtils.gcd(numerator, denominator);\n    numerator /= gcd;\n    denominator /= gcd;\n    return new Fraction(numerator, denominator);\n}"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * <p>\n * Creates a <code>BigFraction</code> instance with the 2 parts of a fraction\n * Y/Z.\n * </p>\n *\n * <p>\n * Any negative signs are resolved to be on the numerator.\n * </p>\n *\n * @param numerator\n *            the numerator, for example the three in 'three sevenths'.\n * @param denominator\n *            the denominator, for example the seven in 'three sevenths'.\n * @return a new fraction instance, with the numerator and denominator\n *         reduced.\n * @throws ArithmeticException\n *             if the denominator is <code>zero</code>.\n */\npublic static BigFraction getReducedFraction(final int numerator, final int denominator) {\n    if (numerator == 0) {\n        // normalize zero.\n        return ZERO;\n    }\n    return new BigFraction(numerator, denominator);\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)}. The only\n * customization is the maximum number of BigFraction digits, which is set to 0.\n * @return the default number format.\n */\nprotected static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)}. The only\n * customization is the maximum number of BigFraction digits, which is set to 0.\n * @param locale the specific locale used by the format.\n * @return the default number format specific to the given locale.\n */\nprotected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n    final NumberFormat nf = NumberFormat.getNumberInstance(locale);\n    nf.setMaximumFractionDigits(0);\n    nf.setParseIntegerOnly(true);\n    return nf;\n}"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Parses <code>source</code> until a non-whitespace character is found.\n * @param source the string to parse\n * @param pos input/output parsing parameter.\n * @return the first non-whitespace character.\n */\nprotected static char parseNextCharacter(final String source, final ParsePosition pos) {\n    int index = pos.getIndex();\n    final int n = source.length();\n    char ret = 0;\n    if (index < n) {\n        char c;\n        do {\n            c = source.charAt(index++);\n        } while (Character.isWhitespace(c) && index < n);\n        pos.setIndex(index);\n        if (index < n) {\n            ret = c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Get the set of locales for which complex formats are available.  This\n * is the same set as the {@link NumberFormat} set.\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "formatFraction",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * This static method calls formatFraction() on a default instance of\n * FractionFormat.\n *\n * @param f Fraction object to format\n * @return a formatted fraction in proper form.\n */\npublic static String formatFraction(Fraction f) {\n    return getImproperInstance().format(f);\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static FractionFormat getImproperInstance() {\n    return getImproperInstance(Locale.getDefault());\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static FractionFormat getImproperInstance(final Locale locale) {\n    return new FractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static FractionFormat getProperInstance() {\n    return getProperInstance(Locale.getDefault());\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static FractionFormat getProperInstance(final Locale locale) {\n    return new ProperFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n * customizing is the maximum number of fraction digits, which is set to 0.\n * @return the default number format.\n */\nprotected static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "FractionField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static FractionField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static BigFractionField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "flatten",
                "org.apache.commons.math3.exception.util",
                "ArgUtils",
                "/**\n * Transform a multidimensional array into a one-dimensional list.\n *\n * @param array Array (possibly multidimensional).\n * @return a list of all the {@code Object} instances contained in\n * {@code array}.\n */\npublic static Object[] flatten(Object[] array) {\n    final List<Object> list = new ArrayList<Object>();\n    if (array != null) {\n        for (Object o : array) {\n            if (o instanceof Object[]) {\n                for (Object oR : flatten((Object[]) o)) {\n                    list.add(oR);\n                }\n            } else {\n                list.add(o);\n            }\n        }\n    }\n    return list.toArray();\n}"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Multiply every component in the given real array by the\n * given real number. The change is made in place.\n *\n * @param f the real array to be scaled\n * @param d the real scaling coefficient\n * @return a reference to the scaled array\n */\npublic static double[] scaleArray(double[] f, double d) {\n    for (int i = 0; i < f.length; i++) {\n        f[i] *= d;\n    }\n    return f;\n}"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Multiply every component in the given complex array by the\n * given real number. The change is made in place.\n *\n * @param f the complex array to be scaled\n * @param d the real scaling coefficient\n * @return a reference to the scaled array\n */\npublic static Complex[] scaleArray(Complex[] f, double d) {\n    for (int i = 0; i < f.length; i++) {\n        f[i] = new Complex(d * f[i].getReal(), d * f[i].getImaginary());\n    }\n    return f;\n}"
            ],
            [
                "createRealImaginaryArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Builds a new two dimensional array of {@code double} filled with the real\n * and imaginary parts of the specified {@link Complex} numbers. In the\n * returned array {@code dataRI}, the data is laid out as follows\n * <ul>\n * <li>{@code dataRI[0][i] = dataC[i].getReal()},</li>\n * <li>{@code dataRI[1][i] = dataC[i].getImaginary()}.</li>\n * </ul>\n *\n * @param dataC the array of {@link Complex} data to be transformed\n * @return a two dimensional array filled with the real and imaginary parts\n *   of the specified complex input\n */\npublic static double[][] createRealImaginaryArray(final Complex[] dataC) {\n    final double[][] dataRI = new double[2][dataC.length];\n    final double[] dataR = dataRI[0];\n    final double[] dataI = dataRI[1];\n    for (int i = 0; i < dataC.length; i++) {\n        final Complex c = dataC[i];\n        dataR[i] = c.getReal();\n        dataI[i] = c.getImaginary();\n    }\n    return dataRI;\n}"
            ],
            [
                "createComplexArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Builds a new array of {@link Complex} from the specified two dimensional\n * array of real and imaginary parts. In the returned array {@code dataC},\n * the data is laid out as follows\n * <ul>\n * <li>{@code dataC[i].getReal() = dataRI[0][i]},</li>\n * <li>{@code dataC[i].getImaginary() = dataRI[1][i]}.</li>\n * </ul>\n *\n * @param dataRI the array of real and imaginary parts to be transformed\n * @return an array of {@link Complex} with specified real and imaginary parts.\n * @throws DimensionMismatchException if the number of rows of the specified\n *   array is not two, or the array is not rectangular\n */\npublic static Complex[] createComplexArray(final double[][] dataRI) throws DimensionMismatchException {\n    if (dataRI.length != 2) {\n        throw new DimensionMismatchException(dataRI.length, 2);\n    }\n    final double[] dataR = dataRI[0];\n    final double[] dataI = dataRI[1];\n    if (dataR.length != dataI.length) {\n        throw new DimensionMismatchException(dataI.length, dataR.length);\n    }\n    final int n = dataR.length;\n    final Complex[] c = new Complex[n];\n    for (int i = 0; i < n; i++) {\n        c[i] = new Complex(dataR[i], dataI[i]);\n    }\n    return c;\n}"
            ],
            [
                "exactLog2",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Returns the base-2 logarithm of the specified {@code int}. Throws an\n * exception if {@code n} is not a power of two.\n *\n * @param n the {@code int} whose base-2 logarithm is to be evaluated\n * @return the base-2 logarithm of {@code n}\n * @throws MathIllegalArgumentException if {@code n} is not a power of two\n */\npublic static int exactLog2(final int n) throws MathIllegalArgumentException {\n    int index = Arrays.binarySearch(TransformUtils.POWERS_OF_TWO, n);\n    if (index < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, Integer.valueOf(n));\n    }\n    return index;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "PRIMES",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * The first 512 prime numbers.\n * <p>\n * It contains all primes smaller or equal to the cubic square of Integer.MAX_VALUE.\n * As a result, <code>int</code> numbers which are not reduced by those primes are guaranteed\n * to be either prime or semi prime.\n */\npublic static final int[] PRIMES = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671 };"
            ],
            [
                "PRIMES_LAST",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * The last number in PRIMES.\n */\npublic static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];"
            ],
            [
                "MIDPOINT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "MidPointIntegrator",
                "/**\n * Maximum number of iterations for midpoint.\n */\npublic static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "ROMBERG_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "RombergIntegrator",
                "/**\n * Maximal number of iterations for Romberg.\n */\npublic static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;"
            ],
            [
                "SIMPSON_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "SimpsonIntegrator",
                "/**\n * Maximal number of iterations for Simpson.\n */\npublic static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default absolute accuracy.\n */\npublic static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;"
            ],
            [
                "DEFAULT_RELATIVE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default relative accuracy.\n */\npublic static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;"
            ],
            [
                "DEFAULT_MIN_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default minimal iteration count.\n */\npublic static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default maximal iteration count.\n */\npublic static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;"
            ],
            [
                "TRAPEZOID_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "TrapezoidIntegrator",
                "/**\n * Maximum number of iterations for trapezoid.\n */\npublic static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "BaseSecantSolver",
                "/**\n * Default absolute accuracy.\n */\nprotected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "SecantSolver",
                "/**\n * Default absolute accuracy.\n */\nprotected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_BANDWIDTH",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value of the bandwidth parameter.\n */\npublic static final double DEFAULT_BANDWIDTH = 0.3;"
            ],
            [
                "DEFAULT_ROBUSTNESS_ITERS",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value of the number of robustness iterations.\n */\npublic static final int DEFAULT_ROBUSTNESS_ITERS = 2;"
            ],
            [
                "DEFAULT_ACCURACY",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value for accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_ACCURACY = 1e-12;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.analysis.interpolation",
                "NevilleInterpolator",
                "/**\n * serializable version identifier\n */\nstatic final long serialVersionUID = 3003707660147873733L;"
            ],
            [
                "DEFAULT_EXTEND",
                "org.apache.commons.math3.analysis.interpolation",
                "UnivariatePeriodicInterpolator",
                "/**\n * Default number of extension points of the samples array.\n */\npublic static final int DEFAULT_EXTEND = 5;"
            ],
            [
                "DEFAULT_MICROSPHERE_ELEMENTS",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "/**\n * Default number of surface elements that composes the microsphere.\n */\npublic static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;"
            ],
            [
                "DEFAULT_BRIGHTNESS_EXPONENT",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "/**\n * Default exponent used the weights calculation.\n */\npublic static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;"
            ],
            [
                "EPSILON",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * <p>\n * Largest double-precision floating-point number such that\n * {@code 1 + EPSILON} is numerically equal to 1. This value is an upper\n * bound on the relative error due to rounding real numbers to double\n * precision floating-point numbers.\n * </p>\n * <p>\n * In IEEE 754 arithmetic, this is 2<sup>-53</sup>.\n * </p>\n *\n * @see <a href=\"http://en.wikipedia.org/wiki/Machine_epsilon\">Machine epsilon</a>\n */\npublic static final double EPSILON;"
            ],
            [
                "SAFE_MIN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Safe minimum, such that {@code 1 / SAFE_MIN} does not overflow.\n * <br/>\n * In IEEE 754 arithmetic, this is also the smallest normalized\n * number 2<sup>-1022</sup>.\n */\npublic static final double SAFE_MIN;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;"
            ],
            [
                "PI",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Archimede's constant PI, ratio of circle circumference to diameter.\n */\npublic static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
            ],
            [
                "E",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Napier's constant e, base of the natural logarithm.\n */\npublic static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
            ],
            [
                "EXP_INT_TABLE_MAX_INDEX",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Index of exp(0) in the array of integer exponentials.\n */\nstatic final int EXP_INT_TABLE_MAX_INDEX = 750;"
            ],
            [
                "EXP_INT_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Length of the array of integer exponentials.\n */\nstatic final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;"
            ],
            [
                "LN_MANT_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Logarithm table length.\n */\nstatic final int LN_MANT_LEN = 1024;"
            ],
            [
                "EXP_FRAC_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Exponential fractions table length.\n */\n// 0, 1/1024, ... 1024/1024\nstatic final int EXP_FRAC_TABLE_LEN = 1025;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of NaN.\n */\npublic static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of positive infinity.\n */\npublic static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of negative infinity.\n */\npublic static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of NaN.\n */\npublic static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of positive infinity.\n */\npublic static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of negative infinity.\n */\npublic static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "ADDITIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "/**\n * Additive expansion mode.\n * @deprecated As of 3.1. Please use {@link ExpansionMode#ADDITIVE} instead.\n */\n@Deprecated\npublic static final int ADDITIVE_MODE = 1;"
            ],
            [
                "MULTIPLICATIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "/**\n * Multiplicative expansion mode.\n * @deprecated As of 3.1. Please use {@link ExpansionMode#MULTIPLICATIVE} instead.\n */\n@Deprecated\npublic static final int MULTIPLICATIVE_MODE = 0;"
            ],
            [
                "TWO_PI",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * \\(2\\pi\\)\n * @since 2.1\n */\npublic static final double TWO_PI = 2 * FastMath.PI;"
            ],
            [
                "PI_SQUARED",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * \\(\\pi^2\\)\n * @since 3.4\n */\npublic static final double PI_SQUARED = FastMath.PI * FastMath.PI;"
            ],
            [
                "FACTORIALS",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * All long-representable factorials\n */\nstatic final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };"
            ],
            [
                "STIRLING_S2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Stirling numbers of the second kind.\n */\nstatic final AtomicReference<long[][]> STIRLING_S2 = new AtomicReference<long[][]>(null);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@code 0d} as a {@code Decimal64}.\n */\npublic static final Decimal64 ZERO;"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@code 1d} as a {@code Decimal64}.\n */\npublic static final Decimal64 ONE;"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#NEGATIVE_INFINITY} as a\n * {@code Decimal64}.\n */\npublic static final Decimal64 NEGATIVE_INFINITY;"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#POSITIVE_INFINITY} as a\n * {@code Decimal64}.\n */\npublic static final Decimal64 POSITIVE_INFINITY;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#NaN} as a {@code Decimal64}.\n */\npublic static final Decimal64 NAN;"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "BigReal",
                "/**\n * A big real representing 0.\n */\npublic static final BigReal ZERO = new BigReal(BigDecimal.ZERO);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "BigReal",
                "/**\n * A big real representing 1.\n */\npublic static final BigReal ONE = new BigReal(BigDecimal.ONE);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Identity quaternion.\n */\npublic static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Zero quaternion.\n */\npublic static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * i\n */\npublic static final Quaternion I = new Quaternion(0, 1, 0, 0);"
            ],
            [
                "J",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * j\n */\npublic static final Quaternion J = new Quaternion(0, 0, 1, 0);"
            ],
            [
                "K",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * k\n */\npublic static final Quaternion K = new Quaternion(0, 0, 0, 1);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * The square root of -1. A number representing \"0.0 + 1.0i\"\n */\npublic static final Complex I = new Complex(0.0, 1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A complex number representing \"NaN + NaNi\"\n */\npublic static final Complex NaN = new Complex(Double.NaN, Double.NaN);"
            ],
            [
                "INF",
                "org.apache.commons.math3.complex",
                "Complex",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A complex number representing \"+INF + INFi\"\n */\npublic static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * A complex number representing \"1.0 + 0.0i\"\n */\npublic static final Complex ONE = new Complex(1.0, 0.0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * A complex number representing \"0.0 + 0.0i\"\n */\npublic static final Complex ZERO = new Complex(0.0, 0.0);"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Minimum dimension of the problem: {@value}\n */\npublic static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #initialTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #stoppingTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "DEFAULT_CHECKFEASABLECOUNT",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #checkFeasableCount}: {@value}.\n */\npublic static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
            ],
            [
                "DEFAULT_STOPFITNESS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #stopFitness}: {@value}.\n */\npublic static final double DEFAULT_STOPFITNESS = 0;"
            ],
            [
                "DEFAULT_ISACTIVECMA",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #isActiveCMA}: {@value}.\n */\npublic static final boolean DEFAULT_ISACTIVECMA = true;"
            ],
            [
                "DEFAULT_MAXITERATIONS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #maxIterations}: {@value}.\n */\npublic static final int DEFAULT_MAXITERATIONS = 30000;"
            ],
            [
                "DEFAULT_DIAGONALONLY",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #diagonalOnly}: {@value}.\n */\npublic static final int DEFAULT_DIAGONALONLY = 0;"
            ],
            [
                "DEFAULT_RANDOMGENERATOR",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #random}.\n */\npublic static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.optimization.linear",
                "AbstractLinearOptimizer",
                "/**\n * Default maximal number of iterations allowed.\n */\npublic static final int DEFAULT_MAX_ITERATIONS = 100;"
            ],
            [
                "DEFAULT_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * The default format for {@link RealMatrix} objects.\n * @since 3.1\n */\npublic static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();"
            ],
            [
                "OCTAVE_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * A format for {@link RealMatrix} objects compatible with octave.\n * @since 3.1\n */\npublic static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat(\"[\", \"]\", \"\", \"\", \"; \", \", \");"
            ],
            [
                "DEFAULT_ZERO_TOLERANCE",
                "org.apache.commons.math3.linear",
                "OpenMapRealVector",
                "/**\n * Default Tolerance for having a value considered zero.\n */\npublic static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Block size.\n */\npublic static final int BLOCK_SIZE = 36;"
            ],
            [
                "OPERATOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "/**\n * Key for the <a href=\"#context\">exception context</a>.\n */\npublic static final String OPERATOR = \"operator\";"
            ],
            [
                "VECTOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "/**\n * Key for the <a href=\"#context\">exception context</a>.\n */\npublic static final String VECTOR = \"vector\";"
            ],
            [
                "DEFAULT_RELATIVE_SYMMETRY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "/**\n * Default threshold above which off-diagonal elements are considered too different\n * and matrix not symmetric.\n */\npublic static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;"
            ],
            [
                "DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "/**\n * Default threshold below which diagonal elements are considered null\n * and matrix not positive definite.\n */\npublic static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Block size.\n */\npublic static final int BLOCK_SIZE = 52;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "/**\n * The cubic root of {@link #MACH_PREC}.\n */\nstatic final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "/**\n * The machine precision.\n */\nstatic final double MACH_PREC;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "/**\n * The cubic root of {@link #MACH_PREC}.\n */\nstatic final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "/**\n * The machine precision.\n */\nstatic final double MACH_PREC;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "CauchyDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "SOLVER_DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "AbstractRealDistribution",
                "/**\n * Default accuracy.\n */\npublic static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "TDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ChiSquaredDistribution",
                "/**\n * Default inverse cumulative probability accuracy\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NormalDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "UniformRealDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @deprecated as of 3.2 not used anymore, will be removed in 4.0\n */\n@Deprecated\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "WeibullDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NakagamiDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ExponentialDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "LogNormalDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ParetoDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "FDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "/**\n * Default maximum number of iterations for cumulative probability calculations.\n * @since 2.1\n */\npublic static final int DEFAULT_MAX_ITERATIONS = 10000000;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "/**\n * Default convergence criterion.\n * @since 2.1\n */\npublic static final double DEFAULT_EPSILON = 1e-12;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "GammaDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_ULPS",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "/**\n * Default amount of error to accept in floating point comparisons (as ulps).\n */\nstatic final int DEFAULT_ULPS = 10;"
            ],
            [
                "DEFAULT_CUT_OFF",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "/**\n * Default cut-off value.\n */\nstatic final double DEFAULT_CUT_OFF = 1e-10;"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Minimum dimension of the problem: {@value}\n */\npublic static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #initialTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #stoppingTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "GAMMA",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <a href=\"http://en.wikipedia.org/wiki/Euler-Mascheroni_constant\">Euler-Mascheroni constant</a>\n * @since 2.0\n */\npublic static final double GAMMA = 0.577215664901532860606512090082;"
            ],
            [
                "LANCZOS_G",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * The value of the {@code g} constant in the Lanczos approximation, see\n * {@link #lanczos(double)}.\n * @since 3.1\n */\npublic static final double LANCZOS_G = 607.0 / 128.0;"
            ],
            [
                "DEFAULT_NAN_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "/**\n * default NaN strategy\n */\npublic static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.FAILED;"
            ],
            [
                "DEFAULT_TIES_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "/**\n * default ties strategy\n */\npublic static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;"
            ],
            [
                "MAXIMUM_PARTIAL_SUM_COUNT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Bound on the number of partial sums in {@link #ksSum(double, double, int)}\n */\nprotected static final int MAXIMUM_PARTIAL_SUM_COUNT = 100000;"
            ],
            [
                "KS_SUM_CAUCHY_CRITERION",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Convergence criterion for {@link #ksSum(double, double, int)}\n */\nprotected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;"
            ],
            [
                "PG_SUM_RELATIVE_ERROR",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Convergence criterion for the sums in #pelzGood(double, double, int)}\n */\nprotected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;"
            ],
            [
                "SMALL_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * No longer used.\n */\n@Deprecated\nprotected static final int SMALL_SAMPLE_PRODUCT = 200;"
            ],
            [
                "LARGE_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * When product of sample sizes exceeds this value, 2-sample K-S test uses asymptotic\n * distribution to compute the p-value.\n */\nprotected static final int LARGE_SAMPLE_PRODUCT = 10000;"
            ],
            [
                "MONTE_CARLO_ITERATIONS",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Default number of iterations used by {@link #monteCarloP(double, int, int, boolean, int)}.\n *  Deprecated as of version 3.6, as this method is no longer needed.\n */\n@Deprecated\nprotected static final int MONTE_CARLO_ITERATIONS = 1000000;"
            ],
            [
                "INFINITE_WINDOW",
                "org.apache.commons.math3.stat.descriptive",
                "DescriptiveStatistics",
                "/**\n * Represents an infinite window size.  When the {@link #getWindowSize()}\n * returns this value, there is no limit to the number of data values\n * that can be stored in the dataset.\n */\npublic static final int INFINITE_WINDOW = -1;"
            ],
            [
                "UPSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "/**\n * The UPSIDE Direction is used to specify that the observations above the\n * cutoff point will be used to calculate SemiVariance.\n */\npublic static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;"
            ],
            [
                "DOWNSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "/**\n * The DOWNSIDE Direction is used to specify that the observations below\n * the cutoff point will be used to calculate SemiVariance\n */\npublic static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Comparator.\n */\nstatic final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "PairNeuronDouble",
                "/**\n * Comparator.\n */\nstatic final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "RADIX",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The radix, or base of this system.  Set to 10000\n */\npublic static final int RADIX = 10000;"
            ],
            [
                "MIN_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The minimum exponent before underflow is signaled.  Flush to zero\n *  occurs at minExp-DIGITS\n */\npublic static final int MIN_EXP = -32767;"
            ],
            [
                "MAX_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The maximum exponent before overflow is signaled and results flushed\n *  to infinity\n */\npublic static final int MAX_EXP = 32768;"
            ],
            [
                "ERR_SCALE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The amount under/overflows are scaled by before going to trap handler\n */\npublic static final int ERR_SCALE = 32760;"
            ],
            [
                "FINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for normal finite numbers.\n */\npublic static final byte FINITE = 0;"
            ],
            [
                "INFINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for Infinity.\n */\npublic static final byte INFINITE = 1;"
            ],
            [
                "SNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for signaling NaN.\n */\npublic static final byte SNAN = 2;"
            ],
            [
                "QNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for quiet NaN.\n */\npublic static final byte QNAN = 3;"
            ],
            [
                "FLAG_INVALID",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for invalid operation.\n */\npublic static final int FLAG_INVALID = 1;"
            ],
            [
                "FLAG_DIV_ZERO",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for division by zero.\n */\npublic static final int FLAG_DIV_ZERO = 2;"
            ],
            [
                "FLAG_OVERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for overflow.\n */\npublic static final int FLAG_OVERFLOW = 4;"
            ],
            [
                "FLAG_UNDERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for underflow.\n */\npublic static final int FLAG_UNDERFLOW = 8;"
            ],
            [
                "FLAG_INEXACT",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for inexact result.\n */\npublic static final int FLAG_INEXACT = 16;"
            ],
            [
                "DEFAULT_PREFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default prefix: \"{\".\n */\npublic static final String DEFAULT_PREFIX = \"{\";"
            ],
            [
                "DEFAULT_SUFFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default suffix: \"}\".\n */\npublic static final String DEFAULT_SUFFIX = \"}\";"
            ],
            [
                "DEFAULT_SEPARATOR",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default separator: \", \".\n */\npublic static final String DEFAULT_SEPARATOR = \"; \";"
            ],
            [
                "XYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around X, then around Y, then\n * around Z\n */\npublic static final RotationOrder XYZ = new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "XZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around X, then around Z, then\n * around Y\n */\npublic static final RotationOrder XZY = new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "YXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Y, then around X, then\n * around Z\n */\npublic static final RotationOrder YXZ = new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "YZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Y, then around Z, then\n * around X\n */\npublic static final RotationOrder YZX = new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "ZXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Z, then around X, then\n * around Y\n */\npublic static final RotationOrder ZXY = new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "ZYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Z, then around Y, then\n * around X\n */\npublic static final RotationOrder ZYX = new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around X, then around Y, then\n * around X\n */\npublic static final RotationOrder XYX = new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around X, then around Z, then\n * around X\n */\npublic static final RotationOrder XZX = new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "YXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Y, then around X, then\n * around Y\n */\npublic static final RotationOrder YXY = new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "YZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Y, then around Z, then\n * around Y\n */\npublic static final RotationOrder YZY = new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "ZXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Z, then around X, then\n * around Z\n */\npublic static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "ZYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Z, then around Y, then\n * around Z\n */\npublic static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "/**\n * Identity rotation.\n */\npublic static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Null vector (coordinates: 0, 0, 0).\n */\npublic static final Vector3D ZERO = new Vector3D(0, 0, 0);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * First canonical vector (coordinates: 1, 0, 0).\n */\npublic static final Vector3D PLUS_I = new Vector3D(1, 0, 0);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the first canonical vector (coordinates: -1, 0, 0).\n */\npublic static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Second canonical vector (coordinates: 0, 1, 0).\n */\npublic static final Vector3D PLUS_J = new Vector3D(0, 1, 0);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the second canonical vector (coordinates: 0, -1, 0).\n */\npublic static final Vector3D MINUS_J = new Vector3D(0, -1, 0);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Third canonical vector (coordinates: 0, 0, 1).\n */\npublic static final Vector3D PLUS_K = new Vector3D(0, 0, 1);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the third canonical vector (coordinates: 0, 0, -1).\n */\npublic static final Vector3D MINUS_K = new Vector3D(0, 0, -1);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Origin (coordinates: 0).\n */\npublic static final Vector1D ZERO = new Vector1D(0.0);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Unit (coordinates: 1).\n */\npublic static final Vector1D ONE = new Vector1D(1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector1D NaN = new Vector1D(Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector1D POSITIVE_INFINITY = new Vector1D(Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector1D NEGATIVE_INFINITY = new Vector1D(Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Origin (coordinates: 0, 0).\n */\npublic static final Vector2D ZERO = new Vector2D(0, 0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector2D POSITIVE_INFINITY = new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector2D NEGATIVE_INFINITY = new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +I (coordinates: \\( \\theta = 0, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +J (coordinates: \\( \\theta = \\pi/2, \\varphi = \\pi/2 \\))).\n */\npublic static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +K (coordinates: \\( \\theta = any angle, \\varphi = 0 \\)).\n */\npublic static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -I (coordinates: \\( \\theta = \\pi, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -J (coordinates: \\( \\theta = 3\\pi/2, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -K (coordinates: \\( \\theta = any angle, \\varphi = \\pi \\)).\n */\npublic static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);"
            ],
            [
                "DIGEST_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Use empirical distribution.\n */\npublic static final int DIGEST_MODE = 0;"
            ],
            [
                "REPLAY_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Replay data from valuesFilePath.\n */\npublic static final int REPLAY_MODE = 1;"
            ],
            [
                "UNIFORM_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Uniform random deviates with mean = &mu;.\n */\npublic static final int UNIFORM_MODE = 2;"
            ],
            [
                "EXPONENTIAL_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Exponential random deviates with mean = &mu;.\n */\npublic static final int EXPONENTIAL_MODE = 3;"
            ],
            [
                "GAUSSIAN_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Gaussian random deviates with mean = &mu;, std dev = &sigma;.\n */\npublic static final int GAUSSIAN_MODE = 4;"
            ],
            [
                "CONSTANT_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Always return mu\n */\npublic static final int CONSTANT_MODE = 5;"
            ],
            [
                "DEFAULT_BIN_COUNT",
                "org.apache.commons.math3.random",
                "EmpiricalDistribution",
                "/**\n * Default bin count\n */\npublic static final int DEFAULT_BIN_COUNT = 1000;"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2 / 1\".\n */\npublic static final Fraction TWO = new Fraction(2, 1);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1\".\n */\npublic static final Fraction ONE = new Fraction(1, 1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"0\".\n */\npublic static final Fraction ZERO = new Fraction(0, 1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"4/5\".\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/5\".\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/2\".\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/4\".\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/3\".\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"3/5\".\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"3/4\".\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/5\".\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/4\".\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/3\".\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"-1 / 1\".\n */\npublic static final Fraction MINUS_ONE = new Fraction(-1, 1);"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2 / 1\".\n */\npublic static final BigFraction TWO = new BigFraction(2);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1\".\n */\npublic static final BigFraction ONE = new BigFraction(1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"0\".\n */\npublic static final BigFraction ZERO = new BigFraction(0);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"-1 / 1\".\n */\npublic static final BigFraction MINUS_ONE = new BigFraction(-1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"4/5\".\n */\npublic static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/5\".\n */\npublic static final BigFraction ONE_FIFTH = new BigFraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/2\".\n */\npublic static final BigFraction ONE_HALF = new BigFraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/4\".\n */\npublic static final BigFraction ONE_QUARTER = new BigFraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/3\".\n */\npublic static final BigFraction ONE_THIRD = new BigFraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"3/5\".\n */\npublic static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"3/4\".\n */\npublic static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/5\".\n */\npublic static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/4\".\n */\npublic static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/3\".\n */\npublic static final BigFraction TWO_THIRDS = new BigFraction(2, 3);"
            ],
            [
                "INTEGER_ZERO",
                "org.apache.commons.math3.exception",
                "MathIllegalNumberException",
                "/**\n * Helper to avoid boxing warnings. @since 3.3\n */\nprotected static final Integer INTEGER_ZERO = Integer.valueOf(0);"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastSineTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120211L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastFourierTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120210L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastCosineTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120212L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastHadamardTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120211L;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "realPart",
                "",
                "double"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "divide",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code (this / divisor)},\n * with {@code divisor} interpreted as a real number.\n *\n * @param  divisor Value by which this {@code Complex} is to be divided.\n * @return {@code this / divisor}.\n * @see #divide(Complex)\n */\npublic Complex divide(double divisor) {\n    if (isNaN || Double.isNaN(divisor)) {\n        return NaN;\n    }\n    if (divisor == 0d) {\n        return NaN;\n    }\n    if (Double.isInfinite(divisor)) {\n        return !isInfinite() ? ZERO : NaN;\n    }\n    return createComplex(real / divisor, imaginary / divisor);\n}"
            ],
            [
                "getField",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract Field<T> getField()"
            ],
            [
                "readResolve",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Resolve the transient fields in a deserialized Complex Object.\n * Subclasses will need to override {@link #createComplex} to\n * deserialize properly.\n *\n * @return A Complex instance with all fields resolved.\n * @since 2.0\n */\nprotected final Object readResolve() {\n    return createComplex(real, imaginary);\n}"
            ],
            [
                "hashCode",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Get a hashCode for the complex number.\n * Any {@code Double.NaN} value in real or imaginary part produces\n * the same hash code {@code 7}.\n *\n * @return a hash code value for this object.\n */\n@Override\npublic int hashCode() {\n    if (isNaN) {\n        return 7;\n    }\n    return 37 * (17 * MathUtils.hash(imaginary) + MathUtils.hash(real));\n}"
            ],
            [
                "divide",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T divide(T arg0) throws NullArgumentException, MathArithmeticException"
            ],
            [
                "getField",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * {@inheritDoc}\n */\npublic ComplexField getField() {\n    return ComplexField.getInstance();\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Test for equality with another object.\n * If both the real and imaginary parts of two complex numbers\n * are exactly the same, and neither is {@code Double.NaN}, the two\n * Complex objects are considered to be equal.\n * The behavior is the same as for JDK's {@link Double#equals(Object)\n * Double}:\n * <ul>\n *  <li>All {@code NaN} values are considered to be equal,\n *   i.e, if either (or both) real and imaginary parts of the complex\n *   number are equal to {@code Double.NaN}, the complex number is equal\n *   to {@code NaN}.\n *  </li>\n *  <li>\n *   Instances constructed with different representations of zero (i.e.\n *   either \"0\" or \"-0\") are <em>not</em> considered to be equal.\n *  </li>\n * </ul>\n *\n * @param other Object to test for equality with this instance.\n * @return {@code true} if the objects are equal, {@code false} if object\n * is {@code null}, not an instance of {@code Complex}, or not equal to\n * this instance.\n */\n@Override\npublic boolean equals(Object other) {\n    if (this == other) {\n        return true;\n    }\n    if (other instanceof Complex) {\n        Complex c = (Complex) other;\n        if (c.isNaN) {\n            return isNaN;\n        } else {\n            return MathUtils.equals(real, c.real) && MathUtils.equals(imaginary, c.imaginary);\n        }\n    }\n    return false;\n}"
            ],
            [
                "isNaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Checks whether either or both parts of this complex number is\n * {@code NaN}.\n *\n * @return true if either or both parts of this complex number is\n * {@code NaN}; false otherwise.\n */\npublic boolean isNaN() {\n    return isNaN;\n}"
            ],
            [
                "subtract",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T subtract(T arg0) throws NullArgumentException"
            ],
            [
                "toString",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * {@inheritDoc}\n */\n@Override\npublic String toString() {\n    return \"(\" + real + \", \" + imaginary + \")\";\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n * interpreted as a real number.\n *\n * @param  factor value to be multiplied by this {@code Complex}.\n * @return {@code this * factor}.\n * @see #multiply(Complex)\n */\npublic Complex multiply(double factor) {\n    if (isNaN || Double.isNaN(factor)) {\n        return NaN;\n    }\n    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor)) {\n        // we don't use isInfinite() to avoid testing for NaN again\n        return INF;\n    }\n    return createComplex(real * factor, imaginary * factor);\n}"
            ],
            [
                "negate",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T negate()"
            ],
            [
                "tan",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n * tangent</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n * {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite (or critical) values in real or imaginary parts of the input may\n * result in infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\n *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\n *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n *  </code>\n * </pre>\n *\n * @return the tangent of {@code this}.\n * @since 1.2\n */\npublic Complex tan() {\n    if (isNaN || Double.isInfinite(real)) {\n        return NaN;\n    }\n    if (imaginary > 20.0) {\n        return createComplex(0.0, 1.0);\n    }\n    if (imaginary < -20.0) {\n        return createComplex(0.0, -1.0);\n    }\n    double real2 = 2.0 * real;\n    double imaginary2 = 2.0 * imaginary;\n    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);\n}"
            ],
            [
                "add",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T add(T arg0) throws NullArgumentException"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code (this + addend)},\n * with {@code addend} interpreted as a real number.\n *\n * @param addend Value to be added to this {@code Complex}.\n * @return {@code this + addend}.\n * @see #add(Complex)\n */\npublic Complex add(double addend) {\n    if (isNaN || Double.isNaN(addend)) {\n        return NaN;\n    }\n    return createComplex(real + addend, imaginary);\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n * interpreted as a integer number.\n *\n * @param  factor value to be multiplied by this {@code Complex}.\n * @return {@code this * factor}.\n * @see #multiply(Complex)\n */\npublic Complex multiply(final int factor) {\n    if (isNaN) {\n        return NaN;\n    }\n    if (Double.isInfinite(real) || Double.isInfinite(imaginary)) {\n        return INF;\n    }\n    return createComplex(real * factor, imaginary * factor);\n}"
            ],
            [
                "cosh",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n * hyperbolic cosine</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n *   cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n *   cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the hyperbolic cosine of this complex number.\n * @since 1.2\n */\npublic Complex cosh() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.cosh(real) * FastMath.cos(imaginary), FastMath.sinh(real) * FastMath.sin(imaginary));\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n * natural logarithm</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i\n *  </code>\n * </pre>\n * where ln on the right hand side is {@link FastMath#log},\n * {@code |a + bi|} is the modulus, {@link Complex#abs},  and\n * {@code arg(a + bi) = }{@link FastMath#atan2}(b, a).\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite (or critical) values in real or imaginary parts of the input may\n * result in infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n *   log(INFINITY + i) = INFINITY + 0i\n *   log(-INFINITY + i) = INFINITY + &pi;i\n *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n *   log(0 + 0i) = -INFINITY + 0i\n *  </code>\n * </pre>\n *\n * @return the value <code>ln &nbsp; this</code>, the natural logarithm\n * of {@code this}.\n * @since 1.2\n */\npublic Complex log() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.log(abs()), FastMath.atan2(imaginary, real));\n}"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n * square root</a> of this complex number.\n * Implements the following algorithm to compute {@code sqrt(a + bi)}:\n * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>\n * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}\n *  else return {@code |b|/2t + sign(b)t i }</pre></li>\n * </ol>\n * where <ul>\n * <li>{@code |a| = }{@link FastMath#abs}(a)</li>\n * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>\n * <li>{@code sign(b) =  }{@link FastMath#copySign(double,double) copySign(1d, b)}\n * </ul>\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n *   sqrt(INFINITY + i) = INFINITY + 0i\n *   sqrt(-INFINITY + i) = 0 + INFINITY i\n *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n *  </code>\n * </pre>\n *\n * @return the square root of {@code this}.\n * @since 1.2\n */\npublic Complex sqrt() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return createComplex(0.0, 0.0);\n    }\n    double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n    if (real >= 0.0) {\n        return createComplex(t, imaginary / (2.0 * t));\n    } else {\n        return createComplex(FastMath.abs(imaginary) / (2.0 * t), FastMath.copySign(1d, imaginary) * t);\n    }\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Return the absolute value of this complex number.\n * Returns {@code NaN} if either real or imaginary part is {@code NaN}\n * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},\n * but at least one part is infinite.\n *\n * @return the absolute value.\n */\npublic double abs() {\n    if (isNaN) {\n        return Double.NaN;\n    }\n    if (isInfinite()) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        if (imaginary == 0.0) {\n            return FastMath.abs(real);\n        }\n        double q = real / imaginary;\n        return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n    } else {\n        if (real == 0.0) {\n            return FastMath.abs(imaginary);\n        }\n        double q = imaginary / real;\n        return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n    }\n}"
            ],
            [
                "acos",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n * inverse cosine</a> of this complex number.\n * Implements the formula:\n * <p>\n *  {@code acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))}\n * </p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite.\n *\n * @return the inverse cosine of this complex number.\n * @since 1.2\n */\npublic Complex acos() {\n    if (isNaN) {\n        return NaN;\n    }\n    return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());\n}"
            ],
            [
                "conjugate",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns the conjugate of this complex number.\n * The conjugate of {@code a + bi} is {@code a - bi}.\n * <p>\n * {@link #NaN} is returned if either the real or imaginary\n * part of this Complex number equals {@code Double.NaN}.\n * </p><p>\n * If the imaginary part is infinite, and the real part is not\n * {@code NaN}, the returned value has infinite imaginary part\n * of the opposite sign, e.g. the conjugate of\n * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.\n * </p>\n * @return the conjugate of this Complex object.\n */\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(real, -imaginary);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns of value of this complex number raised to the power of {@code x}.\n *\n * @param  x exponent to which this {@code Complex} is to be raised.\n * @return <code>this<sup>x</sup></code>.\n * @see #pow(Complex)\n */\npublic Complex pow(double x) {\n    return this.log().multiply(x).exp();\n}"
            ],
            [
                "reciprocal",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * {@inheritDoc}\n */\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return INF;\n    }\n    if (isInfinite) {\n        return ZERO;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}"
            ],
            [
                "atan",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n * inverse tangent</a> of this complex number.\n * Implements the formula:\n * <p>\n * {@code atan(z) = (i/2) log((i + z)/(i - z))}\n * </p><p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite.</p>\n *\n * @return the inverse tangent of this complex number\n * @since 1.2\n */\npublic Complex atan() {\n    if (isNaN) {\n        return NaN;\n    }\n    return this.add(I).divide(I.subtract(this)).log().multiply(I.divide(createComplex(2.0, 0.0)));\n}"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this - subtrahend)}.\n * Uses the definitional formula\n * <p>\n *  {@code (a + bi) - (c + di) = (a-c) + (b-d)i}\n * </p>\n * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,\n * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are\n * returned in the parts of the result according to the rules for\n * {@link java.lang.Double} arithmetic.\n *\n * @param  subtrahend value to be subtracted from this {@code Complex}.\n * @return {@code this - subtrahend}.\n * @throws NullArgumentException if {@code subtrahend} is {@code null}.\n */\npublic Complex subtract(Complex subtrahend) throws NullArgumentException {\n    MathUtils.checkNotNull(subtrahend);\n    if (isNaN || subtrahend.isNaN) {\n        return NaN;\n    }\n    return createComplex(real - subtrahend.getReal(), imaginary - subtrahend.getImaginary());\n}"
            ],
            [
                "getReal",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Access the real part.\n *\n * @return the real part.\n */\npublic double getReal() {\n    return real;\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this + addend)}.\n * Uses the definitional formula\n * <p>\n *   {@code (a + bi) + (c + di) = (a+c) + (b+d)i}\n * </p>\n * If either {@code this} or {@code addend} has a {@code NaN} value in\n * either part, {@link #NaN} is returned; otherwise {@code Infinite}\n * and {@code NaN} values are returned in the parts of the result\n * according to the rules for {@link java.lang.Double} arithmetic.\n *\n * @param  addend Value to be added to this {@code Complex}.\n * @return {@code this + addend}.\n * @throws NullArgumentException if {@code addend} is {@code null}.\n */\npublic Complex add(Complex addend) throws NullArgumentException {\n    MathUtils.checkNotNull(addend);\n    if (isNaN || addend.isNaN) {\n        return NaN;\n    }\n    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());\n}"
            ],
            [
                "sqrt1z",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n * square root</a> of <code>1 - this<sup>2</sup></code> for this complex\n * number.\n * Computes the result directly as\n * {@code sqrt(ONE.subtract(z.multiply(z)))}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n *\n * @return the square root of <code>1 - this<sup>2</sup></code>.\n * @since 1.2\n */\npublic Complex sqrt1z() {\n    return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n}"
            ],
            [
                "exp",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n * exponential function</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#exp}, {@link FastMath#cos}, and\n * {@link FastMath#sin}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   exp(1 &plusmn; INFINITY i) = NaN + NaN i\n *   exp(INFINITY + i) = INFINITY + INFINITY i\n *   exp(-INFINITY + i) = 0 + 0i\n *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return <code><i>e</i><sup>this</sup></code>.\n * @since 1.2\n */\npublic Complex exp() {\n    if (isNaN) {\n        return NaN;\n    }\n    double expReal = FastMath.exp(real);\n    return createComplex(expReal * FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));\n}"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this - subtrahend)}.\n *\n * @param  subtrahend value to be subtracted from this {@code Complex}.\n * @return {@code this - subtrahend}.\n * @see #subtract(Complex)\n */\npublic Complex subtract(double subtrahend) {\n    if (isNaN || Double.isNaN(subtrahend)) {\n        return NaN;\n    }\n    return createComplex(real - subtrahend, imaginary);\n}"
            ],
            [
                "sinh",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n * hyperbolic sine</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p><p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n *   sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n *   sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the hyperbolic sine of {@code this}.\n * @since 1.2\n */\npublic Complex sinh() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary), FastMath.cosh(real) * FastMath.sin(imaginary));\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T multiply(int arg0)"
            ],
            [
                "getImaginary",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Access the imaginary part.\n *\n * @return the imaginary part.\n */\npublic double getImaginary() {\n    return imaginary;\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code this * factor}.\n * Implements preliminary checks for {@code NaN} and infinity followed by\n * the definitional formula:\n * <p>\n *   {@code (a + bi)(c + di) = (ac - bd) + (ad + bc)i}\n * </p>\n * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n * more {@code NaN} parts.\n * <p>\n * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n * or more {@code NaN} parts and if either {@code this} or {@code factor}\n * has one or more infinite parts (same result is returned regardless of\n * the sign of the components).\n * </p><p>\n * Returns finite values in components of the result per the definitional\n * formula in all remaining cases.</p>\n *\n * @param  factor value to be multiplied by this {@code Complex}.\n * @return {@code this * factor}.\n * @throws NullArgumentException if {@code factor} is {@code null}.\n */\npublic Complex multiply(Complex factor) throws NullArgumentException {\n    MathUtils.checkNotNull(factor);\n    if (isNaN || factor.isNaN) {\n        return NaN;\n    }\n    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {\n        // we don't use isInfinite() to avoid testing for NaN again\n        return INF;\n    }\n    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);\n}"
            ],
            [
                "tanh",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n * hyperbolic tangent</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n * {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\n *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\n *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i\n *  </code>\n * </pre>\n *\n * @return the hyperbolic tangent of {@code this}.\n * @since 1.2\n */\npublic Complex tanh() {\n    if (isNaN || Double.isInfinite(imaginary)) {\n        return NaN;\n    }\n    if (real > 20.0) {\n        return createComplex(1.0, 0.0);\n    }\n    if (real < -20.0) {\n        return createComplex(-1.0, 0.0);\n    }\n    double real2 = 2.0 * real;\n    double imaginary2 = 2.0 * imaginary;\n    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n    return createComplex(FastMath.sinh(real2) / d, FastMath.sin(imaginary2) / d);\n}"
            ],
            [
                "divide",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this / divisor)}.\n * Implements the definitional formula\n * <pre>\n *  <code>\n *    a + bi          ac + bd + (bc - ad)i\n *    ----------- = -------------------------\n *    c + di         c<sup>2</sup> + d<sup>2</sup>\n *  </code>\n * </pre>\n * but uses\n * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n * prescaling of operands</a> to limit the effects of overflows and\n * underflows in the computation.\n * <p>\n * {@code Infinite} and {@code NaN} values are handled according to the\n * following rules, applied in the order presented:\n * <ul>\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n *   in either part, {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code this} and {@code divisor} are both infinite,\n *   {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\n *   infinite), {@link #ZERO} is returned.\n *  </li>\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\n *   {@code NaN} values are returned in the parts of the result if the\n *   {@link java.lang.Double} rules applied to the definitional formula\n *   force {@code NaN} results.\n *  </li>\n * </ul>\n *\n * @param divisor Value by which this {@code Complex} is to be divided.\n * @return {@code this / divisor}.\n * @throws NullArgumentException if {@code divisor} is {@code null}.\n */\npublic Complex divide(Complex divisor) throws NullArgumentException {\n    MathUtils.checkNotNull(divisor);\n    if (isNaN || divisor.isNaN) {\n        return NaN;\n    }\n    final double c = divisor.getReal();\n    final double d = divisor.getImaginary();\n    if (c == 0.0 && d == 0.0) {\n        return NaN;\n    }\n    if (divisor.isInfinite() && !isInfinite()) {\n        return ZERO;\n    }\n    if (FastMath.abs(c) < FastMath.abs(d)) {\n        double q = c / d;\n        double denominator = c * q + d;\n        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);\n    } else {\n        double q = d / c;\n        double denominator = d * q + c;\n        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns of value of this complex number raised to the power of {@code x}.\n * Implements the formula:\n * <pre>\n *  <code>\n *   y<sup>x</sup> = exp(x&middot;log(y))\n *  </code>\n * </pre>\n * where {@code exp} and {@code log} are {@link #exp} and\n * {@link #log}, respectively.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite, or if {@code y}\n * equals {@link Complex#ZERO}.</p>\n *\n * @param  x exponent to which this {@code Complex} is to be raised.\n * @return <code> this<sup>x</sup></code>.\n * @throws NullArgumentException if x is {@code null}.\n * @since 1.2\n */\npublic Complex pow(Complex x) throws NullArgumentException {\n    MathUtils.checkNotNull(x);\n    return this.log().multiply(x).exp();\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "nthRoot",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Computes the n-th roots of this complex number.\n * The nth roots are defined by the formula:\n * <pre>\n *  <code>\n *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n *  </code>\n * </pre>\n * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n * are respectively the {@link #abs() modulus} and\n * {@link #getArgument() argument} of this complex number.\n * <p>\n * If one or both parts of this complex number is NaN, a list with just\n * one element, {@link #NaN} is returned.\n * if neither part is NaN, but at least one part is infinite, the result\n * is a one-element list containing {@link #INF}.\n *\n * @param n Degree of root.\n * @return a List of all {@code n}-th roots of {@code this}.\n * @throws NotPositiveException if {@code n <= 0}.\n * @since 2.0\n */\npublic List<Complex> nthRoot(int n) throws NotPositiveException {\n    if (n <= 0) {\n        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);\n    }\n    final List<Complex> result = new ArrayList<Complex>();\n    if (isNaN) {\n        result.add(NaN);\n        return result;\n    }\n    if (isInfinite()) {\n        result.add(INF);\n        return result;\n    }\n    // nth root of abs -- faster / more accurate to use a solver here?\n    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n    // Compute nth roots of complex number with k = 0, 1, ... n-1\n    final double nthPhi = getArgument() / n;\n    final double slice = 2 * FastMath.PI / n;\n    double innerPart = nthPhi;\n    for (int k = 0; k < n; k++) {\n        // inner part\n        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);\n        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);\n        result.add(createComplex(realPart, imaginaryPart));\n        innerPart += slice;\n    }\n    return result;\n}"
            ],
            [
                "sin",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n * sine</a>\n * of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p><p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or {@code NaN} values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n *   sin(&plusmn;INFINITY + i) = NaN + NaN i\n *   sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the sine of this complex number.\n * @since 1.2\n */\npublic Complex sin() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.sin(real) * FastMath.cosh(imaginary), FastMath.cos(real) * FastMath.sinh(imaginary));\n}"
            ],
            [
                "getArgument",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the argument of this complex number.\n * The argument is the angle phi between the positive real axis and\n * the point representing this number in the complex plane.\n * The value returned is between -PI (not inclusive)\n * and PI (inclusive), with negative values returned for numbers with\n * negative imaginary parts.\n * <p>\n * If either real or imaginary part (or both) is NaN, NaN is returned.\n * Infinite parts are handled as {@code Math.atan2} handles them,\n * essentially treating finite parts as zero in the presence of an\n * infinite coordinate and returning a multiple of pi/4 depending on\n * the signs of the infinite parts.\n * See the javadoc for {@code Math.atan2} for full details.\n *\n * @return the argument of {@code this}.\n */\npublic double getArgument() {\n    return FastMath.atan2(getImaginary(), getReal());\n}"
            ],
            [
                "createComplex",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Create a complex number given the real and imaginary parts.\n *\n * @param realPart Real part.\n * @param imaginaryPart Imaginary part.\n * @return a new complex number instance.\n * @since 1.2\n * @see #valueOf(double, double)\n */\nprotected Complex createComplex(double realPart, double imaginaryPart) {\n    return new Complex(realPart, imaginaryPart);\n}"
            ],
            [
                "isInfinite",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Checks whether either the real or imaginary part of this complex number\n * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or\n * {@code Double.NEGATIVE_INFINITY}) and neither part\n * is {@code NaN}.\n *\n * @return true if one or both parts of this complex number are infinite\n * and neither part is {@code NaN}.\n */\npublic boolean isInfinite() {\n    return isInfinite;\n}"
            ],
            [
                "reciprocal",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T reciprocal() throws MathArithmeticException"
            ],
            [
                "cos",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n * cosine</a> of this complex number.\n * Implements the formula:\n * <p>\n *  {@code cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i}\n * </p><p>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * </p><p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p><p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.</p>\n * <pre>\n *  Examples:\n *  <code>\n *   cos(1 &plusmn; INFINITY i) = 1 \\u2213 INFINITY i\n *   cos(&plusmn;INFINITY + i) = NaN + NaN i\n *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the cosine of this complex number.\n * @since 1.2\n */\npublic Complex cos() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.cos(real) * FastMath.cosh(imaginary), -FastMath.sin(real) * FastMath.sinh(imaginary));\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T multiply(T arg0) throws NullArgumentException"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "negate",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code (-this)}.\n * Returns {@code NaN} if either real or imaginary\n * part of this Complex number is {@code Double.NaN}.\n *\n * @return {@code -this}.\n */\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(-real, -imaginary);\n}"
            ],
            [
                "asin",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n * inverse sine</a> of this complex number.\n * Implements the formula:\n * <p>\n *  {@code asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))}\n * </p><p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite.</p>\n *\n * @return the inverse sine of this complex number.\n * @since 1.2\n */\npublic Complex asin() {\n    if (isNaN) {\n        return NaN;\n    }\n    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());\n}"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 15384,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "commons-math3-3.6.1",
        "packageName": "org.apache.commons.math3.complex",
        "className": "Complex",
        "javadocTag": "@param real Real part.",
        "methodJavadoc": "    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param real Real part.\n     * @param imaginary Imaginary part.\n     */",
        "methodSourceCode": "public Complex(double real, double imaginary){\n    this.real = real;\n    this.imaginary = imaginary;\n    isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n    isInfinite = !isNaN && (Double.isInfinite(real) || Double.isInfinite(imaginary));\n}",
        "classJavadoc": "/**\n * Representation of a Complex number, i.e. a number which has both a\n * real and imaginary part.\n * <p>\n * Implementations of arithmetic operations handle {@code NaN} and\n * infinite values according to the rules for {@link java.lang.Double}, i.e.\n * {@link #equals} is an equivalence relation for all instances that have\n * a {@code NaN} in either real or imaginary part, e.g. the following are\n * considered equal:\n * <ul>\n *  <li>{@code 1 + NaNi}</li>\n *  <li>{@code NaN + i}</li>\n *  <li>{@code NaN + NaNi}</li>\n * </ul><p>\n * Note that this contradicts the IEEE-754 standard for floating\n * point numbers (according to which the test {@code x == x} must fail if\n * {@code x} is {@code NaN}). The method\n * {@link org.apache.commons.math3.util.Precision#equals(double,double,int)\n * equals for primitive double} in {@link org.apache.commons.math3.util.Precision}\n * conforms with IEEE-754 while this class conforms with the standard behavior\n * for Java object types.</p>\n *\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.complex;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.FieldElement;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.Precision;\n\n/**\n * Representation of a Complex number, i.e. a number which has both a\n * real and imaginary part.\n * <p>\n * Implementations of arithmetic operations handle {@code NaN} and\n * infinite values according to the rules for {@link java.lang.Double}, i.e.\n * {@link #equals} is an equivalence relation for all instances that have\n * a {@code NaN} in either real or imaginary part, e.g. the following are\n * considered equal:\n * <ul>\n *  <li>{@code 1 + NaNi}</li>\n *  <li>{@code NaN + i}</li>\n *  <li>{@code NaN + NaNi}</li>\n * </ul><p>\n * Note that this contradicts the IEEE-754 standard for floating\n * point numbers (according to which the test {@code x == x} must fail if\n * {@code x} is {@code NaN}). The method\n * {@link org.apache.commons.math3.util.Precision#equals(double,double,int)\n * equals for primitive double} in {@link org.apache.commons.math3.util.Precision}\n * conforms with IEEE-754 while this class conforms with the standard behavior\n * for Java object types.</p>\n *\n */\npublic class Complex implements FieldElement<Complex>, Serializable  {\n    /** The square root of -1. A number representing \"0.0 + 1.0i\" */\n    public static final Complex I = new Complex(0.0, 1.0);\n    // CHECKSTYLE: stop ConstantName\n    /** A complex number representing \"NaN + NaNi\" */\n    public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n    // CHECKSTYLE: resume ConstantName\n    /** A complex number representing \"+INF + INFi\" */\n    public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    /** A complex number representing \"1.0 + 0.0i\" */\n    public static final Complex ONE = new Complex(1.0, 0.0);\n    /** A complex number representing \"0.0 + 0.0i\" */\n    public static final Complex ZERO = new Complex(0.0, 0.0);\n\n    /** Serializable version identifier */\n    private static final long serialVersionUID = -6195664516687396620L;\n\n    /** The imaginary part. */\n    private final double imaginary;\n    /** The real part. */\n    private final double real;\n    /** Record whether this complex number is equal to NaN. */\n    private final transient boolean isNaN;\n    /** Record whether this complex number is infinite. */\n    private final transient boolean isInfinite;\n\n    /**\n     * Create a complex number given only the real part.\n     *\n     * @param real Real part.\n     */\n    public Complex(double real) {\n        this(real, 0.0);\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param real Real part.\n     * @param imaginary Imaginary part.\n     */\n    public Complex(double real, double imaginary) {\n        this.real = real;\n        this.imaginary = imaginary;\n\n        isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n        isInfinite = !isNaN &&\n            (Double.isInfinite(real) || Double.isInfinite(imaginary));\n    }\n\n    /**\n     * Return the absolute value of this complex number.\n     * Returns {@code NaN} if either real or imaginary part is {@code NaN}\n     * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},\n     * but at least one part is infinite.\n     *\n     * @return the absolute value.\n     */\n    public double abs() {\n        if (isNaN) {\n            return Double.NaN;\n        }\n        if (isInfinite()) {\n            return Double.POSITIVE_INFINITY;\n        }\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            if (imaginary == 0.0) {\n                return FastMath.abs(real);\n            }\n            double q = real / imaginary;\n            return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n        } else {\n            if (real == 0.0) {\n                return FastMath.abs(imaginary);\n            }\n            double q = imaginary / real;\n            return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n        }\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this + addend)}.\n     * Uses the definitional formula\n     * <p>\n     *   {@code (a + bi) + (c + di) = (a+c) + (b+d)i}\n     * </p>\n     * If either {@code this} or {@code addend} has a {@code NaN} value in\n     * either part, {@link #NaN} is returned; otherwise {@code Infinite}\n     * and {@code NaN} values are returned in the parts of the result\n     * according to the rules for {@link java.lang.Double} arithmetic.\n     *\n     * @param  addend Value to be added to this {@code Complex}.\n     * @return {@code this + addend}.\n     * @throws NullArgumentException if {@code addend} is {@code null}.\n     */\n    public Complex add(Complex addend) throws NullArgumentException {\n        MathUtils.checkNotNull(addend);\n        if (isNaN || addend.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real + addend.getReal(),\n                             imaginary + addend.getImaginary());\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code (this + addend)},\n     * with {@code addend} interpreted as a real number.\n     *\n     * @param addend Value to be added to this {@code Complex}.\n     * @return {@code this + addend}.\n     * @see #add(Complex)\n     */\n    public Complex add(double addend) {\n        if (isNaN || Double.isNaN(addend)) {\n            return NaN;\n        }\n\n        return createComplex(real + addend, imaginary);\n    }\n\n     /**\n     * Returns the conjugate of this complex number.\n     * The conjugate of {@code a + bi} is {@code a - bi}.\n     * <p>\n     * {@link #NaN} is returned if either the real or imaginary\n     * part of this Complex number equals {@code Double.NaN}.\n     * </p><p>\n     * If the imaginary part is infinite, and the real part is not\n     * {@code NaN}, the returned value has infinite imaginary part\n     * of the opposite sign, e.g. the conjugate of\n     * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.\n     * </p>\n     * @return the conjugate of this Complex object.\n     */\n    public Complex conjugate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real, -imaginary);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this / divisor)}.\n     * Implements the definitional formula\n     * <pre>\n     *  <code>\n     *    a + bi          ac + bd + (bc - ad)i\n     *    ----------- = -------------------------\n     *    c + di         c<sup>2</sup> + d<sup>2</sup>\n     *  </code>\n     * </pre>\n     * but uses\n     * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n     * prescaling of operands</a> to limit the effects of overflows and\n     * underflows in the computation.\n     * <p>\n     * {@code Infinite} and {@code NaN} values are handled according to the\n     * following rules, applied in the order presented:\n     * <ul>\n     *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n     *   in either part, {@link #NaN} is returned.\n     *  </li>\n     *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n     *  </li>\n     *  <li>If {@code this} and {@code divisor} are both infinite,\n     *   {@link #NaN} is returned.\n     *  </li>\n     *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\n     *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\n     *   infinite), {@link #ZERO} is returned.\n     *  </li>\n     *  <li>If {@code this} is infinite and {@code divisor} is finite,\n     *   {@code NaN} values are returned in the parts of the result if the\n     *   {@link java.lang.Double} rules applied to the definitional formula\n     *   force {@code NaN} results.\n     *  </li>\n     * </ul>\n     *\n     * @param divisor Value by which this {@code Complex} is to be divided.\n     * @return {@code this / divisor}.\n     * @throws NullArgumentException if {@code divisor} is {@code null}.\n     */\n    public Complex divide(Complex divisor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(divisor);\n        if (isNaN || divisor.isNaN) {\n            return NaN;\n        }\n\n        final double c = divisor.getReal();\n        final double d = divisor.getImaginary();\n        if (c == 0.0 && d == 0.0) {\n            return NaN;\n        }\n\n        if (divisor.isInfinite() && !isInfinite()) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(c) < FastMath.abs(d)) {\n            double q = c / d;\n            double denominator = c * q + d;\n            return createComplex((real * q + imaginary) / denominator,\n                (imaginary * q - real) / denominator);\n        } else {\n            double q = d / c;\n            double denominator = d * q + c;\n            return createComplex((imaginary * q + real) / denominator,\n                (imaginary - real * q) / denominator);\n        }\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code (this / divisor)},\n     * with {@code divisor} interpreted as a real number.\n     *\n     * @param  divisor Value by which this {@code Complex} is to be divided.\n     * @return {@code this / divisor}.\n     * @see #divide(Complex)\n     */\n    public Complex divide(double divisor) {\n        if (isNaN || Double.isNaN(divisor)) {\n            return NaN;\n        }\n        if (divisor == 0d) {\n            return NaN;\n        }\n        if (Double.isInfinite(divisor)) {\n            return !isInfinite() ? ZERO : NaN;\n        }\n        return createComplex(real / divisor,\n                             imaginary  / divisor);\n    }\n\n    /** {@inheritDoc} */\n    public Complex reciprocal() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return INF;\n        }\n\n        if (isInfinite) {\n            return ZERO;\n        }\n\n        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n            double q = real / imaginary;\n            double scale = 1. / (real * q + imaginary);\n            return createComplex(scale * q, -scale);\n        } else {\n            double q = imaginary / real;\n            double scale = 1. / (imaginary * q + real);\n            return createComplex(scale, -scale * q);\n        }\n    }\n\n    /**\n     * Test for equality with another object.\n     * If both the real and imaginary parts of two complex numbers\n     * are exactly the same, and neither is {@code Double.NaN}, the two\n     * Complex objects are considered to be equal.\n     * The behavior is the same as for JDK's {@link Double#equals(Object)\n     * Double}:\n     * <ul>\n     *  <li>All {@code NaN} values are considered to be equal,\n     *   i.e, if either (or both) real and imaginary parts of the complex\n     *   number are equal to {@code Double.NaN}, the complex number is equal\n     *   to {@code NaN}.\n     *  </li>\n     *  <li>\n     *   Instances constructed with different representations of zero (i.e.\n     *   either \"0\" or \"-0\") are <em>not</em> considered to be equal.\n     *  </li>\n     * </ul>\n     *\n     * @param other Object to test for equality with this instance.\n     * @return {@code true} if the objects are equal, {@code false} if object\n     * is {@code null}, not an instance of {@code Complex}, or not equal to\n     * this instance.\n     */\n    @Override\n    public boolean equals(Object other) {\n        if (this == other) {\n            return true;\n        }\n        if (other instanceof Complex){\n            Complex c = (Complex) other;\n            if (c.isNaN) {\n                return isNaN;\n            } else {\n                return MathUtils.equals(real, c.real) &&\n                    MathUtils.equals(imaginary, c.imaginary);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Test for the floating-point equality between Complex objects.\n     * It returns {@code true} if both arguments are equal or within the\n     * range of allowed error (inclusive).\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n     * values between the real (resp. imaginary) parts of {@code x} and\n     * {@code y}.\n     * @return {@code true} if there are fewer than {@code maxUlps} floating\n     * point values between the real (resp. imaginary) parts of {@code x}\n     * and {@code y}.\n     *\n     * @see Precision#equals(double,double,int)\n     * @since 3.3\n     */\n    public static boolean equals(Complex x, Complex y, int maxUlps) {\n        return Precision.equals(x.real, y.real, maxUlps) &&\n            Precision.equals(x.imaginary, y.imaginary, maxUlps);\n    }\n\n    /**\n     * Returns {@code true} iff the values are equal as defined by\n     * {@link #equals(Complex,Complex,int) equals(x, y, 1)}.\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @return {@code true} if the values are equal.\n     *\n     * @since 3.3\n     */\n    public static boolean equals(Complex x, Complex y) {\n        return equals(x, y, 1);\n    }\n\n    /**\n     * Returns {@code true} if, both for the real part and for the imaginary\n     * part, there is no double value strictly between the arguments or the\n     * difference between them is within the range of allowed error\n     * (inclusive).  Returns {@code false} if either of the arguments is NaN.\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @param eps Amount of allowed absolute error.\n     * @return {@code true} if the values are two adjacent floating point\n     * numbers or they are within range of each other.\n     *\n     * @see Precision#equals(double,double,double)\n     * @since 3.3\n     */\n    public static boolean equals(Complex x, Complex y, double eps) {\n        return Precision.equals(x.real, y.real, eps) &&\n            Precision.equals(x.imaginary, y.imaginary, eps);\n    }\n\n    /**\n     * Returns {@code true} if, both for the real part and for the imaginary\n     * part, there is no double value strictly between the arguments or the\n     * relative difference between them is smaller or equal to the given\n     * tolerance. Returns {@code false} if either of the arguments is NaN.\n     *\n     * @param x First value (cannot be {@code null}).\n     * @param y Second value (cannot be {@code null}).\n     * @param eps Amount of allowed relative error.\n     * @return {@code true} if the values are two adjacent floating point\n     * numbers or they are within range of each other.\n     *\n     * @see Precision#equalsWithRelativeTolerance(double,double,double)\n     * @since 3.3\n     */\n    public static boolean equalsWithRelativeTolerance(Complex x, Complex y,\n                                                      double eps) {\n        return Precision.equalsWithRelativeTolerance(x.real, y.real, eps) &&\n            Precision.equalsWithRelativeTolerance(x.imaginary, y.imaginary, eps);\n    }\n\n    /**\n     * Get a hashCode for the complex number.\n     * Any {@code Double.NaN} value in real or imaginary part produces\n     * the same hash code {@code 7}.\n     *\n     * @return a hash code value for this object.\n     */\n    @Override\n    public int hashCode() {\n        if (isNaN) {\n            return 7;\n        }\n        return 37 * (17 * MathUtils.hash(imaginary) +\n            MathUtils.hash(real));\n    }\n\n    /**\n     * Access the imaginary part.\n     *\n     * @return the imaginary part.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Access the real part.\n     *\n     * @return the real part.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Checks whether either or both parts of this complex number is\n     * {@code NaN}.\n     *\n     * @return true if either or both parts of this complex number is\n     * {@code NaN}; false otherwise.\n     */\n    public boolean isNaN() {\n        return isNaN;\n    }\n\n    /**\n     * Checks whether either the real or imaginary part of this complex number\n     * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or\n     * {@code Double.NEGATIVE_INFINITY}) and neither part\n     * is {@code NaN}.\n     *\n     * @return true if one or both parts of this complex number are infinite\n     * and neither part is {@code NaN}.\n     */\n    public boolean isInfinite() {\n        return isInfinite;\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}.\n     * Implements preliminary checks for {@code NaN} and infinity followed by\n     * the definitional formula:\n     * <p>\n     *   {@code (a + bi)(c + di) = (ac - bd) + (ad + bc)i}\n     * </p>\n     * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n     * more {@code NaN} parts.\n     * <p>\n     * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n     * or more {@code NaN} parts and if either {@code this} or {@code factor}\n     * has one or more infinite parts (same result is returned regardless of\n     * the sign of the components).\n     * </p><p>\n     * Returns finite values in components of the result per the definitional\n     * formula in all remaining cases.</p>\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @throws NullArgumentException if {@code factor} is {@code null}.\n     */\n    public Complex multiply(Complex factor)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(factor);\n        if (isNaN || factor.isNaN) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor.real) ||\n            Double.isInfinite(factor.imaginary)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor.real - imaginary * factor.imaginary,\n                             real * factor.imaginary + imaginary * factor.real);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n     * interpreted as a integer number.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @see #multiply(Complex)\n     */\n    public Complex multiply(final int factor) {\n        if (isNaN) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary)) {\n            return INF;\n        }\n        return createComplex(real * factor, imaginary * factor);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n     * interpreted as a real number.\n     *\n     * @param  factor value to be multiplied by this {@code Complex}.\n     * @return {@code this * factor}.\n     * @see #multiply(Complex)\n     */\n    public Complex multiply(double factor) {\n        if (isNaN || Double.isNaN(factor)) {\n            return NaN;\n        }\n        if (Double.isInfinite(real) ||\n            Double.isInfinite(imaginary) ||\n            Double.isInfinite(factor)) {\n            // we don't use isInfinite() to avoid testing for NaN again\n            return INF;\n        }\n        return createComplex(real * factor, imaginary * factor);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is {@code (-this)}.\n     * Returns {@code NaN} if either real or imaginary\n     * part of this Complex number is {@code Double.NaN}.\n     *\n     * @return {@code -this}.\n     */\n    public Complex negate() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(-real, -imaginary);\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this - subtrahend)}.\n     * Uses the definitional formula\n     * <p>\n     *  {@code (a + bi) - (c + di) = (a-c) + (b-d)i}\n     * </p>\n     * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,\n     * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are\n     * returned in the parts of the result according to the rules for\n     * {@link java.lang.Double} arithmetic.\n     *\n     * @param  subtrahend value to be subtracted from this {@code Complex}.\n     * @return {@code this - subtrahend}.\n     * @throws NullArgumentException if {@code subtrahend} is {@code null}.\n     */\n    public Complex subtract(Complex subtrahend)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(subtrahend);\n        if (isNaN || subtrahend.isNaN) {\n            return NaN;\n        }\n\n        return createComplex(real - subtrahend.getReal(),\n                             imaginary - subtrahend.getImaginary());\n    }\n\n    /**\n     * Returns a {@code Complex} whose value is\n     * {@code (this - subtrahend)}.\n     *\n     * @param  subtrahend value to be subtracted from this {@code Complex}.\n     * @return {@code this - subtrahend}.\n     * @see #subtract(Complex)\n     */\n    public Complex subtract(double subtrahend) {\n        if (isNaN || Double.isNaN(subtrahend)) {\n            return NaN;\n        }\n        return createComplex(real - subtrahend, imaginary);\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n     * inverse cosine</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     *  {@code acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))}\n     * </p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite.\n     *\n     * @return the inverse cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex acos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n     * inverse sine</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     *  {@code asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))}\n     * </p><p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite.</p>\n     *\n     * @return the inverse sine of this complex number.\n     * @since 1.2\n     */\n    public Complex asin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n     * inverse tangent</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     * {@code atan(z) = (i/2) log((i + z)/(i - z))}\n     * </p><p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite.</p>\n     *\n     * @return the inverse tangent of this complex number\n     * @since 1.2\n     */\n    public Complex atan() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return this.add(I).divide(I.subtract(this)).log()\n                .multiply(I.divide(createComplex(2.0, 0.0)));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n     * cosine</a> of this complex number.\n     * Implements the formula:\n     * <p>\n     *  {@code cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i}\n     * </p><p>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * </p><p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p><p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.</p>\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   cos(1 &plusmn; INFINITY i) = 1 \\u2213 INFINITY i\n     *   cos(&plusmn;INFINITY + i) = NaN + NaN i\n     *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex cos() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cos(real) * FastMath.cosh(imaginary),\n                             -FastMath.sin(real) * FastMath.sinh(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n     * hyperbolic cosine</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n     *   cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n     *   cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the hyperbolic cosine of this complex number.\n     * @since 1.2\n     */\n    public Complex cosh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.cosh(real) * FastMath.cos(imaginary),\n                             FastMath.sinh(real) * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n     * exponential function</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#exp}, {@link FastMath#cos}, and\n     * {@link FastMath#sin}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   exp(1 &plusmn; INFINITY i) = NaN + NaN i\n     *   exp(INFINITY + i) = INFINITY + INFINITY i\n     *   exp(-INFINITY + i) = 0 + 0i\n     *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return <code><i>e</i><sup>this</sup></code>.\n     * @since 1.2\n     */\n    public Complex exp() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        double expReal = FastMath.exp(real);\n        return createComplex(expReal *  FastMath.cos(imaginary),\n                             expReal * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n     * natural logarithm</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i\n     *  </code>\n     * </pre>\n     * where ln on the right hand side is {@link FastMath#log},\n     * {@code |a + bi|} is the modulus, {@link Complex#abs},  and\n     * {@code arg(a + bi) = }{@link FastMath#atan2}(b, a).\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n     *   log(INFINITY + i) = INFINITY + 0i\n     *   log(-INFINITY + i) = INFINITY + &pi;i\n     *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n     *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n     *   log(0 + 0i) = -INFINITY + 0i\n     *  </code>\n     * </pre>\n     *\n     * @return the value <code>ln &nbsp; this</code>, the natural logarithm\n     * of {@code this}.\n     * @since 1.2\n     */\n    public Complex log() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.log(abs()),\n                             FastMath.atan2(imaginary, real));\n    }\n\n    /**\n     * Returns of value of this complex number raised to the power of {@code x}.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   y<sup>x</sup> = exp(x&middot;log(y))\n     *  </code>\n     * </pre>\n     * where {@code exp} and {@code log} are {@link #exp} and\n     * {@link #log}, respectively.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN} or infinite, or if {@code y}\n     * equals {@link Complex#ZERO}.</p>\n     *\n     * @param  x exponent to which this {@code Complex} is to be raised.\n     * @return <code> this<sup>x</sup></code>.\n     * @throws NullArgumentException if x is {@code null}.\n     * @since 1.2\n     */\n    public Complex pow(Complex x)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(x);\n        return this.log().multiply(x).exp();\n    }\n\n    /**\n     * Returns of value of this complex number raised to the power of {@code x}.\n     *\n     * @param  x exponent to which this {@code Complex} is to be raised.\n     * @return <code>this<sup>x</sup></code>.\n     * @see #pow(Complex)\n     */\n     public Complex pow(double x) {\n        return this.log().multiply(x).exp();\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n     * sine</a>\n     * of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p><p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or {@code NaN} values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n     *   sin(&plusmn;INFINITY + i) = NaN + NaN i\n     *   sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the sine of this complex number.\n     * @since 1.2\n     */\n    public Complex sin() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sin(real) * FastMath.cosh(imaginary),\n                             FastMath.cos(real) * FastMath.sinh(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n     * hyperbolic sine</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos},\n     * {@link FastMath#cosh} and {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p><p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n     *   sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n     *   sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the hyperbolic sine of {@code this}.\n     * @since 1.2\n     */\n    public Complex sinh() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary),\n            FastMath.cosh(real) * FastMath.sin(imaginary));\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of this complex number.\n     * Implements the following algorithm to compute {@code sqrt(a + bi)}:\n     * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>\n     * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}\n     *  else return {@code |b|/2t + sign(b)t i }</pre></li>\n     * </ol>\n     * where <ul>\n     * <li>{@code |a| = }{@link FastMath#abs}(a)</li>\n     * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>\n     * <li>{@code sign(b) =  }{@link FastMath#copySign(double,double) copySign(1d, b)}\n     * </ul>\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n     *   sqrt(INFINITY + i) = INFINITY + 0i\n     *   sqrt(-INFINITY + i) = 0 + INFINITY i\n     *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n     *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n     *  </code>\n     * </pre>\n     *\n     * @return the square root of {@code this}.\n     * @since 1.2\n     */\n    public Complex sqrt() {\n        if (isNaN) {\n            return NaN;\n        }\n\n        if (real == 0.0 && imaginary == 0.0) {\n            return createComplex(0.0, 0.0);\n        }\n\n        double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n        if (real >= 0.0) {\n            return createComplex(t, imaginary / (2.0 * t));\n        } else {\n            return createComplex(FastMath.abs(imaginary) / (2.0 * t),\n                                 FastMath.copySign(1d, imaginary) * t);\n        }\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n     * square root</a> of <code>1 - this<sup>2</sup></code> for this complex\n     * number.\n     * Computes the result directly as\n     * {@code sqrt(ONE.subtract(z.multiply(z)))}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     *\n     * @return the square root of <code>1 - this<sup>2</sup></code>.\n     * @since 1.2\n     */\n    public Complex sqrt1z() {\n        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n     * tangent</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n     * {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite (or critical) values in real or imaginary parts of the input may\n     * result in infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\n     *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\n     *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n     *  </code>\n     * </pre>\n     *\n     * @return the tangent of {@code this}.\n     * @since 1.2\n     */\n    public Complex tan() {\n        if (isNaN || Double.isInfinite(real)) {\n            return NaN;\n        }\n        if (imaginary > 20.0) {\n            return createComplex(0.0, 1.0);\n        }\n        if (imaginary < -20.0) {\n            return createComplex(0.0, -1.0);\n        }\n\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n\n        return createComplex(FastMath.sin(real2) / d,\n                             FastMath.sinh(imaginary2) / d);\n    }\n\n    /**\n     * Compute the\n     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n     * hyperbolic tangent</a> of this complex number.\n     * Implements the formula:\n     * <pre>\n     *  <code>\n     *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i\n     *  </code>\n     * </pre>\n     * where the (real) functions on the right-hand side are\n     * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n     * {@link FastMath#sinh}.\n     * <p>\n     * Returns {@link Complex#NaN} if either real or imaginary part of the\n     * input argument is {@code NaN}.\n     * </p>\n     * Infinite values in real or imaginary parts of the input may result in\n     * infinite or NaN values returned in parts of the result.\n     * <pre>\n     *  Examples:\n     *  <code>\n     *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\n     *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\n     *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n     *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i\n     *  </code>\n     * </pre>\n     *\n     * @return the hyperbolic tangent of {@code this}.\n     * @since 1.2\n     */\n    public Complex tanh() {\n        if (isNaN || Double.isInfinite(imaginary)) {\n            return NaN;\n        }\n        if (real > 20.0) {\n            return createComplex(1.0, 0.0);\n        }\n        if (real < -20.0) {\n            return createComplex(-1.0, 0.0);\n        }\n        double real2 = 2.0 * real;\n        double imaginary2 = 2.0 * imaginary;\n        double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n\n        return createComplex(FastMath.sinh(real2) / d,\n                             FastMath.sin(imaginary2) / d);\n    }\n\n\n\n    /**\n     * Compute the argument of this complex number.\n     * The argument is the angle phi between the positive real axis and\n     * the point representing this number in the complex plane.\n     * The value returned is between -PI (not inclusive)\n     * and PI (inclusive), with negative values returned for numbers with\n     * negative imaginary parts.\n     * <p>\n     * If either real or imaginary part (or both) is NaN, NaN is returned.\n     * Infinite parts are handled as {@code Math.atan2} handles them,\n     * essentially treating finite parts as zero in the presence of an\n     * infinite coordinate and returning a multiple of pi/4 depending on\n     * the signs of the infinite parts.\n     * See the javadoc for {@code Math.atan2} for full details.\n     *\n     * @return the argument of {@code this}.\n     */\n    public double getArgument() {\n        return FastMath.atan2(getImaginary(), getReal());\n    }\n\n    /**\n     * Computes the n-th roots of this complex number.\n     * The nth roots are defined by the formula:\n     * <pre>\n     *  <code>\n     *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n     *  </code>\n     * </pre>\n     * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n     * are respectively the {@link #abs() modulus} and\n     * {@link #getArgument() argument} of this complex number.\n     * <p>\n     * If one or both parts of this complex number is NaN, a list with just\n     * one element, {@link #NaN} is returned.\n     * if neither part is NaN, but at least one part is infinite, the result\n     * is a one-element list containing {@link #INF}.\n     *\n     * @param n Degree of root.\n     * @return a List of all {@code n}-th roots of {@code this}.\n     * @throws NotPositiveException if {@code n <= 0}.\n     * @since 2.0\n     */\n    public List<Complex> nthRoot(int n) throws NotPositiveException {\n\n        if (n <= 0) {\n            throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N,\n                                           n);\n        }\n\n        final List<Complex> result = new ArrayList<Complex>();\n\n        if (isNaN) {\n            result.add(NaN);\n            return result;\n        }\n        if (isInfinite()) {\n            result.add(INF);\n            return result;\n        }\n\n        // nth root of abs -- faster / more accurate to use a solver here?\n        final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n\n        // Compute nth roots of complex number with k = 0, 1, ... n-1\n        final double nthPhi = getArgument() / n;\n        final double slice = 2 * FastMath.PI / n;\n        double innerPart = nthPhi;\n        for (int k = 0; k < n ; k++) {\n            // inner part\n            final double realPart = nthRootOfAbs *  FastMath.cos(innerPart);\n            final double imaginaryPart = nthRootOfAbs *  FastMath.sin(innerPart);\n            result.add(createComplex(realPart, imaginaryPart));\n            innerPart += slice;\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param realPart Real part.\n     * @param imaginaryPart Imaginary part.\n     * @return a new complex number instance.\n     * @since 1.2\n     * @see #valueOf(double, double)\n     */\n    protected Complex createComplex(double realPart,\n                                    double imaginaryPart) {\n        return new Complex(realPart, imaginaryPart);\n    }\n\n    /**\n     * Create a complex number given the real and imaginary parts.\n     *\n     * @param realPart Real part.\n     * @param imaginaryPart Imaginary part.\n     * @return a Complex instance.\n     */\n    public static Complex valueOf(double realPart,\n                                  double imaginaryPart) {\n        if (Double.isNaN(realPart) ||\n            Double.isNaN(imaginaryPart)) {\n            return NaN;\n        }\n        return new Complex(realPart, imaginaryPart);\n    }\n\n    /**\n     * Create a complex number given only the real part.\n     *\n     * @param realPart Real part.\n     * @return a Complex instance.\n     */\n    public static Complex valueOf(double realPart) {\n        if (Double.isNaN(realPart)) {\n            return NaN;\n        }\n        return new Complex(realPart);\n    }\n\n    /**\n     * Resolve the transient fields in a deserialized Complex Object.\n     * Subclasses will need to override {@link #createComplex} to\n     * deserialize properly.\n     *\n     * @return A Complex instance with all fields resolved.\n     * @since 2.0\n     */\n    protected final Object readResolve() {\n        return createComplex(real, imaginary);\n    }\n\n    /** {@inheritDoc} */\n    public ComplexField getField() {\n        return ComplexField.getInstance();\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String toString() {\n        return \"(\" + real + \", \" + imaginary + \")\";\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "RealFieldElement",
                "org.apache.commons.math3"
            ],
            [
                "Primes",
                "org.apache.commons.math3.primes"
            ],
            [
                "SmallPrimes",
                "org.apache.commons.math3.primes"
            ],
            [
                "PollardRho",
                "org.apache.commons.math3.primes"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "SimpleCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.fitting"
            ],
            [
                "ParameterValidator",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "EvaluationRmsChecker",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "OptimumImpl",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresAdapter",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "DenseWeightedEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "AbstractEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresFactory",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "ValueAndJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "MultivariateJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresBuilder",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresProblem",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "WeightedObservedPoints",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "AbstractCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "UnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "FunctionUtils",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "IterativeLegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "LegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "MidPointIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "RombergIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "SimpsonIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BaseRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "HermiteRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegratorFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreHighPrecisionRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "SymmetricGaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "BaseAbstractUnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "UnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "TrapezoidIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "AbstractDifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PegasusSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolverUtils",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "FieldBracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonRaphsonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseSecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "SecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "DifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver2",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractPolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseAbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "LaguerreSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "IllinoisSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RegulaFalsiSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AllowedSolution",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RiddersSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BisectionSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedRealFieldUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "Asin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Multiply",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Asinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Rint",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "StepFunction",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Add",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sqrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Inverse",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Gaussian",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Pow",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Exp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cbrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log1p",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Constant",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Identity",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Signum",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logit",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ceil",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Subtract",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Max",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Min",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Expm1",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Abs",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Divide",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ulp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log10",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Power",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Minus",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan2",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logistic",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Floor",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sigmoid",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinc",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "HarmonicOscillator",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "MultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TrivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "MultivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "ParametricUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableMatrixFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DSCompiler",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "SparseGradient",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateMatrixFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "JacobianFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "GradientFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DerivativeStructure",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateVectorFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "FiniteDifferencesDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "PolynomialFunctionNewtonForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunctionLagrangeForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialSplineFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialsUtils",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "RealFieldUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TricubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LoessInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "DividedDifferenceInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "HermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TrivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "NevilleInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereProjectionInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "AkimaSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MultivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "FieldHermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LinearInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariatePeriodicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SmoothingPolynomialBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere2D",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "Precision",
                "org.apache.commons.math3.util"
            ],
            [
                "MultidimensionalCounter",
                "org.apache.commons.math3.util"
            ],
            [
                "DoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "Incrementor",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToDoubleHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToFieldHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "MathArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "Pair",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathCalc",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMath",
                "org.apache.commons.math3.util"
            ],
            [
                "ResizableDoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "BigRealField",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64Field",
                "org.apache.commons.math3.util"
            ],
            [
                "Combinations",
                "org.apache.commons.math3.util"
            ],
            [
                "MathUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "NumberTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "ContinuedFraction",
                "org.apache.commons.math3.util"
            ],
            [
                "RandomPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationManager",
                "org.apache.commons.math3.util"
            ],
            [
                "CompositeFormat",
                "org.apache.commons.math3.util"
            ],
            [
                "KthSelector",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationEvent",
                "org.apache.commons.math3.util"
            ],
            [
                "TransformerMap",
                "org.apache.commons.math3.util"
            ],
            [
                "IntegerSequence",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathLiteralArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "CombinatoricsUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationListener",
                "org.apache.commons.math3.util"
            ],
            [
                "PivotingStrategyInterface",
                "org.apache.commons.math3.util"
            ],
            [
                "CentralPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64",
                "org.apache.commons.math3.util"
            ],
            [
                "DefaultTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "BigReal",
                "org.apache.commons.math3.util"
            ],
            [
                "ArithmeticUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "MedianOf3PivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "ComplexFormat",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexField",
                "org.apache.commons.math3.complex"
            ],
            [
                "RootsOfUnity",
                "org.apache.commons.math3.complex"
            ],
            [
                "Quaternion",
                "org.apache.commons.math3.complex"
            ],
            [
                "Complex",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexUtils",
                "org.apache.commons.math3.complex"
            ],
            [
                "DifferentiableMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractScalarDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "ConjugateGradientFormula",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "BaseMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "AbstractLinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseAbstractUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Target",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NonSymmetricMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "AnyMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularValueDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "EigenDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldLUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixUtils",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "TriDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixDimensionMismatchException",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "DecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "LUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "ConjugateGradient",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSelfAdjointOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BiDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "CholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldDecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "PreconditionedIterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "QRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "SymmLQ",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "IllConditionedOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultIterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DiagonalMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "HessenbergTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RectangularCholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "JacobiPreconditioner",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealLinearOperator",
                "org.apache.commons.math3.linear"
            ],
            [
                "RRQRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SchurTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "CauchyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LaplaceDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "HypergeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ChiSquaredDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TriangularDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalMixtureExpectationMaximization",
                "org.apache.commons.math3.distribution.fitting"
            ],
            [
                "BetaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "RealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "SaddlePointExpansion",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GumbelDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ZipfDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "BinomialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "IntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "WeibullDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NakagamiDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ConstantRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ExponentialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PascalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ParetoDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "FDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PoissonDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "KolmogorovSmirnovDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GammaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogisticDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LevyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxIter",
                "org.apache.commons.math3.optim"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraintSet",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "PivotSelectionRule",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SolutionCallback",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "NonNegativeConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "AbstractOptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optim"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseMultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "MultiStartUnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateObjectiveFunction",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SearchInterval",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxEval",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optim"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GradientMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "LineSearch",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunction",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunctionGradient",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ModelFunction",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "ModelFunctionJacobian",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "JacobianMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Target",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultiStartMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Erf",
                "org.apache.commons.math3.special"
            ],
            [
                "BesselJ",
                "org.apache.commons.math3.special"
            ],
            [
                "Gamma",
                "org.apache.commons.math3.special"
            ],
            [
                "Beta",
                "org.apache.commons.math3.special"
            ],
            [
                "FieldODEState",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldODEStateAndDerivative",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ODEIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterConfiguration",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputFieldModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderConverter",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ExpandableStatefulODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "Parameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "JacobianMatrices",
                "org.apache.commons.math3.ode"
            ],
            [
                "StepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "DummyStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractFieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldFixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerMode",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerBounds",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "NordsieckStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "RungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldButcherArrayProvider",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckFieldTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldSecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MainStateJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldEquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldExpandableODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterizedWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractParameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "UnknownParameterException",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "EquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "Transformer",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "Action",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventFilter",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FilterType",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "ParameterizedODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "NaNStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "NaturalRanking",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "TiesStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "RankingAlgorithm",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "StatUtils",
                "org.apache.commons.math3.stat"
            ],
            [
                "IntervalUtils",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "AgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "WilsonScoreInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "NormalApproximationInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "BinomialConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "StorelessCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "StorelessBivariateCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "KendallsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "Covariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "PearsonsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "SpearmansCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanIntegerPoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanDoublePoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "TestUtils",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "TTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "GTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AlternativeHypothesis",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "MannWhitneyUTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "WilcoxonSignedRankTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "OneWayAnova",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "ChiSquareTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "BinomialTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "KolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AbstractUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "DescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "MultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SecondMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Mean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FourthMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Variance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Kurtosis",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "GeometricMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StandardDeviation",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialCovariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "ThirdMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "SemiVariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FirstMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Skewness",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StatisticalSummaryValues",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalMultivariateSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "AggregateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "WeightedEvaluation",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "UnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "Percentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Max",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "PSquarePercentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Min",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Median",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "SynchronizedDescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedMultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SumOfSquares",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Product",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Sum",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "SumOfLogs",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "AbstractStorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SimpleRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "UpdatingMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "AbstractMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "GLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "ModelSpecificationException",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "RegressionResults",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MillerUpdatingRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "OLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "Frequency",
                "org.apache.commons.math3.stat"
            ],
            [
                "ChebyshevDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CanberraDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EuclideanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "ManhattanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EarthMoversDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "DistanceMeasure",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CentroidCluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "MultiKMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "FuzzyKMeansClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "SumOfClusterVariances",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "ClusterEvaluator",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "Clusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DoublePoint",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KohonenTrainingTask",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "KohonenUpdateAction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "QuasiSigmoidDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "ExponentialDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "NeighbourhoodSizeFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "NeighbourhoodSizeFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "MapUtils",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Network",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializerFactory",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Neuron",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializer",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "NeuronString",
                "org.apache.commons.math3.ml.neuralnet.oned"
            ],
            [
                "NeuronSquareMesh2D",
                "org.apache.commons.math3.ml.neuralnet.twod"
            ],
            [
                "SmoothedDataHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "UnifiedDistanceMatrix",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapDataVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "LocationFinder",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "HitHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "QuantizationError",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "TopographicErrorHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "SquareNeighbourhood",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "UpdateAction",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "BracketingNthOrderBrentSolverDFP",
                "org.apache.commons.math3.dfp"
            ],
            [
                "UnivariateDfpFunction",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpDec",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpMath",
                "org.apache.commons.math3.dfp"
            ],
            [
                "Dfp",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpField",
                "org.apache.commons.math3.dfp"
            ],
            [
                "GeneticAlgorithm",
                "org.apache.commons.math3.genetics"
            ],
            [
                "SelectionPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedGenerationCount",
                "org.apache.commons.math3.genetics"
            ],
            [
                "AbstractListChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OnePointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ElitisticListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Chromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OrderedCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "InvalidRepresentationException",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKey",
                "org.apache.commons.math3.genetics"
            ],
            [
                "StoppingCondition",
                "org.apache.commons.math3.genetics"
            ],
            [
                "PermutationChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ChromosomePair",
                "org.apache.commons.math3.genetics"
            ],
            [
                "TournamentSelection",
                "org.apache.commons.math3.genetics"
            ],
            [
                "NPointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "UniformCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "MutationPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedElapsedTime",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CycleCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Population",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKeyMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Fitness",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CrossoverPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Vector",
                "org.apache.commons.math3.geometry"
            ],
            [
                "VectorFormat",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Point",
                "org.apache.commons.math3.geometry"
            ],
            [
                "RotationConvention",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubPlane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3DFormat",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "OutlineExtractor",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "PolyhedronsSet",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "RotationOrder",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Rotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Euclidean3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphericalCoordinates",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "CardanEulerSingularityException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "NotARotationMatrixException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldRotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Plane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphereGenerator",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "IntervalsSet",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Interval",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "SubOrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "OrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Euclidean1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1DFormat",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "AbstractConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "AklToussaintHeuristic",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHull2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "MonotoneChain",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "Vector2DFormat",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "PolygonsSet",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "DiskGenerator",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Vector2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "NestedLoops",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Euclidean2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "ConvexHullGenerator",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ConvexHull",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ArcsSet",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "S1Point",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere1D",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Arc",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "LimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "SubLimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere2D",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SubCircle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Vertex",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Circle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "PropertiesComputer",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SphericalPolygonsSet",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Edge",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "EdgesBuilder",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "S2Point",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SupportBallGenerator",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "EnclosingBall",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "WelzlEncloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "Encloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "InsideFinder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjection",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjector",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Region",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Transform",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "NodesSet",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractRegion",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Characterization",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractSubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BSPTree",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "RegionFactory",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Side",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundarySizeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AVLTree",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "OrderedTuple",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "BSPTreeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Hyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Embedding",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryAttribute",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "SubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryBuilder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Space",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Field",
                "org.apache.commons.math3"
            ],
            [
                "ProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "MeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "KalmanFilter",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultMeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "NormalizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "GaussianRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "ISAACRandom",
                "org.apache.commons.math3.random"
            ],
            [
                "CorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937a",
                "org.apache.commons.math3.random"
            ],
            [
                "Well1024a",
                "org.apache.commons.math3.random"
            ],
            [
                "UniformRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497a",
                "org.apache.commons.math3.random"
            ],
            [
                "BitsStreamGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "SynchronizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "UncorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937c",
                "org.apache.commons.math3.random"
            ],
            [
                "ValueServer",
                "org.apache.commons.math3.random"
            ],
            [
                "HaltonSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497b",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomData",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well512a",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "JDKRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "StableRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomAdaptor",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGeneratorFactory",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractWell",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataImpl",
                "org.apache.commons.math3.random"
            ],
            [
                "EmpiricalDistribution",
                "org.apache.commons.math3.random"
            ],
            [
                "SobolSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "MersenneTwister",
                "org.apache.commons.math3.random"
            ],
            [
                "UnitSphereRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "FieldElement",
                "org.apache.commons.math3"
            ],
            [
                "BigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "Fraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "AbstractFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionConversionException",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperBigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "NotFiniteNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoBracketingException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathArithmeticException",
                "org.apache.commons.math3.exception"
            ],
            [
                "InsufficientDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyEvaluationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ExceptionContextProvider",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ExceptionContext",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ArgUtils",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "DummyLocalizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "Localizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "LocalizedFormats",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "NotANumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MultiDimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "OutOfRangeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyIterationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NullArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooLargeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalStateException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathUnsupportedOperationException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotStrictlyPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NonMonotonicSequenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ZeroException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "DimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathRuntimeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathParseException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MaxCountExceededException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooSmallException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ConvergenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathInternalError",
                "org.apache.commons.math3.exception"
            ],
            [
                "DftNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "RealTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastSineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "DctNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastFourierTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformType",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastCosineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformUtils",
                "org.apache.commons.math3.transform"
            ],
            [
                "DstNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastHadamardTransformer",
                "org.apache.commons.math3.transform"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "isPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Primality test: tells if the argument is a (provable) prime or not.\n * <p>\n * It uses the Miller-Rabin probabilistic test in such a way that a result is guaranteed:\n * it uses the firsts prime numbers as successive base (see Handbook of applied cryptography\n * by Menezes, table 4.1).\n *\n * @param n number to test.\n * @return true if n is prime. (All numbers &lt; 2 return false).\n */\npublic static boolean isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int p : SmallPrimes.PRIMES) {\n        if (0 == (n % p)) {\n            return n == p;\n        }\n    }\n    return SmallPrimes.millerRabinPrimeTest(n);\n}"
            ],
            [
                "nextPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Return the smallest prime greater than or equal to n.\n *\n * @param n a positive number.\n * @return the smallest prime greater than or equal to n.\n * @throws MathIllegalArgumentException if n &lt; 0.\n */\npublic static int nextPrime(int n) {\n    if (n < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL, n, 0);\n    }\n    if (n == 2) {\n        return 2;\n    }\n    //make sure n is odd\n    n |= 1;\n    if (n == 1) {\n        return 2;\n    }\n    if (isPrime(n)) {\n        return n;\n    }\n    // prepare entry in the +2, +4 loop:\n    // n should not be a multiple of 3\n    final int rem = n % 3;\n    if (0 == rem) {\n        // if n % 3 == 0\n        // n % 3 == 2\n        n += 2;\n    } else if (1 == rem) {\n        // if n % 3 == 1\n        // if (isPrime(n)) return n;\n        // n % 3 == 2\n        n += 4;\n    }\n    while (true) {\n        // this loop skips all multiple of 3\n        if (isPrime(n)) {\n            return n;\n        }\n        // n % 3 == 1\n        n += 2;\n        if (isPrime(n)) {\n            return n;\n        }\n        // n % 3 == 2\n        n += 4;\n    }\n}"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Prime factors decomposition\n *\n * @param n number to factorize: must be &ge; 2\n * @return list of prime factors of n\n * @throws MathIllegalArgumentException if n &lt; 2.\n */\npublic static List<Integer> primeFactors(int n) {\n    if (n < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL, n, 2);\n    }\n    // slower than trial div unless we do an awful lot of computation\n    // (then it finally gets JIT-compiled efficiently\n    // List<Integer> out = PollardRho.primeFactors(n);\n    return SmallPrimes.trialDivision(n);\n}"
            ],
            [
                "smallTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Extract small factors.\n * @param n the number to factor, must be &gt; 0.\n * @param factors the list where to add the factors.\n * @return the part of n which remains to be factored, it is either a prime or a semi-prime\n */\npublic static int smallTrialDivision(int n, final List<Integer> factors) {\n    for (int p : PRIMES) {\n        while (0 == n % p) {\n            n /= p;\n            factors.add(p);\n        }\n    }\n    return n;\n}"
            ],
            [
                "boundedTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Extract factors in the range <code>PRIME_LAST+2</code> to <code>maxFactors</code>.\n * @param n the number to factorize, must be >= PRIME_LAST+2 and must not contain any factor below PRIME_LAST+2\n * @param maxFactor the upper bound of trial division: if it is reached, the method gives up and returns n.\n * @param factors the list where to add the factors.\n * @return  n or 1 if factorization is completed.\n */\npublic static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors) {\n    int f = PRIMES_LAST + 2;\n    // no check is done about n >= f\n    while (f <= maxFactor) {\n        if (0 == n % f) {\n            n /= f;\n            factors.add(f);\n            break;\n        }\n        f += 4;\n        if (0 == n % f) {\n            n /= f;\n            factors.add(f);\n            break;\n        }\n        f += 2;\n    }\n    if (n != 1) {\n        factors.add(n);\n    }\n    return n;\n}"
            ],
            [
                "trialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Factorization by trial division.\n * @param n the number to factor\n * @return the list of prime factors of n\n */\npublic static List<Integer> trialDivision(int n) {\n    final List<Integer> factors = new ArrayList<Integer>(32);\n    n = smallTrialDivision(n, factors);\n    if (1 == n) {\n        return factors;\n    }\n    // here we are sure that n is either a prime or a semi prime\n    final int bound = (int) FastMath.sqrt(n);\n    boundedTrialDivision(n, bound, factors);\n    return factors;\n}"
            ],
            [
                "millerRabinPrimeTest",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Miller-Rabin probabilistic primality test for int type, used in such a way that a result is always guaranteed.\n * <p>\n * It uses the prime numbers as successive base therefore it is guaranteed to be always correct.\n * (see Handbook of applied cryptography by Menezes, table 4.1)\n *\n * @param n number to test: an odd integer &ge; 3\n * @return true if n is prime. false if n is definitely composite.\n */\npublic static boolean millerRabinPrimeTest(final int n) {\n    final int nMinus1 = n - 1;\n    final int s = Integer.numberOfTrailingZeros(nMinus1);\n    final int r = nMinus1 >> s;\n    //r must be odd, it is not checked here\n    int t = 1;\n    if (n >= 2047) {\n        t = 2;\n    }\n    if (n >= 1373653) {\n        t = 3;\n    }\n    if (n >= 25326001) {\n        t = 4;\n    }\n    // works up to 3.2 billion, int range stops at 2.7 so we are safe :-)\n    BigInteger br = BigInteger.valueOf(r);\n    BigInteger bn = BigInteger.valueOf(n);\n    for (int i = 0; i < t; i++) {\n        BigInteger a = BigInteger.valueOf(SmallPrimes.PRIMES[i]);\n        BigInteger bPow = a.modPow(br, bn);\n        int y = bPow.intValue();\n        if ((1 != y) && (y != nMinus1)) {\n            int j = 1;\n            while ((j <= s - 1) && (nMinus1 != y)) {\n                long square = ((long) y) * y;\n                y = (int) (square % n);\n                if (1 == y) {\n                    return false;\n                }\n                // definitely composite\n                j++;\n            }\n            if (nMinus1 != y) {\n                return false;\n            }\n            // definitely composite\n        }\n    }\n    // definitely prime\n    return true;\n}"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Factorization using Pollard's rho algorithm.\n * @param n number to factors, must be &gt; 0\n * @return the list of prime factors of n.\n */\npublic static List<Integer> primeFactors(int n) {\n    final List<Integer> factors = new ArrayList<Integer>();\n    n = SmallPrimes.smallTrialDivision(n, factors);\n    if (1 == n) {\n        return factors;\n    }\n    if (SmallPrimes.millerRabinPrimeTest(n)) {\n        factors.add(n);\n        return factors;\n    }\n    int divisor = rhoBrent(n);\n    factors.add(divisor);\n    factors.add(n / divisor);\n    return factors;\n}"
            ],
            [
                "rhoBrent",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Implementation of the Pollard's rho factorization algorithm.\n * <p>\n * This implementation follows the paper \"An improved Monte Carlo factorization algorithm\"\n * by Richard P. Brent. This avoids the triple computation of f(x) typically found in Pollard's\n * rho implementations. It also batches several gcd computation into 1.\n * <p>\n * The backtracking is not implemented as we deal only with semi-primes.\n *\n * @param n number to factor, must be semi-prime.\n * @return a prime factor of n.\n */\nstatic int rhoBrent(final int n) {\n    final int x0 = 2;\n    final int m = 25;\n    int cst = SmallPrimes.PRIMES_LAST;\n    int y = x0;\n    int r = 1;\n    do {\n        int x = y;\n        for (int i = 0; i < r; i++) {\n            final long y2 = ((long) y) * y;\n            y = (int) ((y2 + cst) % n);\n        }\n        int k = 0;\n        do {\n            final int bound = FastMath.min(m, r - k);\n            int q = 1;\n            for (int i = -3; i < bound; i++) {\n                //start at -3 to ensure we enter this loop at least 3 times\n                final long y2 = ((long) y) * y;\n                y = (int) ((y2 + cst) % n);\n                final long divisor = FastMath.abs(x - y);\n                if (0 == divisor) {\n                    cst += SmallPrimes.PRIMES_LAST;\n                    k = -m;\n                    y = x0;\n                    r = 1;\n                    break;\n                }\n                final long prod = divisor * q;\n                q = (int) (prod % n);\n                if (0 == q) {\n                    return gcdPositive(FastMath.abs((int) divisor), n);\n                }\n            }\n            final int out = gcdPositive(FastMath.abs(q), n);\n            if (1 != out) {\n                return out;\n            }\n            k += m;\n        } while (k < r);\n        r = 2 * r;\n    } while (true);\n}"
            ],
            [
                "gcdPositive",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Gcd between two positive numbers.\n * <p>\n * Gets the greatest common divisor of two numbers, using the \"binary gcd\" method,\n * which avoids division and modulo operations. See Knuth 4.5.2 algorithm B.\n * This algorithm is due to Josef Stein (1961).\n * </p>\n * Special cases:\n * <ul>\n * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and {@code gcd(x, 0)} is the value of {@code x}.</li>\n * <li>The invocation {@code gcd(0, 0)} is the only one which returns {@code 0}.</li>\n * </ul>\n *\n * @param a first number, must be &ge; 0\n * @param b second number, must be &ge; 0\n * @return gcd(a,b)\n */\nstatic int gcdPositive(int a, int b) {\n    // both a and b must be positive, it is not checked here\n    // gdc(a,0) = a\n    if (a == 0) {\n        return b;\n    } else if (b == 0) {\n        return a;\n    }\n    // make a and b odd, keep in mind the common power of twos\n    final int aTwos = Integer.numberOfTrailingZeros(a);\n    a >>= aTwos;\n    final int bTwos = Integer.numberOfTrailingZeros(b);\n    b >>= bTwos;\n    final int shift = FastMath.min(aTwos, bTwos);\n    // a and b >0\n    // if a > b then gdc(a,b) = gcd(a-b,b)\n    // if a < b then gcd(a,b) = gcd(b-a,a)\n    // so next a is the absolute difference and next b is the minimum of current values\n    while (a != b) {\n        final int delta = a - b;\n        b = FastMath.min(a, b);\n        a = FastMath.abs(delta);\n        // for speed optimization:\n        // remove any power of two in a as b is guaranteed to be odd throughout all iterations\n        a >>= Integer.numberOfTrailingZeros(a);\n    }\n    // gcd(a,a) = a, just \"add\" the common power of twos\n    return a << shift;\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "GaussianCurveFitter",
                "/**\n * Creates a default curve fitter.\n * The initial guess for the parameters will be {@link ParameterGuesser}\n * computed automatically, and the maximum number of iterations of the\n * optimization algorithm is set to {@link Integer#MAX_VALUE}.\n *\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static GaussianCurveFitter create() {\n    return new GaussianCurveFitter(null, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "SimpleCurveFitter",
                "/**\n * Creates a curve fitter.\n * The maximum number of iterations of the optimization algorithm is set\n * to {@link Integer#MAX_VALUE}.\n *\n * @param f Function to fit.\n * @param start Initial guess for the parameters.  Cannot be {@code null}.\n * Its length must be consistent with the number of parameters of the\n * function to fit.\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static SimpleCurveFitter create(ParametricUnivariateFunction f, double[] start) {\n    return new SimpleCurveFitter(f, start, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements. There will be no weights applied (unit weights).\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @param lazyEvaluation Whether the call to {@link Evaluation#evaluate(RealVector)}\n * will defer the evaluation until access to the value is requested.\n * @param paramValidator Model parameters validator.\n * @return the specified General Least Squares problem.\n *\n * @since 3.4\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations, final boolean lazyEvaluation, final ParameterValidator paramValidator) {\n    final LeastSquaresProblem p = new LocalLeastSquaresProblem(model, observed, start, checker, maxEvaluations, maxIterations, lazyEvaluation, paramValidator);\n    if (weight != null) {\n        return weightMatrix(p, weight);\n    } else {\n        return p;\n    }\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements. There will be no weights applied (unit weights).\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return create(model, observed, start, null, checker, maxEvaluations, maxIterations, false, null);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements.\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return weightMatrix(create(model, observed, start, checker, maxEvaluations, maxIterations), weight);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements.\n * <p>\n * This factory method is provided for continuity with previous interfaces. Newer\n * applications should use {@link #create(MultivariateJacobianFunction, RealVector,\n * RealVector, ConvergenceChecker, int, int)}, or {@link #create(MultivariateJacobianFunction,\n * RealVector, RealVector, RealMatrix, ConvergenceChecker, int, int)}.\n *\n * @param model          the model function. Produces the computed values.\n * @param jacobian       the jacobian of the model with respect to the parameters\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateVectorFunction model, final MultivariateMatrixFunction jacobian, final double[] observed, final double[] start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return create(model(model, jacobian), new ArrayRealVector(observed, false), new ArrayRealVector(start, false), weight, checker, maxEvaluations, maxIterations);\n}"
            ],
            [
                "weightMatrix",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Apply a dense weight matrix to the {@link LeastSquaresProblem}.\n *\n * @param problem the unweighted problem\n * @param weights the matrix of weights\n * @return a new {@link LeastSquaresProblem} with the weights applied. The original\n *         {@code problem} is not modified.\n */\npublic static LeastSquaresProblem weightMatrix(final LeastSquaresProblem problem, final RealMatrix weights) {\n    final RealMatrix weightSquareRoot = squareRoot(weights);\n    return new LeastSquaresAdapter(problem) {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Evaluation evaluate(final RealVector point) {\n            return new DenseWeightedEvaluation(super.evaluate(point), weightSquareRoot);\n        }\n    };\n}"
            ],
            [
                "weightDiagonal",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Apply a diagonal weight matrix to the {@link LeastSquaresProblem}.\n *\n * @param problem the unweighted problem\n * @param weights the diagonal of the weight matrix\n * @return a new {@link LeastSquaresProblem} with the weights applied. The original\n *         {@code problem} is not modified.\n */\npublic static LeastSquaresProblem weightDiagonal(final LeastSquaresProblem problem, final RealVector weights) {\n    // TODO more efficient implementation\n    return weightMatrix(problem, new DiagonalMatrix(weights.toArray()));\n}"
            ],
            [
                "countEvaluations",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Count the evaluations of a particular problem. The {@code counter} will be\n * incremented every time {@link LeastSquaresProblem#evaluate(RealVector)} is called on\n * the <em>returned</em> problem.\n *\n * @param problem the problem to track.\n * @param counter the counter to increment.\n * @return a least squares problem that tracks evaluations\n */\npublic static LeastSquaresProblem countEvaluations(final LeastSquaresProblem problem, final Incrementor counter) {\n    return new LeastSquaresAdapter(problem) {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Evaluation evaluate(final RealVector point) {\n            counter.incrementCount();\n            return super.evaluate(point);\n        }\n    };\n}"
            ],
            [
                "evaluationChecker",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * View a convergence checker specified for a {@link PointVectorValuePair} as one\n * specified for an {@link Evaluation}.\n *\n * @param checker the convergence checker to adapt.\n * @return a convergence checker that delegates to {@code checker}.\n */\npublic static ConvergenceChecker<Evaluation> evaluationChecker(final ConvergenceChecker<PointVectorValuePair> checker) {\n    return new ConvergenceChecker<Evaluation>() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean converged(final int iteration, final Evaluation previous, final Evaluation current) {\n            return checker.converged(iteration, new PointVectorValuePair(previous.getPoint().toArray(), previous.getResiduals().toArray(), false), new PointVectorValuePair(current.getPoint().toArray(), current.getResiduals().toArray(), false));\n        }\n    };\n}"
            ],
            [
                "model",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Combine a {@link MultivariateVectorFunction} with a {@link\n * MultivariateMatrixFunction} to produce a {@link MultivariateJacobianFunction}.\n *\n * @param value    the vector value function\n * @param jacobian the Jacobian function\n * @return a function that computes both at the same time\n */\npublic static MultivariateJacobianFunction model(final MultivariateVectorFunction value, final MultivariateMatrixFunction jacobian) {\n    return new LocalValueAndJacobianFunction(value, jacobian);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "HarmonicCurveFitter",
                "/**\n * Creates a default curve fitter.\n * The initial guess for the parameters will be {@link ParameterGuesser}\n * computed automatically, and the maximum number of iterations of the\n * optimization algorithm is set to {@link Integer#MAX_VALUE}.\n *\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static HarmonicCurveFitter create() {\n    return new HarmonicCurveFitter(null, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "PolynomialCurveFitter",
                "/**\n * Creates a default curve fitter.\n * Zero will be used as initial guess for the coefficients, and the maximum\n * number of iterations of the optimization algorithm is set to\n * {@link Integer#MAX_VALUE}.\n *\n * @param degree Degree of the polynomial to be fitted.\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static PolynomialCurveFitter create(int degree) {\n    return new PolynomialCurveFitter(new double[degree + 1], Integer.MAX_VALUE);\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n */\npublic static UnivariateFunction compose(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = x;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction compose(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = t;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public DerivativeStructure value(final DerivativeStructure t) {\n            DerivativeStructure r = t;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n * @deprecated as of 3.1 replaced by {@link #compose(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = x;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double p = 1;\n                    double r = x;\n                    for (int i = f.length - 1; i >= 0; i--) {\n                        p *= f[i].derivative().value(r);\n                        r = f[i].value(r);\n                    }\n                    return p;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n */\npublic static UnivariateFunction add(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(x);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction add(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(t);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         * @throws DimensionMismatchException if functions are not consistent with each other\n         */\n        public DerivativeStructure value(final DerivativeStructure t) throws DimensionMismatchException {\n            DerivativeStructure r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r = r.add(f[i].value(t));\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n * @deprecated as of 3.1 replaced by {@link #add(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(x);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double r = f[0].derivative().value(x);\n                    for (int i = 1; i < f.length; i++) {\n                        r += f[i].derivative().value(x);\n                    }\n                    return r;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n */\npublic static UnivariateFunction multiply(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(x);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction multiply(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(t);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public DerivativeStructure value(final DerivativeStructure t) {\n            DerivativeStructure r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r = r.multiply(f[i].value(t));\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n * @deprecated as of 3.1 replaced by {@link #multiply(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(x);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double sum = 0;\n                    for (int i = 0; i < f.length; i++) {\n                        double prod = f[i].derivative().value(x);\n                        for (int j = 0; j < f.length; j++) {\n                            if (i != j) {\n                                prod *= f[j].value(x);\n                            }\n                        }\n                        sum += prod;\n                    }\n                    return sum;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "combine",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns the univariate function\n * {@code h(x) = combiner(f(x), g(x)).}\n *\n * @param combiner Combiner function.\n * @param f Function.\n * @param g Function.\n * @return the composite function.\n */\npublic static UnivariateFunction combine(final BivariateFunction combiner, final UnivariateFunction f, final UnivariateFunction g) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return combiner.value(f.value(x), g.value(x));\n        }\n    };\n}"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns a MultivariateFunction h(x[]) defined by <pre> <code>\n * h(x[]) = combiner(...combiner(combiner(initialValue,f(x[0])),f(x[1]))...),f(x[x.length-1]))\n * </code></pre>\n *\n * @param combiner Combiner function.\n * @param f Function.\n * @param initialValue Initial value.\n * @return a collector function.\n */\npublic static MultivariateFunction collector(final BivariateFunction combiner, final UnivariateFunction f, final double initialValue) {\n    return new MultivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double[] point) {\n            double result = combiner.value(initialValue, f.value(point[0]));\n            for (int i = 1; i < point.length; i++) {\n                result = combiner.value(result, f.value(point[i]));\n            }\n            return result;\n        }\n    };\n}"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns a MultivariateFunction h(x[]) defined by <pre> <code>\n * h(x[]) = combiner(...combiner(combiner(initialValue,x[0]),x[1])...),x[x.length-1])\n * </code></pre>\n *\n * @param combiner Combiner function.\n * @param initialValue Initial value.\n * @return a collector function.\n */\npublic static MultivariateFunction collector(final BivariateFunction combiner, final double initialValue) {\n    return collector(combiner, new Identity(), initialValue);\n}"
            ],
            [
                "fix1stArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Creates a unary function by fixing the first argument of a binary function.\n *\n * @param f Binary function.\n * @param fixed value to which the first argument of {@code f} is set.\n * @return the unary function h(x) = f(fixed, x)\n */\npublic static UnivariateFunction fix1stArgument(final BivariateFunction f, final double fixed) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return f.value(fixed, x);\n        }\n    };\n}"
            ],
            [
                "fix2ndArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Creates a unary function by fixing the second argument of a binary function.\n *\n * @param f Binary function.\n * @param fixed value to which the second argument of {@code f} is set.\n * @return the unary function h(x) = f(x, fixed)\n */\npublic static UnivariateFunction fix2ndArgument(final BivariateFunction f, final double fixed) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return f.value(x, fixed);\n        }\n    };\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Samples the specified univariate real function on the specified interval.\n * <p>\n * The interval is divided equally into {@code n} sections and sample points\n * are taken from {@code min} to {@code max - (max - min) / n}; therefore\n * {@code f} is not sampled at the upper bound {@code max}.</p>\n *\n * @param f Function to be sampled\n * @param min Lower bound of the interval (included).\n * @param max Upper bound of the interval (excluded).\n * @param n Number of sample points.\n * @return the array of samples.\n * @throws NumberIsTooLargeException if the lower bound {@code min} is\n * greater than, or equal to the upper bound {@code max}.\n * @throws NotStrictlyPositiveException if the number of sample points\n * {@code n} is negative.\n */\npublic static double[] sample(UnivariateFunction f, double min, double max, int n) throws NumberIsTooLargeException, NotStrictlyPositiveException {\n    if (n <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES, Integer.valueOf(n));\n    }\n    if (min >= max) {\n        throw new NumberIsTooLargeException(min, max, false);\n    }\n    final double[] s = new double[n];\n    final double h = (max - min) / n;\n    for (int i = 0; i < n; i++) {\n        s[i] = f.value(min + i * h);\n    }\n    return s;\n}"
            ],
            [
                "toDifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link UnivariateDifferentiableFunction} into a {@link DifferentiableUnivariateFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableUnivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction toDifferentiableUnivariateFunction(final UnivariateDifferentiableFunction f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(final double x) {\n                    return f.value(new DerivativeStructure(1, 1, 0, x)).getPartialDerivative(1);\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toUnivariateDifferential",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableUnivariateFunction} into a {@link UnivariateDifferentiableFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} up to order one.\n * If the function is called with higher order, a {@link NumberIsTooLargeException} is thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableUnivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static UnivariateDifferentiableFunction toUnivariateDifferential(final DifferentiableUnivariateFunction f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is greater than 1\n         */\n        public DerivativeStructure value(final DerivativeStructure t) throws NumberIsTooLargeException {\n            switch(t.getOrder()) {\n                case 0:\n                    return new DerivativeStructure(t.getFreeParameters(), 0, f.value(t.getValue()));\n                case 1:\n                    {\n                        final int parameters = t.getFreeParameters();\n                        final double[] derivatives = new double[parameters + 1];\n                        derivatives[0] = f.value(t.getValue());\n                        final double fPrime = f.derivative().value(t.getValue());\n                        int[] orders = new int[parameters];\n                        for (int i = 0; i < parameters; ++i) {\n                            orders[i] = 1;\n                            derivatives[i + 1] = fPrime * t.getPartialDerivative(orders);\n                            orders[i] = 0;\n                        }\n                        return new DerivativeStructure(parameters, 1, derivatives);\n                    }\n                default:\n                    throw new NumberIsTooLargeException(t.getOrder(), 1, true);\n            }\n        }\n    };\n}"
            ],
            [
                "toDifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link MultivariateDifferentiableFunction} into a {@link DifferentiableMultivariateFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f) {\n    return new DifferentiableMultivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateFunction partialDerivative(final int k) {\n            return new MultivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        if (i == k) {\n                            dsX[i] = new DerivativeStructure(1, 1, 0, x[i]);\n                        } else {\n                            dsX[i] = new DerivativeStructure(1, 1, x[i]);\n                        }\n                    }\n                    final DerivativeStructure y = f.value(dsX);\n                    // extract partial derivative\n                    return y.getPartialDerivative(1);\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateVectorFunction gradient() {\n            return new MultivariateVectorFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double[] value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        dsX[i] = new DerivativeStructure(n, 1, i, x[i]);\n                    }\n                    final DerivativeStructure y = f.value(dsX);\n                    // extract gradient\n                    final double[] gradient = new double[n];\n                    final int[] orders = new int[n];\n                    for (int i = 0; i < n; ++i) {\n                        orders[i] = 1;\n                        gradient[i] = y.getPartialDerivative(orders);\n                        orders[i] = 0;\n                    }\n                    return gradient;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toMultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableMultivariateFunction} into a {@link MultivariateDifferentiableFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} elements\n * that all have the same number of free parameters and order, and with order at most 1.\n * If the function is called with inconsistent numbers of free parameters or higher order, a\n * {@link DimensionMismatchException} or a {@link NumberIsTooLargeException} will be thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f) {\n    return new MultivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is higher than 1\n         * @exception DimensionMismatchException if numbers of free parameters are inconsistent\n         */\n        public DerivativeStructure value(final DerivativeStructure[] t) throws DimensionMismatchException, NumberIsTooLargeException {\n            // check parameters and orders limits\n            final int parameters = t[0].getFreeParameters();\n            final int order = t[0].getOrder();\n            final int n = t.length;\n            if (order > 1) {\n                throw new NumberIsTooLargeException(order, 1, true);\n            }\n            // check all elements in the array are consistent\n            for (int i = 0; i < n; ++i) {\n                if (t[i].getFreeParameters() != parameters) {\n                    throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n                }\n                if (t[i].getOrder() != order) {\n                    throw new DimensionMismatchException(t[i].getOrder(), order);\n                }\n            }\n            // delegate computation to underlying function\n            final double[] point = new double[n];\n            for (int i = 0; i < n; ++i) {\n                point[i] = t[i].getValue();\n            }\n            final double value = f.value(point);\n            final double[] gradient = f.gradient().value(point);\n            // merge value and gradient into one DerivativeStructure\n            final double[] derivatives = new double[parameters + 1];\n            derivatives[0] = value;\n            final int[] orders = new int[parameters];\n            for (int i = 0; i < parameters; ++i) {\n                orders[i] = 1;\n                for (int j = 0; j < n; ++j) {\n                    derivatives[i + 1] += gradient[j] * t[j].getPartialDerivative(orders);\n                }\n                orders[i] = 0;\n            }\n            return new DerivativeStructure(parameters, order, derivatives);\n        }\n    };\n}"
            ],
            [
                "toDifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link MultivariateDifferentiableVectorFunction} into a {@link DifferentiableMultivariateVectorFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateVectorFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f) {\n    return new DifferentiableMultivariateVectorFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double[] value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateMatrixFunction jacobian() {\n            return new MultivariateMatrixFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double[][] value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        dsX[i] = new DerivativeStructure(n, 1, i, x[i]);\n                    }\n                    final DerivativeStructure[] y = f.value(dsX);\n                    // extract Jacobian\n                    final double[][] jacobian = new double[y.length][n];\n                    final int[] orders = new int[n];\n                    for (int i = 0; i < y.length; ++i) {\n                        for (int j = 0; j < n; ++j) {\n                            orders[j] = 1;\n                            jacobian[i][j] = y[i].getPartialDerivative(orders);\n                            orders[j] = 0;\n                        }\n                    }\n                    return jacobian;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toMultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableMultivariateVectorFunction} into a {@link MultivariateDifferentiableVectorFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} elements\n * that all have the same number of free parameters and order, and with order at most 1.\n * If the function is called with inconsistent numbers of free parameters or higher order, a\n * {@link DimensionMismatchException} or a {@link NumberIsTooLargeException} will be thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f) {\n    return new MultivariateDifferentiableVectorFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double[] value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is higher than 1\n         * @exception DimensionMismatchException if numbers of free parameters are inconsistent\n         */\n        public DerivativeStructure[] value(final DerivativeStructure[] t) throws DimensionMismatchException, NumberIsTooLargeException {\n            // check parameters and orders limits\n            final int parameters = t[0].getFreeParameters();\n            final int order = t[0].getOrder();\n            final int n = t.length;\n            if (order > 1) {\n                throw new NumberIsTooLargeException(order, 1, true);\n            }\n            // check all elements in the array are consistent\n            for (int i = 0; i < n; ++i) {\n                if (t[i].getFreeParameters() != parameters) {\n                    throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n                }\n                if (t[i].getOrder() != order) {\n                    throw new DimensionMismatchException(t[i].getOrder(), order);\n                }\n            }\n            // delegate computation to underlying function\n            final double[] point = new double[n];\n            for (int i = 0; i < n; ++i) {\n                point[i] = t[i].getValue();\n            }\n            final double[] value = f.value(point);\n            final double[][] jacobian = f.jacobian().value(point);\n            // merge value and Jacobian into a DerivativeStructure array\n            final DerivativeStructure[] merged = new DerivativeStructure[value.length];\n            for (int k = 0; k < merged.length; ++k) {\n                final double[] derivatives = new double[parameters + 1];\n                derivatives[0] = value[k];\n                final int[] orders = new int[parameters];\n                for (int i = 0; i < parameters; ++i) {\n                    orders[i] = 1;\n                    for (int j = 0; j < n; ++j) {\n                        derivatives[i + 1] += jacobian[k][j] * t[j].getPartialDerivative(orders);\n                    }\n                    orders[i] = 0;\n                }\n                merged[k] = new DerivativeStructure(parameters, order, derivatives);\n            }\n            return merged;\n        }\n    };\n}"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Convenience method to find a zero of a univariate real function.  A default\n * solver is used.\n *\n * @param function Function.\n * @param x0 Lower bound for the interval.\n * @param x1 Upper bound for the interval.\n * @return a value where the function is zero.\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double solve(UnivariateFunction function, double x0, double x1) throws NullArgumentException, NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final UnivariateSolver solver = new BrentSolver();\n    return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n}"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Convenience method to find a zero of a univariate real function.  A default\n * solver is used.\n *\n * @param function Function.\n * @param x0 Lower bound for the interval.\n * @param x1 Upper bound for the interval.\n * @param absoluteAccuracy Accuracy to be used by the solver.\n * @return a value where the function is zero.\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double solve(UnivariateFunction function, double x0, double x1, double absoluteAccuracy) throws NullArgumentException, NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final UnivariateSolver solver = new BrentSolver(absoluteAccuracy);\n    return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n}"
            ],
            [
                "forceSide",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Force a root found by a non-bracketing solver to lie on a specified side,\n * as if the solver were a bracketing one.\n *\n * @param maxEval maximal number of new evaluations of the function\n * (evaluations already done for finding the root should have already been subtracted\n * from this number)\n * @param f function to solve\n * @param bracketing bracketing solver to use for shifting the root\n * @param baseRoot original root found by a previous non-bracketing solver\n * @param min minimal bound of the search interval\n * @param max maximal bound of the search interval\n * @param allowedSolution the kind of solutions that the root-finding algorithm may\n * accept as solutions.\n * @return a root approximation, on the specified side of the exact root\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n */\npublic static double forceSide(final int maxEval, final UnivariateFunction f, final BracketedUnivariateSolver<UnivariateFunction> bracketing, final double baseRoot, final double min, final double max, final AllowedSolution allowedSolution) throws NoBracketingException {\n    if (allowedSolution == AllowedSolution.ANY_SIDE) {\n        // no further bracketing required\n        return baseRoot;\n    }\n    // find a very small interval bracketing the root\n    final double step = FastMath.max(bracketing.getAbsoluteAccuracy(), FastMath.abs(baseRoot * bracketing.getRelativeAccuracy()));\n    double xLo = FastMath.max(min, baseRoot - step);\n    double fLo = f.value(xLo);\n    double xHi = FastMath.min(max, baseRoot + step);\n    double fHi = f.value(xHi);\n    int remainingEval = maxEval - 2;\n    while (remainingEval > 0) {\n        if ((fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0)) {\n            // compute the root on the selected side\n            return bracketing.solve(remainingEval, f, xLo, xHi, baseRoot, allowedSolution);\n        }\n        // try increasing the interval\n        boolean changeLo = false;\n        boolean changeHi = false;\n        if (fLo < fHi) {\n            // increasing function\n            if (fLo >= 0) {\n                changeLo = true;\n            } else {\n                changeHi = true;\n            }\n        } else if (fLo > fHi) {\n            // decreasing function\n            if (fLo <= 0) {\n                changeLo = true;\n            } else {\n                changeHi = true;\n            }\n        } else {\n            // unknown variation\n            changeLo = true;\n            changeHi = true;\n        }\n        // update the lower bound\n        if (changeLo) {\n            xLo = FastMath.max(min, xLo - step);\n            fLo = f.value(xLo);\n            remainingEval--;\n        }\n        // update the higher bound\n        if (changeHi) {\n            xHi = FastMath.min(max, xHi + step);\n            fHi = f.value(xHi);\n            remainingEval--;\n        }\n    }\n    throw new NoBracketingException(LocalizedFormats.FAILED_BRACKETING, xLo, xHi, fLo, fHi, maxEval - remainingEval, maxEval, baseRoot, min, max);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method simply calls {@link #bracket(UnivariateFunction, double, double, double,\n * double, double, int) bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)}\n * with {@code q} and {@code r} set to 1.0 and {@code maximumIterations} set to {@code Integer.MAX_VALUE}.\n * <p>\n * <strong>Note: </strong> this method can take {@code Integer.MAX_VALUE}\n * iterations to throw a {@code ConvergenceException.}  Unless you are\n * confident that there is a root between {@code lowerBound} and\n * {@code upperBound} near {@code initial}, it is better to use\n * {@link #bracket(UnivariateFunction, double, double, double, double,double, int)\n * bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)},\n * explicitly specifying the maximum number of iterations.</p>\n *\n * @param function Function.\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value)\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @return a two-element array holding a and b.\n * @throws NoBracketingException if a root cannot be bracketted.\n * @throws NotStrictlyPositiveException if {@code maximumIterations <= 0}.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException {\n    return bracket(function, initial, lowerBound, upperBound, 1.0, 1.0, Integer.MAX_VALUE);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method simply calls {@link #bracket(UnivariateFunction, double, double, double,\n * double, double, int) bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)}\n * with {@code q} and {@code r} set to 1.0.\n * @param function Function.\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value).\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @param maximumIterations Maximum number of iterations to perform\n * @return a two element array holding a and b.\n * @throws NoBracketingException if the algorithm fails to find a and b\n * satisfying the desired conditions.\n * @throws NotStrictlyPositiveException if {@code maximumIterations <= 0}.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException {\n    return bracket(function, initial, lowerBound, upperBound, 1.0, 1.0, maximumIterations);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method attempts to find two values a and b satisfying <ul>\n * <li> {@code lowerBound <= a < initial < b <= upperBound} </li>\n * <li> {@code f(a) * f(b) <= 0} </li>\n * </ul>\n * If {@code f} is continuous on {@code [a,b]}, this means that {@code a}\n * and {@code b} bracket a root of {@code f}.\n * <p>\n * The algorithm checks the sign of \\( f(l_k) \\) and \\( f(u_k) \\) for increasing\n * values of k, where \\( l_k = max(lower, initial - \\delta_k) \\),\n * \\( u_k = min(upper, initial + \\delta_k) \\), using recurrence\n * \\( \\delta_{k+1} = r \\delta_k + q, \\delta_0 = 0\\) and starting search with \\( k=1 \\).\n * The algorithm stops when one of the following happens: <ul>\n * <li> at least one positive and one negative value have been found --  success!</li>\n * <li> both endpoints have reached their respective limits -- NoBracketingException </li>\n * <li> {@code maximumIterations} iterations elapse -- NoBracketingException </li></ul>\n * <p>\n * If different signs are found at first iteration ({@code k=1}), then the returned\n * interval will be \\( [a, b] = [l_1, u_1] \\). If different signs are found at a later\n * iteration {@code k>1}, then the returned interval will be either\n * \\( [a, b] = [l_{k+1}, l_{k}] \\) or \\( [a, b] = [u_{k}, u_{k+1}] \\). A root solver called\n * with these parameters will therefore start with the smallest bracketing interval known\n * at this step.\n * </p>\n * <p>\n * Interval expansion rate is tuned by changing the recurrence parameters {@code r} and\n * {@code q}. When the multiplicative factor {@code r} is set to 1, the sequence is a\n * simple arithmetic sequence with linear increase. When the multiplicative factor {@code r}\n * is larger than 1, the sequence has an asymptotically exponential rate. Note than the\n * additive parameter {@code q} should never be set to zero, otherwise the interval would\n * degenerate to the single initial point for all values of {@code k}.\n * </p>\n * <p>\n * As a rule of thumb, when the location of the root is expected to be approximately known\n * within some error margin, {@code r} should be set to 1 and {@code q} should be set to the\n * order of magnitude of the error margin. When the location of the root is really a wild guess,\n * then {@code r} should be set to a value larger than 1 (typically 2 to double the interval\n * length at each iteration) and {@code q} should be set according to half the initial\n * search interval length.\n * </p>\n * <p>\n * As an example, if we consider the trivial function {@code f(x) = 1 - x} and use\n * {@code initial = 4}, {@code r = 1}, {@code q = 2}, the algorithm will compute\n * {@code f(4-2) = f(2) = -1} and {@code f(4+2) = f(6) = -5} for {@code k = 1}, then\n * {@code f(4-4) = f(0) = +1} and {@code f(4+4) = f(8) = -7} for {@code k = 2}. Then it will\n * return the interval {@code [0, 2]} as the smallest one known to be bracketing the root.\n * As shown by this example, the initial value (here {@code 4}) may lie outside of the returned\n * bracketing interval.\n * </p>\n * @param function function to check\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value).\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @param q additive offset used to compute bounds sequence (must be strictly positive)\n * @param r multiplicative factor used to compute bounds sequence\n * @param maximumIterations Maximum number of iterations to perform\n * @return a two element array holding the bracketing values.\n * @exception NoBracketingException if function cannot be bracketed in the search interval\n */\npublic static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    if (q <= 0) {\n        throw new NotStrictlyPositiveException(q);\n    }\n    if (maximumIterations <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.INVALID_MAX_ITERATIONS, maximumIterations);\n    }\n    verifySequence(lowerBound, initial, upperBound);\n    // initialize the recurrence\n    double a = initial;\n    double b = initial;\n    double fa = Double.NaN;\n    double fb = Double.NaN;\n    double delta = 0;\n    for (int numIterations = 0; (numIterations < maximumIterations) && (a > lowerBound || b < upperBound); ++numIterations) {\n        final double previousA = a;\n        final double previousFa = fa;\n        final double previousB = b;\n        final double previousFb = fb;\n        delta = r * delta + q;\n        a = FastMath.max(initial - delta, lowerBound);\n        b = FastMath.min(initial + delta, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        if (numIterations == 0) {\n            // at first iteration, we don't have a previous interval\n            // we simply compare both sides of the initial interval\n            if (fa * fb <= 0) {\n                // the first interval already brackets a root\n                return new double[] { a, b };\n            }\n        } else {\n            // we have a previous interval with constant sign and expand it,\n            // we expect sign changes to occur at boundaries\n            if (fa * previousFa <= 0) {\n                // sign change detected at near lower bound\n                return new double[] { a, previousA };\n            } else if (fb * previousFb <= 0) {\n                // sign change detected at near upper bound\n                return new double[] { previousB, b };\n            }\n        }\n    }\n    // no bracketing found\n    throw new NoBracketingException(a, b, fa, fb);\n}"
            ],
            [
                "midpoint",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Compute the midpoint of two values.\n *\n * @param a first value.\n * @param b second value.\n * @return the midpoint.\n */\npublic static double midpoint(double a, double b) {\n    return (a + b) * 0.5;\n}"
            ],
            [
                "isBracketing",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Check whether the interval bounds bracket a root. That is, if the\n * values at the endpoints are not equal to zero, then the function takes\n * opposite signs at the endpoints.\n *\n * @param function Function.\n * @param lower Lower endpoint.\n * @param upper Upper endpoint.\n * @return {@code true} if the function values have opposite signs at the\n * given points.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static boolean isBracketing(UnivariateFunction function, final double lower, final double upper) throws NullArgumentException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final double fLo = function.value(lower);\n    final double fHi = function.value(upper);\n    return (fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0);\n}"
            ],
            [
                "isSequence",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Check whether the arguments form a (strictly) increasing sequence.\n *\n * @param start First number.\n * @param mid Second number.\n * @param end Third number.\n * @return {@code true} if the arguments form an increasing sequence.\n */\npublic static boolean isSequence(final double start, final double mid, final double end) {\n    return (start < mid) && (mid < end);\n}"
            ],
            [
                "getCompiler",
                "org.apache.commons.math3.analysis.differentiation",
                "DSCompiler",
                "/**\n * Get the compiler for number of free parameters and order.\n * @param parameters number of free parameters\n * @param order derivation order\n * @return cached rules set\n * @throws NumberIsTooLargeException if order is too large\n */\npublic static DSCompiler getCompiler(int parameters, int order) throws NumberIsTooLargeException {\n    // get the cached compilers\n    final DSCompiler[][] cache = compilers.get();\n    if (cache != null && cache.length > parameters && cache[parameters].length > order && cache[parameters][order] != null) {\n        // the compiler has already been created\n        return cache[parameters][order];\n    }\n    // we need to create more compilers\n    final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);\n    final int maxOrder = FastMath.max(order, cache == null ? 0 : cache[0].length);\n    final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];\n    if (cache != null) {\n        // preserve the already created compilers\n        for (int i = 0; i < cache.length; ++i) {\n            System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);\n        }\n    }\n    // create the array in increasing diagonal order\n    for (int diag = 0; diag <= parameters + order; ++diag) {\n        for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {\n            final int p = diag - o;\n            if (newCache[p][o] == null) {\n                final DSCompiler valueCompiler = (p == 0) ? null : newCache[p - 1][o];\n                final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];\n                newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);\n            }\n        }\n    }\n    // atomically reset the cached compilers array\n    compilers.compareAndSet(cache, newCache);\n    return newCache[parameters][order];\n}"
            ],
            [
                "createConstant",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Factory method creating a constant.\n * @param value value of the constant\n * @return a new instance\n */\npublic static SparseGradient createConstant(final double value) {\n    return new SparseGradient(value, Collections.<Integer, Double>emptyMap());\n}"
            ],
            [
                "createVariable",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Factory method creating an independent variable.\n * @param idx index of the variable\n * @param value value of the variable\n * @return a new instance\n */\npublic static SparseGradient createVariable(final int idx, final double value) {\n    return new SparseGradient(value, Collections.singletonMap(idx, 1.0));\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n */\npublic static SparseGradient hypot(final SparseGradient x, final SparseGradient y) {\n    return x.hypot(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Compute a<sup>x</sup> where a is a double and x a {@link SparseGradient}\n * @param a number to exponentiate\n * @param x power to apply\n * @return a<sup>x</sup>\n */\npublic static SparseGradient pow(final double a, final SparseGradient x) {\n    if (a == 0) {\n        if (x.value == 0) {\n            return x.compose(1.0, Double.NEGATIVE_INFINITY);\n        } else if (x.value < 0) {\n            return x.compose(Double.NaN, Double.NaN);\n        } else {\n            return x.getField().getZero();\n        }\n    } else {\n        final double ax = FastMath.pow(a, x.value);\n        return new SparseGradient(ax, ax * FastMath.log(a), x.derivatives);\n    }\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Two arguments arc tangent operation.\n * @param y first argument of the arc tangent\n * @param x second argument of the arc tangent\n * @return atan2(y, x)\n */\npublic static SparseGradient atan2(final SparseGradient y, final SparseGradient x) {\n    return y.atan2(x);\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * @exception DimensionMismatchException if number of free parameters\n * or orders do not match\n * @since 3.2\n */\npublic static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y) throws DimensionMismatchException {\n    return x.hypot(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Compute a<sup>x</sup> where a is a double and x a {@link DerivativeStructure}\n * @param a number to exponentiate\n * @param x power to apply\n * @return a<sup>x</sup>\n * @since 3.3\n */\npublic static DerivativeStructure pow(final double a, final DerivativeStructure x) {\n    final DerivativeStructure result = new DerivativeStructure(x.compiler);\n    x.compiler.pow(a, x.data, 0, result.data, 0);\n    return result;\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Two arguments arc tangent operation.\n * @param y first argument of the arc tangent\n * @param x second argument of the arc tangent\n * @return atan2(y, x)\n * @exception DimensionMismatchException if number of free parameters\n * or orders do not match\n * @since 3.2\n */\npublic static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException {\n    return y.atan2(x);\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionNewtonForm",
                "/**\n * Evaluate the Newton polynomial using nested multiplication. It is\n * also called <a href=\"http://mathworld.wolfram.com/HornersRule.html\">\n * Horner's Rule</a> and takes O(N) time.\n *\n * @param a Coefficients in Newton form formula.\n * @param c Centers.\n * @param z Point at which the function value is to be computed.\n * @return the function value.\n * @throws NullArgumentException if any argument is {@code null}.\n * @throws NoDataException if any array has zero length.\n * @throws DimensionMismatchException if the size difference between\n * {@code a} and {@code c} is not equal to 1.\n */\npublic static double evaluate(double[] a, double[] c, double z) throws NullArgumentException, DimensionMismatchException, NoDataException {\n    verifyInputArray(a, c);\n    final int n = c.length;\n    double value = a[n];\n    for (int i = n - 1; i >= 0; i--) {\n        value = a[i] + (z - c[i]) * value;\n    }\n    return value;\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "/**\n * Evaluate the Lagrange polynomial using\n * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n * Neville's Algorithm</a>. It takes O(n^2) time.\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @param z Point at which the function value is to be computed.\n * @return the function value.\n * @throws DimensionMismatchException if {@code x} and {@code y} have\n * different lengths.\n * @throws NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order.\n * @throws NumberIsTooSmallException if the size of {@code x} is less\n * than 2.\n */\npublic static double evaluate(double[] x, double[] y, double z) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    if (verifyInterpolationArray(x, y, false)) {\n        return evaluateInternal(x, y, z);\n    }\n    // Array is not sorted.\n    final double[] xNew = new double[x.length];\n    final double[] yNew = new double[y.length];\n    System.arraycopy(x, 0, xNew, 0, x.length);\n    System.arraycopy(y, 0, yNew, 0, y.length);\n    MathArrays.sortInPlace(xNew, yNew);\n    // Second check in case some abscissa is duplicated.\n    verifyInterpolationArray(xNew, yNew, true);\n    return evaluateInternal(xNew, yNew, z);\n}"
            ],
            [
                "verifyInterpolationArray",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "/**\n * Check that the interpolation arrays are valid.\n * The arrays features checked by this method are that both arrays have the\n * same length and this length is at least 2.\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @param abort Whether to throw an exception if {@code x} is not sorted.\n * @throws DimensionMismatchException if the array lengths are different.\n * @throws NumberIsTooSmallException if the number of points is less than 2.\n * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order and {@code abort}\n * is {@code true}.\n * @return {@code false} if the {@code x} is not sorted in increasing order,\n * {@code true} otherwise.\n * @see #evaluate(double[], double[], double)\n * @see #computeCoefficients()\n */\npublic static boolean verifyInterpolationArray(double[] x, double[] y, boolean abort) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    if (x.length != y.length) {\n        throw new DimensionMismatchException(x.length, y.length);\n    }\n    if (x.length < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.WRONG_NUMBER_OF_POINTS, 2, x.length, true);\n    }\n    return MathArrays.checkOrder(x, MathArrays.OrderDirection.INCREASING, true, abort);\n}"
            ],
            [
                "createChebyshevPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Chebyshev polynomial of the first kind.\n * <p><a href=\"https://en.wikipedia.org/wiki/Chebyshev_polynomials\">Chebyshev\n * polynomials of the first kind</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *    T_0(x) = 1 \\\\\n *    T_1(x) = x \\\\\n *    T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Chebyshev polynomial of specified degree\n */\npublic static PolynomialFunction createChebyshevPolynomial(final int degree) {\n    return buildPolynomial(degree, CHEBYSHEV_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * Fixed recurrence coefficients.\n         */\n        private final BigFraction[] coeffs = { BigFraction.ZERO, BigFraction.TWO, BigFraction.ONE };\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            return coeffs;\n        }\n    });\n}"
            ],
            [
                "createHermitePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Hermite polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/HermitePolynomial.html\">Hermite\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *  H_0(x) = 1 \\\\\n *  H_1(x) = 2x \\\\\n *  H_{k+1}(x) = 2x H_k(X) - 2k H_{k-1}(x)\n * \\)\n * </p>\n *\n * @param degree degree of the polynomial\n * @return Hermite polynomial of specified degree\n */\npublic static PolynomialFunction createHermitePolynomial(final int degree) {\n    return buildPolynomial(degree, HERMITE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            return new BigFraction[] { BigFraction.ZERO, BigFraction.TWO, new BigFraction(2 * k) };\n        }\n    });\n}"
            ],
            [
                "createLaguerrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Laguerre polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/LaguerrePolynomial.html\">Laguerre\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *   L_0(x) = 1 \\\\\n *   L_1(x) = 1 - x \\\\\n *   (k+1) L_{k+1}(x) = (2k + 1 - x) L_k(x) - k L_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Laguerre polynomial of specified degree\n */\npublic static PolynomialFunction createLaguerrePolynomial(final int degree) {\n    return buildPolynomial(degree, LAGUERRE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            final int kP1 = k + 1;\n            return new BigFraction[] { new BigFraction(2 * k + 1, kP1), new BigFraction(-1, kP1), new BigFraction(k, kP1) };\n        }\n    });\n}"
            ],
            [
                "createLegendrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Legendre polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/LegendrePolynomial.html\">Legendre\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *   P_0(x) = 1 \\\\\n *   P_1(x) = x \\\\\n *   (k+1) P_{k+1}(x) = (2k+1) x P_k(x) - k P_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Legendre polynomial of specified degree\n */\npublic static PolynomialFunction createLegendrePolynomial(final int degree) {\n    return buildPolynomial(degree, LEGENDRE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            final int kP1 = k + 1;\n            return new BigFraction[] { BigFraction.ZERO, new BigFraction(k + kP1, kP1), new BigFraction(k, kP1) };\n        }\n    });\n}"
            ],
            [
                "createJacobiPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Jacobi polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/JacobiPolynomial.html\">Jacobi\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *    P_0^{vw}(x) = 1 \\\\\n *    P_{-1}^{vw}(x) = 0 \\\\\n *    2k(k + v + w)(2k + v + w - 2) P_k^{vw}(x) = \\\\\n *    (2k + v + w - 1)[(2k + v + w)(2k + v + w - 2) x + v^2 - w^2] P_{k-1}^{vw}(x) \\\\\n *  - 2(k + v - 1)(k + w - 1)(2k + v + w) P_{k-2}^{vw}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @param v first exponent\n * @param w second exponent\n * @return Jacobi polynomial of specified degree\n */\npublic static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w) {\n    // select the appropriate list\n    final JacobiKey key = new JacobiKey(v, w);\n    if (!JACOBI_COEFFICIENTS.containsKey(key)) {\n        // allocate a new list for v, w\n        final List<BigFraction> list = new ArrayList<BigFraction>();\n        JACOBI_COEFFICIENTS.put(key, list);\n        // Pv,w,0(x) = 1;\n        list.add(BigFraction.ONE);\n        // P1(x) = (v - w) / 2 + (2 + v + w) * X / 2\n        list.add(new BigFraction(v - w, 2));\n        list.add(new BigFraction(2 + v + w, 2));\n    }\n    return buildPolynomial(degree, JACOBI_COEFFICIENTS.get(key), new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            k++;\n            final int kvw = k + v + w;\n            final int twoKvw = kvw + k;\n            final int twoKvwM1 = twoKvw - 1;\n            final int twoKvwM2 = twoKvw - 2;\n            final int den = 2 * k * kvw * twoKvwM2;\n            return new BigFraction[] { new BigFraction(twoKvwM1 * (v * v - w * w), den), new BigFraction(twoKvwM1 * twoKvw * twoKvwM2, den), new BigFraction(2 * (k + v - 1) * (k + w - 1) * twoKvw, den) };\n        }\n    });\n}"
            ],
            [
                "shift",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Compute the coefficients of the polynomial \\(P_s(x)\\)\n * whose values at point {@code x} will be the same as the those from the\n * original polynomial \\(P(x)\\) when computed at {@code x + shift}.\n * <p>\n * More precisely, let \\(\\Delta = \\) {@code shift} and let\n * \\(P_s(x) = P(x + \\Delta)\\).  The returned array\n * consists of the coefficients of \\(P_s\\).  So if \\(a_0, ..., a_{n-1}\\)\n * are the coefficients of \\(P\\), then the returned array\n * \\(b_0, ..., b_{n-1}\\) satisfies the identity\n * \\(\\sum_{i=0}^{n-1} b_i x^i = \\sum_{i=0}^{n-1} a_i (x + \\Delta)^i\\) for all \\(x\\).\n *\n * @param coefficients Coefficients of the original polynomial.\n * @param shift Shift value.\n * @return the coefficients \\(b_i\\) of the shifted\n * polynomial.\n */\npublic static double[] shift(final double[] coefficients, final double shift) {\n    final int dp1 = coefficients.length;\n    final double[] newCoefficients = new double[dp1];\n    // Pascal triangle.\n    final int[][] coeff = new int[dp1][dp1];\n    for (int i = 0; i < dp1; i++) {\n        for (int j = 0; j <= i; j++) {\n            coeff[i][j] = (int) CombinatoricsUtils.binomialCoefficient(i, j);\n        }\n    }\n    // First polynomial coefficient.\n    for (int i = 0; i < dp1; i++) {\n        newCoefficients[0] += coefficients[i] * FastMath.pow(shift, i);\n    }\n    // Superior order.\n    final int d = dp1 - 1;\n    for (int i = 0; i < d; i++) {\n        for (int j = i; j < d; j++) {\n            newCoefficients[i + 1] += coeff[j + 1][j - i] * coefficients[j + 1] * FastMath.pow(shift, j - i);\n        }\n    }\n    return newCoefficients;\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "/**\n * Uses Horner's Method to evaluate the polynomial with the given coefficients at\n * the argument.\n *\n * @param coefficients Coefficients of the polynomial to evaluate.\n * @param argument Input value.\n * @return the value of the polynomial.\n * @throws NoDataException if {@code coefficients} is empty.\n * @throws NullArgumentException if {@code coefficients} is {@code null}.\n */\nprotected static double evaluate(double[] coefficients, double argument) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(coefficients);\n    int n = coefficients.length;\n    if (n == 0) {\n        throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n    }\n    double result = coefficients[n - 1];\n    for (int j = n - 2; j >= 0; j--) {\n        result = argument * result + coefficients[j];\n    }\n    return result;\n}"
            ],
            [
                "differentiate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "/**\n * Returns the coefficients of the derivative of the polynomial with the given coefficients.\n *\n * @param coefficients Coefficients of the polynomial to differentiate.\n * @return the coefficients of the derivative or {@code null} if coefficients has length 1.\n * @throws NoDataException if {@code coefficients} is empty.\n * @throws NullArgumentException if {@code coefficients} is {@code null}.\n */\nprotected static double[] differentiate(double[] coefficients) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(coefficients);\n    int n = coefficients.length;\n    if (n == 0) {\n        throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n    }\n    if (n == 1) {\n        return new double[] { 0 };\n    }\n    double[] result = new double[n - 1];\n    for (int i = n - 1; i > 0; i--) {\n        result[i - 1] = i * coefficients[i];\n    }\n    return result;\n}"
            ],
            [
                "computeDividedDifference",
                "org.apache.commons.math3.analysis.interpolation",
                "DividedDifferenceInterpolator",
                "/**\n * Return a copy of the divided difference array.\n * <p>\n * The divided difference array is defined recursively by <pre>\n * f[x0] = f(x0)\n * f[x0,x1,...,xk] = (f[x1,...,xk] - f[x0,...,x[k-1]]) / (xk - x0)\n * </pre>\n * <p>\n * The computational complexity is \\(O(n^2)\\) where \\(n\\) is the common\n * length of {@code x} and {@code y}.</p>\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @return a fresh copy of the divided difference array.\n * @throws DimensionMismatchException if the array lengths are different.\n * @throws NumberIsTooSmallException if the number of points is less than 2.\n * @throws NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order.\n */\nprotected static double[] computeDividedDifference(final double[] x, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y, true);\n    // initialization\n    final double[] divdiff = y.clone();\n    final int n = x.length;\n    final double[] a = new double[n];\n    a[0] = divdiff[0];\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n - i; j++) {\n            final double denominator = x[j + i] - x[j];\n            divdiff[j] = (divdiff[j + 1] - divdiff[j]) / denominator;\n        }\n        a[i] = divdiff[0];\n    }\n    return a;\n}"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Compares two numbers given some amount of allowed error.\n *\n * @param x the first number\n * @param y the second number\n * @param eps the amount of error to allow when checking for equality\n * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y or\n *       either argument is NaN</li></ul>\n */\npublic static int compareTo(double x, double y, double eps) {\n    if (equals(x, y, eps)) {\n        return 0;\n    } else if (x < y) {\n        return -1;\n    }\n    return 1;\n}"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Compares two numbers given some amount of allowed error.\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>. Returns {@code false} if either of the arguments is NaN.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return <ul><li>0 if  {@link #equals(double, double, int) equals(x, y, maxUlps)}</li>\n *       <li>&lt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y</li>\n *       <li>&gt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x > y\n *       or either argument is NaN</li></ul>\n */\npublic static int compareTo(final double x, final double y, final int maxUlps) {\n    if (equals(x, y, maxUlps)) {\n        return 0;\n    } else if (x < y) {\n        return -1;\n    }\n    return 1;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true iff they are equal as defined by\n * {@link #equals(float,float,int) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\npublic static boolean equals(float x, float y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if both arguments are NaN or they are\n * equal as defined by {@link #equals(float,float) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).  Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other.\n * @since 2.2\n */\npublic static boolean equals(float x, float y, float eps) {\n    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN, are equal, or are within the range\n * of allowed error (inclusive).\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,\n * or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y, float eps) {\n    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>.  Returns {@code false} if either of the arguments is NaN.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equals(final float x, final float y, final int maxUlps) {\n    final int xInt = Float.floatToRawIntBits(x);\n    final int yInt = Float.floatToRawIntBits(y);\n    final boolean isEqual;\n    if (((xInt ^ yInt) & SGN_MASK_FLOAT) == 0) {\n        // number have same sign, there is no risk of overflow\n        isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    } else {\n        // number have opposite signs, take care of overflow\n        final int deltaPlus;\n        final int deltaMinus;\n        if (xInt < yInt) {\n            deltaPlus = yInt - POSITIVE_ZERO_FLOAT_BITS;\n            deltaMinus = xInt - NEGATIVE_ZERO_FLOAT_BITS;\n        } else {\n            deltaPlus = xInt - POSITIVE_ZERO_FLOAT_BITS;\n            deltaMinus = yInt - NEGATIVE_ZERO_FLOAT_BITS;\n        }\n        if (deltaPlus > maxUlps) {\n            isEqual = false;\n        } else {\n            isEqual = deltaMinus <= (maxUlps - deltaPlus);\n        }\n    }\n    return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN or if they are equal as defined\n * by {@link #equals(float,float,int) equals(x, y, maxUlps)}.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than\n * {@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, maxUlps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true iff they are equal as defined by\n * {@link #equals(double,double,int) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\npublic static boolean equals(double x, double y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN or they are\n * equal as defined by {@link #equals(double,double) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns {@code true} if there is no double value strictly between the\n * arguments or the difference between them is within the range of allowed\n * error (inclusive). Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed absolute error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n */\npublic static boolean equals(double x, double y, double eps) {\n    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n}"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns {@code true} if there is no double value strictly between the\n * arguments or the relative difference between them is less than or equal\n * to the given tolerance. Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed relative error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n * @since 3.1\n */\npublic static boolean equalsWithRelativeTolerance(double x, double y, double eps) {\n    if (equals(x, y, 1)) {\n        return true;\n    }\n    final double absoluteMax = FastMath.max(FastMath.abs(x), FastMath.abs(y));\n    final double relativeDifference = FastMath.abs((x - y) / absoluteMax);\n    return relativeDifference <= eps;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN, are equal or are within the range\n * of allowed error (inclusive).\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,\n * or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y, double eps) {\n    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).\n * <p>\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent\n * floating point numbers are considered equal.\n * </p>\n * <p>\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>. Returns {@code false} if either of the arguments is NaN.\n * </p>\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n */\npublic static boolean equals(final double x, final double y, final int maxUlps) {\n    final long xInt = Double.doubleToRawLongBits(x);\n    final long yInt = Double.doubleToRawLongBits(y);\n    final boolean isEqual;\n    if (((xInt ^ yInt) & SGN_MASK) == 0l) {\n        // number have same sign, there is no risk of overflow\n        isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    } else {\n        // number have opposite signs, take care of overflow\n        final long deltaPlus;\n        final long deltaMinus;\n        if (xInt < yInt) {\n            deltaPlus = yInt - POSITIVE_ZERO_DOUBLE_BITS;\n            deltaMinus = xInt - NEGATIVE_ZERO_DOUBLE_BITS;\n        } else {\n            deltaPlus = xInt - POSITIVE_ZERO_DOUBLE_BITS;\n            deltaMinus = yInt - NEGATIVE_ZERO_DOUBLE_BITS;\n        }\n        if (deltaPlus > maxUlps) {\n            isEqual = false;\n        } else {\n            isEqual = deltaMinus <= (maxUlps - deltaPlus);\n        }\n    }\n    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if both arguments are NaN or if they are equal as defined\n * by {@link #equals(double,double,int) equals(x, y, maxUlps)}.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than\n * {@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, maxUlps);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double round(double x, int scale) {\n    return round(x, scale, BigDecimal.ROUND_HALF_UP);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is\n * returned unchanged, regardless of the other parameters.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}\n * and the specified scaling operation would require rounding.\n * @throws IllegalArgumentException if {@code roundingMethod} does not\n * represent a valid rounding mode.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double round(double x, int scale, int roundingMethod) {\n    try {\n        final double rounded = (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\n        // MATH-1089: negative values rounded to zero should result in negative zero\n        return rounded == POSITIVE_ZERO ? POSITIVE_ZERO * x : rounded;\n    } catch (NumberFormatException ex) {\n        if (Double.isInfinite(x)) {\n            return x;\n        } else {\n            return Double.NaN;\n        }\n    }\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static float round(float x, int scale) {\n    return round(x, scale, BigDecimal.ROUND_HALF_UP);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n * @throws MathArithmeticException if an exact operation is required but result is not exact\n * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n */\npublic static float round(float x, int scale, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException {\n    final float sign = FastMath.copySign(1f, x);\n    final float factor = (float) FastMath.pow(10.0f, scale) * sign;\n    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;\n}"
            ],
            [
                "representableDelta",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Computes a number {@code delta} close to {@code originalDelta} with\n * the property that <pre><code>\n *   x + delta - x\n * </code></pre>\n * is exactly machine-representable.\n * This is useful when computing numerical derivatives, in order to reduce\n * roundoff errors.\n *\n * @param x Value.\n * @param originalDelta Offset value.\n * @return a number {@code delta} so that {@code x + delta} and {@code x}\n * differ by a representable floating number.\n */\npublic static double representableDelta(double x, double originalDelta) {\n    return x + originalDelta - x;\n}"
            ],
            [
                "wrap",
                "org.apache.commons.math3.util",
                "Incrementor",
                "/**\n * Create an instance that delegates everything to a {@link IntegerSequence.Incrementor}.\n * <p>\n * This factory method is intended only as a temporary hack for internal use in\n * Apache Commons Math 3.X series, when {@code Incrementor} is required in\n * interface (as a return value or in protected fields). It should <em>not</em>\n * be used in other cases. The {@link IntegerSequence.Incrementor} class should\n * be used instead of {@code Incrementor}.\n * </p>\n * <p>\n * All methods are mirrored to the underlying {@link IntegerSequence.Incrementor},\n * as long as neither {@link #setMaximalCount(int)} nor {@link #resetCount()} are called.\n * If one of these two methods is called, the created instance becomes independent\n * of the {@link IntegerSequence.Incrementor} used at creation. The rationale is that\n * {@link IntegerSequence.Incrementor} cannot change their maximal count and cannot be reset.\n * </p>\n * @param incrementor wrapped {@link IntegerSequence.Incrementor}\n * @return an incrementor wrapping an {@link IntegerSequence.Incrementor}\n * @since 3.6\n */\npublic static Incrementor wrap(final IntegerSequence.Incrementor incrementor) {\n    return new Incrementor() {\n\n        /**\n         * Underlying incrementor.\n         */\n        private IntegerSequence.Incrementor delegate;\n\n        {\n            // set up matching values at initialization\n            delegate = incrementor;\n            super.setMaximalCount(delegate.getMaximalCount());\n            super.incrementCount(delegate.getCount());\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void setMaximalCount(int max) {\n            super.setMaximalCount(max);\n            delegate = delegate.withMaximalCount(max);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void resetCount() {\n            super.resetCount();\n            delegate = delegate.withStart(0);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void incrementCount() {\n            super.incrementCount();\n            delegate.increment();\n        }\n    };\n}"
            ],
            [
                "scale",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Create a copy of an array scaled by a value.\n *\n * @param arr Array to scale.\n * @param val Scalar.\n * @return scaled copy of array with each entry multiplied by val.\n * @since 3.2\n */\npublic static double[] scale(double val, final double[] arr) {\n    double[] newArr = new double[arr.length];\n    for (int i = 0; i < arr.length; i++) {\n        newArr[i] = arr[i] * val;\n    }\n    return newArr;\n}"
            ],
            [
                "ebeAdd",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * addition of the arguments.\n *\n * @param a First term of the addition.\n * @param b Second term of the addition.\n * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] += b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeSubtract",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * subtraction of the second argument from the first.\n *\n * @param a First term.\n * @param b Element to be subtracted.\n * @return a new array {@code r} where {@code r[i] = a[i] - b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] -= b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeMultiply",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * multiplication of the arguments.\n *\n * @param a First factor of the multiplication.\n * @param b Second factor of the multiplication.\n * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] *= b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeDivide",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * division of the first argument by the second.\n *\n * @param a Numerator of the division.\n * @param b Denominator of the division.\n * @return a new array {@code r} where {@code r[i] = a[i] / b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] /= b[i];\n    }\n    return result;\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>1</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance1(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        sum += FastMath.abs(p1[i] - p2[i]);\n    }\n    return sum;\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>1</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static int distance1(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    int sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        sum += FastMath.abs(p1[i] - p2[i]);\n    }\n    return sum;\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>2</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final double dp = p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return FastMath.sqrt(sum);\n}"
            ],
            [
                "cosAngle",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the cosine of the angle between two vectors.\n *\n * @param v1 Cartesian coordinates of the first vector.\n * @param v2 Cartesian coordinates of the second vector.\n * @return the cosine of the angle between the vectors.\n * @since 3.6\n */\npublic static double cosAngle(double[] v1, double[] v2) {\n    return linearCombination(v1, v2) / (safeNorm(v1) * safeNorm(v2));\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>2</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final double dp = p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return FastMath.sqrt(sum);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>&infin;</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double max = 0;\n    for (int i = 0; i < p1.length; i++) {\n        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n    }\n    return max;\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>&infin;</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    int max = 0;\n    for (int i = 0; i < p1.length; i++) {\n        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n    }\n    return max;\n}"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that an array is monotonically increasing or decreasing.\n *\n * @param <T> the type of the elements in the specified array\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\npublic static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {\n    T previous = val[0];\n    final int max = val.length;\n    for (int i = 1; i < max; i++) {\n        final int comp;\n        switch(dir) {\n            case INCREASING:\n                comp = previous.compareTo(val[i]);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            case DECREASING:\n                comp = val[i].compareTo(previous);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n        }\n        previous = val[i];\n    }\n    return true;\n}"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that an array is monotonically increasing or decreasing.\n *\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\npublic static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {\n    return checkOrder(val, dir, strict, false);\n}"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that both arrays have the same length.\n *\n * @param a Array.\n * @param b Array.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the arrays have the same length.\n * @throws DimensionMismatchException if the lengths differ and\n * {@code abort} is {@code true}.\n * @since 3.6\n */\npublic static boolean checkEqualLength(double[] a, double[] b, boolean abort) {\n    if (a.length == b.length) {\n        return true;\n    } else {\n        if (abort) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n        return false;\n    }\n}"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that both arrays have the same length.\n *\n * @param a Array.\n * @param b Array.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the arrays have the same length.\n * @throws DimensionMismatchException if the lengths differ and\n * {@code abort} is {@code true}.\n * @since 3.6\n */\npublic static boolean checkEqualLength(int[] a, int[] b, boolean abort) {\n    if (a.length == b.length) {\n        return true;\n    } else {\n        if (abort) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n        return false;\n    }\n}"
            ],
            [
                "checkOrder",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that the given array is sorted.\n *\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the array is sorted.\n * @throws NonMonotonicSequenceException if the array is not sorted\n * and {@code abort} is {@code true}.\n */\npublic static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {\n    double previous = val[0];\n    final int max = val.length;\n    int index;\n    ITEM: for (index = 1; index < max; index++) {\n        switch(dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[index] <= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] < previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[index] >= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] > previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n        }\n        previous = val[index];\n    }\n    if (index == max) {\n        // Loop completed.\n        return true;\n    }\n    // Loop early exit means wrong ordering.\n    if (abort) {\n        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n    } else {\n        return false;\n    }\n}"
            ],
            [
                "safeNorm",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n * Translation of the minpack enorm subroutine.\n *\n * The redistribution policy for MINPACK is available\n * <a href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n * convenience, it is reproduced below.</p>\n *\n * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n * <tr><td>\n *    Minpack Copyright Notice (1999) University of Chicago.\n *    All rights reserved\n * </td></tr>\n * <tr><td>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * <ol>\n *  <li>Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.</li>\n * <li>Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.</li>\n * <li>The end-user documentation included with the redistribution, if any,\n *     must include the following acknowledgment:\n *     {@code This product includes software developed by the University of\n *           Chicago, as Operator of Argonne National Laboratory.}\n *     Alternately, this acknowledgment may appear in the software itself,\n *     if and wherever such third-party acknowledgments normally appear.</li>\n * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n *     BE CORRECTED.</strong></li>\n * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n * <ol></td></tr>\n * </table>\n *\n * @param v Vector of doubles.\n * @return the 2-norm of the vector.\n * @since 2.2\n */\npublic static double safeNorm(double[] v) {\n    double rdwarf = 3.834e-20;\n    double rgiant = 1.304e+19;\n    double s1 = 0;\n    double s2 = 0;\n    double s3 = 0;\n    double x1max = 0;\n    double x3max = 0;\n    double floatn = v.length;\n    double agiant = rgiant / floatn;\n    for (int i = 0; i < v.length; i++) {\n        double xabs = FastMath.abs(v[i]);\n        if (xabs < rdwarf || xabs > agiant) {\n            if (xabs > rdwarf) {\n                if (xabs > x1max) {\n                    double r = x1max / xabs;\n                    s1 = 1 + s1 * r * r;\n                    x1max = xabs;\n                } else {\n                    double r = xabs / x1max;\n                    s1 += r * r;\n                }\n            } else {\n                if (xabs > x3max) {\n                    double r = x3max / xabs;\n                    s3 = 1 + s3 * r * r;\n                    x3max = xabs;\n                } else {\n                    if (xabs != 0) {\n                        double r = xabs / x3max;\n                        s3 += r * r;\n                    }\n                }\n            }\n        } else {\n            s2 += xabs * xabs;\n        }\n    }\n    double norm;\n    if (s1 != 0) {\n        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n    } else {\n        if (s2 == 0) {\n            norm = x3max * Math.sqrt(s3);\n        } else {\n            if (s2 >= x3max) {\n                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n            } else {\n                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n            }\n        }\n    }\n    return norm;\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @return the copied array.\n */\npublic static int[] copyOf(int[] source) {\n    return copyOf(source, source.length);\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @return the copied array.\n */\npublic static double[] copyOf(double[] source) {\n    return copyOf(source, source.length);\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the source\n * length, the copy will be truncated, if larger it will padded with\n * zeroes.\n * @return the copied array.\n */\npublic static int[] copyOf(int[] source, int len) {\n    final int[] output = new int[len];\n    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n    return output;\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the source\n * length, the copy will be truncated, if larger it will padded with\n * zeroes.\n * @return the copied array.\n */\npublic static double[] copyOf(double[] source, int len) {\n    final double[] output = new double[len];\n    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n    return output;\n}"
            ],
            [
                "copyOfRange",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param from Initial index of the range to be copied, inclusive.\n * @param to Final index of the range to be copied, exclusive. (This index may lie outside the array.)\n * @return the copied array.\n */\npublic static double[] copyOfRange(double[] source, int from, int to) {\n    final int len = to - from;\n    final double[] output = new double[len];\n    System.arraycopy(source, from, output, 0, FastMath.min(len, source.length - from));\n    return output;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * This method computes the sum of the products\n * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n * It does so by using specific multiplication and addition algorithms to\n * preserve accuracy and reduce cancellation effects.\n * <br/>\n * It is based on the 2005 paper\n * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n *\n * @param a Factors.\n * @param b Factors.\n * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n * @throws DimensionMismatchException if arrays dimensions don't match\n */\npublic static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final int len = a.length;\n    if (len == 1) {\n        // Revert to scalar multiplication.\n        return a[0] * b[0];\n    }\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double aHigh = Double.longBitsToDouble(Double.doubleToRawLongBits(ai) & ((-1L) << 27));\n        final double aLow = ai - aHigh;\n        final double bi = b[i];\n        final double bHigh = Double.longBitsToDouble(Double.doubleToRawLongBits(bi) & ((-1L) << 27));\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n    final double prodHighCur = prodHigh[0];\n    double prodHighNext = prodHigh[1];\n    double sHighPrev = prodHighCur + prodHighNext;\n    double sPrime = sHighPrev - prodHighNext;\n    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n    final int lenMinusOne = len - 1;\n    for (int i = 1; i < lenMinusOne; i++) {\n        prodHighNext = prodHigh[i + 1];\n        final double sHighCur = sHighPrev + prodHighNext;\n        sPrime = sHighCur - prodHighNext;\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n        sHighPrev = sHighCur;\n    }\n    double result = sHighPrev + (prodLowSum + sLowSum);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\n * so by using specific multiplication and addition algorithms to\n * preserve accuracy and reduce cancellation effects. It is based\n * on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub>\n * @see #linearCombination(double, double, double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // use IEEE754 floating point arithmetic rounding properties.\n    // The variable naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // final rounding, s12 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s12High + (prod1Low + prod2Low + s12Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2;\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n * to high accuracy. It does so by using specific multiplication and\n * addition algorithms to preserve accuracy and reduce cancellation effects.\n * It is based on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n * @see #linearCombination(double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // do use IEEE754 floating point arithmetic rounding properties.\n    // The variables naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // split a3 and b3 as one 26 bits number and one 27 bits number\n    final double a3High = Double.longBitsToDouble(Double.doubleToRawLongBits(a3) & ((-1L) << 27));\n    final double a3Low = a3 - a3High;\n    final double b3High = Double.longBitsToDouble(Double.doubleToRawLongBits(b3) & ((-1L) << 27));\n    final double b3Low = b3 - b3High;\n    // accurate multiplication a3 * b3\n    final double prod3High = a3 * b3;\n    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n    final double s123High = s12High + prod3High;\n    final double s123Prime = s123High - prod3High;\n    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n    // final rounding, s123 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2 + a3 * b3;\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n * a<sub>4</sub>&times;b<sub>4</sub>\n * to high accuracy. It does so by using specific multiplication and\n * addition algorithms to preserve accuracy and reduce cancellation effects.\n * It is based on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @param a4 first factor of the third term\n * @param b4 second factor of the third term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n * a<sub>4</sub>&times;b<sub>4</sub>\n * @see #linearCombination(double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // do use IEEE754 floating point arithmetic rounding properties.\n    // The variables naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // split a3 and b3 as one 26 bits number and one 27 bits number\n    final double a3High = Double.longBitsToDouble(Double.doubleToRawLongBits(a3) & ((-1L) << 27));\n    final double a3Low = a3 - a3High;\n    final double b3High = Double.longBitsToDouble(Double.doubleToRawLongBits(b3) & ((-1L) << 27));\n    final double b3Low = b3 - b3High;\n    // accurate multiplication a3 * b3\n    final double prod3High = a3 * b3;\n    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n    // split a4 and b4 as one 26 bits number and one 27 bits number\n    final double a4High = Double.longBitsToDouble(Double.doubleToRawLongBits(a4) & ((-1L) << 27));\n    final double a4Low = a4 - a4High;\n    final double b4High = Double.longBitsToDouble(Double.doubleToRawLongBits(b4) & ((-1L) << 27));\n    final double b4Low = b4 - b4High;\n    // accurate multiplication a4 * b4\n    final double prod4High = a4 * b4;\n    final double prod4Low = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n    final double s123High = s12High + prod3High;\n    final double s123Prime = s123High - prod3High;\n    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4\n    final double s1234High = s123High + prod4High;\n    final double s1234Prime = s1234High - prod4High;\n    final double s1234Low = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n    // final rounding, s1234 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n    }\n    return result;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns true iff both arguments are null or have same dimensions and all\n * their elements are equal as defined by\n * {@link Precision#equals(float,float)}.\n *\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension\n * and equal elements.\n */\npublic static boolean equals(float[] x, float[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equals(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns true iff both arguments are null or have same dimensions and all\n * their elements are equal as defined by\n * {@link Precision#equalsIncludingNaN(double,double) this method}.\n *\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension and\n * equal elements\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float[] x, float[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns {@code true} iff both arguments are {@code null} or have same\n * dimensions and all their elements are equal as defined by\n * {@link Precision#equals(double,double)}.\n *\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have same\n * dimension and equal elements.\n */\npublic static boolean equals(double[] x, double[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equals(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns {@code true} iff both arguments are {@code null} or have same\n * dimensions and all their elements are equal as defined by\n * {@link Precision#equalsIncludingNaN(double,double) this method}.\n *\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have same\n * dimension and equal elements.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double[] x, double[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "normalizeArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Normalizes an array to make it sum to a specified value.\n * Returns the result of the transformation\n * <pre>\n *    x |-> x * normalizedSum / sum\n * </pre>\n * applied to each non-NaN element x of the input array, where sum is the\n * sum of the non-NaN entries in the input array.\n * <p>\n * Throws IllegalArgumentException if {@code normalizedSum} is infinite\n * or NaN and ArithmeticException if the input array contains any infinite elements\n * or sums to 0.\n * <p>\n * Ignores (i.e., copies unchanged to the output array) NaNs in the input array.\n *\n * @param values Input array to be normalized\n * @param normalizedSum Target sum for the normalized array\n * @return the normalized array.\n * @throws MathArithmeticException if the input array contains infinite\n * elements or sums to zero.\n * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.\n * @since 2.1\n */\npublic static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n    }\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n    }\n    double sum = 0d;\n    final int len = values.length;\n    double[] out = new double[len];\n    for (int i = 0; i < len; i++) {\n        if (Double.isInfinite(values[i])) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n        }\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n    }\n    for (int i = 0; i < len; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Build an array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n *\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param length of the array\n * @return a new array\n * @since 3.2\n */\npublic static <T> T[] buildArray(final Field<T> field, final int length) {\n    // OK because field must be correct class\n    @SuppressWarnings(\"unchecked\")\n    T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);\n    Arrays.fill(array, field.getZero());\n    return array;\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Build a double dimension  array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n *\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param rows number of rows in the array\n * @param columns number of columns (may be negative to build partial\n * arrays in the same way <code>new Field[rows][]</code> works)\n * @return a new array\n * @since 3.2\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n    final T[][] array;\n    if (columns < 0) {\n        T[] dummyRow = buildArray(field, 0);\n        array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n    } else {\n        array = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { rows, columns });\n        for (int i = 0; i < rows; ++i) {\n            Arrays.fill(array[i], field.getZero());\n        }\n    }\n    return array;\n}"
            ],
            [
                "convolve",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the <a href=\"http://en.wikipedia.org/wiki/Convolution\">\n * convolution</a> between two sequences.\n * <p>\n * The solution is obtained via straightforward computation of the\n * convolution sum (and not via FFT). Whenever the computation needs\n * an element that would be located at an index outside the input arrays,\n * the value is assumed to be zero.\n *\n * @param x First sequence.\n * Typically, this sequence will represent an input signal to a system.\n * @param h Second sequence.\n * Typically, this sequence will represent the impulse response of the system.\n * @return the convolution of {@code x} and {@code h}.\n * This array's length will be {@code x.length + h.length - 1}.\n * @throws NullArgumentException if either {@code x} or {@code h} is {@code null}.\n * @throws NoDataException if either {@code x} or {@code h} is empty.\n *\n * @since 3.3\n */\npublic static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(x);\n    MathUtils.checkNotNull(h);\n    final int xLen = x.length;\n    final int hLen = h.length;\n    if (xLen == 0 || hLen == 0) {\n        throw new NoDataException();\n    }\n    // initialize the output array\n    final int totalLength = xLen + hLen - 1;\n    final double[] y = new double[totalLength];\n    // straightforward implementation of the convolution sum\n    for (int n = 0; n < totalLength; n++) {\n        double yn = 0;\n        int k = FastMath.max(0, n + 1 - xLen);\n        int j = n - k;\n        while (k < hLen && j >= 0) {\n            yn += x[j--] * h[k++];\n        }\n        y[n] = yn;\n    }\n    return y;\n}"
            ],
            [
                "natural",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array representing the natural number {@code n}.\n *\n * @param n Natural number.\n * @return an array whose entries are the numbers 0, 1, ..., {@code n}-1.\n * If {@code n == 0}, the returned array is empty.\n */\npublic static int[] natural(int n) {\n    return sequence(n, 0, 1);\n}"
            ],
            [
                "sequence",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array of {@code size} integers starting at {@code start},\n * skipping {@code stride} numbers.\n *\n * @param size Natural number.\n * @param start Natural number.\n * @param stride Natural number.\n * @return an array whose entries are the numbers\n * {@code start, start + stride, ..., start + (size - 1) * stride}.\n * If {@code size == 0}, the returned array is empty.\n *\n * @since 3.4\n */\npublic static int[] sequence(int size, int start, int stride) {\n    final int[] a = new int[size];\n    for (int i = 0; i < size; i++) {\n        a[i] = start + i * stride;\n    }\n    return a;\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the input parameters designate a subarray of positive length.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * positive length</li>\n * <li>throws <code>MathIllegalArgumentException</code> if the array is null or\n * or the indices are invalid</li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0.\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return true if the parameters are valid and designate a subarray of positive length\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return verifyValues(values, begin, length, false);\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the input parameters designate a subarray of positive length.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * non-negative length</li>\n * <li>throws <code>IllegalArgumentException</code> if the array is null or\n * or the indices are invalid</li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @param allowEmpty if <code>true</code> then zero length arrays are allowed\n * @return true if the parameters are valid\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {\n    if (values == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    if (begin < 0) {\n        throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));\n    }\n    if (length < 0) {\n        throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));\n    }\n    if (begin + length > values.length) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END, Integer.valueOf(begin + length), Integer.valueOf(values.length), true);\n    }\n    if (length == 0 && !allowEmpty) {\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the begin and length parameters designate a subarray of positive length\n * and the weights are all non-negative, non-NaN, finite, and not all zero.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * positive length and the weights array contains legitimate values.</li>\n * <li>throws <code>IllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li></ul>\n * </li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0.\n * </ul></p>\n *\n * @param values the input array\n * @param weights the weights array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return true if the parameters are valid and designate a subarray of positive length\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException {\n    return verifyValues(values, weights, begin, length, false);\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the begin and length parameters designate a subarray of positive length\n * and the weights are all non-negative, non-NaN, finite, and not all zero.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * non-negative length and the weights array contains legitimate values.</li>\n * <li>throws <code>MathIllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li></ul>\n * </li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>.\n * </ul></p>\n *\n * @param values the input array.\n * @param weights the weights array.\n * @param begin index of the first array element to include.\n * @param length the number of elements to include.\n * @param allowEmpty if {@code true} than allow zero length arrays to pass.\n * @return {@code true} if the parameters are valid.\n * @throws NullArgumentException if either of the arrays are null\n * @throws MathIllegalArgumentException if the array indices are not valid,\n * the weights array contains NaN, infinite or negative elements, or there\n * are no positive weights.\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {\n    if (weights == null || values == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    checkEqualLength(weights, values);\n    boolean containsPositiveWeight = false;\n    for (int i = begin; i < begin + length; i++) {\n        final double weight = weights[i];\n        if (Double.isNaN(weight)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_ELEMENT_AT_INDEX, Integer.valueOf(i));\n        }\n        if (Double.isInfinite(weight)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, Double.valueOf(weight), Integer.valueOf(i));\n        }\n        if (weight < 0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX, Integer.valueOf(i), Double.valueOf(weight));\n        }\n        if (!containsPositiveWeight && weight > 0.0) {\n            containsPositiveWeight = true;\n        }\n    }\n    if (!containsPositiveWeight) {\n        throw new MathIllegalArgumentException(LocalizedFormats.WEIGHT_AT_LEAST_ONE_NON_ZERO);\n    }\n    return verifyValues(values, begin, length, allowEmpty);\n}"
            ],
            [
                "concatenate",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Concatenates a sequence of arrays. The return array consists of the\n * entries of the input arrays concatenated in the order they appear in\n * the argument list.  Null arrays cause NullPointerExceptions; zero\n * length arrays are allowed (contributing nothing to the output array).\n *\n * @param x list of double[] arrays to concatenate\n * @return a new array consisting of the entries of the argument arrays\n * @throws NullPointerException if any of the arrays are null\n * @since 3.6\n */\npublic static double[] concatenate(double[]... x) {\n    int combinedLength = 0;\n    for (double[] a : x) {\n        combinedLength += a.length;\n    }\n    int offset = 0;\n    int curLength = 0;\n    final double[] combined = new double[combinedLength];\n    for (int i = 0; i < x.length; i++) {\n        curLength = x[i].length;\n        System.arraycopy(x[i], 0, combined, offset, curLength);\n        offset += curLength;\n    }\n    return combined;\n}"
            ],
            [
                "unique",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array consisting of the unique values in {@code data}.\n * The return array is sorted in descending order.  Empty arrays\n * are allowed, but null arrays result in NullPointerException.\n * Infinities are allowed.  NaN values are allowed with maximum\n * sort order - i.e., if there are NaN values in {@code data},\n * {@code Double.NaN} will be the first element of the output array,\n * even if the array also contains {@code Double.POSITIVE_INFINITY}.\n *\n * @param data array to scan\n * @return descending list of values included in the input array\n * @throws NullPointerException if data is null\n * @since 3.6\n */\npublic static double[] unique(double[] data) {\n    TreeSet<Double> values = new TreeSet<Double>();\n    for (int i = 0; i < data.length; i++) {\n        values.add(data[i]);\n    }\n    final int count = values.size();\n    final double[] out = new double[count];\n    Iterator<Double> iterator = values.iterator();\n    int i = 0;\n    while (iterator.hasNext()) {\n        out[count - ++i] = iterator.next();\n    }\n    return out;\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Pair",
                "/**\n * Convenience factory method that calls the\n * {@link #Pair(Object, Object) constructor}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param k First element of the pair.\n * @param v Second element of the pair.\n * @return a new {@code Pair} containing {@code k} and {@code v}.\n * @since 3.3\n */\npublic static <K, V> Pair<K, V> create(K k, V v) {\n    return new Pair<K, V>(k, v);\n}"
            ],
            [
                "slowCos",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n *  For x between 0 and pi/4 compute cosine using Talor series\n *  cos(x) = 1 - x^2/2! + x^4/4! ...\n * @param x number from which cosine is requested\n * @param result placeholder where to put the result in extended precision\n * (may be null)\n * @return cos(x)\n */\nstatic double slowCos(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        if ((i & 1) != 0) {\n            // skip odd entries\n            continue;\n        }\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        if ((i & 2) != 0) {\n            // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowSin",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * For x between 0 and pi/4 compute sine using Taylor expansion:\n * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...\n * @param x number from which sine is requested\n * @param result placeholder where to put the result in extended precision\n * (may be null)\n * @return sin(x)\n */\nstatic double slowSin(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        if ((i & 1) == 0) {\n            // Ignore even numbers\n            continue;\n        }\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        if ((i & 2) != 0) {\n            // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowexp",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n *  For x between 0 and 1, returns exp(x), uses extended precision\n *  @param x argument of exponential\n *  @param result placeholder where to place exp(x) split in two terms\n *  for extra precision (i.e. exp(x) = result[0] + result[1]\n *  @return exp(x)\n */\nstatic double slowexp(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "expint",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * Compute exp(p) for a integer p in extended precision.\n * @param p integer whose exponential is requested\n * @param result placeholder where to put the result in extended precision\n * @return exp(p) in standard precision (equal to result[0] + result[1])\n */\nstatic double expint(int p, final double[] result) {\n    //double x = M_E;\n    final double[] xs = new double[2];\n    final double[] as = new double[2];\n    final double[] ys = new double[2];\n    //split(x, xs);\n    //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n    //xs[0] = 2.71827697753906250000;\n    //xs[1] = 4.85091998273542816811e-06;\n    //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n    //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n    /* E */\n    xs[0] = 2.718281828459045;\n    xs[1] = 1.4456468917292502E-16;\n    split(1.0, ys);\n    while (p > 0) {\n        if ((p & 1) != 0) {\n            quadMult(ys, xs, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n        quadMult(xs, xs, as);\n        xs[0] = as[0];\n        xs[1] = as[1];\n        p >>= 1;\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n        resplit(result);\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowLog",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * xi in the range of [1, 2].\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      1-x           \\          3        5        7          /\n *\n * So, compute a Remez approximation of the following function\n *\n *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n *\n * This will be an even function with only positive coefficents.\n * x is in the range [0 - 1/3].\n *\n * Transform xi for input to the above function by setting\n * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n * the result is multiplied by x.\n * @param xi number from which log is requested\n * @return log(xi)\n */\nstatic double[] slowLog(double xi) {\n    double[] x = new double[2];\n    double[] x2 = new double[2];\n    double[] y = new double[2];\n    double[] a = new double[2];\n    split(xi, x);\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a, y);\n    x[0] = y[0];\n    x[1] = y[1];\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n    //x[0] -= 1.0;\n    //resplit(x);\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][1];\n    for (int i = LN_SPLIT_COEF.length - 2; i >= 0; i--) {\n        splitMult(y, x2, a);\n        y[0] = a[0];\n        y[1] = a[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a);\n        y[0] = a[0];\n        y[1] = a[1];\n    }\n    splitMult(y, x, a);\n    y[0] = a[0];\n    y[1] = a[1];\n    return y;\n}"
            ],
            [
                "format",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * Format a double.\n * @param d double number to format\n * @return formatted number\n */\nstatic String format(double d) {\n    if (d != d) {\n        return \"Double.NaN,\";\n    } else {\n        return ((d >= 0) ? \"+\" : \"\") + Double.toString(d) + \"d,\";\n    }\n}"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the square root of a number.\n * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n * @param a number on which evaluation is done\n * @return square root of a\n */\npublic static double sqrt(final double a) {\n    return Math.sqrt(a);\n}"
            ],
            [
                "cosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic cosine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic cosine of x\n */\npublic static double cosh(double x) {\n    if (x != x) {\n        return x;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        if (x >= LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(x);\n        }\n    } else if (x < -20) {\n        if (x <= -LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(-0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(-x);\n        }\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}"
            ],
            [
                "sinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic sine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic sine of x\n */\npublic static double sinh(double x) {\n    boolean negate = false;\n    if (x != x) {\n        return x;\n    }\n    // sinh[z] = (exp(z) - exp(-z) / 2\n    // for values of z larger than about 20,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        if (x >= LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(x);\n        }\n    } else if (x < -20) {\n        if (x <= -LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(-0.5 * x);\n            return (-0.5 * t) * t;\n        } else {\n            return -0.5 * exp(-x);\n        }\n    }\n    if (x == 0) {\n        return x;\n    }\n    if (x < 0.0) {\n        x = -x;\n        negate = true;\n    }\n    double result;\n    if (x > 0.25) {\n        double[] hiPrec = new double[2];\n        exp(x, 0.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n        // recip = 1/y\n        double recip = 1.0 / ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n        // Correct for rounding in division\n        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n        // Account for yb\n        recipb += -yb * recip * recip;\n        recipa = -recipa;\n        recipb = -recipb;\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n        result = ya + yb;\n        result *= 0.5;\n    } else {\n        double[] hiPrec = new double[2];\n        expm1(x, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n        double denom = 1.0 + ya;\n        double denomr = 1.0 / denom;\n        double denomb = -(denom - 1.0 - ya) + yb;\n        double ratio = ya * denomr;\n        double temp = ratio * HEX_40000000;\n        double ra = ratio + temp - temp;\n        double rb = ratio - ra;\n        temp = denom * HEX_40000000;\n        double za = denom + temp - temp;\n        double zb = denom - za;\n        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n        // Adjust for yb\n        // numerator\n        rb += yb * denomr;\n        // denominator\n        rb += -ya * denomb * denomr * denomr;\n        // y = y - 1/y\n        temp = ya + ra;\n        yb += -(temp - ya - ra);\n        ya = temp;\n        temp = ya + rb;\n        yb += -(temp - ya - rb);\n        ya = temp;\n        result = ya + yb;\n        result *= 0.5;\n    }\n    if (negate) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "tanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic tangent of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic tangent of x\n */\npublic static double tanh(double x) {\n    boolean negate = false;\n    if (x != x) {\n        return x;\n    }\n    // tanh[z] = sinh[z] / cosh[z]\n    // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n    // = (exp(2x) - 1) / (exp(2x) + 1)\n    // for magnitude > 20, sinh[z] == cosh[z] in double precision\n    if (x > 20.0) {\n        return 1.0;\n    }\n    if (x < -20) {\n        return -1.0;\n    }\n    if (x == 0) {\n        return x;\n    }\n    if (x < 0.0) {\n        x = -x;\n        negate = true;\n    }\n    double result;\n    if (x >= 0.5) {\n        double[] hiPrec = new double[2];\n        // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n        exp(x * 2.0, 0.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Numerator */\n        double na = -1.0 + ya;\n        double nb = -(na + 1.0 - ya);\n        double temp = na + yb;\n        nb += -(temp - na - yb);\n        na = temp;\n        /* Denominator */\n        double da = 1.0 + ya;\n        double db = -(da - 1.0 - ya);\n        temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n        result = ratioa + ratiob;\n    } else {\n        double[] hiPrec = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x * 2.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n        result = ratioa + ratiob;\n    }\n    if (negate) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "acosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic cosine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic cosine of a\n */\npublic static double acosh(final double a) {\n    return FastMath.log(a + FastMath.sqrt(a * a - 1));\n}"
            ],
            [
                "asinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic sine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic sine of a\n */\npublic static double asinh(double a) {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAsinh;\n    if (a > 0.167) {\n        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);\n        }\n    }\n    return negative ? -absAsinh : absAsinh;\n}"
            ],
            [
                "atanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic tangent of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic tangent of a\n */\npublic static double atanh(double a) {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.15) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n    return negative ? -absAtanh : absAtanh;\n}"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the signum of a number.\n * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\npublic static double signum(final double a) {\n    // return +0.0/-0.0/NaN depending on a\n    return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a);\n}"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the signum of a number.\n * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\npublic static float signum(final float a) {\n    // return +0.0/-0.0/NaN depending on a\n    return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a);\n}"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\npublic static double nextUp(final double a) {\n    return nextAfter(a, Double.POSITIVE_INFINITY);\n}"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\npublic static float nextUp(final float a) {\n    return nextAfter(a, Float.POSITIVE_INFINITY);\n}"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards negative infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards negative infinity\n * @since 3.4\n */\npublic static double nextDown(final double a) {\n    return nextAfter(a, Double.NEGATIVE_INFINITY);\n}"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards negative infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards negative infinity\n * @since 3.4\n */\npublic static float nextDown(final float a) {\n    return nextAfter(a, Float.NEGATIVE_INFINITY);\n}"
            ],
            [
                "random",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns a pseudo-random number between 0.0 and 1.0.\n * <p><b>Note:</b> this implementation currently delegates to {@link Math#random}\n * @return a random number between 0.0 and 1.0\n */\npublic static double random() {\n    return Math.random();\n}"
            ],
            [
                "exp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Exponential function.\n *\n * Computes exp(x), function result is nearly rounded.   It will be correctly\n * rounded to the theoretical value for 99.9% of input values, otherwise it will\n * have a 1 ULP error.\n *\n * Method:\n *    Lookup intVal = exp(int(x))\n *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );\n *    Compute z as the exponential of the remaining bits by a polynomial minus one\n *    exp(x) = intVal * fracVal * (1 + z)\n *\n * Accuracy:\n *    Calculation is done with 63 bits of precision, so result should be correctly\n *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n *\n * @param x   a double\n * @return double e<sup>x</sup>\n */\npublic static double exp(double x) {\n    return exp(x, 0.0, null);\n}"
            ],
            [
                "expm1",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute exp(x) - 1\n * @param x number to compute shifted exponential\n * @return exp(x) - 1\n */\npublic static double expm1(double x) {\n    return expm1(x, null);\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Natural logarithm.\n *\n * @param x   a double\n * @return log(x)\n */\npublic static double log(final double x) {\n    return log(x, null);\n}"
            ],
            [
                "log1p",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes log(1 + x).\n *\n * @param x Number.\n * @return {@code log(1 + x)}.\n */\npublic static double log1p(final double x) {\n    if (x == -1) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (x == Double.POSITIVE_INFINITY) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (x > 1e-6 || x < -1e-6) {\n        final double xpa = 1 + x;\n        final double xpb = -(xpa - 1 - x);\n        final double[] hiPrec = new double[2];\n        final double lores = log(xpa, hiPrec);\n        if (Double.isInfinite(lores)) {\n            // Don't allow this to be converted to NaN\n            return lores;\n        }\n        // Do a taylor series expansion around xpa:\n        //   f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2\n        final double fx1 = xpb / xpa;\n        final double epsilon = 0.5 * fx1 + 1;\n        return epsilon * fx1 + hiPrec[1] + hiPrec[0];\n    } else {\n        // Value is small |x| < 1e6, do a Taylor series centered on 1.\n        final double y = (x * F_1_3 - F_1_2) * x + 1;\n        return y * x;\n    }\n}"
            ],
            [
                "log10",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the base 10 logarithm.\n * @param x a number\n * @return log10(x)\n */\npublic static double log10(final double x) {\n    final double[] hiPrec = new double[2];\n    final double lores = log(x, hiPrec);\n    if (Double.isInfinite(lores)) {\n        // don't allow this to be converted to NaN\n        return lores;\n    }\n    final double tmp = hiPrec[0] * HEX_40000000;\n    final double lna = hiPrec[0] + tmp - tmp;\n    final double lnb = hiPrec[0] - lna + hiPrec[1];\n    final double rln10a = 0.4342944622039795;\n    final double rln10b = 1.9699272335463627E-8;\n    return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes the <a href=\"http://mathworld.wolfram.com/Logarithm.html\">\n * logarithm</a> in a given base.\n *\n * Returns {@code NaN} if either argument is negative.\n * If {@code base} is 0 and {@code x} is positive, 0 is returned.\n * If {@code base} is positive and {@code x} is 0,\n * {@code Double.NEGATIVE_INFINITY} is returned.\n * If both arguments are 0, the result is {@code NaN}.\n *\n * @param base Base of the logarithm, must be greater than 0.\n * @param x Argument, must be greater than 0.\n * @return the value of the logarithm, i.e. the number {@code y} such that\n * <code>base<sup>y</sup> = x</code>.\n * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double log(double base, double x) {\n    return log(x) / log(base);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Power function.  Compute x^y.\n *\n * @param x   a double\n * @param y   a double\n * @return double\n */\npublic static double pow(final double x, final double y) {\n    if (y == 0) {\n        // y = -0 or y = +0\n        return 1.0;\n    } else {\n        final long yBits = Double.doubleToRawLongBits(y);\n        final int yRawExp = (int) ((yBits & MASK_DOUBLE_EXPONENT) >> 52);\n        final long yRawMantissa = yBits & MASK_DOUBLE_MANTISSA;\n        final long xBits = Double.doubleToRawLongBits(x);\n        final int xRawExp = (int) ((xBits & MASK_DOUBLE_EXPONENT) >> 52);\n        final long xRawMantissa = xBits & MASK_DOUBLE_MANTISSA;\n        if (yRawExp > 1085) {\n            // y is either a very large integral value that does not fit in a long or it is a special number\n            if ((yRawExp == 2047 && yRawMantissa != 0) || (xRawExp == 2047 && xRawMantissa != 0)) {\n                // NaN\n                return Double.NaN;\n            } else if (xRawExp == 1023 && xRawMantissa == 0) {\n                // x = -1.0 or x = +1.0\n                if (yRawExp == 2047) {\n                    // y is infinite\n                    return Double.NaN;\n                } else {\n                    // y is a large even integer\n                    return 1.0;\n                }\n            } else {\n                // the absolute value of x is either greater or smaller than 1.0\n                // if yRawExp == 2047 and mantissa is 0, y = -infinity or y = +infinity\n                // if 1085 < yRawExp < 2047, y is simply a large number, however, due to limited\n                // accuracy, at this magnitude it behaves just like infinity with regards to x\n                if ((y > 0) ^ (xRawExp < 1023)) {\n                    // either y = +infinity (or large engouh) and abs(x) > 1.0\n                    // or     y = -infinity (or large engouh) and abs(x) < 1.0\n                    return Double.POSITIVE_INFINITY;\n                } else {\n                    // either y = +infinity (or large engouh) and abs(x) < 1.0\n                    // or     y = -infinity (or large engouh) and abs(x) > 1.0\n                    return +0.0;\n                }\n            }\n        } else {\n            // y is a regular non-zero number\n            if (yRawExp >= 1023) {\n                // y may be an integral value, which should be handled specifically\n                final long yFullMantissa = IMPLICIT_HIGH_BIT | yRawMantissa;\n                if (yRawExp < 1075) {\n                    // normal number with negative shift that may have a fractional part\n                    final long integralMask = (-1L) << (1075 - yRawExp);\n                    if ((yFullMantissa & integralMask) == yFullMantissa) {\n                        // all fractional bits are 0, the number is really integral\n                        final long l = yFullMantissa >> (1075 - yRawExp);\n                        return FastMath.pow(x, (y < 0) ? -l : l);\n                    }\n                } else {\n                    // normal number with positive shift, always an integral value\n                    // we know it fits in a primitive long because yRawExp > 1085 has been handled above\n                    final long l = yFullMantissa << (yRawExp - 1075);\n                    return FastMath.pow(x, (y < 0) ? -l : l);\n                }\n            }\n            // y is a non-integral value\n            if (x == 0) {\n                // x = -0 or x = +0\n                // the integer powers have already been handled above\n                return y < 0 ? Double.POSITIVE_INFINITY : +0.0;\n            } else if (xRawExp == 2047) {\n                if (xRawMantissa == 0) {\n                    // x = -infinity or x = +infinity\n                    return (y < 0) ? +0.0 : Double.POSITIVE_INFINITY;\n                } else {\n                    // NaN\n                    return Double.NaN;\n                }\n            } else if (x < 0) {\n                // the integer powers have already been handled above\n                return Double.NaN;\n            } else {\n                // this is the general case, for regular fractional numbers x and y\n                // Split y into ya and yb such that y = ya+yb\n                final double tmp = y * HEX_40000000;\n                final double ya = (y + tmp) - tmp;\n                final double yb = y - ya;\n                /* Compute ln(x) */\n                final double[] lns = new double[2];\n                final double lores = log(x, lns);\n                if (Double.isInfinite(lores)) {\n                    // don't allow this to be converted to NaN\n                    return lores;\n                }\n                double lna = lns[0];\n                double lnb = lns[1];\n                /* resplit lns */\n                final double tmp1 = lna * HEX_40000000;\n                final double tmp2 = (lna + tmp1) - tmp1;\n                lnb += lna - tmp2;\n                lna = tmp2;\n                // y*ln(x) = (aa+ab)\n                final double aa = lna * ya;\n                final double ab = lna * yb + lnb * ya + lnb * yb;\n                lna = aa + ab;\n                lnb = -(lna - aa - ab);\n                double z = 1.0 / 120.0;\n                z = z * lnb + (1.0 / 24.0);\n                z = z * lnb + (1.0 / 6.0);\n                z = z * lnb + 0.5;\n                z = z * lnb + 1.0;\n                z *= lnb;\n                final double result = exp(lna, z, null);\n                //result = result + result * z;\n                return result;\n            }\n        }\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Raise a double to an int power.\n *\n * @param d Number to raise.\n * @param e Exponent.\n * @return d<sup>e</sup>\n * @since 3.1\n */\npublic static double pow(double d, int e) {\n    return pow(d, (long) e);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Raise a double to a long power.\n *\n * @param d Number to raise.\n * @param e Exponent.\n * @return d<sup>e</sup>\n * @since 3.6\n */\npublic static double pow(double d, long e) {\n    if (e == 0) {\n        return 1.0;\n    } else if (e > 0) {\n        return new Split(d).pow(e).full;\n    } else {\n        return new Split(d).reciprocal().pow(-e).full;\n    }\n}"
            ],
            [
                "sin",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Sine function.\n *\n * @param x Argument.\n * @return sin(x)\n */\npublic static double sin(double x) {\n    boolean negative = false;\n    int quadrant = 0;\n    double xa;\n    double xb = 0.0;\n    /* Take absolute value of the input */\n    xa = x;\n    if (x < 0) {\n        negative = true;\n        xa = -xa;\n    }\n    /* Check for zero and negative zero */\n    if (xa == 0.0) {\n        long bits = Double.doubleToRawLongBits(x);\n        if (bits < 0) {\n            return -0.0;\n        }\n        return 0.0;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    if (negative) {\n        // Flip bit 1\n        quadrant ^= 2;\n    }\n    switch(quadrant) {\n        case 0:\n            return sinQ(xa, xb);\n        case 1:\n            return cosQ(xa, xb);\n        case 2:\n            return -sinQ(xa, xb);\n        case 3:\n            return -cosQ(xa, xb);\n        default:\n            return Double.NaN;\n    }\n}"
            ],
            [
                "cos",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Cosine function.\n *\n * @param x Argument.\n * @return cos(x)\n */\npublic static double cos(double x) {\n    int quadrant = 0;\n    /* Take absolute value of the input */\n    double xa = x;\n    if (x < 0) {\n        xa = -xa;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    double xb = 0;\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    //if (negative)\n    //  quadrant = (quadrant + 2) % 4;\n    switch(quadrant) {\n        case 0:\n            return cosQ(xa, xb);\n        case 1:\n            return -sinQ(xa, xb);\n        case 2:\n            return -cosQ(xa, xb);\n        case 3:\n            return sinQ(xa, xb);\n        default:\n            return Double.NaN;\n    }\n}"
            ],
            [
                "tan",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Tangent function.\n *\n * @param x Argument.\n * @return tan(x)\n */\npublic static double tan(double x) {\n    boolean negative = false;\n    int quadrant = 0;\n    /* Take absolute value of the input */\n    double xa = x;\n    if (x < 0) {\n        negative = true;\n        xa = -xa;\n    }\n    /* Check for zero and negative zero */\n    if (xa == 0.0) {\n        long bits = Double.doubleToRawLongBits(x);\n        if (bits < 0) {\n            return -0.0;\n        }\n        return 0.0;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    double xb = 0;\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    if (xa > 1.5) {\n        // Accuracy suffers between 1.5 and PI/2\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n        xa = a + b;\n        xb = -(xa - a - b);\n        quadrant ^= 1;\n        negative ^= true;\n    }\n    double result;\n    if ((quadrant & 1) == 0) {\n        result = tanQ(xa, xb, false);\n    } else {\n        result = -tanQ(xa, xb, true);\n    }\n    if (negative) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "atan",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Arctangent function\n *  @param x a number\n *  @return atan(x)\n */\npublic static double atan(double x) {\n    return atan(x, 0.0, false);\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Two arguments arctangent function\n * @param y ordinate\n * @param x abscissa\n * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\n */\npublic static double atan2(double y, double x) {\n    if (x != x || y != y) {\n        return Double.NaN;\n    }\n    if (y == 0) {\n        final double result = x * y;\n        final double invx = 1d / x;\n        final double invy = 1d / y;\n        if (invx == 0) {\n            // X is infinite\n            if (x > 0) {\n                // return +/- 0.0\n                return y;\n            } else {\n                return copySign(Math.PI, y);\n            }\n        }\n        if (x < 0 || invx < 0) {\n            if (y < 0 || invy < 0) {\n                return -Math.PI;\n            } else {\n                return Math.PI;\n            }\n        } else {\n            return result;\n        }\n    }\n    // y cannot now be zero\n    if (y == Double.POSITIVE_INFINITY) {\n        if (x == Double.POSITIVE_INFINITY) {\n            return Math.PI * F_1_4;\n        }\n        if (x == Double.NEGATIVE_INFINITY) {\n            return Math.PI * F_3_4;\n        }\n        return Math.PI * F_1_2;\n    }\n    if (y == Double.NEGATIVE_INFINITY) {\n        if (x == Double.POSITIVE_INFINITY) {\n            return -Math.PI * F_1_4;\n        }\n        if (x == Double.NEGATIVE_INFINITY) {\n            return -Math.PI * F_3_4;\n        }\n        return -Math.PI * F_1_2;\n    }\n    if (x == Double.POSITIVE_INFINITY) {\n        if (y > 0 || 1 / y > 0) {\n            return 0d;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -0d;\n        }\n    }\n    if (x == Double.NEGATIVE_INFINITY) {\n        if (y > 0.0 || 1 / y > 0.0) {\n            return Math.PI;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -Math.PI;\n        }\n    }\n    // Neither y nor x can be infinite or NAN here\n    if (x == 0) {\n        if (y > 0 || 1 / y > 0) {\n            return Math.PI * F_1_2;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -Math.PI * F_1_2;\n        }\n    }\n    // Compute ratio r = y/x\n    final double r = y / x;\n    if (Double.isInfinite(r)) {\n        // bypass calculations that can create NaN\n        return atan(r, 0, x < 0);\n    }\n    double ra = doubleHighPart(r);\n    double rb = r - ra;\n    // Split x\n    final double xa = doubleHighPart(x);\n    final double xb = x - xa;\n    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n    final double temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    if (ra == 0) {\n        // Fix up the sign so atan works correctly\n        ra = copySign(0d, y);\n    }\n    // Call atan\n    final double result = atan(ra, rb, x < 0);\n    return result;\n}"
            ],
            [
                "asin",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the arc sine of a number.\n * @param x number on which evaluation is done\n * @return arc sine of x\n */\npublic static double asin(double x) {\n    if (x != x) {\n        return Double.NaN;\n    }\n    if (x > 1.0 || x < -1.0) {\n        return Double.NaN;\n    }\n    if (x == 1.0) {\n        return Math.PI / 2.0;\n    }\n    if (x == -1.0) {\n        return -Math.PI / 2.0;\n    }\n    if (x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n    /* Split x */\n    double temp = x * HEX_40000000;\n    final double xa = x + temp - temp;\n    final double xb = x - xa;\n    /* Square it */\n    double ya = xa * xa;\n    double yb = xa * xb * 2.0 + xb * xb;\n    /* Subtract from 1 */\n    ya = -ya;\n    yb = -yb;\n    double za = 1.0 + ya;\n    double zb = -(za - 1.0 - ya);\n    temp = za + yb;\n    zb += -(temp - za - yb);\n    za = temp;\n    /* Square root */\n    double y;\n    y = sqrt(za);\n    temp = y * HEX_40000000;\n    ya = y + temp - temp;\n    yb = y - ya;\n    /* Extend precision of sqrt */\n    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);\n    /* Contribution of zb to sqrt */\n    double dx = zb / (2.0 * y);\n    // Compute ratio r = x/y\n    double r = x / y;\n    temp = r * HEX_40000000;\n    double ra = r + temp - temp;\n    double rb = r - ra;\n    // Correct for rounding in division\n    rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y;\n    // Add in effect additional bits of sqrt.\n    rb += -x * dx / y / y;\n    temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    return atan(ra, rb, false);\n}"
            ],
            [
                "acos",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the arc cosine of a number.\n * @param x number on which evaluation is done\n * @return arc cosine of x\n */\npublic static double acos(double x) {\n    if (x != x) {\n        return Double.NaN;\n    }\n    if (x > 1.0 || x < -1.0) {\n        return Double.NaN;\n    }\n    if (x == -1.0) {\n        return Math.PI;\n    }\n    if (x == 1.0) {\n        return 0.0;\n    }\n    if (x == 0) {\n        return Math.PI / 2.0;\n    }\n    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n    /* Split x */\n    double temp = x * HEX_40000000;\n    final double xa = x + temp - temp;\n    final double xb = x - xa;\n    /* Square it */\n    double ya = xa * xa;\n    double yb = xa * xb * 2.0 + xb * xb;\n    /* Subtract from 1 */\n    ya = -ya;\n    yb = -yb;\n    double za = 1.0 + ya;\n    double zb = -(za - 1.0 - ya);\n    temp = za + yb;\n    zb += -(temp - za - yb);\n    za = temp;\n    /* Square root */\n    double y = sqrt(za);\n    temp = y * HEX_40000000;\n    ya = y + temp - temp;\n    yb = y - ya;\n    /* Extend precision of sqrt */\n    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);\n    /* Contribution of zb to sqrt */\n    yb += zb / (2.0 * y);\n    y = ya + yb;\n    yb = -(y - ya - yb);\n    // Compute ratio r = y/x\n    double r = y / x;\n    // Did r overflow?\n    if (Double.isInfinite(r)) {\n        // x is effectively zero\n        // so return the appropriate value\n        return Math.PI / 2;\n    }\n    double ra = doubleHighPart(r);\n    double rb = r - ra;\n    // Correct for rounding in division\n    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n    // Add in effect additional bits of sqrt.\n    rb += yb / x;\n    temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    return atan(ra, rb, x < 0);\n}"
            ],
            [
                "cbrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the cubic root of a number.\n * @param x number on which evaluation is done\n * @return cubic root of x\n */\npublic static double cbrt(double x) {\n    /* Convert input double to bits */\n    long inbits = Double.doubleToRawLongBits(x);\n    int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n    boolean subnormal = false;\n    if (exponent == -1023) {\n        if (x == 0) {\n            return x;\n        }\n        /* Subnormal, so normalize */\n        subnormal = true;\n        // 2^54\n        x *= 1.8014398509481984E16;\n        inbits = Double.doubleToRawLongBits(x);\n        exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n    }\n    if (exponent == 1024) {\n        // Nan or infinity.  Don't care which.\n        return x;\n    }\n    /* Divide the exponent by 3 */\n    int exp3 = exponent / 3;\n    /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\n    double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long) (((exp3 + 1023) & 0x7ff)) << 52);\n    /* This will be a number between 1 and 2 */\n    final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n    /* Estimate the cube root of mant by polynomial */\n    double est = -0.010714690733195933;\n    est = est * mant + 0.0875862700108075;\n    est = est * mant + -0.3058015757857271;\n    est = est * mant + 0.7249995199969751;\n    est = est * mant + 0.5039018405998233;\n    est *= CBRTTWO[exponent % 3 + 2];\n    // est should now be good to about 15 bits of precision.   Do 2 rounds of\n    // Newton's method to get closer,  this should get us full double precision\n    // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n    final double xs = x / (p2 * p2 * p2);\n    est += (xs - est * est * est) / (3 * est * est);\n    est += (xs - est * est * est) / (3 * est * est);\n    // Do one round of Newton's method in extended precision to get the last bit right.\n    double temp = est * HEX_40000000;\n    double ya = est + temp - temp;\n    double yb = est - ya;\n    double za = ya * ya;\n    double zb = ya * yb * 2.0 + yb * yb;\n    temp = za * HEX_40000000;\n    double temp2 = za + temp - temp;\n    zb += za - temp2;\n    za = temp2;\n    zb = za * yb + ya * zb + zb * yb;\n    za *= ya;\n    double na = xs - za;\n    double nb = -(na - xs + za);\n    nb -= zb;\n    est += (na + nb) / (3 * est * est);\n    /* Scale by a power of two, so this is exact. */\n    est *= p2;\n    if (subnormal) {\n        // 2^-18\n        est *= 3.814697265625E-6;\n    }\n    return est;\n}"
            ],
            [
                "toRadians",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n *  Convert degrees to radians, with error of less than 0.5 ULP\n *  @param x angle in degrees\n *  @return x converted into radians\n */\npublic static double toRadians(double x) {\n    if (Double.isInfinite(x) || x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    // These are PI/180 split into high and low order bits\n    final double facta = 0.01745329052209854;\n    final double factb = 1.997844754509471E-9;\n    double xa = doubleHighPart(x);\n    double xb = x - xa;\n    double result = xb * factb + xb * facta + xa * factb + xa * facta;\n    if (result == 0) {\n        // ensure correct sign if calculation underflows\n        result *= x;\n    }\n    return result;\n}"
            ],
            [
                "toDegrees",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n *  Convert radians to degrees, with error of less than 0.5 ULP\n *  @param x angle in radians\n *  @return x converted into degrees\n */\npublic static double toDegrees(double x) {\n    if (Double.isInfinite(x) || x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    // These are 180/PI split into high and low order bits\n    final double facta = 57.2957763671875;\n    final double factb = 3.145894820876798E-6;\n    double xa = doubleHighPart(x);\n    double xb = x - xa;\n    return xb * factb + xb * facta + xa * factb + xa * facta;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static int abs(final int x) {\n    final int i = x >>> 31;\n    return (x ^ (~i + 1)) + i;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static long abs(final long x) {\n    final long l = x >>> 63;\n    // l is one if x negative zero else\n    // ~l+1 is zero if x is positive, -1 if x is negative\n    // x^(~l+1) is x is x is positive, ~x if x is negative\n    // add around\n    return (x ^ (~l + 1)) + l;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static float abs(final float x) {\n    return Float.intBitsToFloat(MASK_NON_SIGN_INT & Float.floatToRawIntBits(x));\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static double abs(double x) {\n    return Double.longBitsToDouble(MASK_NON_SIGN_LONG & Double.doubleToRawLongBits(x));\n}"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\npublic static double ulp(double x) {\n    if (Double.isInfinite(x)) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1));\n}"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\npublic static float ulp(float x) {\n    if (Float.isInfinite(x)) {\n        return Float.POSITIVE_INFINITY;\n    }\n    return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));\n}"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply a double number by a power of 2.\n * @param d number to multiply\n * @param n power of 2\n * @return d &times; 2<sup>n</sup>\n */\npublic static double scalb(final double d, final int n) {\n    // first simple and fast handling when 2^n can be represented using normal numbers\n    if ((n > -1023) && (n < 1024)) {\n        return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n    }\n    // handle special cases\n    if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n        return d;\n    }\n    if (n < -2098) {\n        return (d > 0) ? 0.0 : -0.0;\n    }\n    if (n > 2097) {\n        return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n    }\n    // decompose d\n    final long bits = Double.doubleToRawLongBits(d);\n    final long sign = bits & 0x8000000000000000L;\n    int exponent = ((int) (bits >>> 52)) & 0x7ff;\n    long mantissa = bits & 0x000fffffffffffffL;\n    // compute scaled exponent\n    int scaledExponent = exponent + n;\n    if (n < 0) {\n        // we are really in the case n <= -1023\n        if (scaledExponent > 0) {\n            // both the input and the result are normal numbers, we only adjust the exponent\n            return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n        } else if (scaledExponent > -53) {\n            // the input is a normal number and the result is a subnormal number\n            // recover the hidden mantissa bit\n            mantissa |= 1L << 52;\n            // scales down complete mantissa, hence losing least significant bits\n            final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n            mantissa >>>= 1 - scaledExponent;\n            if (mostSignificantLostBit != 0) {\n                // we need to add 1 bit to round up the result\n                mantissa++;\n            }\n            return Double.longBitsToDouble(sign | mantissa);\n        } else {\n            // no need to compute the mantissa, the number scales down to 0\n            return (sign == 0L) ? 0.0 : -0.0;\n        }\n    } else {\n        // we are really in the case n >= 1024\n        if (exponent == 0) {\n            // the input number is subnormal, normalize it\n            while ((mantissa >>> 52) != 1) {\n                mantissa <<= 1;\n                --scaledExponent;\n            }\n            ++scaledExponent;\n            mantissa &= 0x000fffffffffffffL;\n            if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        } else if (scaledExponent < 2047) {\n            return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n        } else {\n            return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n    }\n}"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply a float number by a power of 2.\n * @param f number to multiply\n * @param n power of 2\n * @return f &times; 2<sup>n</sup>\n */\npublic static float scalb(final float f, final int n) {\n    // first simple and fast handling when 2^n can be represented using normal numbers\n    if ((n > -127) && (n < 128)) {\n        return f * Float.intBitsToFloat((n + 127) << 23);\n    }\n    // handle special cases\n    if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n        return f;\n    }\n    if (n < -277) {\n        return (f > 0) ? 0.0f : -0.0f;\n    }\n    if (n > 276) {\n        return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n    }\n    // decompose f\n    final int bits = Float.floatToIntBits(f);\n    final int sign = bits & 0x80000000;\n    int exponent = (bits >>> 23) & 0xff;\n    int mantissa = bits & 0x007fffff;\n    // compute scaled exponent\n    int scaledExponent = exponent + n;\n    if (n < 0) {\n        // we are really in the case n <= -127\n        if (scaledExponent > 0) {\n            // both the input and the result are normal numbers, we only adjust the exponent\n            return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n        } else if (scaledExponent > -24) {\n            // the input is a normal number and the result is a subnormal number\n            // recover the hidden mantissa bit\n            mantissa |= 1 << 23;\n            // scales down complete mantissa, hence losing least significant bits\n            final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n            mantissa >>>= 1 - scaledExponent;\n            if (mostSignificantLostBit != 0) {\n                // we need to add 1 bit to round up the result\n                mantissa++;\n            }\n            return Float.intBitsToFloat(sign | mantissa);\n        } else {\n            // no need to compute the mantissa, the number scales down to 0\n            return (sign == 0) ? 0.0f : -0.0f;\n        }\n    } else {\n        // we are really in the case n >= 128\n        if (exponent == 0) {\n            // the input number is subnormal, normalize it\n            while ((mantissa >>> 23) != 1) {\n                mantissa <<= 1;\n                --scaledExponent;\n            }\n            ++scaledExponent;\n            mantissa &= 0x007fffff;\n            if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        } else if (scaledExponent < 255) {\n            return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n        } else {\n            return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n    }\n}"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the next machine representable number after a number, moving\n * in the direction of another number.\n * <p>\n * The ordering is as follows (increasing):\n * <ul>\n * <li>-INFINITY</li>\n * <li>-MAX_VALUE</li>\n * <li>-MIN_VALUE</li>\n * <li>-0.0</li>\n * <li>+0.0</li>\n * <li>+MIN_VALUE</li>\n * <li>+MAX_VALUE</li>\n * <li>+INFINITY</li>\n * <li></li>\n * <p>\n * If arguments compare equal, then the second argument is returned.\n * <p>\n * If {@code direction} is greater than {@code d},\n * the smallest machine representable number strictly greater than\n * {@code d} is returned; if less, then the largest representable number\n * strictly less than {@code d} is returned.</p>\n * <p>\n * If {@code d} is infinite and direction does not\n * bring it back to finite numbers, it is returned unchanged.</p>\n *\n * @param d base number\n * @param direction (the only important thing is whether\n * {@code direction} is greater or smaller than {@code d})\n * @return the next machine representable number in the specified direction\n */\npublic static double nextAfter(double d, double direction) {\n    // handling of some important special cases\n    if (Double.isNaN(d) || Double.isNaN(direction)) {\n        return Double.NaN;\n    } else if (d == direction) {\n        return direction;\n    } else if (Double.isInfinite(d)) {\n        return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n    } else if (d == 0) {\n        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n    }\n    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n    // are handled just as normal numbers\n    // can use raw bits since already dealt with infinity and NaN\n    final long bits = Double.doubleToRawLongBits(d);\n    final long sign = bits & 0x8000000000000000L;\n    if ((direction < d) ^ (sign == 0L)) {\n        return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n    } else {\n        return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n    }\n}"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the next machine representable number after a number, moving\n * in the direction of another number.\n * <p>\n * The ordering is as follows (increasing):\n * <ul>\n * <li>-INFINITY</li>\n * <li>-MAX_VALUE</li>\n * <li>-MIN_VALUE</li>\n * <li>-0.0</li>\n * <li>+0.0</li>\n * <li>+MIN_VALUE</li>\n * <li>+MAX_VALUE</li>\n * <li>+INFINITY</li>\n * <li></li>\n * <p>\n * If arguments compare equal, then the second argument is returned.\n * <p>\n * If {@code direction} is greater than {@code f},\n * the smallest machine representable number strictly greater than\n * {@code f} is returned; if less, then the largest representable number\n * strictly less than {@code f} is returned.</p>\n * <p>\n * If {@code f} is infinite and direction does not\n * bring it back to finite numbers, it is returned unchanged.</p>\n *\n * @param f base number\n * @param direction (the only important thing is whether\n * {@code direction} is greater or smaller than {@code f})\n * @return the next machine representable number in the specified direction\n */\npublic static float nextAfter(final float f, final double direction) {\n    // handling of some important special cases\n    if (Double.isNaN(f) || Double.isNaN(direction)) {\n        return Float.NaN;\n    } else if (f == direction) {\n        return (float) direction;\n    } else if (Float.isInfinite(f)) {\n        return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n    } else if (f == 0f) {\n        return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n    }\n    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n    // are handled just as normal numbers\n    final int bits = Float.floatToIntBits(f);\n    final int sign = bits & 0x80000000;\n    if ((direction < f) ^ (sign == 0)) {\n        return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n    } else {\n        return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1));\n    }\n}"
            ],
            [
                "floor",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the largest whole number smaller than x.\n * @param x number from which floor is requested\n * @return a double number f such that f is an integer f <= x < f + 1.0\n */\npublic static double floor(double x) {\n    long y;\n    if (x != x) {\n        // NaN\n        return x;\n    }\n    if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n        return x;\n    }\n    y = (long) x;\n    if (x < 0 && y != x) {\n        y--;\n    }\n    if (y == 0) {\n        return x * y;\n    }\n    return y;\n}"
            ],
            [
                "ceil",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the smallest whole number larger than x.\n * @param x number from which ceil is requested\n * @return a double number c such that c is an integer c - 1.0 < x <= c\n */\npublic static double ceil(double x) {\n    double y;\n    if (x != x) {\n        // NaN\n        return x;\n    }\n    y = floor(x);\n    if (y == x) {\n        return y;\n    }\n    y += 1.0;\n    if (y == 0) {\n        return x * y;\n    }\n    return y;\n}"
            ],
            [
                "rint",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\n * @param x number from which nearest whole number is requested\n * @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5\n */\npublic static double rint(double x) {\n    double y = floor(x);\n    double d = x - y;\n    if (d > 0.5) {\n        if (y == -1.0) {\n            // Preserve sign of operand\n            return -0.0;\n        }\n        return y + 1.0;\n    }\n    if (d < 0.5) {\n        return y;\n    }\n    /* half way, round to even */\n    long z = (long) y;\n    return (z & 1) == 0 ? y : y + 1.0;\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the closest long to x.\n * @param x number from which closest long is requested\n * @return closest long to x\n */\npublic static long round(double x) {\n    return (long) floor(x + 0.5);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the closest int to x.\n * @param x number from which closest int is requested\n * @return closest int to x\n */\npublic static int round(final float x) {\n    return (int) floor(x + 0.5f);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static int min(final int a, final int b) {\n    return (a <= b) ? a : b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static long min(final long a, final long b) {\n    return (a <= b) ? a : b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static float min(final float a, final float b) {\n    if (a > b) {\n        return b;\n    }\n    if (a < b) {\n        return a;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Float.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */\n    int bits = Float.floatToRawIntBits(a);\n    if (bits == 0x80000000) {\n        return a;\n    }\n    return b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static double min(final double a, final double b) {\n    if (a > b) {\n        return b;\n    }\n    if (a < b) {\n        return a;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Double.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n    long bits = Double.doubleToRawLongBits(a);\n    if (bits == 0x8000000000000000L) {\n        return a;\n    }\n    return b;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static int max(final int a, final int b) {\n    return (a <= b) ? b : a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static long max(final long a, final long b) {\n    return (a <= b) ? b : a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static float max(final float a, final float b) {\n    if (a > b) {\n        return a;\n    }\n    if (a < b) {\n        return b;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Float.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */\n    int bits = Float.floatToRawIntBits(a);\n    if (bits == 0x80000000) {\n        return b;\n    }\n    return a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static double max(final double a, final double b) {\n    if (a > b) {\n        return a;\n    }\n    if (a < b) {\n        return b;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Double.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n    long bits = Double.doubleToRawLongBits(a);\n    if (bits == 0x8000000000000000L) {\n        return b;\n    }\n    return a;\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n */\npublic static double hypot(final double x, final double y) {\n    if (Double.isInfinite(x) || Double.isInfinite(y)) {\n        return Double.POSITIVE_INFINITY;\n    } else if (Double.isNaN(x) || Double.isNaN(y)) {\n        return Double.NaN;\n    } else {\n        final int expX = getExponent(x);\n        final int expY = getExponent(y);\n        if (expX > expY + 27) {\n            // y is neglectible with respect to x\n            return abs(x);\n        } else if (expY > expX + 27) {\n            // x is neglectible with respect to y\n            return abs(y);\n        } else {\n            // find an intermediate scale to avoid both overflow and underflow\n            final int middleExp = (expX + expY) / 2;\n            // scale parameters without losing precision\n            final double scaledX = scalb(x, -middleExp);\n            final double scaledY = scalb(y, -middleExp);\n            // compute scaled hypotenuse\n            final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n            // remove scaling\n            return scalb(scaledH, middleExp);\n        }\n    }\n}"
            ],
            [
                "IEEEremainder",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes the remainder as prescribed by the IEEE 754 standard.\n * The remainder value is mathematically equal to {@code x - y*n}\n * where {@code n} is the mathematical integer closest to the exact mathematical value\n * of the quotient {@code x/y}.\n * If two mathematical integers are equally close to {@code x/y} then\n * {@code n} is the integer that is even.\n * <p>\n * <ul>\n * <li>If either operand is NaN, the result is NaN.</li>\n * <li>If the result is not NaN, the sign of the result equals the sign of the dividend.</li>\n * <li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.</li>\n * <li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</li>\n * <li>If the dividend is a zero and the divisor is finite, the result equals the dividend.</li>\n * </ul>\n * <p><b>Note:</b> this implementation currently delegates to {@link StrictMath#IEEEremainder}\n * @param dividend the number to be divided\n * @param divisor the number by which to divide\n * @return the remainder, rounded\n */\npublic static double IEEEremainder(double dividend, double divisor) {\n    // TODO provide our own implementation\n    return StrictMath.IEEEremainder(dividend, divisor);\n}"
            ],
            [
                "toIntExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Convert a long to interger, detecting overflows\n * @param n number to convert to int\n * @return integer with same valie as n if no overflows occur\n * @exception MathArithmeticException if n cannot fit into an int\n * @since 3.4\n */\npublic static int toIntExact(final long n) throws MathArithmeticException {\n    if (n < Integer.MIN_VALUE || n > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    }\n    return (int) n;\n}"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Increment a number, detecting overflows.\n * @param n number to increment\n * @return n+1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int incrementExact(final int n) throws MathArithmeticException {\n    if (n == Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);\n    }\n    return n + 1;\n}"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Increment a number, detecting overflows.\n * @param n number to increment\n * @return n+1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long incrementExact(final long n) throws MathArithmeticException {\n    if (n == Long.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);\n    }\n    return n + 1;\n}"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Decrement a number, detecting overflows.\n * @param n number to decrement\n * @return n-1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int decrementExact(final int n) throws MathArithmeticException {\n    if (n == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);\n    }\n    return n - 1;\n}"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Decrement a number, detecting overflows.\n * @param n number to decrement\n * @return n-1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long decrementExact(final long n) throws MathArithmeticException {\n    if (n == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);\n    }\n    return n - 1;\n}"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Add two numbers, detecting overflows.\n * @param a first number to add\n * @param b second number to add\n * @return a+b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int addExact(final int a, final int b) throws MathArithmeticException {\n    // compute sum\n    final int sum = a + b;\n    // check for overflow\n    if ((a ^ b) >= 0 && (sum ^ b) < 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);\n    }\n    return sum;\n}"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Add two numbers, detecting overflows.\n * @param a first number to add\n * @param b second number to add\n * @return a+b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long addExact(final long a, final long b) throws MathArithmeticException {\n    // compute sum\n    final long sum = a + b;\n    // check for overflow\n    if ((a ^ b) >= 0 && (sum ^ b) < 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);\n    }\n    return sum;\n}"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Subtract two numbers, detecting overflows.\n * @param a first number\n * @param b second number to subtract from a\n * @return a-b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int subtractExact(final int a, final int b) {\n    // compute subtraction\n    final int sub = a - b;\n    // check for overflow\n    if ((a ^ b) < 0 && (sub ^ b) >= 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);\n    }\n    return sub;\n}"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Subtract two numbers, detecting overflows.\n * @param a first number\n * @param b second number to subtract from a\n * @return a-b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long subtractExact(final long a, final long b) {\n    // compute subtraction\n    final long sub = a - b;\n    // check for overflow\n    if ((a ^ b) < 0 && (sub ^ b) >= 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);\n    }\n    return sub;\n}"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply two numbers, detecting overflows.\n * @param a first number to multiply\n * @param b second number to multiply\n * @return a*b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int multiplyExact(final int a, final int b) {\n    if (((b > 0) && (a > Integer.MAX_VALUE / b || a < Integer.MIN_VALUE / b)) || ((b < -1) && (a > Integer.MIN_VALUE / b || a < Integer.MAX_VALUE / b)) || ((b == -1) && (a == Integer.MIN_VALUE))) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);\n    }\n    return a * b;\n}"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply two numbers, detecting overflows.\n * @param a first number to multiply\n * @param b second number to multiply\n * @return a*b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long multiplyExact(final long a, final long b) {\n    if (((b > 0l) && (a > Long.MAX_VALUE / b || a < Long.MIN_VALUE / b)) || ((b < -1l) && (a > Long.MIN_VALUE / b || a < Long.MAX_VALUE / b)) || ((b == -1l) && (a == Long.MIN_VALUE))) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);\n    }\n    return a * b;\n}"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer division when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorMod(int, int)\n * @since 3.4\n */\npublic static int floorDiv(final int a, final int b) throws MathArithmeticException {\n    if (b == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final int m = a % b;\n    if ((a ^ b) >= 0 || m == 0) {\n        // a an b have same sign, or division is exact\n        return a / b;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return (a / b) - 1;\n    }\n}"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer division when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorMod(long, long)\n * @since 3.4\n */\npublic static long floorDiv(final long a, final long b) throws MathArithmeticException {\n    if (b == 0l) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final long m = a % b;\n    if ((a ^ b) >= 0l || m == 0l) {\n        // a an b have same sign, or division is exact\n        return a / b;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return (a / b) - 1l;\n    }\n}"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer modulo when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorDiv(int, int)\n * @since 3.4\n */\npublic static int floorMod(final int a, final int b) throws MathArithmeticException {\n    if (b == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final int m = a % b;\n    if ((a ^ b) >= 0 || m == 0) {\n        // a an b have same sign, or division is exact\n        return m;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return b + m;\n    }\n}"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer modulo when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorDiv(long, long)\n * @since 3.4\n */\npublic static long floorMod(final long a, final long b) {\n    if (b == 0l) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final long m = a % b;\n    if ((a ^ b) >= 0l || m == 0l) {\n        // a an b have same sign, or division is exact\n        return m;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return b + m;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the first argument with the sign of the second argument.\n * A NaN {@code sign} argument is treated as positive.\n *\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\npublic static double copySign(double magnitude, double sign) {\n    // The highest order bit is going to be zero if the\n    // highest order bit of m and s is the same and one otherwise.\n    // So (m^s) will be positive if both m and s have the same sign\n    // and negative otherwise.\n    // don't care about NaN\n    final long m = Double.doubleToRawLongBits(magnitude);\n    final long s = Double.doubleToRawLongBits(sign);\n    if ((m ^ s) >= 0) {\n        return magnitude;\n    }\n    // flip sign\n    return -magnitude;\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the first argument with the sign of the second argument.\n * A NaN {@code sign} argument is treated as positive.\n *\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\npublic static float copySign(float magnitude, float sign) {\n    // The highest order bit is going to be zero if the\n    // highest order bit of m and s is the same and one otherwise.\n    // So (m^s) will be positive if both m and s have the same sign\n    // and negative otherwise.\n    final int m = Float.floatToRawIntBits(magnitude);\n    final int s = Float.floatToRawIntBits(sign);\n    if ((m ^ s) >= 0) {\n        return magnitude;\n    }\n    // flip sign\n    return -magnitude;\n}"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Return the exponent of a double number, removing the bias.\n * <p>\n * For double numbers of the form 2<sup>x</sup>, the unbiased\n * exponent is exactly x.\n * </p>\n * @param d number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\npublic static int getExponent(final double d) {\n    // NaN and Infinite will return 1024 anywho so can use raw bits\n    return (int) ((Double.doubleToRawLongBits(d) >>> 52) & 0x7ff) - 1023;\n}"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Return the exponent of a float number, removing the bias.\n * <p>\n * For float numbers of the form 2<sup>x</sup>, the unbiased\n * exponent is exactly x.\n * </p>\n * @param f number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\npublic static int getExponent(final float f) {\n    // NaN and Infinite will return the same exponent anywho so can use raw bits\n    return ((Float.floatToRawIntBits(f) >>> 23) & 0xff) - 127;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "BigRealField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static BigRealField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "Decimal64Field",
                "/**\n * Returns the unique instance of this class.\n *\n * @return the unique instance of this class\n */\npublic static final Decimal64Field getInstance() {\n    return INSTANCE;\n}"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns an integer hash code representing the given double value.\n *\n * @param value the value to be hashed\n * @return the hash code\n */\npublic static int hash(double value) {\n    return new Double(value).hashCode();\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns {@code true} if the values are equal according to semantics of\n * {@link Double#equals(Object)}.\n *\n * @param x Value\n * @param y Value\n * @return {@code new Double(x).equals(new Double(y))}\n */\npublic static boolean equals(double x, double y) {\n    return new Double(x).equals(new Double(y));\n}"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns an integer hash code representing the given double array.\n *\n * @param value the value to be hashed (may be null)\n * @return the hash code\n * @since 1.2\n */\npublic static int hash(double[] value) {\n    return Arrays.hashCode(value);\n}"
            ],
            [
                "normalizeAngle",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Normalize an angle in a 2&pi; wide interval around a center value.\n * <p>This method has three main uses:</p>\n * <ul>\n *   <li>normalize an angle between 0 and 2&pi;:<br/>\n *       {@code a = MathUtils.normalizeAngle(a, FastMath.PI);}</li>\n *   <li>normalize an angle between -&pi; and +&pi;<br/>\n *       {@code a = MathUtils.normalizeAngle(a, 0.0);}</li>\n *   <li>compute the angle between two defining angular positions:<br>\n *       {@code angle = MathUtils.normalizeAngle(end, start) - start;}</li>\n * </ul>\n * <p>Note that due to numerical accuracy and since &pi; cannot be represented\n * exactly, the result interval is <em>closed</em>, it cannot be half-closed\n * as would be more satisfactory in a purely mathematical view.</p>\n * @param a angle to normalize\n * @param center center of the desired 2&pi; interval for the result\n * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;\n * @since 1.2\n */\npublic static double normalizeAngle(double a, double center) {\n    return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Find the maximum of two field elements.\n * @param <T> the type of the field elements\n * @param e1 first element\n * @param e2 second element\n * @return max(a1, e2)\n * @since 3.6\n */\npublic static <T extends RealFieldElement<T>> T max(final T e1, final T e2) {\n    return e1.subtract(e2).getReal() >= 0 ? e1 : e2;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Find the minimum of two field elements.\n * @param <T> the type of the field elements\n * @param e1 first element\n * @param e2 second element\n * @return min(a1, e2)\n * @since 3.6\n */\npublic static <T extends RealFieldElement<T>> T min(final T e1, final T e2) {\n    return e1.subtract(e2).getReal() >= 0 ? e2 : e1;\n}"
            ],
            [
                "reduce",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * <p>Reduce {@code |a - offset|} to the primary interval\n * {@code [0, |period|)}.</p>\n *\n * <p>Specifically, the value returned is <br/>\n * {@code a - |period| * floor((a - offset) / |period|) - offset}.</p>\n *\n * <p>If any of the parameters are {@code NaN} or infinite, the result is\n * {@code NaN}.</p>\n *\n * @param a Value to reduce.\n * @param period Period.\n * @param offset Value that will be mapped to {@code 0}.\n * @return the value, within the interval {@code [0 |period|)},\n * that corresponds to {@code a}.\n */\npublic static double reduce(double a, double period, double offset) {\n    final double p = FastMath.abs(period);\n    return a - p * FastMath.floor((a - offset) / p) - offset;\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Byte.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static byte copySign(byte magnitude, byte sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Byte.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return (byte) -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Short.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static short copySign(short magnitude, short sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Short.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return (short) -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Integer.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static int copySign(int magnitude, int sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Long.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static long copySign(long magnitude, long sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return -magnitude;\n    }\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getInstance()} with the only customizing that the\n * maximum number of fraction digits is set to 10.\n * @return the default number format.\n */\npublic static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n * customizing that the maximum number of fraction digits is set to 10.\n * @param locale the specific locale used by the format.\n * @return the default number format specific to the given locale.\n */\npublic static NumberFormat getDefaultNumberFormat(final Locale locale) {\n    final NumberFormat nf = NumberFormat.getInstance(locale);\n    nf.setMaximumFractionDigits(10);\n    return nf;\n}"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parses <code>source</code> until a non-whitespace character is found.\n *\n * @param source the string to parse\n * @param pos input/output parsing parameter.\n * @return the first non-whitespace character.\n */\npublic static char parseNextCharacter(final String source, final ParsePosition pos) {\n    int index = pos.getIndex();\n    final int n = source.length();\n    char ret = 0;\n    if (index < n) {\n        char c;\n        do {\n            c = source.charAt(index++);\n        } while (Character.isWhitespace(c) && index < n);\n        pos.setIndex(index);\n        if (index < n) {\n            ret = c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "parseNumber",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parses <code>source</code> for a number.  This method can parse normal,\n * numeric values as well as special values.  These special values include\n * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n *\n * @param source the string to parse\n * @param format the number format used to parse normal, numeric values.\n * @param pos input/output parsing parameter.\n * @return the parsed number.\n */\npublic static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos) {\n    final int startIndex = pos.getIndex();\n    Number number = format.parse(source, pos);\n    final int endIndex = pos.getIndex();\n    // check for error parsing number\n    if (startIndex == endIndex) {\n        // try parsing special numbers\n        final double[] special = { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY };\n        for (int i = 0; i < special.length; ++i) {\n            number = parseNumber(source, special[i], pos);\n            if (number != null) {\n                break;\n            }\n        }\n    }\n    return number;\n}"
            ],
            [
                "parseFixedstring",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parse <code>source</code> for an expected fixed string.\n * @param source the string to parse\n * @param expected expected string\n * @param pos input/output parsing parameter.\n * @return true if the expected string was there\n */\npublic static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos) {\n    final int startIndex = pos.getIndex();\n    final int endIndex = startIndex + expected.length();\n    if ((startIndex >= source.length()) || (endIndex > source.length()) || (source.substring(startIndex, endIndex).compareTo(expected) != 0)) {\n        // set index back to start, error index should be the start index\n        pos.setIndex(startIndex);\n        pos.setErrorIndex(startIndex);\n        return false;\n    }\n    // the string was here\n    pos.setIndex(endIndex);\n    return true;\n}"
            ],
            [
                "formatDouble",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Formats a double value to produce a string.  In general, the value is\n * formatted using the formatting rules of <code>format</code>.  There are\n * three exceptions to this:\n * <ol>\n * <li>NaN is formatted as '(NaN)'</li>\n * <li>Positive infinity is formatted as '(Infinity)'</li>\n * <li>Negative infinity is formatted as '(-Infinity)'</li>\n * </ol>\n *\n * @param value the double to format.\n * @param format the format used.\n * @param toAppendTo where the text is to be appended\n * @param pos On input: an alignment field, if desired. On output: the\n *            offsets of the alignment field\n * @return the value passed in as toAppendTo.\n */\npublic static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos) {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n        toAppendTo.append('(');\n        toAppendTo.append(value);\n        toAppendTo.append(')');\n    } else {\n        format.format(value, toAppendTo, pos);\n    }\n    return toAppendTo;\n}"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Creates a sequence {@code [start .. end]}.\n * It calls {@link #range(int,int,int) range(start, end, 1)}.\n *\n * @param start First value of the range.\n * @param end Last value of the range.\n * @return a range.\n */\npublic static Range range(int start, int end) {\n    return range(start, end, 1);\n}"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Creates a sequence \\( a_i, i < 0 <= n \\)\n * where \\( a_i = start + i * step \\)\n * and \\( n \\) is such that \\( a_n <= max \\) and \\( a_{n+1} > max \\).\n *\n * @param start First value of the range.\n * @param max Last value of the range that satisfies the above\n * construction rule.\n * @param step Increment.\n * @return a range.\n */\npublic static Range range(final int start, final int max, final int step) {\n    return new Range(start, max, step);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Factory method that creates a default instance.\n * The initial and maximal values are set to 0.\n * For the new instance to be useful, the maximal count must be set\n * by calling {@link #withMaximalCount(int) withMaximalCount}.\n *\n * @return an new instance.\n */\npublic static Incrementor create() {\n    return new Incrementor(0, 0, 1, CALLBACK);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Incrementor",
                "/**\n * Factory method that creates a default instance.\n * The initial and maximal values are set to 0.\n * For the new instance to be useful, the maximal count must be set\n * by calling {@link #withMaximalCount(int) withMaximalCount}.\n *\n * @return an new instance.\n */\npublic static Incrementor create() {\n    return new Incrementor(0, 0, 1, CALLBACK);\n}"
            ],
            [
                "loadExpIntA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_INT_A\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpIntA() {\n    return EXP_INT_A.clone();\n}"
            ],
            [
                "loadExpIntB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_INT_B\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpIntB() {\n    return EXP_INT_B.clone();\n}"
            ],
            [
                "loadExpFracA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_FRAC_A\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpFracA() {\n    return EXP_FRAC_A.clone();\n}"
            ],
            [
                "loadExpFracB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_FRAC_B\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpFracB() {\n    return EXP_FRAC_B.clone();\n}"
            ],
            [
                "loadLnMant",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"LN_MANT\".\n *\n * @return a clone of the data array.\n */\nstatic double[][] loadLnMant() {\n    return LN_MANT.clone();\n}"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns an exact representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which all coefficients are\n * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n * {@code Long.MAX_VALUE} a {@code MathArithMeticException} is\n * thrown.</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    // Use symmetry for large k\n    if (k > n / 2) {\n        return binomialCoefficient(n, n - k);\n    }\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    long result = 1;\n    if (n <= 61) {\n        // For n <= 61, the naive implementation cannot overflow.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            result = result * i / j;\n            i++;\n        }\n    } else if (n <= 66) {\n        // For n > 61 but n <= 66, the result cannot overflow,\n        // but we must take care not to overflow intermediate values.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            // We know that (result * i) is divisible by j,\n            // but (result * i) may overflow, so we split j:\n            // Filter out the gcd, d, so j/d and i/d are integer.\n            // result is divisible by (j/d) because (j/d)\n            // is relative prime to (i/d) and is a divisor of\n            // result * (i/d).\n            final long d = ArithmeticUtils.gcd(i, j);\n            result = (result / (j / d)) * (i / d);\n            i++;\n        }\n    } else {\n        // For n > 66, a result overflow might occur, so we check\n        // the multiplication, taking care to not overflow\n        // unnecessary.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            final long d = ArithmeticUtils.gcd(i, j);\n            result = ArithmeticUtils.mulAndCheck(result / (j / d), i / d);\n            i++;\n        }\n    }\n    return result;\n}"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns a {@code double} representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code double}. The\n * largest value of {@code n} for which all coefficients are less than\n * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n * Double.POSITIVE_INFINITY is returned</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 1d;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    if (k > n / 2) {\n        return binomialCoefficientDouble(n, n - k);\n    }\n    if (n < 67) {\n        return binomialCoefficient(n, k);\n    }\n    double result = 1d;\n    for (int i = 1; i <= k; i++) {\n        result *= (double) (n - k + i) / (double) i;\n    }\n    return FastMath.floor(result + 0.5);\n}"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns the natural {@code log} of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 0;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return FastMath.log(n);\n    }\n    /*\n         * For values small enough to do exact integer computation,\n         * return the log of the exact value\n         */\n    if (n < 67) {\n        return FastMath.log(binomialCoefficient(n, k));\n    }\n    /*\n         * Return the log of binomialCoefficientDouble for values that will not\n         * overflow binomialCoefficientDouble\n         */\n    if (n < 1030) {\n        return FastMath.log(binomialCoefficientDouble(n, k));\n    }\n    if (k > n / 2) {\n        return binomialCoefficientLog(n, n - k);\n    }\n    /*\n         * Sum logs for values that could overflow\n         */\n    double logSum = 0;\n    // n!/(n-k)!\n    for (int i = n - k + 1; i <= n; i++) {\n        logSum += FastMath.log(i);\n    }\n    // divide by k!\n    for (int i = 2; i <= k; i++) {\n        logSum -= FastMath.log(i);\n    }\n    return logSum;\n}"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns n!. Shorthand for {@code n} <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers {@code 1,...,n}.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code n >= 0} (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which {@code n!} does not exceed\n * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n * an {@code MathArithMeticException } is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return {@code n!}\n * @throws MathArithmeticException if the result is too large to be represented\n * by a {@code long}.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n * large to fit in a {@code long}.\n */\npublic static long factorial(final int n) throws NotPositiveException, MathArithmeticException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n > 20) {\n        throw new MathArithmeticException();\n    }\n    return FACTORIALS[n];\n}"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n * {@code double}.\n * The result should be small enough to fit into a {@code double}: The\n * largest {@code n} for which {@code n!} does not exceed\n * {@code Double.MAX_VALUE} is 170. If the computed value exceeds\n * {@code Double.MAX_VALUE}, {@code Double.POSITIVE_INFINITY} is returned.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n */\npublic static double factorialDouble(final int n) throws NotPositiveException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n < 21) {\n        return FACTORIALS[n];\n    }\n    return FastMath.floor(FastMath.exp(CombinatoricsUtils.factorialLog(n)) + 0.5);\n}"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Compute the natural logarithm of the factorial of {@code n}.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n */\npublic static double factorialLog(final int n) throws NotPositiveException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n < 21) {\n        return FastMath.log(FACTORIALS[n]);\n    }\n    double logSum = 0;\n    for (int i = 2; i <= n; i++) {\n        logSum += FastMath.log(i);\n    }\n    return logSum;\n}"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns the <a\n * href=\"http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html\">\n * Stirling number of the second kind</a>, \"{@code S(n,k)}\", the number of\n * ways of partitioning an {@code n}-element set into {@code k} non-empty\n * subsets.\n * <p>\n * The preconditions are {@code 0 <= k <= n } (otherwise\n * {@code NotPositiveException} is thrown)\n * </p>\n * @param n the size of the set\n * @param k the number of non-empty subsets\n * @return {@code S(n,k)}\n * @throws NotPositiveException if {@code k < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\n * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)\n * @since 3.1\n */\npublic static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    if (k < 0) {\n        throw new NotPositiveException(k);\n    }\n    if (k > n) {\n        throw new NumberIsTooLargeException(k, n, true);\n    }\n    long[][] stirlingS2 = STIRLING_S2.get();\n    if (stirlingS2 == null) {\n        // the cache has never been initialized, compute the first numbers\n        // by direct recurrence relation\n        // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n        // we must stop computation at row 26\n        final int maxIndex = 26;\n        stirlingS2 = new long[maxIndex][];\n        stirlingS2[0] = new long[] { 1l };\n        for (int i = 1; i < stirlingS2.length; ++i) {\n            stirlingS2[i] = new long[i + 1];\n            stirlingS2[i][0] = 0;\n            stirlingS2[i][1] = 1;\n            stirlingS2[i][i] = 1;\n            for (int j = 2; j < i; ++j) {\n                stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n            }\n        }\n        // atomically save the cache\n        STIRLING_S2.compareAndSet(null, stirlingS2);\n    }\n    if (n < stirlingS2.length) {\n        // the number is in the small cache\n        return stirlingS2[n][k];\n    } else {\n        // use explicit formula to compute the number without caching it\n        if (k == 0) {\n            return 0;\n        } else if (k == 1 || k == n) {\n            return 1;\n        } else if (k == 2) {\n            return (1l << (n - 1)) - 1l;\n        } else if (k == n - 1) {\n            return binomialCoefficient(n, 2);\n        } else {\n            // definition formula: note that this may trigger some overflow\n            long sum = 0;\n            long sign = ((k & 0x1) == 0) ? 1 : -1;\n            for (int j = 1; j <= k; ++j) {\n                sign = -sign;\n                sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                if (sum < 0) {\n                    // there was an overflow somewhere\n                    throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN, n, 0, stirlingS2.length - 1);\n                }\n            }\n            return sum / factorial(k);\n        }\n    }\n}"
            ],
            [
                "combinationsIterator",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns an iterator whose range is the k-element subsets of {0, ..., n - 1}\n * represented as {@code int[]} arrays.\n * <p>\n * The arrays returned by the iterator are sorted in descending order and\n * they are visited in lexicographic order with significance from right to\n * left. For example, combinationsIterator(4, 2) returns an Iterator that\n * will generate the following sequence of arrays on successive calls to\n * {@code next()}:</p><p>\n * {@code [0, 1], [0, 2], [1, 2], [0, 3], [1, 3], [2, 3]}\n * </p><p>\n * If {@code k == 0} an Iterator containing an empty array is returned and\n * if {@code k == n} an Iterator containing [0, ..., n -1] is returned.</p>\n *\n * @param n Size of the set from which subsets are selected.\n * @param k Size of the subsets to be enumerated.\n * @return an {@link Iterator iterator} over the k-sets in n.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n */\npublic static Iterator<int[]> combinationsIterator(int n, int k) {\n    return new Combinations(n, k).iterator();\n}"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Add two integers, checking for overflow.\n *\n * @param x an addend\n * @param y an addend\n * @return the sum {@code x+y}\n * @throws MathArithmeticException if the result can not be represented\n * as an {@code int}.\n * @since 1.1\n */\npublic static int addAndCheck(int x, int y) throws MathArithmeticException {\n    long s = (long) x + (long) y;\n    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n    }\n    return (int) s;\n}"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Add two long integers, checking for overflow.\n *\n * @param a an addend\n * @param b an addend\n * @return the sum {@code a+b}\n * @throws MathArithmeticException if the result can not be represented as an long\n * @since 1.2\n */\npublic static long addAndCheck(long a, long b) throws MathArithmeticException {\n    return addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n}"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns an exact representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which all coefficients are\n * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n * {@code Long.MAX_VALUE} an {@code ArithMeticException} is\n * thrown.</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficient(int, int)}\n */\n@Deprecated\npublic static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficient(n, k);\n}"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns a {@code double} representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code double}. The\n * largest value of {@code n} for which all coefficients are <\n * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n * Double.POSITIVE_INFINITY is returned</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficientDouble(int, int)}\n */\n@Deprecated\npublic static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficientDouble(n, k);\n}"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns the natural {@code log} of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficientLog(int, int)}\n */\n@Deprecated\npublic static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficientLog(n, k);\n}"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns n!. Shorthand for {@code n} <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers {@code 1,...,n}.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code n >= 0} (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which {@code n!} <\n * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n * an {@code ArithMeticException } is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return {@code n!}\n * @throws MathArithmeticException if the result is too large to be represented\n * by a {@code long}.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n * large to fit in a {@code long}.\n * @deprecated use {@link CombinatoricsUtils#factorial(int)}\n */\n@Deprecated\npublic static long factorial(final int n) throws NotPositiveException, MathArithmeticException {\n    return CombinatoricsUtils.factorial(n);\n}"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n * {@code double}.\n * The result should be small enough to fit into a {@code double}: The\n * largest {@code n} for which {@code n! < Double.MAX_VALUE} is 170.\n * If the computed value exceeds {@code Double.MAX_VALUE},\n * {@code Double.POSITIVE_INFINITY} is returned.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n * @deprecated use {@link CombinatoricsUtils#factorialDouble(int)}\n */\n@Deprecated\npublic static double factorialDouble(final int n) throws NotPositiveException {\n    return CombinatoricsUtils.factorialDouble(n);\n}"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Compute the natural logarithm of the factorial of {@code n}.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n * @deprecated use {@link CombinatoricsUtils#factorialLog(int)}\n */\n@Deprecated\npublic static double factorialLog(final int n) throws NotPositiveException {\n    return CombinatoricsUtils.factorialLog(n);\n}"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Computes the greatest common divisor of the absolute value of two\n * numbers, using a modified version of the \"binary gcd\" method.\n * See Knuth 4.5.2 algorithm B.\n * The algorithm is due to Josef Stein (1961).\n * <br/>\n * Special cases:\n * <ul>\n *  <li>The invocations\n *   {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n *   {@code gcd(Integer.MIN_VALUE, 0)} and\n *   {@code gcd(0, Integer.MIN_VALUE)} throw an\n *   {@code ArithmeticException}, because the result would be 2^31, which\n *   is too large for an int value.</li>\n *  <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n *   {@code gcd(x, 0)} is the absolute value of {@code x}, except\n *   for the special cases above.</li>\n *  <li>The invocation {@code gcd(0, 0)} is the only one which returns\n *   {@code 0}.</li>\n * </ul>\n *\n * @param p Number.\n * @param q Number.\n * @return the greatest common divisor (never negative).\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code int} value.\n * @since 1.1\n */\npublic static int gcd(int p, int q) throws MathArithmeticException {\n    int a = p;\n    int b = q;\n    if (a == 0 || b == 0) {\n        if (a == Integer.MIN_VALUE || b == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return FastMath.abs(a + b);\n    }\n    long al = a;\n    long bl = b;\n    boolean useLong = false;\n    if (a < 0) {\n        if (Integer.MIN_VALUE == a) {\n            useLong = true;\n        } else {\n            a = -a;\n        }\n        al = -al;\n    }\n    if (b < 0) {\n        if (Integer.MIN_VALUE == b) {\n            useLong = true;\n        } else {\n            b = -b;\n        }\n        bl = -bl;\n    }\n    if (useLong) {\n        if (al == bl) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        long blbu = bl;\n        bl = al;\n        al = blbu % al;\n        if (al == 0) {\n            if (bl > Integer.MAX_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n            }\n            return (int) bl;\n        }\n        blbu = bl;\n        // Now \"al\" and \"bl\" fit in an \"int\".\n        b = (int) al;\n        a = (int) (blbu % al);\n    }\n    return gcdPositive(a, b);\n}"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Gets the greatest common divisor of the absolute value of two numbers,\n * using the \"binary gcd\" method which avoids division and modulo\n * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n * Stein (1961).\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations\n * {@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)},\n * {@code gcd(Long.MIN_VALUE, 0L)} and\n * {@code gcd(0L, Long.MIN_VALUE)} throw an\n * {@code ArithmeticException}, because the result would be 2^63, which\n * is too large for a long value.</li>\n * <li>The result of {@code gcd(x, x)}, {@code gcd(0L, x)} and\n * {@code gcd(x, 0L)} is the absolute value of {@code x}, except\n * for the special cases above.\n * <li>The invocation {@code gcd(0L, 0L)} is the only one which returns\n * {@code 0L}.</li>\n * </ul>\n *\n * @param p Number.\n * @param q Number.\n * @return the greatest common divisor, never negative.\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code long} value.\n * @since 2.1\n */\npublic static long gcd(final long p, final long q) throws MathArithmeticException {\n    long u = p;\n    long v = q;\n    if ((u == 0) || (v == 0)) {\n        if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);\n        }\n        return FastMath.abs(u) + FastMath.abs(v);\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^63, while positive numbers can only be as large as 2^63-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    /* assert u!=0 && v!=0; */\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 63) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 63) {\n        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    long t = ((u & 1) == 1) ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1L << k);\n}"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Returns the least common multiple of the absolute value of two numbers,\n * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations {@code lcm(Integer.MIN_VALUE, n)} and\n * {@code lcm(n, Integer.MIN_VALUE)}, where {@code abs(n)} is a\n * power of 2, throw an {@code ArithmeticException}, because the result\n * would be 2^31, which is too large for an int value.</li>\n * <li>The result of {@code lcm(0, x)} and {@code lcm(x, 0)} is\n * {@code 0} for any {@code x}.\n * </ul>\n *\n * @param a Number.\n * @param b Number.\n * @return the least common multiple, never negative.\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code int} value.\n * @since 1.1\n */\npublic static int lcm(int a, int b) throws MathArithmeticException {\n    if (a == 0 || b == 0) {\n        return 0;\n    }\n    int lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));\n    if (lcm == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS, a, b);\n    }\n    return lcm;\n}"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Returns the least common multiple of the absolute value of two numbers,\n * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations {@code lcm(Long.MIN_VALUE, n)} and\n * {@code lcm(n, Long.MIN_VALUE)}, where {@code abs(n)} is a\n * power of 2, throw an {@code ArithmeticException}, because the result\n * would be 2^63, which is too large for an int value.</li>\n * <li>The result of {@code lcm(0L, x)} and {@code lcm(x, 0L)} is\n * {@code 0L} for any {@code x}.\n * </ul>\n *\n * @param a Number.\n * @param b Number.\n * @return the least common multiple, never negative.\n * @throws MathArithmeticException if the result cannot be represented\n * as a non-negative {@code long} value.\n * @since 2.1\n */\npublic static long lcm(long a, long b) throws MathArithmeticException {\n    if (a == 0 || b == 0) {\n        return 0;\n    }\n    long lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));\n    if (lcm == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS, a, b);\n    }\n    return lcm;\n}"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Multiply two integers, checking for overflow.\n *\n * @param x Factor.\n * @param y Factor.\n * @return the product {@code x * y}.\n * @throws MathArithmeticException if the result can not be\n * represented as an {@code int}.\n * @since 1.1\n */\npublic static int mulAndCheck(int x, int y) throws MathArithmeticException {\n    long m = ((long) x) * ((long) y);\n    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n        throw new MathArithmeticException();\n    }\n    return (int) m;\n}"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Multiply two long integers, checking for overflow.\n *\n * @param a Factor.\n * @param b Factor.\n * @return the product {@code a * b}.\n * @throws MathArithmeticException if the result can not be represented\n * as a {@code long}.\n * @since 1.2\n */\npublic static long mulAndCheck(long a, long b) throws MathArithmeticException {\n    long ret;\n    if (a > b) {\n        // use symmetry to reduce boundary cases\n        ret = mulAndCheck(b, a);\n    } else {\n        if (a < 0) {\n            if (b < 0) {\n                // check for positive overflow with negative a, negative b\n                if (a >= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new MathArithmeticException();\n                }\n            } else if (b > 0) {\n                // check for negative overflow with negative a, positive b\n                if (Long.MIN_VALUE / b <= a) {\n                    ret = a * b;\n                } else {\n                    throw new MathArithmeticException();\n                }\n            } else {\n                // assert b == 0\n                ret = 0;\n            }\n        } else if (a > 0) {\n            // assert a > 0\n            // assert b > 0\n            // check for positive overflow with positive a, positive b\n            if (a <= Long.MAX_VALUE / b) {\n                ret = a * b;\n            } else {\n                throw new MathArithmeticException();\n            }\n        } else {\n            // assert a == 0\n            ret = 0;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Subtract two integers, checking for overflow.\n *\n * @param x Minuend.\n * @param y Subtrahend.\n * @return the difference {@code x - y}.\n * @throws MathArithmeticException if the result can not be represented\n * as an {@code int}.\n * @since 1.1\n */\npublic static int subAndCheck(int x, int y) throws MathArithmeticException {\n    long s = (long) x - (long) y;\n    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n    }\n    return (int) s;\n}"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Subtract two long integers, checking for overflow.\n *\n * @param a Value.\n * @param b Value.\n * @return the difference {@code a - b}.\n * @throws MathArithmeticException if the result can not be represented as a\n * {@code long}.\n * @since 1.2\n */\npublic static long subAndCheck(long a, long b) throws MathArithmeticException {\n    long ret;\n    if (b == Long.MIN_VALUE) {\n        if (a < 0) {\n            ret = a - b;\n        } else {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);\n        }\n    } else {\n        // use additive inverse\n        ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n    }\n    return ret;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise an int to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return \\( k^e \\)\n * @throws NotPositiveException if {@code e < 0}.\n * @throws MathArithmeticException if the result would overflow.\n */\npublic static int pow(final int k, final int e) throws NotPositiveException, MathArithmeticException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    try {\n        int exp = e;\n        int result = 1;\n        int k2p = k;\n        while (true) {\n            if ((exp & 0x1) != 0) {\n                result = mulAndCheck(result, k2p);\n            }\n            exp >>= 1;\n            if (exp == 0) {\n                break;\n            }\n            k2p = mulAndCheck(k2p, k2p);\n        }\n        return result;\n    } catch (MathArithmeticException mae) {\n        // Add context information.\n        mae.getContext().addMessage(LocalizedFormats.OVERFLOW);\n        mae.getContext().addMessage(LocalizedFormats.BASE, k);\n        mae.getContext().addMessage(LocalizedFormats.EXPONENT, e);\n        // Rethrow.\n        throw mae;\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise an int to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n * @deprecated As of 3.3. Please use {@link #pow(int,int)} instead.\n */\n@Deprecated\npublic static int pow(final int k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    int result = 1;\n    int k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result *= k2p;\n        }\n        k2p *= k2p;\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a long to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return \\( k^e \\)\n * @throws NotPositiveException if {@code e < 0}.\n * @throws MathArithmeticException if the result would overflow.\n */\npublic static long pow(final long k, final int e) throws NotPositiveException, MathArithmeticException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    try {\n        int exp = e;\n        long result = 1;\n        long k2p = k;\n        while (true) {\n            if ((exp & 0x1) != 0) {\n                result = mulAndCheck(result, k2p);\n            }\n            exp >>= 1;\n            if (exp == 0) {\n                break;\n            }\n            k2p = mulAndCheck(k2p, k2p);\n        }\n        return result;\n    } catch (MathArithmeticException mae) {\n        // Add context information.\n        mae.getContext().addMessage(LocalizedFormats.OVERFLOW);\n        mae.getContext().addMessage(LocalizedFormats.BASE, k);\n        mae.getContext().addMessage(LocalizedFormats.EXPONENT, e);\n        // Rethrow.\n        throw mae;\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a long to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n * @deprecated As of 3.3. Please use {@link #pow(long,int)} instead.\n */\n@Deprecated\npublic static long pow(final long k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    long result = 1l;\n    long k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result *= k2p;\n        }\n        k2p *= k2p;\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, int e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    return k.pow(e);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    BigInteger result = BigInteger.ONE;\n    BigInteger k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result = result.multiply(k2p);\n        }\n        k2p = k2p.multiply(k2p);\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to a BigInteger power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException {\n    if (e.compareTo(BigInteger.ZERO) < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    BigInteger result = BigInteger.ONE;\n    BigInteger k2p = k;\n    while (!BigInteger.ZERO.equals(e)) {\n        if (e.testBit(0)) {\n            result = result.multiply(k2p);\n        }\n        k2p = k2p.multiply(k2p);\n        e = e.shiftRight(1);\n    }\n    return result;\n}"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns the <a\n * href=\"http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html\">\n * Stirling number of the second kind</a>, \"{@code S(n,k)}\", the number of\n * ways of partitioning an {@code n}-element set into {@code k} non-empty\n * subsets.\n * <p>\n * The preconditions are {@code 0 <= k <= n } (otherwise\n * {@code NotPositiveException} is thrown)\n * </p>\n * @param n the size of the set\n * @param k the number of non-empty subsets\n * @return {@code S(n,k)}\n * @throws NotPositiveException if {@code k < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\n * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)\n * @since 3.1\n * @deprecated use {@link CombinatoricsUtils#stirlingS2(int, int)}\n */\n@Deprecated\npublic static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.stirlingS2(n, k);\n}"
            ],
            [
                "isPowerOfTwo",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns true if the argument is a power of two.\n *\n * @param n the number to test\n * @return true if the argument is a power of two\n */\npublic static boolean isPowerOfTwo(long n) {\n    return (n > 0) && ((n & (n - 1)) == 0);\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Get the set of locales for which complex formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static ComplexFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static ComplexFormat getInstance(Locale locale) {\n    NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n    return new ComplexFormat(f);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @param imaginaryCharacter Imaginary character.\n * @return the complex format specific to the given locale.\n * @throws NullArgumentException if {@code imaginaryCharacter} is\n * {@code null}.\n * @throws NoDataException if {@code imaginaryCharacter} is an\n * empty string.\n */\npublic static ComplexFormat getInstance(String imaginaryCharacter, Locale locale) throws NullArgumentException, NoDataException {\n    NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n    return new ComplexFormat(imaginaryCharacter, f);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static ComplexField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Returns the Hamilton product of two quaternions.\n *\n * @param q1 First quaternion.\n * @param q2 Second quaternion.\n * @return the product {@code q1} and {@code q2}, in that order.\n */\npublic static Quaternion multiply(final Quaternion q1, final Quaternion q2) {\n    // Components of the first quaternion.\n    final double q1a = q1.getQ0();\n    final double q1b = q1.getQ1();\n    final double q1c = q1.getQ2();\n    final double q1d = q1.getQ3();\n    // Components of the second quaternion.\n    final double q2a = q2.getQ0();\n    final double q2b = q2.getQ1();\n    final double q2c = q2.getQ2();\n    final double q2d = q2.getQ3();\n    // Components of the product.\n    final double w = q1a * q2a - q1b * q2b - q1c * q2c - q1d * q2d;\n    final double x = q1a * q2b + q1b * q2a + q1c * q2d - q1d * q2c;\n    final double y = q1a * q2c - q1b * q2d + q1c * q2a + q1d * q2b;\n    final double z = q1a * q2d + q1b * q2c - q1c * q2b + q1d * q2a;\n    return new Quaternion(w, x, y, z);\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Computes the sum of two quaternions.\n *\n * @param q1 Quaternion.\n * @param q2 Quaternion.\n * @return the sum of {@code q1} and {@code q2}.\n */\npublic static Quaternion add(final Quaternion q1, final Quaternion q2) {\n    return new Quaternion(q1.getQ0() + q2.getQ0(), q1.getQ1() + q2.getQ1(), q1.getQ2() + q2.getQ2(), q1.getQ3() + q2.getQ3());\n}"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Subtracts two quaternions.\n *\n * @param q1 First Quaternion.\n * @param q2 Second quaternion.\n * @return the difference between {@code q1} and {@code q2}.\n */\npublic static Quaternion subtract(final Quaternion q1, final Quaternion q2) {\n    return new Quaternion(q1.getQ0() - q2.getQ0(), q1.getQ1() - q2.getQ1(), q1.getQ2() - q2.getQ2(), q1.getQ3() - q2.getQ3());\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Computes the dot-product of two quaternions.\n *\n * @param q1 Quaternion.\n * @param q2 Quaternion.\n * @return the dot product of {@code q1} and {@code q2}.\n */\npublic static double dotProduct(final Quaternion q1, final Quaternion q2) {\n    return q1.getQ0() * q2.getQ0() + q1.getQ1() * q2.getQ1() + q1.getQ2() * q2.getQ2() + q1.getQ3() * q2.getQ3();\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Test for the floating-point equality between Complex objects.\n * It returns {@code true} if both arguments are equal or within the\n * range of allowed error (inclusive).\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between the real (resp. imaginary) parts of {@code x} and\n * {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between the real (resp. imaginary) parts of {@code x}\n * and {@code y}.\n *\n * @see Precision#equals(double,double,int)\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y, int maxUlps) {\n    return Precision.equals(x.real, y.real, maxUlps) && Precision.equals(x.imaginary, y.imaginary, maxUlps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} iff the values are equal as defined by\n * {@link #equals(Complex,Complex,int) equals(x, y, 1)}.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @return {@code true} if the values are equal.\n *\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} if, both for the real part and for the imaginary\n * part, there is no double value strictly between the arguments or the\n * difference between them is within the range of allowed error\n * (inclusive).  Returns {@code false} if either of the arguments is NaN.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param eps Amount of allowed absolute error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n *\n * @see Precision#equals(double,double,double)\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y, double eps) {\n    return Precision.equals(x.real, y.real, eps) && Precision.equals(x.imaginary, y.imaginary, eps);\n}"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} if, both for the real part and for the imaginary\n * part, there is no double value strictly between the arguments or the\n * relative difference between them is smaller or equal to the given\n * tolerance. Returns {@code false} if either of the arguments is NaN.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param eps Amount of allowed relative error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n *\n * @see Precision#equalsWithRelativeTolerance(double,double,double)\n * @since 3.3\n */\npublic static boolean equalsWithRelativeTolerance(Complex x, Complex y, double eps) {\n    return Precision.equalsWithRelativeTolerance(x.real, y.real, eps) && Precision.equalsWithRelativeTolerance(x.imaginary, y.imaginary, eps);\n}"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Create a complex number given the real and imaginary parts.\n *\n * @param realPart Real part.\n * @param imaginaryPart Imaginary part.\n * @return a Complex instance.\n */\npublic static Complex valueOf(double realPart, double imaginaryPart) {\n    if (Double.isNaN(realPart) || Double.isNaN(imaginaryPart)) {\n        return NaN;\n    }\n    return new Complex(realPart, imaginaryPart);\n}"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Create a complex number given only the real part.\n *\n * @param realPart Real part.\n * @return a Complex instance.\n */\npublic static Complex valueOf(double realPart) {\n    if (Double.isNaN(realPart)) {\n        return NaN;\n    }\n    return new Complex(realPart);\n}"
            ],
            [
                "polar2Complex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "/**\n * Creates a complex number from the given polar representation.\n * <p>\n * The value returned is <code>r&middot;e<sup>i&middot;theta</sup></code>,\n * computed as <code>r&middot;cos(theta) + r&middot;sin(theta)i</code></p>\n * <p>\n * If either <code>r</code> or <code>theta</code> is NaN, or\n * <code>theta</code> is infinite, {@link Complex#NaN} is returned.</p>\n * <p>\n * If <code>r</code> is infinite and <code>theta</code> is finite,\n * infinite or NaN values may be returned in parts of the result, following\n * the rules for double arithmetic.<pre>\n * Examples:\n * <code>\n * polar2Complex(INFINITY, &pi;/4) = INFINITY + INFINITY i\n * polar2Complex(INFINITY, 0) = INFINITY + NaN i\n * polar2Complex(INFINITY, -&pi;/4) = INFINITY - INFINITY i\n * polar2Complex(INFINITY, 5&pi;/4) = -INFINITY - INFINITY i </code></pre></p>\n *\n * @param r the modulus of the complex number to create\n * @param theta  the argument of the complex number to create\n * @return <code>r&middot;e<sup>i&middot;theta</sup></code>\n * @throws MathIllegalArgumentException if {@code r} is negative.\n * @since 1.1\n */\npublic static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException {\n    if (r < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_COMPLEX_MODULE, r);\n    }\n    return new Complex(r * FastMath.cos(theta), r * FastMath.sin(theta));\n}"
            ],
            [
                "convertToComplex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "/**\n * Convert an array of primitive doubles to an array of {@code Complex} objects.\n *\n * @param real Array of numbers to be converted to their {@code Complex}\n * equivalent.\n * @return an array of {@code Complex} objects.\n *\n * @since 3.1\n */\npublic static Complex[] convertToComplex(double[] real) {\n    final Complex[] c = new Complex[real.length];\n    for (int i = 0; i < real.length; i++) {\n        c[i] = new Complex(real[i], 0);\n    }\n    return c;\n}"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optimization.linear",
                "SimplexTableau",
                "/**\n * Get the -1 times the sum of all coefficients in the given array.\n * @param coefficients coefficients to sum\n * @return the -1 times the sum of all coefficients in the given array.\n */\nprotected static double getInvertedCoefficientSum(final RealVector coefficients) {\n    double sum = 0;\n    for (double coefficient : coefficients.toArray()) {\n        sum -= coefficient;\n    }\n    return sum;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Get the set of locales for which real vectors formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available real vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Returns the default real vector format for the current locale.\n * @return the default real vector format.\n */\npublic static RealMatrixFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Returns the default real vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the real vector format specific to the given locale.\n */\npublic static RealMatrixFormat getInstance(final Locale locale) {\n    return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link RealMatrix} with specified dimensions.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix) which can be stored in a 32kB array, a {@link\n * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n * BlockRealMatrix} instance is built.</p>\n * <p>The matrix elements are all set to 0.0.</p>\n * @param rows number of rows of the matrix\n * @param columns number of columns of the matrix\n * @return  RealMatrix with specified dimensions\n * @see #createRealMatrix(double[][])\n */\npublic static RealMatrix createRealMatrix(final int rows, final int columns) {\n    return (rows * columns <= 4096) ? new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n}"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link FieldMatrix} with specified dimensions.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix), a {@link FieldMatrix} instance is built. Above\n * this threshold a {@link BlockFieldMatrix} instance is built.</p>\n * <p>The matrix elements are all set to field.getZero().</p>\n * @param <T> the type of the field elements\n * @param field field to which the matrix elements belong\n * @param rows number of rows of the matrix\n * @param columns number of columns of the matrix\n * @return  FieldMatrix with specified dimensions\n * @see #createFieldMatrix(FieldElement[][])\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field, final int rows, final int columns) {\n    return (rows * columns <= 4096) ? new Array2DRowFieldMatrix<T>(field, rows, columns) : new BlockFieldMatrix<T>(field, rows, columns);\n}"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link RealMatrix} whose entries are the the values in the\n * the input array.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix) which can be stored in a 32kB array, a {@link\n * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n * BlockRealMatrix} instance is built.</p>\n * <p>The input array is copied, not referenced.</p>\n *\n * @param data input array\n * @return  RealMatrix containing the values of the array\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if {@code data} is not rectangular (not all rows have the same length).\n * @throws NoDataException if a row or column is empty.\n * @throws NullArgumentException if either {@code data} or {@code data[0]}\n * is {@code null}.\n * @throws DimensionMismatchException if {@code data} is not rectangular.\n * @see #createRealMatrix(int, int)\n */\npublic static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException {\n    if (data == null || data[0] == null) {\n        throw new NullArgumentException();\n    }\n    return (data.length * data[0].length <= 4096) ? new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n}"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link FieldMatrix} whose entries are the the values in the\n * the input array.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix), a {@link FieldMatrix} instance is built. Above\n * this threshold a {@link BlockFieldMatrix} instance is built.</p>\n * <p>The input array is copied, not referenced.</p>\n * @param <T> the type of the field elements\n * @param data input array\n * @return a matrix containing the values of the array.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if {@code data} is not rectangular (not all rows have the same length).\n * @throws NoDataException if a row or column is empty.\n * @throws NullArgumentException if either {@code data} or {@code data[0]}\n * is {@code null}.\n * @see #createFieldMatrix(Field, int, int)\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) throws DimensionMismatchException, NoDataException, NullArgumentException {\n    if (data == null || data[0] == null) {\n        throw new NullArgumentException();\n    }\n    return (data.length * data[0].length <= 4096) ? new Array2DRowFieldMatrix<T>(data) : new BlockFieldMatrix<T>(data);\n}"
            ],
            [
                "createRealIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns <code>dimension x dimension</code> identity matrix.\n *\n * @param dimension dimension of identity matrix to generate\n * @return identity matrix\n * @throws IllegalArgumentException if dimension is not positive\n * @since 1.1\n */\npublic static RealMatrix createRealIdentityMatrix(int dimension) {\n    final RealMatrix m = createRealMatrix(dimension, dimension);\n    for (int i = 0; i < dimension; ++i) {\n        m.setEntry(i, i, 1.0);\n    }\n    return m;\n}"
            ],
            [
                "createFieldIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns <code>dimension x dimension</code> identity matrix.\n *\n * @param <T> the type of the field elements\n * @param field field to which the elements belong\n * @param dimension dimension of identity matrix to generate\n * @return identity matrix\n * @throws IllegalArgumentException if dimension is not positive\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(final Field<T> field, final int dimension) {\n    final T zero = field.getZero();\n    final T one = field.getOne();\n    final T[][] d = MathArrays.buildArray(field, dimension, dimension);\n    for (int row = 0; row < dimension; row++) {\n        final T[] dRow = d[row];\n        Arrays.fill(dRow, zero);\n        dRow[row] = one;\n    }\n    return new Array2DRowFieldMatrix<T>(field, d, false);\n}"
            ],
            [
                "createRealDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a diagonal matrix with specified elements.\n *\n * @param diagonal diagonal elements of the matrix (the array elements\n * will be copied)\n * @return diagonal matrix\n * @since 2.0\n */\npublic static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n    final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n    for (int i = 0; i < diagonal.length; ++i) {\n        m.setEntry(i, i, diagonal[i]);\n    }\n    return m;\n}"
            ],
            [
                "createFieldDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a diagonal matrix with specified elements.\n *\n * @param <T> the type of the field elements\n * @param diagonal diagonal elements of the matrix (the array elements\n * will be copied)\n * @return diagonal matrix\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(final T[] diagonal) {\n    final FieldMatrix<T> m = createFieldMatrix(diagonal[0].getField(), diagonal.length, diagonal.length);\n    for (int i = 0; i < diagonal.length; ++i) {\n        m.setEntry(i, i, diagonal[i]);\n    }\n    return m;\n}"
            ],
            [
                "createRealVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a {@link RealVector} using the data from the input array.\n *\n * @param data the input data\n * @return a data.length RealVector\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code data} is {@code null}.\n */\npublic static RealVector createRealVector(double[] data) throws NoDataException, NullArgumentException {\n    if (data == null) {\n        throw new NullArgumentException();\n    }\n    return new ArrayRealVector(data, true);\n}"
            ],
            [
                "createFieldVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a {@link FieldVector} using the data from the input array.\n *\n * @param <T> the type of the field elements\n * @param data the input data\n * @return a data.length FieldVector\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code data} is {@code null}.\n * @throws ZeroException if {@code data} has 0 elements\n */\npublic static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) throws NoDataException, NullArgumentException, ZeroException {\n    if (data == null) {\n        throw new NullArgumentException();\n    }\n    if (data.length == 0) {\n        throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n    }\n    return new ArrayFieldVector<T>(data[0].getField(), data, true);\n}"
            ],
            [
                "createRowRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Create a row {@link RealMatrix} using the data from the input\n * array.\n *\n * @param rowData the input row data\n * @return a 1 x rowData.length RealMatrix\n * @throws NoDataException if {@code rowData} is empty.\n * @throws NullArgumentException if {@code rowData} is {@code null}.\n */\npublic static RealMatrix createRowRealMatrix(double[] rowData) throws NoDataException, NullArgumentException {\n    if (rowData == null) {\n        throw new NullArgumentException();\n    }\n    final int nCols = rowData.length;\n    final RealMatrix m = createRealMatrix(1, nCols);\n    for (int i = 0; i < nCols; ++i) {\n        m.setEntry(0, i, rowData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createRowFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Create a row {@link FieldMatrix} using the data from the input\n * array.\n *\n * @param <T> the type of the field elements\n * @param rowData the input row data\n * @return a 1 x rowData.length FieldMatrix\n * @throws NoDataException if {@code rowData} is empty.\n * @throws NullArgumentException if {@code rowData} is {@code null}.\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(final T[] rowData) throws NoDataException, NullArgumentException {\n    if (rowData == null) {\n        throw new NullArgumentException();\n    }\n    final int nCols = rowData.length;\n    if (nCols == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n    for (int i = 0; i < nCols; ++i) {\n        m.setEntry(0, i, rowData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createColumnRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a column {@link RealMatrix} using the data from the input\n * array.\n *\n * @param columnData  the input column data\n * @return a columnData x 1 RealMatrix\n * @throws NoDataException if {@code columnData} is empty.\n * @throws NullArgumentException if {@code columnData} is {@code null}.\n */\npublic static RealMatrix createColumnRealMatrix(double[] columnData) throws NoDataException, NullArgumentException {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createColumnFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a column {@link FieldMatrix} using the data from the input\n * array.\n *\n * @param <T> the type of the field elements\n * @param columnData  the input column data\n * @return a columnData x 1 FieldMatrix\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code columnData} is {@code null}.\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) throws NoDataException, NullArgumentException {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final FieldMatrix<T> m = createFieldMatrix(columnData[0].getField(), nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
            ],
            [
                "isSymmetric",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Checks whether a matrix is symmetric.\n *\n * @param matrix Matrix to check.\n * @param eps Relative tolerance.\n * @return {@code true} if {@code matrix} is symmetric.\n * @since 3.1\n */\npublic static boolean isSymmetric(RealMatrix matrix, double eps) {\n    return isSymmetricInternal(matrix, eps, false);\n}"
            ],
            [
                "fractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Convert a {@link FieldMatrix}/{@link Fraction} matrix to a {@link RealMatrix}.\n * @param m Matrix to convert.\n * @return the converted matrix.\n */\npublic static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m) {\n    final FractionMatrixConverter converter = new FractionMatrixConverter();\n    m.walkInOptimizedOrder(converter);\n    return converter.getConvertedMatrix();\n}"
            ],
            [
                "bigFractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Convert a {@link FieldMatrix}/{@link BigFraction} matrix to a {@link RealMatrix}.\n *\n * @param m Matrix to convert.\n * @return the converted matrix.\n */\npublic static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m) {\n    final BigFractionMatrixConverter converter = new BigFractionMatrixConverter();\n    m.walkInOptimizedOrder(converter);\n    return converter.getConvertedMatrix();\n}"
            ],
            [
                "blockInverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix by splitting it into\n * 4 sub-matrices.\n *\n * @param m Matrix whose inverse must be computed.\n * @param splitIndex Index that determines the \"split\" line and\n * column.\n * The element corresponding to this index will part of the\n * upper-left sub-matrix.\n * @return the inverse of {@code m}.\n * @throws NonSquareMatrixException if {@code m} is not square.\n */\npublic static RealMatrix blockInverse(RealMatrix m, int splitIndex) {\n    final int n = m.getRowDimension();\n    if (m.getColumnDimension() != n) {\n        throw new NonSquareMatrixException(m.getRowDimension(), m.getColumnDimension());\n    }\n    final int splitIndex1 = splitIndex + 1;\n    final RealMatrix a = m.getSubMatrix(0, splitIndex, 0, splitIndex);\n    final RealMatrix b = m.getSubMatrix(0, splitIndex, splitIndex1, n - 1);\n    final RealMatrix c = m.getSubMatrix(splitIndex1, n - 1, 0, splitIndex);\n    final RealMatrix d = m.getSubMatrix(splitIndex1, n - 1, splitIndex1, n - 1);\n    final SingularValueDecomposition aDec = new SingularValueDecomposition(a);\n    final DecompositionSolver aSolver = aDec.getSolver();\n    if (!aSolver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix aInv = aSolver.getInverse();\n    final SingularValueDecomposition dDec = new SingularValueDecomposition(d);\n    final DecompositionSolver dSolver = dDec.getSolver();\n    if (!dSolver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix dInv = dSolver.getInverse();\n    final RealMatrix tmp1 = a.subtract(b.multiply(dInv).multiply(c));\n    final SingularValueDecomposition tmp1Dec = new SingularValueDecomposition(tmp1);\n    final DecompositionSolver tmp1Solver = tmp1Dec.getSolver();\n    if (!tmp1Solver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix result00 = tmp1Solver.getInverse();\n    final RealMatrix tmp2 = d.subtract(c.multiply(aInv).multiply(b));\n    final SingularValueDecomposition tmp2Dec = new SingularValueDecomposition(tmp2);\n    final DecompositionSolver tmp2Solver = tmp2Dec.getSolver();\n    if (!tmp2Solver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix result11 = tmp2Solver.getInverse();\n    final RealMatrix result01 = aInv.multiply(b).multiply(result11).scalarMultiply(-1);\n    final RealMatrix result10 = dInv.multiply(c).multiply(result00).scalarMultiply(-1);\n    final RealMatrix result = new Array2DRowRealMatrix(n, n);\n    result.setSubMatrix(result00.getData(), 0, 0);\n    result.setSubMatrix(result01.getData(), 0, splitIndex1);\n    result.setSubMatrix(result10.getData(), splitIndex1, 0);\n    result.setSubMatrix(result11.getData(), splitIndex1, splitIndex1);\n    return result;\n}"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix.\n * <p>\n * By default, the inverse of the matrix is computed using the QR-decomposition,\n * unless a more efficient method can be determined for the input matrix.\n * <p>\n * Note: this method will use a singularity threshold of 0,\n * use {@link #inverse(RealMatrix, double)} if a different threshold is needed.\n *\n * @param matrix Matrix whose inverse shall be computed\n * @return the inverse of {@code matrix}\n * @throws NullArgumentException if {@code matrix} is {@code null}\n * @throws SingularMatrixException if m is singular\n * @throws NonSquareMatrixException if matrix is not square\n * @since 3.3\n */\npublic static RealMatrix inverse(RealMatrix matrix) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException {\n    return inverse(matrix, 0);\n}"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix.\n * <p>\n * By default, the inverse of the matrix is computed using the QR-decomposition,\n * unless a more efficient method can be determined for the input matrix.\n *\n * @param matrix Matrix whose inverse shall be computed\n * @param threshold Singularity threshold\n * @return the inverse of {@code m}\n * @throws NullArgumentException if {@code matrix} is {@code null}\n * @throws SingularMatrixException if matrix is singular\n * @throws NonSquareMatrixException if matrix is not square\n * @since 3.3\n */\npublic static RealMatrix inverse(RealMatrix matrix, double threshold) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException {\n    MathUtils.checkNotNull(matrix);\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n    }\n    if (matrix instanceof DiagonalMatrix) {\n        return ((DiagonalMatrix) matrix).inverse(threshold);\n    } else {\n        QRDecomposition decomposition = new QRDecomposition(matrix, threshold);\n        return decomposition.getSolver().getInverse();\n    }\n}"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Convert a data array from raw layout to blocks layout.\n * <p>\n * Raw layout is the straightforward layout where element at row i and\n * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n * is the layout used in {@link BlockFieldMatrix} instances, where the matrix\n * is split in square blocks (except at right and bottom side where blocks may\n * be rectangular to fit matrix size) and each block is stored in a flattened\n * one-dimensional array.\n * </p>\n * <p>\n * This method creates an array in blocks layout from an input array in raw layout.\n * It can be used to provide the array argument of the {@link\n * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n * constructor.\n * </p>\n * @param <T> Type of the field elements.\n * @param rawData Data array in raw layout.\n * @return a new data array containing the same entries but in blocks layout\n * @throws DimensionMismatchException if {@code rawData} is not rectangular\n *  (not all rows have the same length).\n * @see #createBlocksLayout(Field, int, int)\n * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n */\npublic static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n    // convert array\n    final Field<T> field = extractField(rawData);\n    final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            // allocate new block\n            final T[] block = MathArrays.buildArray(field, iHeight * jWidth);\n            blocks[blockIndex] = block;\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Create a data array in blocks layout.\n * <p>\n * This method can be used to create the array argument of the {@link\n * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n * constructor.\n * </p>\n * @param <T> Type of the field elements.\n * @param field Field to which the elements belong.\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(FieldElement[][])\n * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n */\npublic static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns) {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = MathArrays.buildArray(field, iHeight * jWidth);\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Convert a data array from raw layout to blocks layout.\n * <p>\n * Raw layout is the straightforward layout where element at row i and\n * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n * is the layout used in {@link BlockRealMatrix} instances, where the matrix\n * is split in square blocks (except at right and bottom side where blocks may\n * be rectangular to fit matrix size) and each block is stored in a flattened\n * one-dimensional array.\n * </p>\n * <p>\n * This method creates an array in blocks layout from an input array in raw layout.\n * It can be used to provide the array argument of the {@link\n * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n * </p>\n * @param rawData Data array in raw layout.\n * @return a new data array containing the same entries but in blocks layout.\n * @throws DimensionMismatchException if {@code rawData} is not rectangular.\n * @see #createBlocksLayout(int, int)\n * @see #BlockRealMatrix(int, int, double[][], boolean)\n */\npublic static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Create a data array in blocks layout.\n * <p>\n * This method can be used to create the array argument of the {@link\n * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n * </p>\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(double[][])\n * @see #BlockRealMatrix(int, int, double[][], boolean)\n */\npublic static double[][] createBlocksLayout(final int rows, final int columns) {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "unmodifiableRealVector",
                "org.apache.commons.math3.linear",
                "RealVector",
                "/**\n * Returns an unmodifiable view of the specified vector.\n * The returned vector has read-only access. An attempt to modify it will\n * result in a {@link MathUnsupportedOperationException}. However, the\n * returned vector is <em>not</em> immutable, since any modification of\n * {@code v} will also change the returned view.\n * For example, in the following piece of code\n * <pre>\n *     RealVector v = new ArrayRealVector(2);\n *     RealVector w = RealVector.unmodifiableRealVector(v);\n *     v.setEntry(0, 1.2);\n *     v.setEntry(1, -3.4);\n * </pre>\n * the changes will be seen in the {@code w} view of {@code v}.\n *\n * @param v Vector for which an unmodifiable view is to be returned.\n * @return an unmodifiable view of {@code v}.\n */\npublic static RealVector unmodifiableRealVector(final RealVector v) {\n    /**\n     * This anonymous class is an implementation of {@link RealVector}\n     * with read-only access.\n     * It wraps any {@link RealVector}, and exposes all methods which\n     * do not modify it. Invoking methods which should normally result\n     * in the modification of the calling {@link RealVector} results in\n     * a {@link MathUnsupportedOperationException}. It should be noted\n     * that {@link UnmodifiableVector} is <em>not</em> immutable.\n     */\n    return new RealVector() {\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all circumstances.\n         */\n        @Override\n        public RealVector mapToSelf(UnivariateFunction function) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector map(UnivariateFunction function) {\n            return v.map(function);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Iterator<Entry> iterator() {\n            final Iterator<Entry> i = v.iterator();\n            return new Iterator<Entry>() {\n\n                /**\n                 * The current entry.\n                 */\n                private final UnmodifiableEntry e = new UnmodifiableEntry();\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public boolean hasNext() {\n                    return i.hasNext();\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public Entry next() {\n                    e.setIndex(i.next().getIndex());\n                    return e;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 *\n                 * @throws MathUnsupportedOperationException in all\n                 * circumstances.\n                 */\n                public void remove() throws MathUnsupportedOperationException {\n                    throw new MathUnsupportedOperationException();\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Iterator<Entry> sparseIterator() {\n            final Iterator<Entry> i = v.sparseIterator();\n            return new Iterator<Entry>() {\n\n                /**\n                 * The current entry.\n                 */\n                private final UnmodifiableEntry e = new UnmodifiableEntry();\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public boolean hasNext() {\n                    return i.hasNext();\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public Entry next() {\n                    e.setIndex(i.next().getIndex());\n                    return e;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 *\n                 * @throws MathUnsupportedOperationException in all\n                 * circumstances.\n                 */\n                public void remove() throws MathUnsupportedOperationException {\n                    throw new MathUnsupportedOperationException();\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector copy() {\n            return v.copy();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector add(RealVector w) throws DimensionMismatchException {\n            return v.add(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector subtract(RealVector w) throws DimensionMismatchException {\n            return v.subtract(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapAdd(double d) {\n            return v.mapAdd(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapAddToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapSubtract(double d) {\n            return v.mapSubtract(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapSubtractToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapMultiply(double d) {\n            return v.mapMultiply(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapMultiplyToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapDivide(double d) {\n            return v.mapDivide(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapDivideToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector ebeMultiply(RealVector w) throws DimensionMismatchException {\n            return v.ebeMultiply(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector ebeDivide(RealVector w) throws DimensionMismatchException {\n            return v.ebeDivide(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double dotProduct(RealVector w) throws DimensionMismatchException {\n            return v.dotProduct(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double cosine(RealVector w) throws DimensionMismatchException, MathArithmeticException {\n            return v.cosine(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getNorm() {\n            return v.getNorm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getL1Norm() {\n            return v.getL1Norm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getLInfNorm() {\n            return v.getLInfNorm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getDistance(RealVector w) throws DimensionMismatchException {\n            return v.getDistance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getL1Distance(RealVector w) throws DimensionMismatchException {\n            return v.getL1Distance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getLInfDistance(RealVector w) throws DimensionMismatchException {\n            return v.getLInfDistance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector unitVector() throws MathArithmeticException {\n            return v.unitVector();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void unitize() throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealMatrix outerProduct(RealVector w) {\n            return v.outerProduct(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getEntry(int index) throws OutOfRangeException {\n            return v.getEntry(index);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void setEntry(int index, double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void addToEntry(int index, double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getDimension() {\n            return v.getDimension();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector append(RealVector w) {\n            return v.append(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector append(double d) {\n            return v.append(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector getSubVector(int index, int n) throws OutOfRangeException, NotPositiveException {\n            return v.getSubVector(index, n);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void setSubVector(int index, RealVector w) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void set(double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double[] toArray() {\n            return v.toArray();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isNaN() {\n            return v.isNaN();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isInfinite() {\n            return v.isInfinite();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector combine(double a, double b, RealVector y) throws DimensionMismatchException {\n            return v.combine(a, b, y);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector combineToSelf(double a, double b, RealVector y) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * An entry in the vector.\n         */\n        class UnmodifiableEntry extends Entry {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public double getValue() {\n                return v.getEntry(getIndex());\n            }\n\n            /**\n             * {@inheritDoc}\n             *\n             * @throws MathUnsupportedOperationException in all\n             * circumstances.\n             */\n            @Override\n            public void setValue(double value) throws MathUnsupportedOperationException {\n                throw new MathUnsupportedOperationException();\n            }\n        }\n    };\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Get the set of locales for which real vectors formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available real vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Returns the default real vector format for the current locale.\n * @return the default real vector format.\n */\npublic static RealVectorFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Returns the default real vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the real vector format specific to the given locale.\n */\npublic static RealVectorFormat getInstance(final Locale locale) {\n    return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.linear",
                "JacobiPreconditioner",
                "/**\n * Creates a new instance of this class. This method extracts the diagonal\n * coefficients of the specified linear operator. If {@code a} does not\n * extend {@link AbstractRealMatrix}, then the coefficients of the\n * underlying matrix are not accessible, coefficient extraction is made by\n * matrix-vector products with the basis vectors (and might therefore take\n * some time). With matrices, direct entry access is carried out.\n *\n * @param a the linear operator for which the preconditioner should be built\n * @return the diagonal preconditioner made of the inverse of the diagonal\n * coefficients of the specified linear operator\n * @throws NonSquareOperatorException if {@code a} is not square\n */\npublic static JacobiPreconditioner create(final RealLinearOperator a) throws NonSquareOperatorException {\n    final int n = a.getColumnDimension();\n    if (a.getRowDimension() != n) {\n        throw new NonSquareOperatorException(a.getRowDimension(), n);\n    }\n    final double[] diag = new double[n];\n    if (a instanceof AbstractRealMatrix) {\n        final AbstractRealMatrix m = (AbstractRealMatrix) a;\n        for (int i = 0; i < n; i++) {\n            diag[i] = m.getEntry(i, i);\n        }\n    } else {\n        final ArrayRealVector x = new ArrayRealVector(n);\n        for (int i = 0; i < n; i++) {\n            x.set(0.);\n            x.setEntry(i, 1.);\n            diag[i] = a.operate(x).getEntry(i);\n        }\n    }\n    return new JacobiPreconditioner(diag, false);\n}"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Get the elements type from an array.\n *\n * @param <T> Type of the field elements.\n * @param d Data array.\n * @return the field to which the array elements belong.\n * @throws NullArgumentException if the array is {@code null}.\n * @throws NoDataException if the array is empty.\n */\nprotected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException {\n    if (d == null) {\n        throw new NullArgumentException();\n    }\n    if (d.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    if (d[0].length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    return d[0][0].getField();\n}"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Get the elements type from an array.\n *\n * @param <T> Type of the field elements.\n * @param d Data array.\n * @return the field to which the array elements belong.\n * @throws NoDataException if array is empty.\n */\nprotected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException {\n    if (d.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    return d[0].getField();\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Build an array of elements.\n * <p>\n * Complete arrays are filled with field.getZero()\n * </p>\n * @param <T> Type of the field elements\n * @param field field to which array elements belong\n * @param rows number of rows\n * @param columns number of columns (may be negative to build partial\n * arrays in the same way <code>new Field[rows][]</code> works)\n * @return a new array\n * @deprecated as of 3.2, replaced by {@link MathArrays#buildArray(Field, int, int)}\n */\n@Deprecated\nprotected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n    return MathArrays.buildArray(field, rows, columns);\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Build an array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n * </p>\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param length of the array\n * @return a new array\n * @deprecated as of 3.2, replaced by {@link MathArrays#buildArray(Field, int)}\n */\n@Deprecated\nprotected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length) {\n    return MathArrays.buildArray(field, length);\n}"
            ],
            [
                "estimate",
                "org.apache.commons.math3.distribution.fitting",
                "MultivariateNormalMixtureExpectationMaximization",
                "/**\n * Helper method to create a multivariate normal mixture model which can be\n * used to initialize {@link #fit(MixtureMultivariateNormalDistribution)}.\n *\n * This method uses the data supplied to the constructor to try to determine\n * a good mixture model at which to start the fit, but it is not guaranteed\n * to supply a model which will find the optimal solution or even converge.\n *\n * @param data Data to estimate distribution\n * @param numComponents Number of components for estimated mixture\n * @return Multivariate normal mixture model estimated from the data\n * @throws NumberIsTooLargeException if {@code numComponents} is greater\n * than the number of data rows.\n * @throws NumberIsTooSmallException if {@code numComponents < 2}.\n * @throws NotStrictlyPositiveException if data has less than 2 rows\n * @throws DimensionMismatchException if rows of data have different numbers\n *             of columns\n */\npublic static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException {\n    if (data.length < 2) {\n        throw new NotStrictlyPositiveException(data.length);\n    }\n    if (numComponents < 2) {\n        throw new NumberIsTooSmallException(numComponents, 2, true);\n    }\n    if (numComponents > data.length) {\n        throw new NumberIsTooLargeException(numComponents, data.length, true);\n    }\n    final int numRows = data.length;\n    final int numCols = data[0].length;\n    // sort the data\n    final DataRow[] sortedData = new DataRow[numRows];\n    for (int i = 0; i < numRows; i++) {\n        sortedData[i] = new DataRow(data[i]);\n    }\n    Arrays.sort(sortedData);\n    // uniform weight for each bin\n    final double weight = 1d / numComponents;\n    // components of mixture model to be created\n    final List<Pair<Double, MultivariateNormalDistribution>> components = new ArrayList<Pair<Double, MultivariateNormalDistribution>>(numComponents);\n    // create a component based on data in each bin\n    for (int binIndex = 0; binIndex < numComponents; binIndex++) {\n        // minimum index (inclusive) from sorted data for this bin\n        final int minIndex = (binIndex * numRows) / numComponents;\n        // maximum index (exclusive) from sorted data for this bin\n        final int maxIndex = ((binIndex + 1) * numRows) / numComponents;\n        // number of data records that will be in this bin\n        final int numBinRows = maxIndex - minIndex;\n        // data for this bin\n        final double[][] binData = new double[numBinRows][numCols];\n        // mean of each column for the data in the this bin\n        final double[] columnMeans = new double[numCols];\n        // populate bin and create component\n        for (int i = minIndex, iBin = 0; i < maxIndex; i++, iBin++) {\n            for (int j = 0; j < numCols; j++) {\n                final double val = sortedData[i].getRow()[j];\n                columnMeans[j] += val;\n                binData[iBin][j] = val;\n            }\n        }\n        MathArrays.scaleInPlace(1d / numBinRows, columnMeans);\n        // covariance matrix for this bin\n        final double[][] covMat = new Covariance(binData).getCovarianceMatrix().getData();\n        final MultivariateNormalDistribution mvn = new MultivariateNormalDistribution(columnMeans, covMat);\n        components.add(new Pair<Double, MultivariateNormalDistribution>(weight, mvn));\n    }\n    return new MixtureMultivariateNormalDistribution(components);\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "/**\n * Returns one sample using Cheng's sampling algorithm.\n * @param random random generator to use\n * @param alpha distribution first shape parameter\n * @param beta distribution second shape parameter\n * @return sampled value\n */\nstatic double sample(RandomGenerator random, final double alpha, final double beta) {\n    final double a = FastMath.min(alpha, beta);\n    final double b = FastMath.max(alpha, beta);\n    if (a > 1) {\n        return algorithmBB(random, alpha, a, b);\n    } else {\n        return algorithmBC(random, alpha, b, a);\n    }\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "ChengBetaSampler",
                "/**\n * Returns one sample using Cheng's sampling algorithm.\n * @param random random generator to use\n * @param alpha distribution first shape parameter\n * @param beta distribution second shape parameter\n * @return sampled value\n */\nstatic double sample(RandomGenerator random, final double alpha, final double beta) {\n    final double a = FastMath.min(alpha, beta);\n    final double b = FastMath.max(alpha, beta);\n    if (a > 1) {\n        return algorithmBB(random, alpha, a, b);\n    } else {\n        return algorithmBC(random, alpha, b, a);\n    }\n}"
            ],
            [
                "getStirlingError",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * Compute the error of Stirling's series at the given value.\n * <p>\n * References:\n * <ol>\n * <li>Eric W. Weisstein. \"Stirling's Series.\" From MathWorld--A Wolfram Web\n * Resource. <a target=\"_blank\"\n * href=\"http://mathworld.wolfram.com/StirlingsSeries.html\">\n * http://mathworld.wolfram.com/StirlingsSeries.html</a></li>\n * </ol>\n * </p>\n *\n * @param z the value.\n * @return the Striling's series error.\n */\nstatic double getStirlingError(double z) {\n    double ret;\n    if (z < 15.0) {\n        double z2 = 2.0 * z;\n        if (FastMath.floor(z2) == z2) {\n            ret = EXACT_STIRLING_ERRORS[(int) z2];\n        } else {\n            ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * FastMath.log(z) + z - HALF_LOG_2_PI;\n        }\n    } else {\n        double z2 = z * z;\n        ret = (0.083333333333333333333 - (0.00277777777777777777778 - (0.00079365079365079365079365 - (0.000595238095238095238095238 - 0.0008417508417508417508417508 / z2) / z2) / z2) / z2) / z;\n    }\n    return ret;\n}"
            ],
            [
                "getDeviancePart",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * A part of the deviance portion of the saddle point approximation.\n * <p>\n * References:\n * <ol>\n * <li>Catherine Loader (2000). \"Fast and Accurate Computation of Binomial\n * Probabilities.\". <a target=\"_blank\"\n * href=\"http://www.herine.net/stat/papers/dbinom.pdf\">\n * http://www.herine.net/stat/papers/dbinom.pdf</a></li>\n * </ol>\n * </p>\n *\n * @param x the x value.\n * @param mu the average.\n * @return a part of the deviance.\n */\nstatic double getDeviancePart(double x, double mu) {\n    double ret;\n    if (FastMath.abs(x - mu) < 0.1 * (x + mu)) {\n        double d = x - mu;\n        double v = d / (x + mu);\n        double s1 = v * d;\n        double s = Double.NaN;\n        double ej = 2.0 * x * v;\n        v *= v;\n        int j = 1;\n        while (s1 != s) {\n            s = s1;\n            ej *= v;\n            s1 = s + ej / ((j * 2) + 1);\n            ++j;\n        }\n        ret = s1;\n    } else {\n        ret = x * FastMath.log(x / mu) + mu - x;\n    }\n    return ret;\n}"
            ],
            [
                "logBinomialProbability",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * Compute the logarithm of the PMF for a binomial distribution\n * using the saddle point expansion.\n *\n * @param x the value at which the probability is evaluated.\n * @param n the number of trials.\n * @param p the probability of success.\n * @param q the probability of failure (1 - p).\n * @return log(p(x)).\n */\nstatic double logBinomialProbability(int x, int n, double p, double q) {\n    double ret;\n    if (x == 0) {\n        if (p < 0.1) {\n            ret = -getDeviancePart(n, n * q) - n * p;\n        } else {\n            ret = n * FastMath.log(q);\n        }\n    } else if (x == n) {\n        if (q < 0.1) {\n            ret = -getDeviancePart(n, n * p) - n * q;\n        } else {\n            ret = n * FastMath.log(p);\n        }\n    } else {\n        ret = getStirlingError(n) - getStirlingError(x) - getStirlingError(n - x) - getDeviancePart(x, n * p) - getDeviancePart(n - x, n * q);\n        double f = (MathUtils.TWO_PI * x * (n - x)) / n;\n        ret = -0.5 * FastMath.log(f) + ret;\n    }\n    return ret;\n}"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "/**\n * Helper function that calculates {@code log(1+x)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x a value larger than or equal to -1\n * @return {@code log(1+x)/x}\n */\nstatic double helper1(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.log1p(x) / x;\n    } else {\n        return 1. - x * ((1. / 2.) - x * ((1. / 3.) - x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "/**\n * Helper function to calculate {@code (exp(x)-1)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x free parameter\n * @return {@code (exp(x)-1)/x} if x is non-zero, or 1 if x=0\n */\nstatic double helper2(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.expm1(x) / x;\n    } else {\n        return 1. + x * (1. / 2.) * (1. + x * (1. / 3.) * (1. + x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "/**\n * Helper function that calculates {@code log(1+x)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x a value larger than or equal to -1\n * @return {@code log(1+x)/x}\n */\nstatic double helper1(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.log1p(x) / x;\n    } else {\n        return 1. - x * ((1. / 2.) - x * ((1. / 3.) - x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "/**\n * Helper function to calculate {@code (exp(x)-1)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x free parameter\n * @return {@code (exp(x)-1)/x} if x is non-zero, or 1 if x=0\n */\nstatic double helper2(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.expm1(x) / x;\n    } else {\n        return 1. + x * (1. / 2.) * (1. + x * (1. / 3.) * (1. + x * (1. / 4.)));\n    }\n}"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxIter",
                "/**\n * Factory method that creates instance of this class that represents\n * a virtually unlimited number of iterations.\n *\n * @return a new instance suitable for allowing {@link Integer#MAX_VALUE}\n * evaluations.\n */\npublic static MaxIter unlimited() {\n    return new MaxIter(Integer.MAX_VALUE);\n}"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optim.linear",
                "SimplexTableau",
                "/**\n * Get the -1 times the sum of all coefficients in the given array.\n * @param coefficients coefficients to sum\n * @return the -1 times the sum of all coefficients in the given array.\n */\nprotected static double getInvertedCoefficientSum(final RealVector coefficients) {\n    double sum = 0;\n    for (double coefficient : coefficients.toArray()) {\n        sum -= coefficient;\n    }\n    return sum;\n}"
            ],
            [
                "unbounded",
                "org.apache.commons.math3.optim",
                "SimpleBounds",
                "/**\n * Factory method that creates instance of this class that represents\n * unbounded ranges.\n *\n * @param dim Number of parameters.\n * @return a new instance suitable for passing to an optimizer that\n * requires bounds specification.\n */\npublic static SimpleBounds unbounded(int dim) {\n    final double[] lB = new double[dim];\n    Arrays.fill(lB, Double.NEGATIVE_INFINITY);\n    final double[] uB = new double[dim];\n    Arrays.fill(uB, Double.POSITIVE_INFINITY);\n    return new SimpleBounds(lB, uB);\n}"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxEval",
                "/**\n * Factory method that creates instance of this class that represents\n * a virtually unlimited number of evaluations.\n *\n * @return a new instance suitable for allowing {@link Integer#MAX_VALUE}\n * evaluations.\n */\npublic static MaxEval unlimited() {\n    return new MaxEval(Integer.MAX_VALUE);\n}"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the error function.\n *\n * <p>erf(x) = 2/&radic;&pi; <sub>0</sub>&int;<sup>x</sup> e<sup>-t<sup>2</sup></sup>dt </p>\n *\n * <p>This implementation computes erf(x) using the\n * {@link Gamma#regularizedGammaP(double, double, double, int) regularized gamma function},\n * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3)</p>\n *\n * <p>The value returned is always between -1 and 1 (inclusive).\n * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from\n * either 1 or -1 as a double, so the appropriate extreme value is returned.\n * </p>\n *\n * @param x the value.\n * @return the error function erf(x)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n * @see Gamma#regularizedGammaP(double, double, double, int)\n */\npublic static double erf(double x) {\n    if (FastMath.abs(x) > 40) {\n        return x > 0 ? 1 : -1;\n    }\n    final double ret = Gamma.regularizedGammaP(0.5, x * x, 1.0e-15, 10000);\n    return x < 0 ? -ret : ret;\n}"
            ],
            [
                "erfc",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the complementary error function.\n *\n * <p>erfc(x) = 2/&radic;&pi; <sub>x</sub>&int;<sup>&infin;</sup> e<sup>-t<sup>2</sup></sup>dt\n * <br/>\n *    = 1 - {@link #erf(double) erf(x)} </p>\n *\n * <p>This implementation computes erfc(x) using the\n * {@link Gamma#regularizedGammaQ(double, double, double, int) regularized gamma function},\n * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3).</p>\n *\n * <p>The value returned is always between 0 and 2 (inclusive).\n * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from\n * either 0 or 2 as a double, so the appropriate extreme value is returned.\n * </p>\n *\n * @param x the value\n * @return the complementary error function erfc(x)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n * @see Gamma#regularizedGammaQ(double, double, double, int)\n * @since 2.2\n */\npublic static double erfc(double x) {\n    if (FastMath.abs(x) > 40) {\n        return x > 0 ? 0 : 2;\n    }\n    final double ret = Gamma.regularizedGammaQ(0.5, x * x, 1.0e-15, 10000);\n    return x < 0 ? 2 - ret : ret;\n}"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the difference between erf(x1) and erf(x2).\n *\n * The implementation uses either erf(double) or erfc(double)\n * depending on which provides the most precise result.\n *\n * @param x1 the first value\n * @param x2 the second value\n * @return erf(x2) - erf(x1)\n */\npublic static double erf(double x1, double x2) {\n    if (x1 > x2) {\n        return -erf(x2, x1);\n    }\n    return x1 < -X_CRIT ? x2 < 0.0 ? erfc(-x2) - erfc(-x1) : erf(x2) - erf(x1) : x2 > X_CRIT && x1 > 0.0 ? erfc(x1) - erfc(x2) : erf(x2) - erf(x1);\n}"
            ],
            [
                "erfInv",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the inverse erf.\n * <p>\n * This implementation is described in the paper:\n * <a href=\"http://people.maths.ox.ac.uk/gilesm/files/gems_erfinv.pdf\">Approximating\n * the erfinv function</a> by Mike Giles, Oxford-Man Institute of Quantitative Finance,\n * which was published in GPU Computing Gems, volume 2, 2010.\n * The source code is available <a href=\"http://gpucomputing.net/?q=node/1828\">here</a>.\n * </p>\n * @param x the value\n * @return t such that x = erf(t)\n * @since 3.2\n */\npublic static double erfInv(final double x) {\n    // beware that the logarithm argument must be\n    // commputed as (1.0 - x) * (1.0 + x),\n    // it must NOT be simplified as 1.0 - x * x as this\n    // would induce rounding errors near the boundaries +/-1\n    double w = -FastMath.log((1.0 - x) * (1.0 + x));\n    double p;\n    if (w < 6.25) {\n        w -= 3.125;\n        p = -3.6444120640178196996e-21;\n        p = -1.685059138182016589e-19 + p * w;\n        p = 1.2858480715256400167e-18 + p * w;\n        p = 1.115787767802518096e-17 + p * w;\n        p = -1.333171662854620906e-16 + p * w;\n        p = 2.0972767875968561637e-17 + p * w;\n        p = 6.6376381343583238325e-15 + p * w;\n        p = -4.0545662729752068639e-14 + p * w;\n        p = -8.1519341976054721522e-14 + p * w;\n        p = 2.6335093153082322977e-12 + p * w;\n        p = -1.2975133253453532498e-11 + p * w;\n        p = -5.4154120542946279317e-11 + p * w;\n        p = 1.051212273321532285e-09 + p * w;\n        p = -4.1126339803469836976e-09 + p * w;\n        p = -2.9070369957882005086e-08 + p * w;\n        p = 4.2347877827932403518e-07 + p * w;\n        p = -1.3654692000834678645e-06 + p * w;\n        p = -1.3882523362786468719e-05 + p * w;\n        p = 0.0001867342080340571352 + p * w;\n        p = -0.00074070253416626697512 + p * w;\n        p = -0.0060336708714301490533 + p * w;\n        p = 0.24015818242558961693 + p * w;\n        p = 1.6536545626831027356 + p * w;\n    } else if (w < 16.0) {\n        w = FastMath.sqrt(w) - 3.25;\n        p = 2.2137376921775787049e-09;\n        p = 9.0756561938885390979e-08 + p * w;\n        p = -2.7517406297064545428e-07 + p * w;\n        p = 1.8239629214389227755e-08 + p * w;\n        p = 1.5027403968909827627e-06 + p * w;\n        p = -4.013867526981545969e-06 + p * w;\n        p = 2.9234449089955446044e-06 + p * w;\n        p = 1.2475304481671778723e-05 + p * w;\n        p = -4.7318229009055733981e-05 + p * w;\n        p = 6.8284851459573175448e-05 + p * w;\n        p = 2.4031110387097893999e-05 + p * w;\n        p = -0.0003550375203628474796 + p * w;\n        p = 0.00095328937973738049703 + p * w;\n        p = -0.0016882755560235047313 + p * w;\n        p = 0.0024914420961078508066 + p * w;\n        p = -0.0037512085075692412107 + p * w;\n        p = 0.005370914553590063617 + p * w;\n        p = 1.0052589676941592334 + p * w;\n        p = 3.0838856104922207635 + p * w;\n    } else if (!Double.isInfinite(w)) {\n        w = FastMath.sqrt(w) - 5.0;\n        p = -2.7109920616438573243e-11;\n        p = -2.5556418169965252055e-10 + p * w;\n        p = 1.5076572693500548083e-09 + p * w;\n        p = -3.7894654401267369937e-09 + p * w;\n        p = 7.6157012080783393804e-09 + p * w;\n        p = -1.4960026627149240478e-08 + p * w;\n        p = 2.9147953450901080826e-08 + p * w;\n        p = -6.7711997758452339498e-08 + p * w;\n        p = 2.2900482228026654717e-07 + p * w;\n        p = -9.9298272942317002539e-07 + p * w;\n        p = 4.5260625972231537039e-06 + p * w;\n        p = -1.9681778105531670567e-05 + p * w;\n        p = 7.5995277030017761139e-05 + p * w;\n        p = -0.00021503011930044477347 + p * w;\n        p = -0.00013871931833623122026 + p * w;\n        p = 1.0103004648645343977 + p * w;\n        p = 4.8499064014085844221 + p * w;\n    } else {\n        // this branch does not appears in the original code, it\n        // was added because the previous branch does not handle\n        // x = +/-1 correctly. In this case, w is positive infinity\n        // and as the first coefficient (-2.71e-11) is negative.\n        // Once the first multiplication is done, p becomes negative\n        // infinity and remains so throughout the polynomial evaluation.\n        // So the branch above incorrectly returns negative infinity\n        // instead of the correct positive infinity.\n        p = Double.POSITIVE_INFINITY;\n    }\n    return p * x;\n}"
            ],
            [
                "erfcInv",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the inverse erfc.\n * @param x the value\n * @return t such that x = erfc(t)\n * @since 3.2\n */\npublic static double erfcInv(final double x) {\n    return erfInv(1 - x);\n}"
            ],
            [
                "value",
                "org.apache.commons.math3.special",
                "BesselJ",
                "/**\n * Returns the first Bessel function, \\(J_{order}(x)\\).\n *\n * @param order Order of the Bessel function\n * @param x Argument\n * @return Value of the Bessel function of the first kind, \\(J_{order}(x)\\)\n * @throws MathIllegalArgumentException if {@code x} is too large relative to {@code order}\n * @throws ConvergenceException if the algorithm fails to converge\n */\npublic static double value(double order, double x) throws MathIllegalArgumentException, ConvergenceException {\n    final int n = (int) order;\n    final double alpha = order - n;\n    final int nb = n + 1;\n    final BesselJResult res = rjBesl(x, alpha, nb);\n    if (res.nVals >= nb) {\n        return res.vals[n];\n    } else if (res.nVals < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.BESSEL_FUNCTION_BAD_ARGUMENT, order, x);\n    } else if (FastMath.abs(res.vals[res.nVals - 1]) < 1e-100) {\n        // underflow; return value (will be zero)\n        return res.vals[n];\n    }\n    throw new ConvergenceException(LocalizedFormats.BESSEL_FUNCTION_FAILED_CONVERGENCE, order, x);\n}"
            ],
            [
                "rjBesl",
                "org.apache.commons.math3.special",
                "BesselJ",
                "/**\n * Calculates Bessel functions \\(J_{n+alpha}(x)\\) for\n * non-negative argument x, and non-negative order n + alpha.\n * <p>\n * Before using the output vector, the user should check that\n * nVals = nb, i.e., all orders have been calculated to the desired accuracy.\n * See BesselResult class javadoc for details on return values.\n * </p>\n * @param x non-negative real argument for which J's are to be calculated\n * @param alpha fractional part of order for which J's or exponentially\n * scaled J's (\\(J\\cdot e^{x}\\)) are to be calculated. 0 <= alpha < 1.0.\n * @param nb integer number of functions to be calculated, nb > 0. The first\n * function calculated is of order alpha, and the last is of order\n * nb - 1 + alpha.\n * @return BesselJResult a vector of the functions\n * \\(J_{alpha}(x)\\) through \\(J_{nb-1+alpha}(x)\\), or the corresponding exponentially\n * scaled functions and an integer output variable indicating possible errors\n */\npublic static BesselJResult rjBesl(double x, double alpha, int nb) {\n    final double[] b = new double[nb];\n    int ncalc = 0;\n    double alpem = 0;\n    double alp2em = 0;\n    // ---------------------------------------------------------------------\n    // Check for out of range arguments.\n    // ---------------------------------------------------------------------\n    final int magx = (int) x;\n    if ((nb > 0) && (x >= X_MIN) && (x <= X_MAX) && (alpha >= 0) && (alpha < 1)) {\n        // ---------------------------------------------------------------------\n        // Initialize result array to zero.\n        // ---------------------------------------------------------------------\n        ncalc = nb;\n        for (int i = 0; i < nb; ++i) {\n            b[i] = 0;\n        }\n        // ---------------------------------------------------------------------\n        // Branch to use 2-term ascending series for small X and asymptotic\n        // form for large X when NB is not too large.\n        // ---------------------------------------------------------------------\n        double tempa;\n        double tempb;\n        double tempc;\n        double tover;\n        if (x < RTNSIG) {\n            // ---------------------------------------------------------------------\n            // Two-term ascending series for small X.\n            // ---------------------------------------------------------------------\n            tempa = 1;\n            alpem = 1 + alpha;\n            double halfx = 0;\n            if (x > ENMTEN) {\n                halfx = 0.5 * x;\n            }\n            if (alpha != 0) {\n                tempa = FastMath.pow(halfx, alpha) / (alpha * Gamma.gamma(alpha));\n            }\n            tempb = 0;\n            if (x + 1 > 1) {\n                tempb = -halfx * halfx;\n            }\n            b[0] = tempa + (tempa * tempb / alpem);\n            if ((x != 0) && (b[0] == 0)) {\n                ncalc = 0;\n            }\n            if (nb != 1) {\n                if (x <= 0) {\n                    for (int n = 1; n < nb; ++n) {\n                        b[n] = 0;\n                    }\n                } else {\n                    // ---------------------------------------------------------------------\n                    // Calculate higher order functions.\n                    // ---------------------------------------------------------------------\n                    tempc = halfx;\n                    tover = tempb != 0 ? ENMTEN / tempb : 2 * ENMTEN / x;\n                    for (int n = 1; n < nb; ++n) {\n                        tempa /= alpem;\n                        alpem += 1;\n                        tempa *= tempc;\n                        if (tempa <= tover * alpem) {\n                            tempa = 0;\n                        }\n                        b[n] = tempa + (tempa * tempb / alpem);\n                        if ((b[n] == 0) && (ncalc > n)) {\n                            ncalc = n;\n                        }\n                    }\n                }\n            }\n        } else if ((x > 25.0) && (nb <= magx + 1)) {\n            // ---------------------------------------------------------------------\n            // Asymptotic series for X > 25\n            // ---------------------------------------------------------------------\n            final double xc = FastMath.sqrt(PI2 / x);\n            final double mul = 0.125 / x;\n            final double xin = mul * mul;\n            int m = 0;\n            if (x >= 130.0) {\n                m = 4;\n            } else if (x >= 35.0) {\n                m = 8;\n            } else {\n                m = 11;\n            }\n            final double xm = 4.0 * m;\n            // ---------------------------------------------------------------------\n            // Argument reduction for SIN and COS routines.\n            // ---------------------------------------------------------------------\n            double t = (double) ((int) ((x / TWOPI) + 0.5));\n            final double z = x - t * TOWPI1 - t * TWOPI2 - (alpha + 0.5) / PI2;\n            double vsin = FastMath.sin(z);\n            double vcos = FastMath.cos(z);\n            double gnu = 2 * alpha;\n            double capq;\n            double capp;\n            double s;\n            double t1;\n            double xk;\n            for (int i = 1; i <= 2; i++) {\n                s = (xm - 1 - gnu) * (xm - 1 + gnu) * xin * 0.5;\n                t = (gnu - (xm - 3.0)) * (gnu + (xm - 3.0));\n                capp = (s * t) / FACT[2 * m];\n                t1 = (gnu - (xm + 1)) * (gnu + (xm + 1));\n                capq = (s * t1) / FACT[2 * m + 1];\n                xk = xm;\n                int k = 2 * m;\n                t1 = t;\n                for (int j = 2; j <= m; j++) {\n                    xk -= 4.0;\n                    s = (xk - 1 - gnu) * (xk - 1 + gnu);\n                    t = (gnu - (xk - 3.0)) * (gnu + (xk - 3.0));\n                    capp = (capp + 1 / FACT[k - 2]) * s * t * xin;\n                    capq = (capq + 1 / FACT[k - 1]) * s * t1 * xin;\n                    k -= 2;\n                    t1 = t;\n                }\n                capp += 1;\n                capq = (capq + 1) * ((gnu * gnu) - 1) * (0.125 / x);\n                b[i - 1] = xc * (capp * vcos - capq * vsin);\n                if (nb == 1) {\n                    return new BesselJResult(MathArrays.copyOf(b, b.length), ncalc);\n                }\n                t = vsin;\n                vsin = -vcos;\n                vcos = t;\n                gnu += 2.0;\n            }\n            // ---------------------------------------------------------------------\n            // If NB > 2, compute J(X,ORDER+I) I = 2, NB-1\n            // ---------------------------------------------------------------------\n            if (nb > 2) {\n                gnu = 2 * alpha + 2.0;\n                for (int j = 2; j < nb; ++j) {\n                    b[j] = gnu * b[j - 1] / x - b[j - 2];\n                    gnu += 2.0;\n                }\n            }\n        } else {\n            // ---------------------------------------------------------------------\n            // Use recurrence to generate results. First initialize the\n            // calculation of P*S.\n            // ---------------------------------------------------------------------\n            final int nbmx = nb - magx;\n            int n = magx + 1;\n            int nstart = 0;\n            int nend = 0;\n            double en = 2 * (n + alpha);\n            double plast = 1;\n            double p = en / x;\n            double pold;\n            // ---------------------------------------------------------------------\n            // Calculate general significance test.\n            // ---------------------------------------------------------------------\n            double test = 2 * ENSIG;\n            boolean readyToInitialize = false;\n            if (nbmx >= 3) {\n                // ---------------------------------------------------------------------\n                // Calculate P*S until N = NB-1. Check for possible\n                // overflow.\n                // ---------------------------------------------------------------------\n                tover = ENTEN / ENSIG;\n                nstart = magx + 2;\n                nend = nb - 1;\n                en = 2 * (nstart - 1 + alpha);\n                double psave;\n                double psavel;\n                for (int k = nstart; k <= nend; k++) {\n                    n = k;\n                    en += 2.0;\n                    pold = plast;\n                    plast = p;\n                    p = (en * plast / x) - pold;\n                    if (p > tover) {\n                        // ---------------------------------------------------------------------\n                        // To avoid overflow, divide P*S by TOVER. Calculate\n                        // P*S until\n                        // ABS(P) > 1.\n                        // ---------------------------------------------------------------------\n                        tover = ENTEN;\n                        p /= tover;\n                        plast /= tover;\n                        psave = p;\n                        psavel = plast;\n                        nstart = n + 1;\n                        do {\n                            n += 1;\n                            en += 2.0;\n                            pold = plast;\n                            plast = p;\n                            p = (en * plast / x) - pold;\n                        } while (p <= 1);\n                        tempb = en / x;\n                        // ---------------------------------------------------------------------\n                        // Calculate backward test and find NCALC, the\n                        // highest N such that\n                        // the test is passed.\n                        // ---------------------------------------------------------------------\n                        test = pold * plast * (0.5 - 0.5 / (tempb * tempb));\n                        test /= ENSIG;\n                        p = plast * tover;\n                        n -= 1;\n                        en -= 2.0;\n                        nend = FastMath.min(nb, n);\n                        for (int l = nstart; l <= nend; l++) {\n                            pold = psavel;\n                            psavel = psave;\n                            psave = (en * psavel / x) - pold;\n                            if (psave * psavel > test) {\n                                ncalc = l - 1;\n                                readyToInitialize = true;\n                                break;\n                            }\n                        }\n                        ncalc = nend;\n                        readyToInitialize = true;\n                        break;\n                    }\n                }\n                if (!readyToInitialize) {\n                    n = nend;\n                    en = 2 * (n + alpha);\n                    // ---------------------------------------------------------------------\n                    // Calculate special significance test for NBMX > 2.\n                    // ---------------------------------------------------------------------\n                    test = FastMath.max(test, FastMath.sqrt(plast * ENSIG) * FastMath.sqrt(2 * p));\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Calculate P*S until significance test passes.\n            // ---------------------------------------------------------------------\n            if (!readyToInitialize) {\n                do {\n                    n += 1;\n                    en += 2.0;\n                    pold = plast;\n                    plast = p;\n                    p = (en * plast / x) - pold;\n                } while (p < test);\n            }\n            // ---------------------------------------------------------------------\n            // Initialize the backward recursion and the normalization sum.\n            // ---------------------------------------------------------------------\n            n += 1;\n            en += 2.0;\n            tempb = 0;\n            tempa = 1 / p;\n            int m = (2 * n) - 4 * (n / 2);\n            double sum = 0;\n            double em = (double) (n / 2);\n            alpem = em - 1 + alpha;\n            alp2em = 2 * em + alpha;\n            if (m != 0) {\n                sum = tempa * alpem * alp2em / em;\n            }\n            nend = n - nb;\n            boolean readyToNormalize = false;\n            boolean calculatedB0 = false;\n            // ---------------------------------------------------------------------\n            // Recur backward via difference equation, calculating (but not\n            // storing) B(N), until N = NB.\n            // ---------------------------------------------------------------------\n            for (int l = 1; l <= nend; l++) {\n                n -= 1;\n                en -= 2.0;\n                tempc = tempb;\n                tempb = tempa;\n                tempa = (en * tempb / x) - tempc;\n                m = 2 - m;\n                if (m != 0) {\n                    em -= 1;\n                    alp2em = 2 * em + alpha;\n                    if (n == 1) {\n                        break;\n                    }\n                    alpem = em - 1 + alpha;\n                    if (alpem == 0) {\n                        alpem = 1;\n                    }\n                    sum = (sum + tempa * alp2em) * alpem / em;\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Store B(NB).\n            // ---------------------------------------------------------------------\n            b[n - 1] = tempa;\n            if (nend >= 0) {\n                if (nb <= 1) {\n                    alp2em = alpha;\n                    if (alpha + 1 == 1) {\n                        alp2em = 1;\n                    }\n                    sum += b[0] * alp2em;\n                    readyToNormalize = true;\n                } else {\n                    // ---------------------------------------------------------------------\n                    // Calculate and store B(NB-1).\n                    // ---------------------------------------------------------------------\n                    n -= 1;\n                    en -= 2.0;\n                    b[n - 1] = (en * tempa / x) - tempb;\n                    if (n == 1) {\n                        calculatedB0 = true;\n                    } else {\n                        m = 2 - m;\n                        if (m != 0) {\n                            em -= 1;\n                            alp2em = 2 * em + alpha;\n                            alpem = em - 1 + alpha;\n                            if (alpem == 0) {\n                                alpem = 1;\n                            }\n                            sum = (sum + (b[n - 1] * alp2em)) * alpem / em;\n                        }\n                    }\n                }\n            }\n            if (!readyToNormalize && !calculatedB0) {\n                nend = n - 2;\n                if (nend != 0) {\n                    // ---------------------------------------------------------------------\n                    // Calculate via difference equation and store B(N),\n                    // until N = 2.\n                    // ---------------------------------------------------------------------\n                    for (int l = 1; l <= nend; l++) {\n                        n -= 1;\n                        en -= 2.0;\n                        b[n - 1] = (en * b[n] / x) - b[n + 1];\n                        m = 2 - m;\n                        if (m != 0) {\n                            em -= 1;\n                            alp2em = 2 * em + alpha;\n                            alpem = em - 1 + alpha;\n                            if (alpem == 0) {\n                                alpem = 1;\n                            }\n                            sum = (sum + b[n - 1] * alp2em) * alpem / em;\n                        }\n                    }\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Calculate b[0]\n            // ---------------------------------------------------------------------\n            if (!readyToNormalize) {\n                if (!calculatedB0) {\n                    b[0] = 2.0 * (alpha + 1) * b[1] / x - b[2];\n                }\n                em -= 1;\n                alp2em = 2 * em + alpha;\n                if (alp2em == 0) {\n                    alp2em = 1;\n                }\n                sum += b[0] * alp2em;\n            }\n            // ---------------------------------------------------------------------\n            // Normalize. Divide all B(N) by sum.\n            // ---------------------------------------------------------------------\n            if (FastMath.abs(alpha) > 1e-16) {\n                sum *= Gamma.gamma(alpha) * FastMath.pow(x * 0.5, -alpha);\n            }\n            tempa = ENMTEN;\n            if (sum > 1) {\n                tempa *= sum;\n            }\n            for (n = 0; n < nb; n++) {\n                if (FastMath.abs(b[n]) < tempa) {\n                    b[n] = 0;\n                }\n                b[n] /= sum;\n            }\n        }\n        // ---------------------------------------------------------------------\n        // Error return -- X, NB, or ALPHA is out of range.\n        // ---------------------------------------------------------------------\n    } else {\n        if (b.length > 0) {\n            b[0] = 0;\n        }\n        ncalc = FastMath.min(nb, 0) - 1;\n    }\n    return new BesselJResult(MathArrays.copyOf(b, b.length), ncalc);\n}"
            ],
            [
                "logGamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>\n * Returns the value of log&nbsp;&Gamma;(x) for x&nbsp;&gt;&nbsp;0.\n * </p>\n * <p>\n * For x &le; 8, the implementation is based on the double precision\n * implementation in the <em>NSWC Library of Mathematics Subroutines</em>,\n * {@code DGAMLN}. For x &gt; 8, the implementation is based on\n * </p>\n * <ul>\n * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">Gamma\n *     Function</a>, equation (28).</li>\n * <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">\n *     Lanczos Approximation</a>, equations (1) through (5).</li>\n * <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on\n *     the computation of the convergent Lanczos complex Gamma\n *     approximation</a></li>\n * </ul>\n *\n * @param x Argument.\n * @return the value of {@code log(Gamma(x))}, {@code Double.NaN} if\n * {@code x <= 0.0}.\n */\npublic static double logGamma(double x) {\n    double ret;\n    if (Double.isNaN(x) || (x <= 0.0)) {\n        ret = Double.NaN;\n    } else if (x < 0.5) {\n        return logGamma1p(x) - FastMath.log(x);\n    } else if (x <= 2.5) {\n        return logGamma1p((x - 0.5) - 0.5);\n    } else if (x <= 8.0) {\n        final int n = (int) FastMath.floor(x - 1.5);\n        double prod = 1.0;\n        for (int i = 1; i <= n; i++) {\n            prod *= x - i;\n        }\n        return logGamma1p(x - (n + 1)) + FastMath.log(prod);\n    } else {\n        double sum = lanczos(x);\n        double tmp = x + LANCZOS_G + .5;\n        ret = ((x + .5) * FastMath.log(tmp)) - tmp + HALF_LOG_2_PI + FastMath.log(sum / x);\n    }\n    return ret;\n}"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function P(a, x).\n *\n * @param a Parameter.\n * @param x Value.\n * @return the regularized gamma function P(a, x).\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaP(double a, double x) {\n    return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function P(a, x).\n *\n * The implementation of this method is based on:\n * <ul>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n *   Regularized Gamma Function</a>, equation (1)\n *  </li>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n *   Incomplete Gamma Function</a>, equation (4).\n *  </li>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n *   Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n *  </li>\n * </ul>\n *\n * @param a the a parameter.\n * @param x the value.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized gamma function P(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n        ret = Double.NaN;\n    } else if (x == 0.0) {\n        ret = 0.0;\n    } else if (x >= a + 1) {\n        // use regularizedGammaQ because it should converge faster in this\n        // case.\n        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n    } else {\n        // calculate series\n        // current element index\n        double n = 0.0;\n        // n-th element in the series\n        double an = 1.0 / a;\n        // partial sum\n        double sum = an;\n        while (FastMath.abs(an / sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) {\n            // compute next element in the series\n            n += 1.0;\n            an *= x / (a + n);\n            // update partial sum\n            sum += an;\n        }\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(maxIterations);\n        } else if (Double.isInfinite(sum)) {\n            ret = 1.0;\n        } else {\n            ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * sum;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n *\n * @param a the a parameter.\n * @param x the value.\n * @return the regularized gamma function Q(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaQ(double a, double x) {\n    return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n *\n * The implementation of this method is based on:\n * <ul>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n *   Regularized Gamma Function</a>, equation (1).\n *  </li>\n *  <li>\n *   <a href=\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\">\n *   Regularized incomplete gamma function: Continued fraction representations\n *   (formula 06.08.10.0003)</a>\n *  </li>\n * </ul>\n *\n * @param a the a parameter.\n * @param x the value.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized gamma function P(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n        ret = Double.NaN;\n    } else if (x == 0.0) {\n        ret = 1.0;\n    } else if (x < a + 1.0) {\n        // use regularizedGammaP because it should converge faster in this\n        // case.\n        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        // create continued fraction\n        ContinuedFraction cf = new ContinuedFraction() {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}"
            ],
            [
                "digamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>Computes the digamma function of x.</p>\n *\n * <p>This is an independently written implementation of the algorithm described in\n * Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976.</p>\n *\n * <p>Some of the constants have been changed to increase accuracy at the moderate expense\n * of run-time.  The result should be accurate to within 10^-8 absolute tolerance for\n * x >= 10^-5 and within 10^-8 relative tolerance for x > 0.</p>\n *\n * <p>Performance for large negative values of x will be quite expensive (proportional to\n * |x|).  Accuracy for negative values of x should be about 10^-8 absolute for results\n * less than 10^5 and 10^-8 relative for results larger than that.</p>\n *\n * @param x Argument.\n * @return digamma(x) to within 10-8 relative or absolute error whichever is smaller.\n * @see <a href=\"http://en.wikipedia.org/wiki/Digamma_function\">Digamma</a>\n * @see <a href=\"http://www.uv.es/~bernardo/1976AppStatist.pdf\">Bernardo&apos;s original article </a>\n * @since 2.0\n */\npublic static double digamma(double x) {\n    if (Double.isNaN(x) || Double.isInfinite(x)) {\n        return x;\n    }\n    if (x > 0 && x <= S_LIMIT) {\n        // use method 5 from Bernardo AS103\n        // accurate to O(x)\n        return -GAMMA - 1 / x;\n    }\n    if (x >= C_LIMIT) {\n        // use method 4 (accurate to O(1/x^8)\n        double inv = 1 / (x * x);\n        //            1       1        1         1\n        // log(x) -  --- - ------ + ------- - -------\n        //           2 x   12 x^2   120 x^4   252 x^6\n        return FastMath.log(x) - 0.5 / x - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));\n    }\n    return digamma(x + 1) - 1 / x;\n}"
            ],
            [
                "trigamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Computes the trigamma function of x.\n * This function is derived by taking the derivative of the implementation\n * of digamma.\n *\n * @param x Argument.\n * @return trigamma(x) to within 10-8 relative or absolute error whichever is smaller\n * @see <a href=\"http://en.wikipedia.org/wiki/Trigamma_function\">Trigamma</a>\n * @see Gamma#digamma(double)\n * @since 2.0\n */\npublic static double trigamma(double x) {\n    if (Double.isNaN(x) || Double.isInfinite(x)) {\n        return x;\n    }\n    if (x > 0 && x <= S_LIMIT) {\n        return 1 / (x * x);\n    }\n    if (x >= C_LIMIT) {\n        double inv = 1 / (x * x);\n        //  1    1      1       1       1\n        //  - + ---- + ---- - ----- + -----\n        //  x      2      3       5       7\n        //      2 x    6 x    30 x    42 x\n        return 1 / x + inv / 2 + inv / x * (1.0 / 6 - inv * (1.0 / 30 + inv / 42));\n    }\n    return trigamma(x + 1) + 1 / (x * x);\n}"
            ],
            [
                "lanczos",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>\n * Returns the Lanczos approximation used to compute the gamma function.\n * The Lanczos approximation is related to the Gamma function by the\n * following equation\n * <center>\n * {@code gamma(x) = sqrt(2 * pi) / x * (x + g + 0.5) ^ (x + 0.5)\n *                   * exp(-x - g - 0.5) * lanczos(x)},\n * </center>\n * where {@code g} is the Lanczos constant.\n * </p>\n *\n * @param x Argument.\n * @return The Lanczos approximation.\n * @see <a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">Lanczos Approximation</a>\n * equations (1) through (5), and Paul Godfrey's\n * <a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Note on the computation\n * of the convergent Lanczos complex Gamma approximation</a>\n * @since 3.1\n */\npublic static double lanczos(final double x) {\n    double sum = 0.0;\n    for (int i = LANCZOS.length - 1; i > 0; --i) {\n        sum += LANCZOS[i] / (x + i);\n    }\n    return sum + LANCZOS[0];\n}"
            ],
            [
                "invGamma1pm1",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of 1 / &Gamma;(1 + x) - 1 for -0&#46;5 &le; x &le;\n * 1&#46;5. This implementation is based on the double precision\n * implementation in the <em>NSWC Library of Mathematics Subroutines</em>,\n * {@code DGAM1}.\n *\n * @param x Argument.\n * @return The value of {@code 1.0 / Gamma(1.0 + x) - 1.0}.\n * @throws NumberIsTooSmallException if {@code x < -0.5}\n * @throws NumberIsTooLargeException if {@code x > 1.5}\n * @since 3.1\n */\npublic static double invGamma1pm1(final double x) {\n    if (x < -0.5) {\n        throw new NumberIsTooSmallException(x, -0.5, true);\n    }\n    if (x > 1.5) {\n        throw new NumberIsTooLargeException(x, 1.5, true);\n    }\n    final double ret;\n    final double t = x <= 0.5 ? x : (x - 0.5) - 0.5;\n    if (t < 0.0) {\n        final double a = INV_GAMMA1P_M1_A0 + t * INV_GAMMA1P_M1_A1;\n        double b = INV_GAMMA1P_M1_B8;\n        b = INV_GAMMA1P_M1_B7 + t * b;\n        b = INV_GAMMA1P_M1_B6 + t * b;\n        b = INV_GAMMA1P_M1_B5 + t * b;\n        b = INV_GAMMA1P_M1_B4 + t * b;\n        b = INV_GAMMA1P_M1_B3 + t * b;\n        b = INV_GAMMA1P_M1_B2 + t * b;\n        b = INV_GAMMA1P_M1_B1 + t * b;\n        b = 1.0 + t * b;\n        double c = INV_GAMMA1P_M1_C13 + t * (a / b);\n        c = INV_GAMMA1P_M1_C12 + t * c;\n        c = INV_GAMMA1P_M1_C11 + t * c;\n        c = INV_GAMMA1P_M1_C10 + t * c;\n        c = INV_GAMMA1P_M1_C9 + t * c;\n        c = INV_GAMMA1P_M1_C8 + t * c;\n        c = INV_GAMMA1P_M1_C7 + t * c;\n        c = INV_GAMMA1P_M1_C6 + t * c;\n        c = INV_GAMMA1P_M1_C5 + t * c;\n        c = INV_GAMMA1P_M1_C4 + t * c;\n        c = INV_GAMMA1P_M1_C3 + t * c;\n        c = INV_GAMMA1P_M1_C2 + t * c;\n        c = INV_GAMMA1P_M1_C1 + t * c;\n        c = INV_GAMMA1P_M1_C + t * c;\n        if (x > 0.5) {\n            ret = t * c / x;\n        } else {\n            ret = x * ((c + 0.5) + 0.5);\n        }\n    } else {\n        double p = INV_GAMMA1P_M1_P6;\n        p = INV_GAMMA1P_M1_P5 + t * p;\n        p = INV_GAMMA1P_M1_P4 + t * p;\n        p = INV_GAMMA1P_M1_P3 + t * p;\n        p = INV_GAMMA1P_M1_P2 + t * p;\n        p = INV_GAMMA1P_M1_P1 + t * p;\n        p = INV_GAMMA1P_M1_P0 + t * p;\n        double q = INV_GAMMA1P_M1_Q4;\n        q = INV_GAMMA1P_M1_Q3 + t * q;\n        q = INV_GAMMA1P_M1_Q2 + t * q;\n        q = INV_GAMMA1P_M1_Q1 + t * q;\n        q = 1.0 + t * q;\n        double c = INV_GAMMA1P_M1_C13 + (p / q) * t;\n        c = INV_GAMMA1P_M1_C12 + t * c;\n        c = INV_GAMMA1P_M1_C11 + t * c;\n        c = INV_GAMMA1P_M1_C10 + t * c;\n        c = INV_GAMMA1P_M1_C9 + t * c;\n        c = INV_GAMMA1P_M1_C8 + t * c;\n        c = INV_GAMMA1P_M1_C7 + t * c;\n        c = INV_GAMMA1P_M1_C6 + t * c;\n        c = INV_GAMMA1P_M1_C5 + t * c;\n        c = INV_GAMMA1P_M1_C4 + t * c;\n        c = INV_GAMMA1P_M1_C3 + t * c;\n        c = INV_GAMMA1P_M1_C2 + t * c;\n        c = INV_GAMMA1P_M1_C1 + t * c;\n        c = INV_GAMMA1P_M1_C0 + t * c;\n        if (x > 0.5) {\n            ret = (t / x) * ((c - 0.5) - 0.5);\n        } else {\n            ret = x * c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "logGamma1p",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of log &Gamma;(1 + x) for -0&#46;5 &le; x &le; 1&#46;5.\n * This implementation is based on the double precision implementation in\n * the <em>NSWC Library of Mathematics Subroutines</em>, {@code DGMLN1}.\n *\n * @param x Argument.\n * @return The value of {@code log(Gamma(1 + x))}.\n * @throws NumberIsTooSmallException if {@code x < -0.5}.\n * @throws NumberIsTooLargeException if {@code x > 1.5}.\n * @since 3.1\n */\npublic static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException {\n    if (x < -0.5) {\n        throw new NumberIsTooSmallException(x, -0.5, true);\n    }\n    if (x > 1.5) {\n        throw new NumberIsTooLargeException(x, 1.5, true);\n    }\n    return -FastMath.log1p(invGamma1pm1(x));\n}"
            ],
            [
                "gamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of \u0393(x). Based on the <em>NSWC Library of\n * Mathematics Subroutines</em> double precision implementation,\n * {@code DGAMMA}.\n *\n * @param x Argument.\n * @return the value of {@code Gamma(x)}.\n * @since 3.1\n */\npublic static double gamma(final double x) {\n    if ((x == FastMath.rint(x)) && (x <= 0.0)) {\n        return Double.NaN;\n    }\n    final double ret;\n    final double absX = FastMath.abs(x);\n    if (absX <= 20.0) {\n        if (x >= 1.0) {\n            /*\n                 * From the recurrence relation\n                 * Gamma(x) = (x - 1) * ... * (x - n) * Gamma(x - n),\n                 * then\n                 * Gamma(t) = 1 / [1 + invGamma1pm1(t - 1)],\n                 * where t = x - n. This means that t must satisfy\n                 * -0.5 <= t - 1 <= 1.5.\n                 */\n            double prod = 1.0;\n            double t = x;\n            while (t > 2.5) {\n                t -= 1.0;\n                prod *= t;\n            }\n            ret = prod / (1.0 + invGamma1pm1(t - 1.0));\n        } else {\n            /*\n                 * From the recurrence relation\n                 * Gamma(x) = Gamma(x + n + 1) / [x * (x + 1) * ... * (x + n)]\n                 * then\n                 * Gamma(x + n + 1) = 1 / [1 + invGamma1pm1(x + n)],\n                 * which requires -0.5 <= x + n <= 1.5.\n                 */\n            double prod = x;\n            double t = x;\n            while (t < -0.5) {\n                t += 1.0;\n                prod *= t;\n            }\n            ret = 1.0 / (prod * (1.0 + invGamma1pm1(t)));\n        }\n    } else {\n        final double y = absX + LANCZOS_G + 0.5;\n        final double gammaAbs = SQRT_TWO_PI / absX * FastMath.pow(y, absX + 0.5) * FastMath.exp(-y) * lanczos(absX);\n        if (x > 0.0) {\n            ret = gammaAbs;\n        } else {\n            /*\n                 * From the reflection formula\n                 * Gamma(x) * Gamma(1 - x) * sin(pi * x) = pi,\n                 * and the recurrence relation\n                 * Gamma(1 - x) = -x * Gamma(-x),\n                 * it is found\n                 * Gamma(x) = -pi / [x * sin(pi * x) * Gamma(-x)].\n                 */\n            ret = -FastMath.PI / (x * FastMath.sin(FastMath.PI * x) * gammaAbs);\n        }\n    }\n    return ret;\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * regularized beta function</a> I(x, a, b).\n *\n * @param x Value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @return the regularized beta function I(x, a, b).\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b) {\n    return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * regularized beta function</a> I(x, a, b).\n *\n * @param x Value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b, double epsilon) {\n    return regularizedBeta(x, a, b, epsilon, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b, int maxIterations) {\n    return regularizedBeta(x, a, b, DEFAULT_EPSILON, maxIterations);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li>\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * Regularized Beta Function</a>.</li>\n * <li>\n * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n * Regularized Beta Function</a>.</li>\n * </ul>\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0 || b <= 0) {\n        ret = Double.NaN;\n    } else if (x > (a + 1) / (2 + b + a) && 1 - x <= (b + 1) / (2 + b + a)) {\n        ret = 1 - regularizedBeta(1 - x, b, a, epsilon, maxIterations);\n    } else {\n        ContinuedFraction fraction = new ContinuedFraction() {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getB(int n, double x) {\n                double ret;\n                double m;\n                if (n % 2 == 0) {\n                    // even\n                    m = n / 2.0;\n                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));\n                } else {\n                    m = (n - 1.0) / 2.0;\n                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                }\n                return ret;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getA(int n, double x) {\n                return 1.0;\n            }\n        };\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n    }\n    return ret;\n}"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the natural logarithm of the beta function B(a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n * Beta Function</a>, equation (1).</li>\n * </ul>\n *\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon This parameter is ignored.\n * @param maxIterations This parameter is ignored.\n * @return log(B(a, b)).\n * @deprecated as of version 3.1, this method is deprecated as the\n * computation of the beta function is no longer iterative; it will be\n * removed in version 4.0. Current implementation of this method\n * internally calls {@link #logBeta(double, double)}.\n */\n@Deprecated\npublic static double logBeta(double a, double b, double epsilon, int maxIterations) {\n    return logBeta(a, b);\n}"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the value of log B(p, q) for 0 \u2264 x \u2264 1 and p, q > 0. Based on the\n * <em>NSWC Library of Mathematics Subroutines</em> implementation,\n * {@code DBETLN}.\n *\n * @param p First argument.\n * @param q Second argument.\n * @return the value of {@code log(Beta(p, q))}, {@code NaN} if\n * {@code p <= 0} or {@code q <= 0}.\n */\npublic static double logBeta(final double p, final double q) {\n    if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n        return Double.NaN;\n    }\n    final double a = FastMath.min(p, q);\n    final double b = FastMath.max(p, q);\n    if (a >= 10.0) {\n        final double w = sumDeltaMinusDeltaSum(a, b);\n        final double h = a / b;\n        final double c = h / (1.0 + h);\n        final double u = -(a - 0.5) * FastMath.log(c);\n        final double v = b * FastMath.log1p(h);\n        if (u <= v) {\n            return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;\n        } else {\n            return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n        }\n    } else if (a > 2.0) {\n        if (b > 1000.0) {\n            final int n = (int) FastMath.floor(a - 1.0);\n            double prod = 1.0;\n            double ared = a;\n            for (int i = 0; i < n; i++) {\n                ared -= 1.0;\n                prod *= ared / (1.0 + ared / b);\n            }\n            return (FastMath.log(prod) - n * FastMath.log(b)) + (Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared, b));\n        } else {\n            double prod1 = 1.0;\n            double ared = a;\n            while (ared > 2.0) {\n                ared -= 1.0;\n                final double h = ared / b;\n                prod1 *= h / (1.0 + h);\n            }\n            if (b < 10.0) {\n                double prod2 = 1.0;\n                double bred = b;\n                while (bred > 2.0) {\n                    bred -= 1.0;\n                    prod2 *= bred / (ared + bred);\n                }\n                return FastMath.log(prod1) + FastMath.log(prod2) + (Gamma.logGamma(ared) + (Gamma.logGamma(bred) - logGammaSum(ared, bred)));\n            } else {\n                return FastMath.log(prod1) + Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared, b);\n            }\n        }\n    } else if (a >= 1.0) {\n        if (b > 2.0) {\n            if (b < 10.0) {\n                double prod = 1.0;\n                double bred = b;\n                while (bred > 2.0) {\n                    bred -= 1.0;\n                    prod *= bred / (a + bred);\n                }\n                return FastMath.log(prod) + (Gamma.logGamma(a) + (Gamma.logGamma(bred) - logGammaSum(a, bred)));\n            } else {\n                return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a, b);\n            }\n        } else {\n            return Gamma.logGamma(a) + Gamma.logGamma(b) - logGammaSum(a, b);\n        }\n    } else {\n        if (b >= 10.0) {\n            return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a, b);\n        } else {\n            // The following command is the original NSWC implementation.\n            // return Gamma.logGamma(a) +\n            // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n            // The following command turns out to be more accurate.\n            return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) / Gamma.gamma(a + b));\n        }\n    }\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.sampling",
                "DummyStepHandler",
                "/**\n * Get the only instance.\n * @return the only instance\n */\npublic static DummyStepHandler getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckTransformer",
                "/**\n * Get the Nordsieck transformer for a given number of steps.\n * @param nSteps number of steps of the multistep method\n * (excluding the one being computed)\n * @return Nordsieck transformer for the specified number of steps\n */\npublic static AdamsNordsieckTransformer getInstance(final int nSteps) {\n    synchronized (CACHE) {\n        AdamsNordsieckTransformer t = CACHE.get(nSteps);\n        if (t == null) {\n            t = new AdamsNordsieckTransformer(nSteps);\n            CACHE.put(nSteps, t);\n        }\n        return t;\n    }\n}"
            ],
            [
                "taylor",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsFieldStepInterpolator",
                "/**\n * Estimate state by applying Taylor formula.\n * @param reference reference state\n * @param time time at which state must be estimated\n * @param stepSize step size used in the scaled and Nordsieck arrays\n * @param scaled first scaled derivative\n * @param nordsieck Nordsieck vector\n * @return estimated state\n * @param <S> the type of the field elements\n */\npublic static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference, final S time, final S stepSize, final S[] scaled, final Array2DRowFieldMatrix<S> nordsieck) {\n    final S x = time.subtract(reference.getTime());\n    final S normalizedAbscissa = x.divide(stepSize);\n    S[] stateVariation = MathArrays.buildArray(time.getField(), scaled.length);\n    Arrays.fill(stateVariation, time.getField().getZero());\n    S[] estimatedDerivatives = MathArrays.buildArray(time.getField(), scaled.length);\n    Arrays.fill(estimatedDerivatives, time.getField().getZero());\n    // apply Taylor formula from high order to low order,\n    // for the sake of numerical accuracy\n    final S[][] nData = nordsieck.getDataRef();\n    for (int i = nData.length - 1; i >= 0; --i) {\n        final int order = i + 2;\n        final S[] nDataI = nData[i];\n        final S power = normalizedAbscissa.pow(order);\n        for (int j = 0; j < nDataI.length; ++j) {\n            final S d = nDataI[j].multiply(power);\n            stateVariation[j] = stateVariation[j].add(d);\n            estimatedDerivatives[j] = estimatedDerivatives[j].add(d.multiply(order));\n        }\n    }\n    S[] estimatedState = reference.getState();\n    for (int j = 0; j < stateVariation.length; ++j) {\n        stateVariation[j] = stateVariation[j].add(scaled[j].multiply(normalizedAbscissa));\n        estimatedState[j] = estimatedState[j].add(stateVariation[j]);\n        estimatedDerivatives[j] = estimatedDerivatives[j].add(scaled[j].multiply(normalizedAbscissa)).divide(x);\n    }\n    return new FieldODEStateAndDerivative<S>(time, estimatedState, estimatedDerivatives);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckFieldTransformer",
                "/**\n * Get the Nordsieck transformer for a given field and number of steps.\n * @param field field to which the time and state vector elements belong\n * @param nSteps number of steps of the multistep method\n * (excluding the one being computed)\n * @return Nordsieck transformer for the specified field and number of steps\n * @param <T> the type of the field elements\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T extends RealFieldElement<T>> AdamsNordsieckFieldTransformer<T> getInstance(final Field<T> field, final int nSteps) {\n    synchronized (CACHE) {\n        Map<Field<? extends RealFieldElement<?>>, AdamsNordsieckFieldTransformer<? extends RealFieldElement<?>>> map = CACHE.get(nSteps);\n        if (map == null) {\n            map = new HashMap<Field<? extends RealFieldElement<?>>, AdamsNordsieckFieldTransformer<? extends RealFieldElement<?>>>();\n            CACHE.put(nSteps, map);\n        }\n        // use rawtype to avoid compilation problems with java 1.5\n        @SuppressWarnings(\"rawtypes\")\n        AdamsNordsieckFieldTransformer t = map.get(field);\n        if (t == null) {\n            t = new AdamsNordsieckFieldTransformer<T>(field, nSteps);\n            map.put(field, (AdamsNordsieckFieldTransformer<T>) t);\n        }\n        return (AdamsNordsieckFieldTransformer<T>) t;\n    }\n}"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the values in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the input array\n * is null.</p>\n *\n * @param values  array of values to sum\n * @return the sum of the values or <code>Double.NaN</code> if the array\n * is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sum(final double[] values) throws MathIllegalArgumentException {\n    return SUM.evaluate(values);\n}"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double sum(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM.evaluate(values, begin, length);\n}"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the squares of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values  input array\n * @return the sum of the squared values or <code>Double.NaN</code> if the\n * array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sumSq(final double[] values) throws MathIllegalArgumentException {\n    return SUM_OF_SQUARES.evaluate(values);\n}"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the squares of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the squares of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double sumSq(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM_OF_SQUARES.evaluate(values, begin, length);\n}"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the product of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the product of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double product(final double[] values) throws MathIllegalArgumentException {\n    return PRODUCT.evaluate(values);\n}"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the product of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the product of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double product(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return PRODUCT.evaluate(values, begin, length);\n}"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the natural logs of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.summary.SumOfLogs}.\n * </p>\n *\n * @param values the input array\n * @return the sum of the natural logs of the values or Double.NaN if\n * the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sumLog(final double[] values) throws MathIllegalArgumentException {\n    return SUM_OF_LOGS.evaluate(values);\n}"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the natural logs of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.summary.SumOfLogs}.\n * </p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the natural logs of the values or Double.NaN if\n * length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double sumLog(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM_OF_LOGS.evaluate(values, begin, length);\n}"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the arithmetic mean of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Mean} for\n * details on the computing algorithm.</p>\n *\n * @param values the input array\n * @return the mean of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double mean(final double[] values) throws MathIllegalArgumentException {\n    return MEAN.evaluate(values);\n}"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the arithmetic mean of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Mean} for\n * details on the computing algorithm.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the mean of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double mean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MEAN.evaluate(values, begin, length);\n}"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the geometric mean of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.GeometricMean}\n * for details on the computing algorithm.</p>\n *\n * @param values the input array\n * @return the geometric mean of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double geometricMean(final double[] values) throws MathIllegalArgumentException {\n    return GEOMETRIC_MEAN.evaluate(values);\n}"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the geometric mean of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.GeometricMean}\n * for details on the computing algorithm.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the geometric mean of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double geometricMean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return GEOMETRIC_MEAN.evaluate(values, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[])} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double variance(final double[] values) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], int, int)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double variance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the specified portion of\n * the input array, using the precomputed mean value.  Returns\n * <code>Double.NaN</code> if the designated subarray is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], double, int, int)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double variance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, mean, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the input array, using the\n * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n * is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], double)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @return the variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double variance(final double[] values, final double mean) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, mean);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the formula and computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the population variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double populationVariance(final double[] values) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the population variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double populationVariance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, begin, length);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the specified portion of\n * the input array, using the precomputed mean value.  Returns\n * <code>Double.NaN</code> if the designated subarray is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the population variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double populationVariance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, mean, begin, length);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the input array, using the\n * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n * is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @return the population variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double populationVariance(final double[] values, final double mean) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, mean);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the maximum of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @return the maximum of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double max(final double[] values) throws MathIllegalArgumentException {\n    return MAX.evaluate(values);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the maximum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or\n * the array index parameters are not valid.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the maximum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double max(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MAX.evaluate(values, begin, length);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the minimum of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n * </ul> </p>\n *\n * @param values the input array\n * @return the minimum of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double min(final double[] values) throws MathIllegalArgumentException {\n    return MIN.evaluate(values);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the minimum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or\n * the array index parameters are not valid.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the minimum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double min(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MIN.evaluate(values, begin, length);\n}"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns an estimate of the <code>p</code>th percentile of the values\n * in the <code>values</code> array.\n * <p>\n * <ul>\n * <li>Returns <code>Double.NaN</code> if <code>values</code> has length\n * <code>0</code></li></p>\n * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n *  if <code>values</code> has length <code>1</code></li>\n * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n * is null  or p is not a valid quantile value (p must be greater than 0\n * and less than or equal to 100)</li>\n * </ul></p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n * a description of the percentile estimation algorithm used.</p>\n *\n * @param values input array of values\n * @param p the percentile value to compute\n * @return the percentile value or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if <code>values</code> is null\n * or p is invalid\n */\npublic static double percentile(final double[] values, final double p) throws MathIllegalArgumentException {\n    return PERCENTILE.evaluate(values, p);\n}"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns an estimate of the <code>p</code>th percentile of the values\n * in the <code>values</code> array, starting with the element in (0-based)\n * position <code>begin</code> in the array and including <code>length</code>\n * values.\n * <p>\n * <ul>\n * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n *  if <code>length = 1 </code></li>\n * <li>Throws <code>MathIllegalArgumentException</code> if <code>values</code>\n *  is null , <code>begin</code> or <code>length</code> is invalid, or\n * <code>p</code> is not a valid quantile value (p must be greater than 0\n * and less than or equal to 100)</li>\n * </ul></p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n * a description of the percentile estimation algorithm used.</p>\n *\n * @param values array of input values\n * @param p  the percentile to compute\n * @param begin  the first (0-based) element to include in the computation\n * @param length  the number of array elements to include\n * @return  the percentile value\n * @throws MathIllegalArgumentException if the parameters are not valid or the\n * input array is null\n */\npublic static double percentile(final double[] values, final int begin, final int length, final double p) throws MathIllegalArgumentException {\n    return PERCENTILE.evaluate(values, begin, length, p);\n}"
            ],
            [
                "sumDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., sum(sample1[i] - sample2[i]).\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @return sum of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * (positive) length.\n * @throws NoDataException if the sample arrays are empty.\n */\npublic static double sumDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n <= 0) {\n        throw new NoDataException(LocalizedFormats.INSUFFICIENT_DIMENSION);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        result += sample1[i] - sample2[i];\n    }\n    return result;\n}"
            ],
            [
                "meanDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the mean of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., sum(sample1[i] - sample2[i]) / sample1.length.\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @return mean of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * (positive) length.\n * @throws NoDataException if the sample arrays are empty.\n */\npublic static double meanDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException {\n    return sumDifference(sample1, sample2) / sample1.length;\n}"
            ],
            [
                "varianceDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., var(sample1[i] - sample2[i]).\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @param meanDifference   the mean difference between corresponding entries\n * @see #meanDifference(double[],double[])\n * @return variance of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * length.\n * @throws NumberIsTooSmallException if the arrays length is less than 2.\n */\npublic static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference) throws DimensionMismatchException, NumberIsTooSmallException {\n    double sum1 = 0d;\n    double sum2 = 0d;\n    double diff = 0d;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    for (int i = 0; i < n; i++) {\n        diff = sample1[i] - sample2[i];\n        sum1 += (diff - meanDifference) * (diff - meanDifference);\n        sum2 += diff - meanDifference;\n    }\n    return (sum1 - (sum2 * sum2 / n)) / (n - 1);\n}"
            ],
            [
                "normalize",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Normalize (standardize) the sample, so it is has a mean of 0 and a standard deviation of 1.\n *\n * @param sample Sample to normalize.\n * @return normalized (standardized) sample.\n * @since 2.2\n */\npublic static double[] normalize(final double[] sample) {\n    DescriptiveStatistics stats = new DescriptiveStatistics();\n    // Add the data from the series to stats\n    for (int i = 0; i < sample.length; i++) {\n        stats.addValue(sample[i]);\n    }\n    // Compute mean and standard deviation\n    double mean = stats.getMean();\n    double standardDeviation = stats.getStandardDeviation();\n    // initialize the standardizedSample, which has the same length as the sample\n    double[] standardizedSample = new double[sample.length];\n    for (int i = 0; i < sample.length; i++) {\n        // z = (x- mean)/standardDeviation\n        standardizedSample[i] = (sample[i] - mean) / standardDeviation;\n    }\n    return standardizedSample;\n}"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sample mode(s).  The mode is the most frequently occurring\n * value in the sample. If there is a unique value with maximum frequency,\n * this value is returned as the only element of the output array. Otherwise,\n * the returned array contains the maximum frequency elements in increasing\n * order.  For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},\n * the returned array will have length two, with 0 in the first element and\n * 5 in the second.\n *\n * <p>NaN values are ignored when computing the mode - i.e., NaNs will never\n * appear in the output array.  If the sample includes only NaNs or has\n * length 0, an empty array is returned.</p>\n *\n * @param sample input data\n * @return array of array of the most frequently occurring element(s) sorted in ascending order.\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static double[] mode(double[] sample) throws MathIllegalArgumentException {\n    if (sample == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    return getMode(sample, 0, sample.length);\n}"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sample mode(s).  The mode is the most frequently occurring\n * value in the sample. If there is a unique value with maximum frequency,\n * this value is returned as the only element of the output array. Otherwise,\n * the returned array contains the maximum frequency elements in increasing\n * order.  For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},\n * the returned array will have length two, with 0 in the first element and\n * 5 in the second.\n *\n * <p>NaN values are ignored when computing the mode - i.e., NaNs will never\n * appear in the output array.  If the sample includes only NaNs or has\n * length 0, an empty array is returned.</p>\n *\n * @param sample input data\n * @param begin index (0-based) of the first array element to include\n * @param length the number of elements to include\n *\n * @return array of array of the most frequently occurring element(s) sorted in ascending order.\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static double[] mode(double[] sample, final int begin, final int length) {\n    if (sample == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    if (begin < 0) {\n        throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));\n    }\n    if (length < 0) {\n        throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));\n    }\n    return getMode(sample, begin, length);\n}"
            ],
            [
                "getAgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create an Agresti-Coull binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getAgrestiCoullInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return AGRESTI_COULL.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a Clopper-Pearson binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n * <p>\n * Preconditions:\n * <ul>\n * <li>{@code numberOfTrials} must be positive</li>\n * <li>{@code numberOfSuccesses} may not exceed {@code numberOfTrials}</li>\n * <li>{@code confidenceLevel} must be strictly between 0 and 1 (exclusive)</li>\n * </ul>\n * </p>\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getClopperPearsonInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return CLOPPER_PEARSON.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getNormalApproximationInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a binomial confidence interval for the true probability of success\n * of an unknown binomial distribution with the given observed number of\n * trials, successes and confidence level using the Normal approximation to\n * the binomial distribution.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n */\npublic static ConfidenceInterval getNormalApproximationInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return NORMAL_APPROXIMATION.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getWilsonScoreInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a Wilson score binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getWilsonScoreInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return WILSON_SCORE.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "// CHECKSTYLE: stop JavadocMethodCheck\n/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticT(double[], double[])\n */\npublic static double homoscedasticT(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.homoscedasticT(sample1, sample2);\n}"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticT(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double homoscedasticT(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.homoscedasticT(sampleStats1, sampleStats2);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(double[], double[], double)\n */\npublic static boolean homoscedasticTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sample1, sample2, alpha);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(double[], double[])\n */\npublic static double homoscedasticTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sample1, sample2);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double homoscedasticTTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sampleStats1, sampleStats2);\n}"
            ],
            [
                "pairedT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedT(double[], double[])\n */\npublic static double pairedT(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException {\n    return T_TEST.pairedT(sample1, sample2);\n}"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedTTest(double[], double[], double)\n */\npublic static boolean pairedTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.pairedTTest(sample1, sample2, alpha);\n}"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedTTest(double[], double[])\n */\npublic static double pairedTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.pairedTTest(sample1, sample2);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double, double[])\n */\npublic static double t(final double mu, final double[] observed) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(mu, observed);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double t(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(mu, sampleStats);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double[], double[])\n */\npublic static double t(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(sample1, sample2);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double t(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(sampleStats1, sampleStats2);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, double[], double)\n */\npublic static boolean tTest(final double mu, final double[] sample, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sample, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, double[])\n */\npublic static double tTest(final double mu, final double[] sample) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sample);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary, double)\n */\npublic static boolean tTest(final double mu, final StatisticalSummary sampleStats, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sampleStats, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double tTest(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sampleStats);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double[], double[], double)\n */\npublic static boolean tTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(sample1, sample2, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double[], double[])\n */\npublic static double tTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(sample1, sample2);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary, double)\n */\npublic static boolean tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(sampleStats1, sampleStats2, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(sampleStats1, sampleStats2);\n}"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquare(double[], long[])\n */\npublic static double chiSquare(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException {\n    return CHI_SQUARE_TEST.chiSquare(expected, observed);\n}"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquare(long[][])\n */\npublic static double chiSquare(final long[][] counts) throws NullArgumentException, NotPositiveException, DimensionMismatchException {\n    return CHI_SQUARE_TEST.chiSquare(counts);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(double[], long[], double)\n */\npublic static boolean chiSquareTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(expected, observed, alpha);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(double[], long[])\n */\npublic static double chiSquareTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(expected, observed);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(long[][], double)\n */\npublic static boolean chiSquareTest(final long[][] counts, final double alpha) throws NullArgumentException, DimensionMismatchException, NotPositiveException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(counts, alpha);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(long[][])\n */\npublic static double chiSquareTest(final long[][] counts) throws NullArgumentException, DimensionMismatchException, NotPositiveException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(counts);\n}"
            ],
            [
                "chiSquareDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareDataSetsComparison(long[], long[])\n *\n * @since 1.2\n */\npublic static double chiSquareDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return CHI_SQUARE_TEST.chiSquareDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTestDataSetsComparison(long[], long[])\n *\n * @since 1.2\n */\npublic static double chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTestDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTestDataSetsComparison(long[], long[], double)\n *\n * @since 1.2\n */\npublic static boolean chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTestDataSetsComparison(observed1, observed2, alpha);\n}"
            ],
            [
                "oneWayAnovaFValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaFValue(Collection)\n *\n * @since 1.2\n */\npublic static double oneWayAnovaFValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException {\n    return ONE_WAY_ANANOVA.anovaFValue(categoryData);\n}"
            ],
            [
                "oneWayAnovaPValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaPValue(Collection)\n *\n * @since 1.2\n */\npublic static double oneWayAnovaPValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException, ConvergenceException, MaxCountExceededException {\n    return ONE_WAY_ANANOVA.anovaPValue(categoryData);\n}"
            ],
            [
                "oneWayAnovaTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaTest(Collection,double)\n *\n * @since 1.2\n */\npublic static boolean oneWayAnovaTest(final Collection<double[]> categoryData, final double alpha) throws NullArgumentException, DimensionMismatchException, OutOfRangeException, ConvergenceException, MaxCountExceededException {\n    return ONE_WAY_ANANOVA.anovaTest(categoryData, alpha);\n}"
            ],
            [
                "g",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#g(double[], long[])\n * @since 3.1\n */\npublic static double g(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException {\n    return G_TEST.g(expected, observed);\n}"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTest( double[],  long[] )\n * @since 3.1\n */\npublic static double gTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return G_TEST.gTest(expected, observed);\n}"
            ],
            [
                "gTestIntrinsic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestIntrinsic(double[], long[] )\n * @since 3.1\n */\npublic static double gTestIntrinsic(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return G_TEST.gTestIntrinsic(expected, observed);\n}"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTest( double[],long[],double)\n * @since 3.1\n */\npublic static boolean gTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException {\n    return G_TEST.gTest(expected, observed, alpha);\n}"
            ],
            [
                "gDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gDataSetsComparison(long[], long[])\n * @since 3.1\n */\npublic static double gDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return G_TEST.gDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "rootLogLikelihoodRatio",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#rootLogLikelihoodRatio(long, long, long, long)\n * @since 3.1\n */\npublic static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return G_TEST.rootLogLikelihoodRatio(k11, k12, k21, k22);\n}"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestDataSetsComparison(long[], long[])\n * @since 3.1\n */\npublic static double gTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException {\n    return G_TEST.gTestDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestDataSetsComparison(long[],long[],double)\n * @since 3.1\n */\npublic static boolean gTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException {\n    return G_TEST.gTestDataSetsComparison(observed1, observed2, alpha);\n}"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovStatistic(RealDistribution, double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovStatistic(dist, data);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[], boolean)\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data, strict);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[], double)\n * @since 3.3\n */\npublic static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data, alpha);\n}"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovStatistic(double[], double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovStatistic(double[] x, double[] y) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovStatistic(x, y);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(double[], double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(double[] x, double[] y) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(x, y);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(double[], double[], boolean)\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(double[] x, double[] y, boolean strict) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(x, y, strict);\n}"
            ],
            [
                "exactP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#exactP(double, int, int, boolean)\n * @since 3.3\n */\npublic static double exactP(double d, int m, int n, boolean strict) {\n    return KS_TEST.exactP(d, n, m, strict);\n}"
            ],
            [
                "approximateP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#approximateP(double, int, int)\n * @since 3.3\n */\npublic static double approximateP(double d, int n, int m) {\n    return KS_TEST.approximateP(d, n, m);\n}"
            ],
            [
                "monteCarloP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#monteCarloP(double, int, int, boolean, int)\n * @since 3.3\n */\npublic static double monteCarloP(double d, int n, int m, boolean strict, int iterations) {\n    return KS_TEST.monteCarloP(d, n, m, strict, iterations);\n}"
            ],
            [
                "aggregate",
                "org.apache.commons.math3.stat.descriptive",
                "AggregateSummaryStatistics",
                "/**\n * Computes aggregate summary statistics. This method can be used to combine statistics\n * computed over partitions or subsamples - i.e., the StatisticalSummaryValues returned\n * should contain the same values that would have been obtained by computing a single\n * StatisticalSummary over the combined dataset.\n * <p>\n * Returns null if the collection is empty or null.\n * </p>\n *\n * @param statistics collection of SummaryStatistics to aggregate\n * @return summary statistics for the combined dataset\n */\npublic static StatisticalSummaryValues aggregate(Collection<? extends StatisticalSummary> statistics) {\n    if (statistics == null) {\n        return null;\n    }\n    Iterator<? extends StatisticalSummary> iterator = statistics.iterator();\n    if (!iterator.hasNext()) {\n        return null;\n    }\n    StatisticalSummary current = iterator.next();\n    long n = current.getN();\n    double min = current.getMin();\n    double sum = current.getSum();\n    double max = current.getMax();\n    double var = current.getVariance();\n    double m2 = var * (n - 1d);\n    double mean = current.getMean();\n    while (iterator.hasNext()) {\n        current = iterator.next();\n        if (current.getMin() < min || Double.isNaN(min)) {\n            min = current.getMin();\n        }\n        if (current.getMax() > max || Double.isNaN(max)) {\n            max = current.getMax();\n        }\n        sum += current.getSum();\n        final double oldN = n;\n        final double curN = current.getN();\n        n += curN;\n        final double meanDiff = current.getMean() - mean;\n        mean = sum / n;\n        final double curM2 = current.getVariance() * (curN - 1d);\n        m2 = m2 + curM2 + meanDiff * meanDiff * oldN * curN / n;\n    }\n    final double variance;\n    if (n == 0) {\n        variance = Double.NaN;\n    } else if (n == 1) {\n        variance = 0d;\n    } else {\n        variance = m2 / (n - 1);\n    }\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}"
            ],
            [
                "newMarkers",
                "org.apache.commons.math3.stat.descriptive.rank",
                "PSquarePercentile",
                "/**\n * A creation method to build Markers\n *\n * @param initialFive list of initial five elements\n * @param p the quantile desired\n * @return an instance of PSquareMarkers\n */\npublic static PSquareMarkers newMarkers(final List<Double> initialFive, final double p) {\n    return new Markers(initialFive, p);\n}"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "/**\n * Creates an exponential decay {@link NeighbourhoodSizeFunction function}.\n * It will compute <code>a e<sup>-x / b</sup></code>,\n * where {@code x} is the (integer) independent variable and\n * <ul>\n *  <li><code>a = initValue</code>\n *  <li><code>b = -numCall / ln(valueAtNumCall / initValue)</code>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link NeighbourhoodSizeFunction#value(long) value(0)}.\n * @param valueAtNumCall Value of the function at {@code numCall}.\n * @param numCall Argument for which the function returns\n * {@code valueAtNumCall}.\n * @return the neighbourhood size function.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code initValue <= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code valueAtNumCall <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code valueAtNumCall >= initValue}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static NeighbourhoodSizeFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall) {\n    return new NeighbourhoodSizeFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final ExponentialDecayFunction decay = new ExponentialDecayFunction(initValue, valueAtNumCall, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public int value(long n) {\n            return (int) FastMath.rint(decay.value(n));\n        }\n    };\n}"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "/**\n * Creates an sigmoid-like {@code NeighbourhoodSizeFunction function}.\n * The function {@code f} will have the following properties:\n * <ul>\n *  <li>{@code f(0) = initValue}</li>\n *  <li>{@code numCall} is the inflexion point</li>\n *  <li>{@code slope = f'(numCall)}</li>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link NeighbourhoodSizeFunction#value(long) value(0)}.\n * @param slope Value of the function derivative at {@code numCall}.\n * @param numCall Inflexion point.\n * @return the neighbourhood size function.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code initValue <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code slope >= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static NeighbourhoodSizeFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall) {\n    return new NeighbourhoodSizeFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final QuasiSigmoidDecayFunction decay = new QuasiSigmoidDecayFunction(initValue, slope, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public int value(long n) {\n            return (int) FastMath.rint(decay.value(n));\n        }\n    };\n}"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "/**\n * Creates an exponential decay {@link LearningFactorFunction function}.\n * It will compute <code>a e<sup>-x / b</sup></code>,\n * where {@code x} is the (integer) independent variable and\n * <ul>\n *  <li><code>a = initValue</code>\n *  <li><code>b = -numCall / ln(valueAtNumCall / initValue)</code>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link LearningFactorFunction#value(long) value(0)}.\n * @param valueAtNumCall Value of the function at {@code numCall}.\n * @param numCall Argument for which the function returns\n * {@code valueAtNumCall}.\n * @return the learning factor function.\n * @throws org.apache.commons.math3.exception.OutOfRangeException\n * if {@code initValue <= 0} or {@code initValue > 1}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code valueAtNumCall <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code valueAtNumCall >= initValue}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static LearningFactorFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall) {\n    if (initValue <= 0 || initValue > 1) {\n        throw new OutOfRangeException(initValue, 0, 1);\n    }\n    return new LearningFactorFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final ExponentialDecayFunction decay = new ExponentialDecayFunction(initValue, valueAtNumCall, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(long n) {\n            return decay.value(n);\n        }\n    };\n}"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "/**\n * Creates an sigmoid-like {@code LearningFactorFunction function}.\n * The function {@code f} will have the following properties:\n * <ul>\n *  <li>{@code f(0) = initValue}</li>\n *  <li>{@code numCall} is the inflexion point</li>\n *  <li>{@code slope = f'(numCall)}</li>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link LearningFactorFunction#value(long) value(0)}.\n * @param slope Value of the function derivative at {@code numCall}.\n * @param numCall Inflexion point.\n * @return the learning factor function.\n * @throws org.apache.commons.math3.exception.OutOfRangeException\n * if {@code initValue <= 0} or {@code initValue > 1}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code slope >= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static LearningFactorFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall) {\n    if (initValue <= 0 || initValue > 1) {\n        throw new OutOfRangeException(initValue, 0, 1);\n    }\n    return new LearningFactorFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final QuasiSigmoidDecayFunction decay = new QuasiSigmoidDecayFunction(initValue, slope, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(long n) {\n            return decay.value(n);\n        }\n    };\n}"
            ],
            [
                "findBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Finds the neuron that best matches the given features.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If the list is empty\n * {@code null} will be returned.\n * @param distance Distance function. The neuron's features are\n * passed as the first argument to {@link DistanceMeasure#compute(double[],double[])}.\n * @return the neuron whose features are closest to the given data.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n */\npublic static Neuron findBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    Neuron best = null;\n    double min = Double.POSITIVE_INFINITY;\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        if (d < min) {\n            min = d;\n            best = n;\n        }\n    }\n    return best;\n}"
            ],
            [
                "findBestAndSecondBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Finds the two neurons that best match the given features.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If the list is empty\n * {@code null} will be returned.\n * @param distance Distance function. The neuron's features are\n * passed as the first argument to {@link DistanceMeasure#compute(double[],double[])}.\n * @return the two neurons whose features are closest to the given data.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n */\npublic static Pair<Neuron, Neuron> findBestAndSecondBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    Neuron[] best = { null, null };\n    double[] min = { Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY };\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        if (d < min[0]) {\n            // Replace second best with old best.\n            min[1] = min[0];\n            best[1] = best[0];\n            // Store current as new best.\n            min[0] = d;\n            best[0] = n;\n        } else if (d < min[1]) {\n            // Replace old second best with current.\n            min[1] = d;\n            best[1] = n;\n        }\n    }\n    return new Pair<Neuron, Neuron>(best[0], best[1]);\n}"
            ],
            [
                "sort",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Creates a list of neurons sorted in increased order of the distance\n * to the given {@code features}.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If it is empty, an empty array\n * will be returned.\n * @param distance Distance function.\n * @return the neurons, sorted in increasing order of distance in data\n * space.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n *\n * @see #findBest(double[],Iterable,DistanceMeasure)\n * @see #findBestAndSecondBest(double[],Iterable,DistanceMeasure)\n *\n * @since 3.6\n */\npublic static Neuron[] sort(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    final List<PairNeuronDouble> list = new ArrayList<PairNeuronDouble>();\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        list.add(new PairNeuronDouble(n, d));\n    }\n    Collections.sort(list, PairNeuronDouble.COMPARATOR);\n    final int len = list.size();\n    final Neuron[] sorted = new Neuron[len];\n    for (int i = 0; i < len; i++) {\n        sorted[i] = list.get(i).getNeuron();\n    }\n    return sorted;\n}"
            ],
            [
                "computeU",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the <a href=\"http://en.wikipedia.org/wiki/U-Matrix\">\n *  U-matrix</a> of a two-dimensional map.\n *\n * @param map Network.\n * @param distance Function to use for computing the average\n * distance from a neuron to its neighbours.\n * @return the matrix of average distances.\n */\npublic static double[][] computeU(NeuronSquareMesh2D map, DistanceMeasure distance) {\n    final int numRows = map.getNumberOfRows();\n    final int numCols = map.getNumberOfColumns();\n    final double[][] uMatrix = new double[numRows][numCols];\n    final Network net = map.getNetwork();\n    for (int i = 0; i < numRows; i++) {\n        for (int j = 0; j < numCols; j++) {\n            final Neuron neuron = map.getNeuron(i, j);\n            final Collection<Neuron> neighbours = net.getNeighbours(neuron);\n            final double[] features = neuron.getFeatures();\n            double d = 0;\n            int count = 0;\n            for (Neuron n : neighbours) {\n                ++count;\n                d += distance.compute(features, n.getFeatures());\n            }\n            uMatrix[i][j] = d / count;\n        }\n    }\n    return uMatrix;\n}"
            ],
            [
                "computeHitHistogram",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the \"hit\" histogram of a two-dimensional map.\n *\n * @param data Feature vectors.\n * @param map Network.\n * @param distance Function to use for determining the best matching unit.\n * @return the number of hits for each neuron in the map.\n */\npublic static int[][] computeHitHistogram(Iterable<double[]> data, NeuronSquareMesh2D map, DistanceMeasure distance) {\n    final HashMap<Neuron, Integer> hit = new HashMap<Neuron, Integer>();\n    final Network net = map.getNetwork();\n    for (double[] f : data) {\n        final Neuron best = findBest(f, net, distance);\n        final Integer count = hit.get(best);\n        if (count == null) {\n            hit.put(best, 1);\n        } else {\n            hit.put(best, count + 1);\n        }\n    }\n    // Copy the histogram data into a 2D map.\n    final int numRows = map.getNumberOfRows();\n    final int numCols = map.getNumberOfColumns();\n    final int[][] histo = new int[numRows][numCols];\n    for (int i = 0; i < numRows; i++) {\n        for (int j = 0; j < numCols; j++) {\n            final Neuron neuron = map.getNeuron(i, j);\n            final Integer count = hit.get(neuron);\n            if (count == null) {\n                histo[i][j] = 0;\n            } else {\n                histo[i][j] = count;\n            }\n        }\n    }\n    return histo;\n}"
            ],
            [
                "computeQuantizationError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the quantization error.\n * The quantization error is the average distance between a feature vector\n * and its \"best matching unit\" (closest neuron).\n *\n * @param data Feature vectors.\n * @param neurons List of neurons to scan.\n * @param distance Distance function.\n * @return the error.\n * @throws NoDataException if {@code data} is empty.\n */\npublic static double computeQuantizationError(Iterable<double[]> data, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    double d = 0;\n    int count = 0;\n    for (double[] f : data) {\n        ++count;\n        d += distance.compute(f, findBest(f, neurons, distance).getFeatures());\n    }\n    if (count == 0) {\n        throw new NoDataException();\n    }\n    return d / count;\n}"
            ],
            [
                "computeTopographicError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the topographic error.\n * The topographic error is the proportion of data for which first and\n * second best matching units are not adjacent in the map.\n *\n * @param data Feature vectors.\n * @param net Network.\n * @param distance Distance function.\n * @return the error.\n * @throws NoDataException if {@code data} is empty.\n */\npublic static double computeTopographicError(Iterable<double[]> data, Network net, DistanceMeasure distance) {\n    int notAdjacentCount = 0;\n    int count = 0;\n    for (double[] f : data) {\n        ++count;\n        final Pair<Neuron, Neuron> p = findBestAndSecondBest(f, net, distance);\n        if (!net.getNeighbours(p.getFirst()).contains(p.getSecond())) {\n            // Increment count if first and second best matching units\n            // are not neighbours.\n            ++notAdjacentCount;\n        }\n    }\n    if (count == 0) {\n        throw new NoDataException();\n    }\n    return ((double) notAdjacentCount) / count;\n}"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Uniform sampling of the given range.\n *\n * @param min Lower bound of the range.\n * @param max Upper bound of the range.\n * @param rng Random number generator used to draw samples from a\n * uniform distribution.\n * @return an initializer such that the features will be initialized with\n * values within the given range.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code min >= max}.\n */\npublic static FeatureInitializer uniform(final RandomGenerator rng, final double min, final double max) {\n    return randomize(new UniformRealDistribution(rng, min, max), function(new Constant(0), 0, 0));\n}"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Uniform sampling of the given range.\n *\n * @param min Lower bound of the range.\n * @param max Upper bound of the range.\n * @return an initializer such that the features will be initialized with\n * values within the given range.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code min >= max}.\n */\npublic static FeatureInitializer uniform(final double min, final double max) {\n    return randomize(new UniformRealDistribution(min, max), function(new Constant(0), 0, 0));\n}"
            ],
            [
                "function",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Creates an initializer from a univariate function {@code f(x)}.\n * The argument {@code x} is set to {@code init} at the first call\n * and will be incremented at each call.\n *\n * @param f Function.\n * @param init Initial value.\n * @param inc Increment\n * @return the initializer.\n */\npublic static FeatureInitializer function(final UnivariateFunction f, final double init, final double inc) {\n    return new FeatureInitializer() {\n\n        /**\n         * Argument.\n         */\n        private double arg = init;\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value() {\n            final double result = f.value(arg);\n            arg += inc;\n            return result;\n        }\n    };\n}"
            ],
            [
                "randomize",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Adds some amount of random data to the given initializer.\n *\n * @param random Random variable distribution.\n * @param orig Original initializer.\n * @return an initializer whose {@link FeatureInitializer#value() value}\n * method will return {@code orig.value() + random.sample()}.\n */\npublic static FeatureInitializer randomize(final RealDistribution random, final FeatureInitializer orig) {\n    return new FeatureInitializer() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value() {\n            return orig.value() + random.sample();\n        }\n    };\n}"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Breaks a string representation up into two dfp's.\n * <p>The two dfp are such that the sum of them is equivalent\n * to the input string, but has higher precision than using a\n * single dfp. This is useful for improving accuracy of\n * exponentiation and critical multiplies.\n * @param field field to which the Dfp must belong\n * @param a string representation to split\n * @return an array of two {@link Dfp} which sum is a\n */\nprotected static Dfp[] split(final DfpField field, final String a) {\n    Dfp[] result = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n    buf = new char[a.length()];\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n        if (sig == (field.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig++;\n        }\n    }\n    result[0] = field.newDfp(new String(buf, 0, sp));\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n    result[1] = field.newDfp(new String(buf));\n    return result;\n}"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Splits a {@link Dfp} into 2 {@link Dfp}'s such that their sum is equal to the input {@link Dfp}.\n * @param a number to split\n * @return two elements array containing the split number\n */\nprotected static Dfp[] split(final Dfp a) {\n    final Dfp[] result = new Dfp[2];\n    final Dfp shift = a.multiply(a.power10K(a.getRadixDigits() / 2));\n    result[0] = a.add(shift).subtract(shift);\n    result[1] = a.subtract(result[0]);\n    return result;\n}"
            ],
            [
                "splitMult",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Multiply two numbers that are split in to two pieces that are\n *  meant to be added together.\n *  Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1\n *  Store the first term in result0, the rest in result1\n *  @param a first factor of the multiplication, in split form\n *  @param b second factor of the multiplication, in split form\n *  @return a &times; b, in split form\n */\nprotected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b) {\n    final Dfp[] result = new Dfp[2];\n    result[1] = a[0].getZero();\n    result[0] = a[0].multiply(b[0]);\n    /* If result[0] is infinite or zero, don't compute result[1].\n         * Attempting to do so may produce NaNs.\n         */\n    if (result[0].classify() == Dfp.INFINITE || result[0].equals(result[1])) {\n        return result;\n    }\n    result[1] = a[0].multiply(b[1]).add(a[1].multiply(b[0])).add(a[1].multiply(b[1]));\n    return result;\n}"
            ],
            [
                "splitDiv",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Divide two numbers that are split in to two pieces that are meant to be added together.\n * Inverse of split multiply above:\n *  (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c**2+cd) )\n *  @param a dividend, in split form\n *  @param b divisor, in split form\n *  @return a / b, in split form\n */\nprotected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b) {\n    final Dfp[] result;\n    result = new Dfp[2];\n    result[0] = a[0].divide(b[0]);\n    result[1] = a[1].multiply(b[0]).subtract(a[0].multiply(b[1]));\n    result[1] = result[1].divide(b[0].multiply(b[0]).add(b[0].multiply(b[1])));\n    return result;\n}"
            ],
            [
                "splitPow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Raise a split base to the a power.\n * @param base number to raise\n * @param a power\n * @return base<sup>a</sup>\n */\nprotected static Dfp splitPow(final Dfp[] base, int a) {\n    boolean invert = false;\n    Dfp[] r = new Dfp[2];\n    Dfp[] result = new Dfp[2];\n    result[0] = base[0].getOne();\n    result[1] = base[0].getZero();\n    if (a == 0) {\n        // Special case a = 0\n        return result[0].add(result[1]);\n    }\n    if (a < 0) {\n        // If a is less than zero\n        invert = true;\n        a = -a;\n    }\n    // Exponentiate by successive squaring\n    do {\n        r[0] = new Dfp(base[0]);\n        r[1] = new Dfp(base[1]);\n        int trial = 1;\n        int prevtrial;\n        while (true) {\n            prevtrial = trial;\n            trial *= 2;\n            if (trial > a) {\n                break;\n            }\n            r = splitMult(r, r);\n        }\n        trial = prevtrial;\n        a -= trial;\n        result = splitMult(result, r);\n    } while (a >= 1);\n    result[0] = result[0].add(result[1]);\n    if (invert) {\n        result[0] = base[0].getOne().divide(result[0]);\n    }\n    return result[0];\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Raises base to the power a by successive squaring.\n * @param base number to raise\n * @param a power\n * @return base<sup>a</sup>\n */\npublic static Dfp pow(Dfp base, int a) {\n    boolean invert = false;\n    Dfp result = base.getOne();\n    if (a == 0) {\n        // Special case\n        return result;\n    }\n    if (a < 0) {\n        invert = true;\n        a = -a;\n    }\n    // Exponentiate by successive squaring\n    do {\n        Dfp r = new Dfp(base);\n        Dfp prevr;\n        int trial = 1;\n        int prevtrial;\n        do {\n            prevr = new Dfp(r);\n            prevtrial = trial;\n            r = r.multiply(r);\n            trial *= 2;\n        } while (a > trial);\n        r = prevr;\n        trial = prevtrial;\n        a -= trial;\n        result = result.multiply(r);\n    } while (a >= 1);\n    if (invert) {\n        result = base.getOne().divide(result);\n    }\n    return base.newInstance(result);\n}"
            ],
            [
                "exp",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes e to the given power.\n * a is broken into two parts, such that a = n+m  where n is an integer.\n * We use pow() to compute e<sup>n</sup> and a Taylor series to compute\n * e<sup>m</sup>.  We return e*<sup>n</sup> &times; e<sup>m</sup>\n * @param a power at which e should be raised\n * @return e<sup>a</sup>\n */\npublic static Dfp exp(final Dfp a) {\n    final Dfp inta = a.rint();\n    final Dfp fraca = a.subtract(inta);\n    final int ia = inta.intValue();\n    if (ia > 2147483646) {\n        // return +Infinity\n        return a.newInstance((byte) 1, Dfp.INFINITE);\n    }\n    if (ia < -2147483646) {\n        // return 0;\n        return a.newInstance();\n    }\n    final Dfp einta = splitPow(a.getField().getESplit(), ia);\n    final Dfp efraca = expInternal(fraca);\n    return einta.multiply(efraca);\n}"
            ],
            [
                "expInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes e to the given power.\n * Where -1 < a < 1.  Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...\n * @param a power at which e should be raised\n * @return e<sup>a</sup>\n */\nprotected static Dfp expInternal(final Dfp a) {\n    Dfp y = a.getOne();\n    Dfp x = a.getOne();\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n    for (int i = 1; i < 90; i++) {\n        x = x.multiply(a);\n        fact = fact.divide(i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Returns the natural logarithm of a.\n * a is first split into three parts such that  a = (10000^h)(2^j)k.\n * ln(a) is computed by ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k)\n * k is in the range 2/3 < k <4/3 and is passed on to a series expansion.\n * @param a number from which logarithm is requested\n * @return log(a)\n */\npublic static Dfp log(Dfp a) {\n    int lr;\n    Dfp x;\n    int ix;\n    int p2 = 0;\n    // Check the arguments somewhat here\n    if (a.equals(a.getZero()) || a.lessThan(a.getZero()) || a.isNaN()) {\n        // negative, zero or NaN\n        a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return a.dotrap(DfpField.FLAG_INVALID, \"ln\", a, a.newInstance((byte) 1, Dfp.QNAN));\n    }\n    if (a.classify() == Dfp.INFINITE) {\n        return a;\n    }\n    x = new Dfp(a);\n    lr = x.log10K();\n    x = x.divide(pow(a.newInstance(10000), lr));\n    /* This puts x in the range 0-10000 */\n    ix = x.floor().intValue();\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n    Dfp[] spx = split(x);\n    Dfp[] spy = new Dfp[2];\n    // use spy[0] temporarily as a divisor\n    spy[0] = pow(a.getTwo(), p2);\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n    // Use spy[0] for comparison\n    spy[0] = a.newInstance(\"1.33333\");\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n    // X is now in the range of 2/3 < x < 4/3\n    Dfp[] spz = logInternal(spx);\n    spx[0] = a.newInstance(new StringBuilder().append(p2 + 4 * lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn2Split(), spx);\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n    spx[0] = a.newInstance(new StringBuilder().append(4 * lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn5Split(), spx);\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n    return a.newInstance(spz[0].add(spz[1]));\n}"
            ],
            [
                "logInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes the natural log of a number between 0 and 2.\n *  Let f(x) = ln(x),\n *\n *  We know that f'(x) = 1/x, thus from Taylor's theorum we have:\n *\n *           -----          n+1         n\n *  f(x) =   \\           (-1)    (x - 1)\n *           /          ----------------    for 1 <= n <= infinity\n *           -----             n\n *\n *  or\n *                       2        3       4\n *                   (x-1)   (x-1)    (x-1)\n *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n *                     2       3        4\n *\n *  alternatively,\n *\n *                  2    3   4\n *                 x    x   x\n *  ln(x+1) =  x - -  + - - - + ...\n *                 2    3   4\n *\n *  This series can be used to compute ln(x), but it converges too slowly.\n *\n *  If we substitute -x for x above, we get\n *\n *                   2    3    4\n *                  x    x    x\n *  ln(1-x) =  -x - -  - -  - - + ...\n *                  2    3    4\n *\n *  Note that all terms are now negative.  Because the even powered ones\n *  absorbed the sign.  Now, subtract the series above from the previous\n *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n *  only the odd ones\n *\n *                             3     5      7\n *                           2x    2x     2x\n *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n *                            3     5      7\n *\n *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n *\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      x-1           \\          3        5        7          /\n *\n *  But now we want to find ln(a), so we need to find the value of x\n *  such that a = (x+1)/(x-1).   This is easily solved to find that\n *  x = (a-1)/(a+1).\n * @param a number from which logarithm is requested, in split form\n * @return log(a)\n */\nprotected static Dfp[] logInternal(final Dfp[] a) {\n    /* Now we want to compute x = (a-1)/(a+1) but this is prone to\n         * loss of precision.  So instead, compute x = (a/4 - 1/4) / (a/4 + 1/4)\n         */\n    Dfp t = a[0].divide(4).add(a[1].divide(4));\n    Dfp x = t.add(a[0].newInstance(\"-0.25\")).divide(t.add(a[0].newInstance(\"0.25\")));\n    Dfp y = new Dfp(x);\n    Dfp num = new Dfp(x);\n    Dfp py = new Dfp(y);\n    int den = 1;\n    for (int i = 0; i < 10000; i++) {\n        num = num.multiply(x);\n        num = num.multiply(x);\n        den += 2;\n        t = num.divide(den);\n        y = y.add(t);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    y = y.multiply(a[0].getTwo());\n    return split(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes x to the y power.<p>\n *\n *  Uses the following method:<p>\n *\n *  <ol>\n *  <li> Set u = rint(y), v = y-u\n *  <li> Compute a = v * ln(x)\n *  <li> Compute b = rint( a/ln(2) )\n *  <li> Compute c = a - b*ln(2)\n *  <li> x<sup>y</sup> = x<sup>u</sup>  *   2<sup>b</sup> * e<sup>c</sup>\n *  </ol>\n *  if |y| > 1e8, then we compute by exp(y*ln(x))   <p>\n *\n *  <b>Special Cases</b><p>\n *  <ul>\n *  <li>  if y is 0.0 or -0.0 then result is 1.0\n *  <li>  if y is 1.0 then result is x\n *  <li>  if y is NaN then result is NaN\n *  <li>  if x is NaN and y is not zero then result is NaN\n *  <li>  if |x| > 1.0 and y is +Infinity then result is +Infinity\n *  <li>  if |x| < 1.0 and y is -Infinity then result is +Infinity\n *  <li>  if |x| > 1.0 and y is -Infinity then result is +0\n *  <li>  if |x| < 1.0 and y is +Infinity then result is +0\n *  <li>  if |x| = 1.0 and y is +/-Infinity then result is NaN\n *  <li>  if x = +0 and y > 0 then result is +0\n *  <li>  if x = +Inf and y < 0 then result is +0\n *  <li>  if x = +0 and y < 0 then result is +Inf\n *  <li>  if x = +Inf and y > 0 then result is +Inf\n *  <li>  if x = -0 and y > 0, finite, not odd integer then result is +0\n *  <li>  if x = -0 and y < 0, finite, and odd integer then result is -Inf\n *  <li>  if x = -Inf and y > 0, finite, and odd integer then result is -Inf\n *  <li>  if x = -0 and y < 0, not finite odd integer then result is +Inf\n *  <li>  if x = -Inf and y > 0, not finite odd integer then result is +Inf\n *  <li>  if x < 0 and y > 0, finite, and odd integer then result is -(|x|<sup>y</sup>)\n *  <li>  if x < 0 and y > 0, finite, and not integer then result is NaN\n *  </ul>\n *  @param x base to be raised\n *  @param y power to which base should be raised\n *  @return x<sup>y</sup>\n */\npublic static Dfp pow(Dfp x, final Dfp y) {\n    // make sure we don't mix number with different precision\n    if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = x.newInstance(x.getZero());\n        result.nans = Dfp.QNAN;\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n    }\n    final Dfp zero = x.getZero();\n    final Dfp one = x.getOne();\n    final Dfp two = x.getTwo();\n    boolean invert = false;\n    int ui;\n    /* Check for special cases */\n    if (y.equals(zero)) {\n        return x.newInstance(one);\n    }\n    if (y.equals(one)) {\n        if (x.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n        }\n        return x;\n    }\n    if (x.isNaN() || y.isNaN()) {\n        // Test for NaNs\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    // X == 0\n    if (x.equals(zero)) {\n        if (Dfp.copysign(one, x).greaterThan(zero)) {\n            // X == +0\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n            }\n        } else {\n            // X == -0\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero.negate());\n                } else {\n                    return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE));\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n                }\n            }\n        }\n    }\n    if (x.lessThan(zero)) {\n        // Make x positive, but keep track of it\n        x = x.negate();\n        invert = true;\n    }\n    if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return y;\n        } else {\n            return x.newInstance(zero);\n        }\n    }\n    if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return x.newInstance(zero);\n        } else {\n            return x.newInstance(Dfp.copysign(y, one));\n        }\n    }\n    if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    if (x.classify() == Dfp.INFINITE) {\n        // x = +/- inf\n        if (invert) {\n            // negative infinity\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero.negate());\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        } else {\n            // positive infinity\n            if (y.greaterThan(zero)) {\n                return x;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n    }\n    if (invert && !y.rint().equals(y)) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    // End special cases\n    Dfp r;\n    if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) {\n        final Dfp u = y.rint();\n        ui = u.intValue();\n        final Dfp v = y.subtract(u);\n        if (v.unequal(zero)) {\n            final Dfp a = v.multiply(log(x));\n            final Dfp b = a.divide(x.getField().getLn2()).rint();\n            final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n            r = splitPow(split(x), ui);\n            r = r.multiply(pow(two, b.intValue()));\n            r = r.multiply(exp(c));\n        } else {\n            r = splitPow(split(x), ui);\n        }\n    } else {\n        // very large exponent.  |y| > 1e8\n        r = exp(log(x).multiply(y));\n    }\n    if (invert && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n        // if y is odd integer\n        r = r.negate();\n    }\n    return x.newInstance(r);\n}"
            ],
            [
                "sinInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes sin(a)  Used when 0 < a < pi/4.\n * Uses the classic Taylor series.  x - x**3/3! + x**5/5!  ...\n * @param a number from which sine is desired, in split form\n * @return sin(a)\n */\nprotected static Dfp sinInternal(Dfp[] a) {\n    Dfp c = a[0].add(a[1]);\n    Dfp y = c;\n    c = c.multiply(c);\n    Dfp x = y;\n    Dfp fact = a[0].getOne();\n    Dfp py = new Dfp(y);\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n        // 1 over fact\n        fact = fact.divide((i - 1) * i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "cosInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes cos(a)  Used when 0 < a < pi/4.\n * Uses the classic Taylor series for cosine.  1 - x**2/2! + x**4/4!  ...\n * @param a number from which cosine is desired, in split form\n * @return cos(a)\n */\nprotected static Dfp cosInternal(Dfp[] a) {\n    final Dfp one = a[0].getOne();\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a[0].add(a[1]);\n    c = c.multiply(c);\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n        // 1 over fact\n        fact = fact.divide((i - 1) * i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "sin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the sine of the argument.\n * @param a number from which sine is desired\n * @return sin(a)\n */\npublic static Dfp sin(final Dfp a) {\n    final Dfp pi = a.getField().getPi();\n    final Dfp zero = a.getField().getZero();\n    boolean neg = false;\n    /* First reduce the argument to the range of +/- PI */\n    Dfp x = a.remainder(pi.multiply(2));\n    /* if x < 0 then apply identity sin(-x) = -sin(x) */\n    /* This puts x in the range 0 < x < PI            */\n    if (x.lessThan(zero)) {\n        x = x.negate();\n        neg = true;\n    }\n    /* Since sine(x) = sine(pi - x) we can reduce the range to\n         * 0 < x < pi/2\n         */\n    if (x.greaterThan(pi.divide(2))) {\n        x = pi.subtract(x);\n    }\n    Dfp y;\n    if (x.lessThan(pi.divide(4))) {\n        y = sinInternal(split(x));\n    } else {\n        final Dfp[] c = new Dfp[2];\n        final Dfp[] piSplit = a.getField().getPiSplit();\n        c[0] = piSplit[0].divide(2).subtract(x);\n        c[1] = piSplit[1].divide(2);\n        y = cosInternal(c);\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "cos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the cosine of the argument.\n * @param a number from which cosine is desired\n * @return cos(a)\n */\npublic static Dfp cos(Dfp a) {\n    final Dfp pi = a.getField().getPi();\n    final Dfp zero = a.getField().getZero();\n    boolean neg = false;\n    /* First reduce the argument to the range of +/- PI */\n    Dfp x = a.remainder(pi.multiply(2));\n    /* if x < 0 then apply identity cos(-x) = cos(x) */\n    /* This puts x in the range 0 < x < PI           */\n    if (x.lessThan(zero)) {\n        x = x.negate();\n    }\n    /* Since cos(x) = -cos(pi - x) we can reduce the range to\n         * 0 < x < pi/2\n         */\n    if (x.greaterThan(pi.divide(2))) {\n        x = pi.subtract(x);\n        neg = true;\n    }\n    Dfp y;\n    if (x.lessThan(pi.divide(4))) {\n        Dfp[] c = new Dfp[2];\n        c[0] = x;\n        c[1] = zero;\n        y = cosInternal(c);\n    } else {\n        final Dfp[] c = new Dfp[2];\n        final Dfp[] piSplit = a.getField().getPiSplit();\n        c[0] = piSplit[0].divide(2).subtract(x);\n        c[1] = piSplit[1].divide(2);\n        y = sinInternal(c);\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "tan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the tangent of the argument.\n * @param a number from which tangent is desired\n * @return tan(a)\n */\npublic static Dfp tan(final Dfp a) {\n    return sin(a).divide(cos(a));\n}"
            ],
            [
                "atanInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-tangent of the argument.\n * @param a number from which arc-tangent is desired\n * @return atan(a)\n */\nprotected static Dfp atanInternal(final Dfp a) {\n    Dfp y = new Dfp(a);\n    Dfp x = new Dfp(y);\n    Dfp py = new Dfp(y);\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(a);\n        x = x.multiply(a);\n        x = x.negate();\n        y = y.add(x.divide(i));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "atan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc tangent of the argument\n *\n *  Uses the typical taylor series\n *\n *  but may reduce arguments using the following identity\n * tan(x+y) = (tan(x) + tan(y)) / (1 - tan(x)*tan(y))\n *\n * since tan(PI/8) = sqrt(2)-1,\n *\n * atan(x) = atan( (x - sqrt(2) + 1) / (1+x*sqrt(2) - x) + PI/8.0\n * @param a number from which arc-tangent is desired\n * @return atan(a)\n */\npublic static Dfp atan(final Dfp a) {\n    final Dfp zero = a.getField().getZero();\n    final Dfp one = a.getField().getOne();\n    final Dfp[] sqr2Split = a.getField().getSqr2Split();\n    final Dfp[] piSplit = a.getField().getPiSplit();\n    boolean recp = false;\n    boolean neg = false;\n    boolean sub = false;\n    final Dfp ty = sqr2Split[0].subtract(one).add(sqr2Split[1]);\n    Dfp x = new Dfp(a);\n    if (x.lessThan(zero)) {\n        neg = true;\n        x = x.negate();\n    }\n    if (x.greaterThan(one)) {\n        recp = true;\n        x = one.divide(x);\n    }\n    if (x.greaterThan(ty)) {\n        Dfp[] sty = new Dfp[2];\n        sub = true;\n        sty[0] = sqr2Split[0].subtract(one);\n        sty[1] = sqr2Split[1];\n        Dfp[] xs = split(x);\n        Dfp[] ds = splitMult(xs, sty);\n        ds[0] = ds[0].add(one);\n        xs[0] = xs[0].subtract(sty[0]);\n        xs[1] = xs[1].subtract(sty[1]);\n        xs = splitDiv(xs, ds);\n        x = xs[0].add(xs[1]);\n        //x = x.subtract(ty).divide(dfp.one.add(x.multiply(ty)));\n    }\n    Dfp y = atanInternal(x);\n    if (sub) {\n        y = y.add(piSplit[0].divide(8)).add(piSplit[1].divide(8));\n    }\n    if (recp) {\n        y = piSplit[0].divide(2).subtract(y).add(piSplit[1].divide(2));\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "asin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-sine of the argument.\n * @param a number from which arc-sine is desired\n * @return asin(a)\n */\npublic static Dfp asin(final Dfp a) {\n    return atan(a.divide(a.getOne().subtract(a.multiply(a)).sqrt()));\n}"
            ],
            [
                "acos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-cosine of the argument.\n * @param a number from which arc-cosine is desired\n * @return acos(a)\n */\npublic static Dfp acos(Dfp a) {\n    Dfp result;\n    boolean negative = false;\n    if (a.lessThan(a.getZero())) {\n        negative = true;\n    }\n    // absolute value\n    a = Dfp.copysign(a, a.getOne());\n    result = atan(a.getOne().subtract(a.multiply(a)).sqrt().divide(a));\n    if (negative) {\n        result = a.getField().getPi().subtract(result);\n    }\n    return a.newInstance(result);\n}"
            ],
            [
                "copysign",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Creates an instance that is the same as x except that it has the sign of y.\n * abs(x) = dfp.copysign(x, dfp.one)\n * @param x number to get the value from\n * @param y number to get the sign from\n * @return a number with the value of x and the sign of y\n */\npublic static Dfp copysign(final Dfp x, final Dfp y) {\n    Dfp result = x.newInstance(x);\n    result.sign = y.sign;\n    return result;\n}"
            ],
            [
                "computeExp",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * Compute exp(a).\n * @param a number for which we want the exponential\n * @param one constant with value 1 at desired precision\n * @return exp(a)\n */\npublic static Dfp computeExp(final Dfp a, final Dfp one) {\n    Dfp y = new Dfp(one);\n    Dfp py = new Dfp(one);\n    Dfp f = new Dfp(one);\n    Dfp fi = new Dfp(one);\n    Dfp x = new Dfp(one);\n    for (int i = 0; i < 10000; i++) {\n        x = x.multiply(a);\n        y = y.add(x.divide(f));\n        fi = fi.add(one);\n        f = f.multiply(fi);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "computeLn",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * Compute ln(a).\n *\n *  Let f(x) = ln(x),\n *\n *  We know that f'(x) = 1/x, thus from Taylor's theorem we have:\n *\n *           -----          n+1         n\n *  f(x) =   \\           (-1)    (x - 1)\n *           /          ----------------    for 1 <= n <= infinity\n *           -----             n\n *\n *  or\n *                       2        3       4\n *                   (x-1)   (x-1)    (x-1)\n *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n *                     2       3        4\n *\n *  alternatively,\n *\n *                  2    3   4\n *                 x    x   x\n *  ln(x+1) =  x - -  + - - - + ...\n *                 2    3   4\n *\n *  This series can be used to compute ln(x), but it converges too slowly.\n *\n *  If we substitute -x for x above, we get\n *\n *                   2    3    4\n *                  x    x    x\n *  ln(1-x) =  -x - -  - -  - - + ...\n *                  2    3    4\n *\n *  Note that all terms are now negative.  Because the even powered ones\n *  absorbed the sign.  Now, subtract the series above from the previous\n *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n *  only the odd ones\n *\n *                             3     5      7\n *                           2x    2x     2x\n *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n *                            3     5      7\n *\n *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n *\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      x-1           \\          3        5        7          /\n *\n *  But now we want to find ln(a), so we need to find the value of x\n *  such that a = (x+1)/(x-1).   This is easily solved to find that\n *  x = (a-1)/(a+1).\n * @param a number for which we want the exponential\n * @param one constant with value 1 at desired precision\n * @param two constant with value 2 at desired precision\n * @return ln(a)\n */\npublic static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two) {\n    int den = 1;\n    Dfp x = a.add(new Dfp(a.getField(), -1)).divide(a.add(one));\n    Dfp y = new Dfp(x);\n    Dfp num = new Dfp(x);\n    Dfp py = new Dfp(y);\n    for (int i = 0; i < 10000; i++) {\n        num = num.multiply(x);\n        num = num.multiply(x);\n        den += 2;\n        Dfp t = num.divide(den);\n        y = y.add(t);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y.multiply(two);\n}"
            ],
            [
                "getRandomGenerator",
                "org.apache.commons.math3.genetics",
                "GeneticAlgorithm",
                "/**\n * Returns the (static) random generator.\n *\n * @return the static random generator shared by GA implementation classes\n */\npublic static synchronized RandomGenerator getRandomGenerator() {\n    return randomGenerator;\n}"
            ],
            [
                "randomPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation corresponding to a random permutation of\n * length l which can be passed to the RandomKey constructor.\n *\n * @param l length of the permutation\n * @return representation of a random permutation\n */\npublic static final List<Double> randomPermutation(final int l) {\n    List<Double> repr = new ArrayList<Double>(l);\n    for (int i = 0; i < l; i++) {\n        repr.add(GeneticAlgorithm.getRandomGenerator().nextDouble());\n    }\n    return repr;\n}"
            ],
            [
                "identityPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation corresponding to an identity permutation of\n * length l which can be passed to the RandomKey constructor.\n *\n * @param l length of the permutation\n * @return representation of an identity permutation\n */\npublic static final List<Double> identityPermutation(final int l) {\n    List<Double> repr = new ArrayList<Double>(l);\n    for (int i = 0; i < l; i++) {\n        repr.add((double) i / l);\n    }\n    return repr;\n}"
            ],
            [
                "comparatorPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation of a permutation corresponding to the\n * <code>data</code> sorted by <code>comparator</code>. The\n * <code>data</code> is not modified during the process.\n *\n * This is useful if you want to inject some permutations to the initial\n * population.\n *\n * @param <S> type of the data\n * @param data list of data determining the order\n * @param comparator how the data will be compared\n * @return list representation of the permutation corresponding to the parameters\n */\npublic static <S> List<Double> comparatorPermutation(final List<S> data, final Comparator<S> comparator) {\n    List<S> sortedData = new ArrayList<S>(data);\n    Collections.sort(sortedData, comparator);\n    return inducedPermutation(data, sortedData);\n}"
            ],
            [
                "inducedPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation of a permutation corresponding to a\n * permutation which yields <code>permutedData</code> when applied to\n * <code>originalData</code>.\n *\n * This method can be viewed as an inverse to {@link #decode(List)}.\n *\n * @param <S> type of the data\n * @param originalData the original, unpermuted data\n * @param permutedData the data, somehow permuted\n * @return representation of a permutation corresponding to the permutation\n *   <code>originalData -> permutedData</code>\n * @throws DimensionMismatchException iff the length of <code>originalData</code>\n *   and <code>permutedData</code> lists are not equal\n * @throws MathIllegalArgumentException iff the <code>permutedData</code> and\n *   <code>originalData</code> lists contain different data\n */\npublic static <S> List<Double> inducedPermutation(final List<S> originalData, final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException {\n    if (originalData.size() != permutedData.size()) {\n        throw new DimensionMismatchException(permutedData.size(), originalData.size());\n    }\n    int l = originalData.size();\n    List<S> origDataCopy = new ArrayList<S>(originalData);\n    Double[] res = new Double[l];\n    for (int i = 0; i < l; i++) {\n        int index = origDataCopy.indexOf(permutedData.get(i));\n        if (index == -1) {\n            throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_ORIG_AND_PERMUTED_DATA);\n        }\n        res[index] = (double) i / l;\n        origDataCopy.set(index, null);\n    }\n    return Arrays.asList(res);\n}"
            ],
            [
                "randomBinaryRepresentation",
                "org.apache.commons.math3.genetics",
                "BinaryChromosome",
                "/**\n * Returns a representation of a random binary array of length <code>length</code>.\n * @param length length of the array\n * @return a random binary array of length <code>length</code>\n */\npublic static List<Integer> randomBinaryRepresentation(int length) {\n    // random binary list\n    List<Integer> rList = new ArrayList<Integer>(length);\n    for (int j = 0; j < length; j++) {\n        rList.add(GeneticAlgorithm.getRandomGenerator().nextInt(2));\n    }\n    return rList;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * Get the set of locales for which point/vector formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available point/vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "/**\n * Returns the default 3D vector format for the current locale.\n * @return the default 3D vector format.\n */\npublic static Vector3DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "/**\n * Returns the default 3D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 3D vector format specific to the given locale.\n */\npublic static Vector3DFormat getInstance(final Locale locale) {\n    return new Vector3DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2) throws MathArithmeticException {\n    final T normProduct = v1.getNorm().multiply(v2.getNorm());\n    if (normProduct.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    final T dot = dotProduct(v1, v2);\n    final double threshold = normProduct.getReal() * 0.9999;\n    if ((dot.getReal() < -threshold) || (dot.getReal() > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        FieldVector3D<T> v3 = crossProduct(v1, v2);\n        if (dot.getReal() >= 0) {\n            return v3.getNorm().divide(normProduct).asin();\n        }\n        return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return dot.divide(normProduct).acos();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2) throws MathArithmeticException {\n    final T normProduct = v1.getNorm().multiply(v2.getNorm());\n    if (normProduct.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    final T dot = dotProduct(v1, v2);\n    final double threshold = normProduct.getReal() * 0.9999;\n    if ((dot.getReal() < -threshold) || (dot.getReal() > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        FieldVector3D<T> v3 = crossProduct(v1, v2);\n        if (dot.getReal() >= 0) {\n            return v3.getNorm().divide(normProduct).asin();\n        }\n        return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return dot.divide(normProduct).acos();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2) throws MathArithmeticException {\n    return angle(v2, v1);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.dotProduct(v1);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1, final FieldVector3D<T> v2) {\n    return new FieldVector3D<T>(v2.x.linearCombination(v1.getY(), v2.z, -v1.getZ(), v2.y), v2.y.linearCombination(v1.getZ(), v2.x, -v1.getX(), v2.z), v2.z.linearCombination(v1.getX(), v2.y, -v1.getY(), v2.x));\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distance1(v1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distance(v1);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distanceInf(v1);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distanceSq(v1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "/**\n * Compute the <i>distance</i> between two rotations.\n * <p>The <i>distance</i> is intended here as a way to check if two\n * rotations are almost similar (i.e. they transform vectors the same way)\n * or very different. It is mathematically defined as the angle of\n * the rotation r that prepended to one of the rotations gives the other\n * one:</p>\n * <pre>\n *        r<sub>1</sub>(r) = r<sub>2</sub>\n * </pre>\n * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n * reached for some v. The distance is equal to 0 if and only if the two\n * rotations are identical.</p>\n * <p>Comparing two rotations should always be done using this value rather\n * than for example comparing the components of the quaternions. It is much\n * more stable, and has a geometric meaning. Also comparing quaternions\n * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n * their components are different (they are exact opposites).</p>\n * @param r1 first rotation\n * @param r2 second rotation\n * @return <i>distance</i> between r1 and r2\n */\npublic static double distance(Rotation r1, Rotation r2) {\n    return r1.composeInverseInternal(r2).getAngle();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Euclidean3D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean3D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply a rotation to a vector.\n * @param r rotation to apply\n * @param u vector to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new vector which is the image of u by the rotation\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n    final T x = u.getX();\n    final T y = u.getY();\n    final T z = u.getZ();\n    final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n    return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x), y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y), z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n}"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply the inverse of a rotation to a vector.\n * @param r rotation to apply\n * @param u vector to apply the inverse of the rotation to\n * @param <T> the type of the field elements\n * @return a new vector which such that u is its image by the rotation\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n    final T x = u.getX();\n    final T y = u.getY();\n    final T z = u.getZ();\n    final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n    final double m0 = -r.getQ0();\n    return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x), y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y), z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n}"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply a rotation to another rotation.\n * Applying a rotation to another rotation is computing the composition\n * in an order compliant with the following rule : let u be any\n * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n * where comp = applyTo(rOuter, rInner).\n * @param r1 rotation to apply\n * @param rInner rotation to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new rotation which is the composition of r by the instance\n */\npublic static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n    return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))), rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))), rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))), rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))), false);\n}"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply the inverse of a rotation to another rotation.\n * Applying the inverse of a rotation to another rotation is computing\n * the composition in an order compliant with the following rule :\n * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n * let w be the inverse image of v by rOuter\n * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n * comp = applyInverseTo(rOuter, rInner).\n * @param rOuter rotation to apply the rotation to\n * @param rInner rotation to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new rotation which is the composition of r by the inverse\n * of the instance\n */\npublic static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n    return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(), rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())), rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())), rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())), false);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Compute the <i>distance</i> between two rotations.\n * <p>The <i>distance</i> is intended here as a way to check if two\n * rotations are almost similar (i.e. they transform vectors the same way)\n * or very different. It is mathematically defined as the angle of\n * the rotation r that prepended to one of the rotations gives the other\n * one:</p>\n * <pre>\n *        r<sub>1</sub>(r) = r<sub>2</sub>\n * </pre>\n * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n * reached for some v. The distance is equal to 0 if and only if the two\n * rotations are identical.</p>\n * <p>Comparing two rotations should always be done using this value rather\n * than for example comparing the components of the quaternions. It is much\n * more stable, and has a geometric meaning. Also comparing quaternions\n * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n * their components are different (they are exact opposites).</p>\n * @param r1 first rotation\n * @param r2 second rotation\n * @param <T> the type of the field elements\n * @return <i>distance</i> between r1 and r2\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n    return r1.composeInverseInternal(r2).getAngle();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException {\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    double dot = v1.dotProduct(v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        Vector3D v3 = crossProduct(v1, v2);\n        if (dot >= 0) {\n            return FastMath.asin(v3.getNorm() / normProduct);\n        }\n        return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return FastMath.acos(dot / normProduct);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the dot product v1.v2\n */\npublic static double dotProduct(Vector3D v1, Vector3D v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static double distance1(Vector3D v1, Vector3D v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector3D v1, Vector3D v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector3D v1, Vector3D v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the square of the distance between v1 and v2\n */\npublic static double distanceSq(Vector3D v1, Vector3D v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "intersection",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Plane",
                "/**\n * Get the intersection point of three planes.\n * @param plane1 first plane1\n * @param plane2 second plane2\n * @param plane3 third plane2\n * @return intersection point of three planes, null if some planes are parallel\n */\npublic static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3) {\n    // coefficients of the three planes linear equations\n    final double a1 = plane1.w.getX();\n    final double b1 = plane1.w.getY();\n    final double c1 = plane1.w.getZ();\n    final double d1 = plane1.originOffset;\n    final double a2 = plane2.w.getX();\n    final double b2 = plane2.w.getY();\n    final double c2 = plane2.w.getZ();\n    final double d2 = plane2.originOffset;\n    final double a3 = plane3.w.getX();\n    final double b3 = plane3.w.getY();\n    final double c3 = plane3.w.getZ();\n    final double d3 = plane3.originOffset;\n    // direct Cramer resolution of the linear system\n    // (this is still feasible for a 3x3 system)\n    final double a23 = b2 * c3 - b3 * c2;\n    final double b23 = c2 * a3 - c3 * a2;\n    final double c23 = a2 * b3 - a3 * b2;\n    final double determinant = a1 * a23 + b1 * b23 + c1 * c23;\n    if (FastMath.abs(determinant) < 1.0e-10) {\n        return null;\n    }\n    final double r = 1.0 / determinant;\n    return new Vector3D((-a23 * d1 - (c1 * b3 - c3 * b1) * d2 - (c2 * b1 - c1 * b2) * d3) * r, (-b23 * d1 - (c3 * a1 - c1 * a3) * d2 - (c1 * a2 - c2 * a1) * d3) * r, (-c23 * d1 - (b1 * a3 - b3 * a1) * d2 - (b2 * a1 - b1 * a2) * d3) * r);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Euclidean1D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean1D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "/**\n * Returns the default 1D vector format for the current locale.\n * @return the default 1D vector format.\n */\npublic static Vector1DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "/**\n * Returns the default 1D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 1D vector format specific to the given locale.\n */\npublic static Vector1DFormat getInstance(final Locale locale) {\n    return new Vector1DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector1D p1, Vector1D p2) {\n    return p1.distance(p2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector1D p1, Vector1D p2) {\n    return p1.distanceInf(p2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\npublic static double distanceSq(Vector1D p1, Vector1D p2) {\n    return p1.distanceSq(p2);\n}"
            ],
            [
                "reducePoints",
                "org.apache.commons.math3.geometry.euclidean.twod.hull",
                "AklToussaintHeuristic",
                "/**\n * Returns a point set that is reduced by all points for which it is safe to assume\n * that they are not part of the convex hull.\n *\n * @param points the original point set\n * @return a reduced point set, useful as input for convex hull algorithms\n */\npublic static Collection<Vector2D> reducePoints(final Collection<Vector2D> points) {\n    // find the leftmost point\n    int size = 0;\n    Vector2D minX = null;\n    Vector2D maxX = null;\n    Vector2D minY = null;\n    Vector2D maxY = null;\n    for (Vector2D p : points) {\n        if (minX == null || p.getX() < minX.getX()) {\n            minX = p;\n        }\n        if (maxX == null || p.getX() > maxX.getX()) {\n            maxX = p;\n        }\n        if (minY == null || p.getY() < minY.getY()) {\n            minY = p;\n        }\n        if (maxY == null || p.getY() > maxY.getY()) {\n            maxY = p;\n        }\n        size++;\n    }\n    if (size < 4) {\n        return points;\n    }\n    final List<Vector2D> quadrilateral = buildQuadrilateral(minY, maxX, maxY, minX);\n    // if the quadrilateral is not well formed, e.g. only 2 points, do not attempt to reduce\n    if (quadrilateral.size() < 3) {\n        return points;\n    }\n    final List<Vector2D> reducedPoints = new ArrayList<Vector2D>(quadrilateral);\n    for (final Vector2D p : points) {\n        // check all points if they are within the quadrilateral\n        // in which case they can not be part of the convex hull\n        if (!insideQuadrilateral(p, quadrilateral)) {\n            reducedPoints.add(p);\n        }\n    }\n    return reducedPoints;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "/**\n * Returns the default 2D vector format for the current locale.\n * @return the default 2D vector format.\n */\npublic static Vector2DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "/**\n * Returns the default 2D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 2D vector format specific to the given locale.\n */\npublic static Vector2DFormat getInstance(final Locale locale) {\n    return new Vector2DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException {\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    double dot = v1.dotProduct(v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        final double n = FastMath.abs(MathArrays.linearCombination(v1.x, v2.y, -v1.y, v2.x));\n        if (dot >= 0) {\n            return FastMath.asin(n / normProduct);\n        }\n        return FastMath.PI - FastMath.asin(n / normProduct);\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return FastMath.acos(dot / normProduct);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector2D p1, Vector2D p2) {\n    return p1.distance(p2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector2D p1, Vector2D p2) {\n    return p1.distanceInf(p2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\npublic static double distanceSq(Vector2D p1, Vector2D p2) {\n    return p1.distanceSq(p2);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Euclidean2D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean2D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding an affine transform.\n * @param transform affine transform to embed (must be inversible\n * otherwise the {@link\n * org.apache.commons.math3.geometry.partitioning.Transform#apply(Hyperplane)\n * apply(Hyperplane)} method would work only for some lines, and\n * fail for other ones)\n * @return a new transform that can be applied to either {@link\n * Vector2D Vector2D}, {@link Line Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n * @exception MathIllegalArgumentException if the transform is non invertible\n * @deprecated as of 3.6, replaced with {@link #getTransform(double, double, double, double, double, double)}\n */\n@Deprecated\npublic static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException {\n    final double[] m = new double[6];\n    transform.getMatrix(m);\n    return new LineTransform(m[0], m[1], m[2], m[3], m[4], m[5]);\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding an affine transform.\n * @param cXX transform factor between input abscissa and output abscissa\n * @param cYX transform factor between input abscissa and output ordinate\n * @param cXY transform factor between input ordinate and output abscissa\n * @param cYY transform factor between input ordinate and output ordinate\n * @param cX1 transform addendum for output abscissa\n * @param cY1 transform addendum for output ordinate\n * @return a new transform that can be applied to either {@link\n * Vector2D Vector2D}, {@link Line Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n * @exception MathIllegalArgumentException if the transform is non invertible\n * @since 3.6\n */\npublic static Transform<Euclidean2D, Euclidean1D> getTransform(final double cXX, final double cYX, final double cXY, final double cYY, final double cX1, final double cY1) throws MathIllegalArgumentException {\n    return new LineTransform(cXX, cYX, cXY, cYY, cX1, cY1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "/**\n * Compute the distance (angular separation) between two points.\n * @param p1 first vector\n * @param p2 second vector\n * @return the angular separation between p1 and p2\n */\npublic static double distance(S1Point p1, S1Point p2) {\n    return Vector2D.angle(p1.vector, p2.vector);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "Sphere1D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Sphere1D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Sphere2D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Sphere2D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Circle",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding a 3D rotation.\n * @param rotation rotation to use\n * @return a new transform that can be applied to either {@link\n * Point Point}, {@link Circle Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n */\npublic static Transform<Sphere2D, Sphere1D> getTransform(final Rotation rotation) {\n    return new CircleTransform(rotation);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * Compute the distance (angular separation) between two points.\n * @param p1 first vector\n * @param p2 second vector\n * @return the angular separation between p1 and p2\n */\npublic static double distance(S2Point p1, S2Point p2) {\n    return Vector3D.angle(p1.vector, p2.vector);\n}"
            ],
            [
                "createAdaptor",
                "org.apache.commons.math3.random",
                "RandomAdaptor",
                "/**\n * Factory method to create a <code>Random</code> using the supplied\n * <code>RandomGenerator</code>.\n *\n * @param randomGenerator  wrapped RandomGenerator instance\n * @return a Random instance wrapping the RandomGenerator\n */\npublic static Random createAdaptor(RandomGenerator randomGenerator) {\n    return new RandomAdaptor(randomGenerator);\n}"
            ],
            [
                "createRandomGenerator",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "/**\n * Creates a {@link RandomDataGenerator} instance that wraps a\n * {@link Random} instance.\n *\n * @param rng JDK {@link Random} instance that will generate the\n * the random data.\n * @return the given RNG, wrapped in a {@link RandomGenerator}.\n */\npublic static RandomGenerator createRandomGenerator(final Random rng) {\n    return new RandomGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(int seed) {\n            rng.setSeed((long) seed);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(int[] seed) {\n            rng.setSeed(convertToLong(seed));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(long seed) {\n            rng.setSeed(seed);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void nextBytes(byte[] bytes) {\n            rng.nextBytes(bytes);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int nextInt() {\n            return rng.nextInt();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int nextInt(int n) {\n            if (n <= 0) {\n                throw new NotStrictlyPositiveException(n);\n            }\n            return rng.nextInt(n);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public long nextLong() {\n            return rng.nextLong();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean nextBoolean() {\n            return rng.nextBoolean();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public float nextFloat() {\n            return rng.nextFloat();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public double nextDouble() {\n            return rng.nextDouble();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public double nextGaussian() {\n            return rng.nextGaussian();\n        }\n    };\n}"
            ],
            [
                "convertToLong",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "/**\n * Converts seed from one representation to another.\n *\n * @param seed Original seed.\n * @return the converted seed.\n */\npublic static long convertToLong(int[] seed) {\n    // The following number is the largest prime that fits\n    // in 32 bits (i.e. 2^32 - 5).\n    final long prime = 4294967291l;\n    long combined = 0l;\n    for (int s : seed) {\n        combined = combined * prime + s;\n    }\n    return combined;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Get the set of locales for which complex formats are available.  This\n * is the same set as the {@link NumberFormat} set.\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "formatBigFraction",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * This static method calls formatBigFraction() on a default instance of\n * BigFractionFormat.\n *\n * @param f BigFraction object to format\n * @return A formatted BigFraction in proper form.\n */\npublic static String formatBigFraction(final BigFraction f) {\n    return getImproperInstance().format(f);\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static BigFractionFormat getImproperInstance() {\n    return getImproperInstance(Locale.getDefault());\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static BigFractionFormat getImproperInstance(final Locale locale) {\n    return new BigFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static BigFractionFormat getProperInstance() {\n    return getProperInstance(Locale.getDefault());\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static BigFractionFormat getProperInstance(final Locale locale) {\n    return new ProperBigFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * <p>Creates a {@code Fraction} instance with the 2 parts\n * of a fraction Y/Z.</p>\n *\n * <p>Any negative signs are resolved to be on the numerator.</p>\n *\n * @param numerator  the numerator, for example the three in 'three sevenths'\n * @param denominator  the denominator, for example the seven in 'three sevenths'\n * @return a new fraction instance, with the numerator and denominator reduced\n * @throws MathArithmeticException if the denominator is {@code zero}\n */\npublic static Fraction getReducedFraction(int numerator, int denominator) {\n    if (denominator == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, numerator, denominator);\n    }\n    if (numerator == 0) {\n        // normalize zero.\n        return ZERO;\n    }\n    // allow 2^k/-2^31 as a valid fraction (where k>0)\n    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n        numerator /= 2;\n        denominator /= 2;\n    }\n    if (denominator < 0) {\n        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n        }\n        numerator = -numerator;\n        denominator = -denominator;\n    }\n    // simplify fraction.\n    int gcd = ArithmeticUtils.gcd(numerator, denominator);\n    numerator /= gcd;\n    denominator /= gcd;\n    return new Fraction(numerator, denominator);\n}"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * <p>\n * Creates a <code>BigFraction</code> instance with the 2 parts of a fraction\n * Y/Z.\n * </p>\n *\n * <p>\n * Any negative signs are resolved to be on the numerator.\n * </p>\n *\n * @param numerator\n *            the numerator, for example the three in 'three sevenths'.\n * @param denominator\n *            the denominator, for example the seven in 'three sevenths'.\n * @return a new fraction instance, with the numerator and denominator\n *         reduced.\n * @throws ArithmeticException\n *             if the denominator is <code>zero</code>.\n */\npublic static BigFraction getReducedFraction(final int numerator, final int denominator) {\n    if (numerator == 0) {\n        // normalize zero.\n        return ZERO;\n    }\n    return new BigFraction(numerator, denominator);\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)}. The only\n * customization is the maximum number of BigFraction digits, which is set to 0.\n * @return the default number format.\n */\nprotected static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)}. The only\n * customization is the maximum number of BigFraction digits, which is set to 0.\n * @param locale the specific locale used by the format.\n * @return the default number format specific to the given locale.\n */\nprotected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n    final NumberFormat nf = NumberFormat.getNumberInstance(locale);\n    nf.setMaximumFractionDigits(0);\n    nf.setParseIntegerOnly(true);\n    return nf;\n}"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Parses <code>source</code> until a non-whitespace character is found.\n * @param source the string to parse\n * @param pos input/output parsing parameter.\n * @return the first non-whitespace character.\n */\nprotected static char parseNextCharacter(final String source, final ParsePosition pos) {\n    int index = pos.getIndex();\n    final int n = source.length();\n    char ret = 0;\n    if (index < n) {\n        char c;\n        do {\n            c = source.charAt(index++);\n        } while (Character.isWhitespace(c) && index < n);\n        pos.setIndex(index);\n        if (index < n) {\n            ret = c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Get the set of locales for which complex formats are available.  This\n * is the same set as the {@link NumberFormat} set.\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "formatFraction",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * This static method calls formatFraction() on a default instance of\n * FractionFormat.\n *\n * @param f Fraction object to format\n * @return a formatted fraction in proper form.\n */\npublic static String formatFraction(Fraction f) {\n    return getImproperInstance().format(f);\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static FractionFormat getImproperInstance() {\n    return getImproperInstance(Locale.getDefault());\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static FractionFormat getImproperInstance(final Locale locale) {\n    return new FractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static FractionFormat getProperInstance() {\n    return getProperInstance(Locale.getDefault());\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static FractionFormat getProperInstance(final Locale locale) {\n    return new ProperFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n * customizing is the maximum number of fraction digits, which is set to 0.\n * @return the default number format.\n */\nprotected static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "FractionField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static FractionField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static BigFractionField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "flatten",
                "org.apache.commons.math3.exception.util",
                "ArgUtils",
                "/**\n * Transform a multidimensional array into a one-dimensional list.\n *\n * @param array Array (possibly multidimensional).\n * @return a list of all the {@code Object} instances contained in\n * {@code array}.\n */\npublic static Object[] flatten(Object[] array) {\n    final List<Object> list = new ArrayList<Object>();\n    if (array != null) {\n        for (Object o : array) {\n            if (o instanceof Object[]) {\n                for (Object oR : flatten((Object[]) o)) {\n                    list.add(oR);\n                }\n            } else {\n                list.add(o);\n            }\n        }\n    }\n    return list.toArray();\n}"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Multiply every component in the given real array by the\n * given real number. The change is made in place.\n *\n * @param f the real array to be scaled\n * @param d the real scaling coefficient\n * @return a reference to the scaled array\n */\npublic static double[] scaleArray(double[] f, double d) {\n    for (int i = 0; i < f.length; i++) {\n        f[i] *= d;\n    }\n    return f;\n}"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Multiply every component in the given complex array by the\n * given real number. The change is made in place.\n *\n * @param f the complex array to be scaled\n * @param d the real scaling coefficient\n * @return a reference to the scaled array\n */\npublic static Complex[] scaleArray(Complex[] f, double d) {\n    for (int i = 0; i < f.length; i++) {\n        f[i] = new Complex(d * f[i].getReal(), d * f[i].getImaginary());\n    }\n    return f;\n}"
            ],
            [
                "createRealImaginaryArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Builds a new two dimensional array of {@code double} filled with the real\n * and imaginary parts of the specified {@link Complex} numbers. In the\n * returned array {@code dataRI}, the data is laid out as follows\n * <ul>\n * <li>{@code dataRI[0][i] = dataC[i].getReal()},</li>\n * <li>{@code dataRI[1][i] = dataC[i].getImaginary()}.</li>\n * </ul>\n *\n * @param dataC the array of {@link Complex} data to be transformed\n * @return a two dimensional array filled with the real and imaginary parts\n *   of the specified complex input\n */\npublic static double[][] createRealImaginaryArray(final Complex[] dataC) {\n    final double[][] dataRI = new double[2][dataC.length];\n    final double[] dataR = dataRI[0];\n    final double[] dataI = dataRI[1];\n    for (int i = 0; i < dataC.length; i++) {\n        final Complex c = dataC[i];\n        dataR[i] = c.getReal();\n        dataI[i] = c.getImaginary();\n    }\n    return dataRI;\n}"
            ],
            [
                "createComplexArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Builds a new array of {@link Complex} from the specified two dimensional\n * array of real and imaginary parts. In the returned array {@code dataC},\n * the data is laid out as follows\n * <ul>\n * <li>{@code dataC[i].getReal() = dataRI[0][i]},</li>\n * <li>{@code dataC[i].getImaginary() = dataRI[1][i]}.</li>\n * </ul>\n *\n * @param dataRI the array of real and imaginary parts to be transformed\n * @return an array of {@link Complex} with specified real and imaginary parts.\n * @throws DimensionMismatchException if the number of rows of the specified\n *   array is not two, or the array is not rectangular\n */\npublic static Complex[] createComplexArray(final double[][] dataRI) throws DimensionMismatchException {\n    if (dataRI.length != 2) {\n        throw new DimensionMismatchException(dataRI.length, 2);\n    }\n    final double[] dataR = dataRI[0];\n    final double[] dataI = dataRI[1];\n    if (dataR.length != dataI.length) {\n        throw new DimensionMismatchException(dataI.length, dataR.length);\n    }\n    final int n = dataR.length;\n    final Complex[] c = new Complex[n];\n    for (int i = 0; i < n; i++) {\n        c[i] = new Complex(dataR[i], dataI[i]);\n    }\n    return c;\n}"
            ],
            [
                "exactLog2",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Returns the base-2 logarithm of the specified {@code int}. Throws an\n * exception if {@code n} is not a power of two.\n *\n * @param n the {@code int} whose base-2 logarithm is to be evaluated\n * @return the base-2 logarithm of {@code n}\n * @throws MathIllegalArgumentException if {@code n} is not a power of two\n */\npublic static int exactLog2(final int n) throws MathIllegalArgumentException {\n    int index = Arrays.binarySearch(TransformUtils.POWERS_OF_TWO, n);\n    if (index < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, Integer.valueOf(n));\n    }\n    return index;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "PRIMES",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * The first 512 prime numbers.\n * <p>\n * It contains all primes smaller or equal to the cubic square of Integer.MAX_VALUE.\n * As a result, <code>int</code> numbers which are not reduced by those primes are guaranteed\n * to be either prime or semi prime.\n */\npublic static final int[] PRIMES = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671 };"
            ],
            [
                "PRIMES_LAST",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * The last number in PRIMES.\n */\npublic static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];"
            ],
            [
                "MIDPOINT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "MidPointIntegrator",
                "/**\n * Maximum number of iterations for midpoint.\n */\npublic static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "ROMBERG_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "RombergIntegrator",
                "/**\n * Maximal number of iterations for Romberg.\n */\npublic static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;"
            ],
            [
                "SIMPSON_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "SimpsonIntegrator",
                "/**\n * Maximal number of iterations for Simpson.\n */\npublic static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default absolute accuracy.\n */\npublic static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;"
            ],
            [
                "DEFAULT_RELATIVE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default relative accuracy.\n */\npublic static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;"
            ],
            [
                "DEFAULT_MIN_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default minimal iteration count.\n */\npublic static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default maximal iteration count.\n */\npublic static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;"
            ],
            [
                "TRAPEZOID_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "TrapezoidIntegrator",
                "/**\n * Maximum number of iterations for trapezoid.\n */\npublic static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "BaseSecantSolver",
                "/**\n * Default absolute accuracy.\n */\nprotected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "SecantSolver",
                "/**\n * Default absolute accuracy.\n */\nprotected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_BANDWIDTH",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value of the bandwidth parameter.\n */\npublic static final double DEFAULT_BANDWIDTH = 0.3;"
            ],
            [
                "DEFAULT_ROBUSTNESS_ITERS",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value of the number of robustness iterations.\n */\npublic static final int DEFAULT_ROBUSTNESS_ITERS = 2;"
            ],
            [
                "DEFAULT_ACCURACY",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value for accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_ACCURACY = 1e-12;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.analysis.interpolation",
                "NevilleInterpolator",
                "/**\n * serializable version identifier\n */\nstatic final long serialVersionUID = 3003707660147873733L;"
            ],
            [
                "DEFAULT_EXTEND",
                "org.apache.commons.math3.analysis.interpolation",
                "UnivariatePeriodicInterpolator",
                "/**\n * Default number of extension points of the samples array.\n */\npublic static final int DEFAULT_EXTEND = 5;"
            ],
            [
                "DEFAULT_MICROSPHERE_ELEMENTS",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "/**\n * Default number of surface elements that composes the microsphere.\n */\npublic static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;"
            ],
            [
                "DEFAULT_BRIGHTNESS_EXPONENT",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "/**\n * Default exponent used the weights calculation.\n */\npublic static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;"
            ],
            [
                "EPSILON",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * <p>\n * Largest double-precision floating-point number such that\n * {@code 1 + EPSILON} is numerically equal to 1. This value is an upper\n * bound on the relative error due to rounding real numbers to double\n * precision floating-point numbers.\n * </p>\n * <p>\n * In IEEE 754 arithmetic, this is 2<sup>-53</sup>.\n * </p>\n *\n * @see <a href=\"http://en.wikipedia.org/wiki/Machine_epsilon\">Machine epsilon</a>\n */\npublic static final double EPSILON;"
            ],
            [
                "SAFE_MIN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Safe minimum, such that {@code 1 / SAFE_MIN} does not overflow.\n * <br/>\n * In IEEE 754 arithmetic, this is also the smallest normalized\n * number 2<sup>-1022</sup>.\n */\npublic static final double SAFE_MIN;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;"
            ],
            [
                "PI",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Archimede's constant PI, ratio of circle circumference to diameter.\n */\npublic static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
            ],
            [
                "E",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Napier's constant e, base of the natural logarithm.\n */\npublic static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
            ],
            [
                "EXP_INT_TABLE_MAX_INDEX",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Index of exp(0) in the array of integer exponentials.\n */\nstatic final int EXP_INT_TABLE_MAX_INDEX = 750;"
            ],
            [
                "EXP_INT_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Length of the array of integer exponentials.\n */\nstatic final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;"
            ],
            [
                "LN_MANT_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Logarithm table length.\n */\nstatic final int LN_MANT_LEN = 1024;"
            ],
            [
                "EXP_FRAC_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Exponential fractions table length.\n */\n// 0, 1/1024, ... 1024/1024\nstatic final int EXP_FRAC_TABLE_LEN = 1025;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of NaN.\n */\npublic static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of positive infinity.\n */\npublic static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of negative infinity.\n */\npublic static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of NaN.\n */\npublic static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of positive infinity.\n */\npublic static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of negative infinity.\n */\npublic static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "ADDITIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "/**\n * Additive expansion mode.\n * @deprecated As of 3.1. Please use {@link ExpansionMode#ADDITIVE} instead.\n */\n@Deprecated\npublic static final int ADDITIVE_MODE = 1;"
            ],
            [
                "MULTIPLICATIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "/**\n * Multiplicative expansion mode.\n * @deprecated As of 3.1. Please use {@link ExpansionMode#MULTIPLICATIVE} instead.\n */\n@Deprecated\npublic static final int MULTIPLICATIVE_MODE = 0;"
            ],
            [
                "TWO_PI",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * \\(2\\pi\\)\n * @since 2.1\n */\npublic static final double TWO_PI = 2 * FastMath.PI;"
            ],
            [
                "PI_SQUARED",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * \\(\\pi^2\\)\n * @since 3.4\n */\npublic static final double PI_SQUARED = FastMath.PI * FastMath.PI;"
            ],
            [
                "FACTORIALS",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * All long-representable factorials\n */\nstatic final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };"
            ],
            [
                "STIRLING_S2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Stirling numbers of the second kind.\n */\nstatic final AtomicReference<long[][]> STIRLING_S2 = new AtomicReference<long[][]>(null);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@code 0d} as a {@code Decimal64}.\n */\npublic static final Decimal64 ZERO;"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@code 1d} as a {@code Decimal64}.\n */\npublic static final Decimal64 ONE;"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#NEGATIVE_INFINITY} as a\n * {@code Decimal64}.\n */\npublic static final Decimal64 NEGATIVE_INFINITY;"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#POSITIVE_INFINITY} as a\n * {@code Decimal64}.\n */\npublic static final Decimal64 POSITIVE_INFINITY;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#NaN} as a {@code Decimal64}.\n */\npublic static final Decimal64 NAN;"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "BigReal",
                "/**\n * A big real representing 0.\n */\npublic static final BigReal ZERO = new BigReal(BigDecimal.ZERO);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "BigReal",
                "/**\n * A big real representing 1.\n */\npublic static final BigReal ONE = new BigReal(BigDecimal.ONE);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Identity quaternion.\n */\npublic static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Zero quaternion.\n */\npublic static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * i\n */\npublic static final Quaternion I = new Quaternion(0, 1, 0, 0);"
            ],
            [
                "J",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * j\n */\npublic static final Quaternion J = new Quaternion(0, 0, 1, 0);"
            ],
            [
                "K",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * k\n */\npublic static final Quaternion K = new Quaternion(0, 0, 0, 1);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * The square root of -1. A number representing \"0.0 + 1.0i\"\n */\npublic static final Complex I = new Complex(0.0, 1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A complex number representing \"NaN + NaNi\"\n */\npublic static final Complex NaN = new Complex(Double.NaN, Double.NaN);"
            ],
            [
                "INF",
                "org.apache.commons.math3.complex",
                "Complex",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A complex number representing \"+INF + INFi\"\n */\npublic static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * A complex number representing \"1.0 + 0.0i\"\n */\npublic static final Complex ONE = new Complex(1.0, 0.0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * A complex number representing \"0.0 + 0.0i\"\n */\npublic static final Complex ZERO = new Complex(0.0, 0.0);"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Minimum dimension of the problem: {@value}\n */\npublic static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #initialTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #stoppingTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "DEFAULT_CHECKFEASABLECOUNT",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #checkFeasableCount}: {@value}.\n */\npublic static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
            ],
            [
                "DEFAULT_STOPFITNESS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #stopFitness}: {@value}.\n */\npublic static final double DEFAULT_STOPFITNESS = 0;"
            ],
            [
                "DEFAULT_ISACTIVECMA",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #isActiveCMA}: {@value}.\n */\npublic static final boolean DEFAULT_ISACTIVECMA = true;"
            ],
            [
                "DEFAULT_MAXITERATIONS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #maxIterations}: {@value}.\n */\npublic static final int DEFAULT_MAXITERATIONS = 30000;"
            ],
            [
                "DEFAULT_DIAGONALONLY",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #diagonalOnly}: {@value}.\n */\npublic static final int DEFAULT_DIAGONALONLY = 0;"
            ],
            [
                "DEFAULT_RANDOMGENERATOR",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #random}.\n */\npublic static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.optimization.linear",
                "AbstractLinearOptimizer",
                "/**\n * Default maximal number of iterations allowed.\n */\npublic static final int DEFAULT_MAX_ITERATIONS = 100;"
            ],
            [
                "DEFAULT_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * The default format for {@link RealMatrix} objects.\n * @since 3.1\n */\npublic static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();"
            ],
            [
                "OCTAVE_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * A format for {@link RealMatrix} objects compatible with octave.\n * @since 3.1\n */\npublic static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat(\"[\", \"]\", \"\", \"\", \"; \", \", \");"
            ],
            [
                "DEFAULT_ZERO_TOLERANCE",
                "org.apache.commons.math3.linear",
                "OpenMapRealVector",
                "/**\n * Default Tolerance for having a value considered zero.\n */\npublic static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Block size.\n */\npublic static final int BLOCK_SIZE = 36;"
            ],
            [
                "OPERATOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "/**\n * Key for the <a href=\"#context\">exception context</a>.\n */\npublic static final String OPERATOR = \"operator\";"
            ],
            [
                "VECTOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "/**\n * Key for the <a href=\"#context\">exception context</a>.\n */\npublic static final String VECTOR = \"vector\";"
            ],
            [
                "DEFAULT_RELATIVE_SYMMETRY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "/**\n * Default threshold above which off-diagonal elements are considered too different\n * and matrix not symmetric.\n */\npublic static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;"
            ],
            [
                "DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "/**\n * Default threshold below which diagonal elements are considered null\n * and matrix not positive definite.\n */\npublic static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Block size.\n */\npublic static final int BLOCK_SIZE = 52;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "/**\n * The cubic root of {@link #MACH_PREC}.\n */\nstatic final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "/**\n * The machine precision.\n */\nstatic final double MACH_PREC;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "/**\n * The cubic root of {@link #MACH_PREC}.\n */\nstatic final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "/**\n * The machine precision.\n */\nstatic final double MACH_PREC;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "CauchyDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "SOLVER_DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "AbstractRealDistribution",
                "/**\n * Default accuracy.\n */\npublic static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "TDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ChiSquaredDistribution",
                "/**\n * Default inverse cumulative probability accuracy\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NormalDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "UniformRealDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @deprecated as of 3.2 not used anymore, will be removed in 4.0\n */\n@Deprecated\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "WeibullDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NakagamiDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ExponentialDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "LogNormalDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ParetoDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "FDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "/**\n * Default maximum number of iterations for cumulative probability calculations.\n * @since 2.1\n */\npublic static final int DEFAULT_MAX_ITERATIONS = 10000000;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "/**\n * Default convergence criterion.\n * @since 2.1\n */\npublic static final double DEFAULT_EPSILON = 1e-12;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "GammaDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_ULPS",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "/**\n * Default amount of error to accept in floating point comparisons (as ulps).\n */\nstatic final int DEFAULT_ULPS = 10;"
            ],
            [
                "DEFAULT_CUT_OFF",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "/**\n * Default cut-off value.\n */\nstatic final double DEFAULT_CUT_OFF = 1e-10;"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Minimum dimension of the problem: {@value}\n */\npublic static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #initialTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #stoppingTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "GAMMA",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <a href=\"http://en.wikipedia.org/wiki/Euler-Mascheroni_constant\">Euler-Mascheroni constant</a>\n * @since 2.0\n */\npublic static final double GAMMA = 0.577215664901532860606512090082;"
            ],
            [
                "LANCZOS_G",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * The value of the {@code g} constant in the Lanczos approximation, see\n * {@link #lanczos(double)}.\n * @since 3.1\n */\npublic static final double LANCZOS_G = 607.0 / 128.0;"
            ],
            [
                "DEFAULT_NAN_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "/**\n * default NaN strategy\n */\npublic static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.FAILED;"
            ],
            [
                "DEFAULT_TIES_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "/**\n * default ties strategy\n */\npublic static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;"
            ],
            [
                "MAXIMUM_PARTIAL_SUM_COUNT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Bound on the number of partial sums in {@link #ksSum(double, double, int)}\n */\nprotected static final int MAXIMUM_PARTIAL_SUM_COUNT = 100000;"
            ],
            [
                "KS_SUM_CAUCHY_CRITERION",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Convergence criterion for {@link #ksSum(double, double, int)}\n */\nprotected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;"
            ],
            [
                "PG_SUM_RELATIVE_ERROR",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Convergence criterion for the sums in #pelzGood(double, double, int)}\n */\nprotected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;"
            ],
            [
                "SMALL_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * No longer used.\n */\n@Deprecated\nprotected static final int SMALL_SAMPLE_PRODUCT = 200;"
            ],
            [
                "LARGE_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * When product of sample sizes exceeds this value, 2-sample K-S test uses asymptotic\n * distribution to compute the p-value.\n */\nprotected static final int LARGE_SAMPLE_PRODUCT = 10000;"
            ],
            [
                "MONTE_CARLO_ITERATIONS",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Default number of iterations used by {@link #monteCarloP(double, int, int, boolean, int)}.\n *  Deprecated as of version 3.6, as this method is no longer needed.\n */\n@Deprecated\nprotected static final int MONTE_CARLO_ITERATIONS = 1000000;"
            ],
            [
                "INFINITE_WINDOW",
                "org.apache.commons.math3.stat.descriptive",
                "DescriptiveStatistics",
                "/**\n * Represents an infinite window size.  When the {@link #getWindowSize()}\n * returns this value, there is no limit to the number of data values\n * that can be stored in the dataset.\n */\npublic static final int INFINITE_WINDOW = -1;"
            ],
            [
                "UPSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "/**\n * The UPSIDE Direction is used to specify that the observations above the\n * cutoff point will be used to calculate SemiVariance.\n */\npublic static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;"
            ],
            [
                "DOWNSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "/**\n * The DOWNSIDE Direction is used to specify that the observations below\n * the cutoff point will be used to calculate SemiVariance\n */\npublic static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Comparator.\n */\nstatic final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "PairNeuronDouble",
                "/**\n * Comparator.\n */\nstatic final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "RADIX",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The radix, or base of this system.  Set to 10000\n */\npublic static final int RADIX = 10000;"
            ],
            [
                "MIN_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The minimum exponent before underflow is signaled.  Flush to zero\n *  occurs at minExp-DIGITS\n */\npublic static final int MIN_EXP = -32767;"
            ],
            [
                "MAX_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The maximum exponent before overflow is signaled and results flushed\n *  to infinity\n */\npublic static final int MAX_EXP = 32768;"
            ],
            [
                "ERR_SCALE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The amount under/overflows are scaled by before going to trap handler\n */\npublic static final int ERR_SCALE = 32760;"
            ],
            [
                "FINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for normal finite numbers.\n */\npublic static final byte FINITE = 0;"
            ],
            [
                "INFINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for Infinity.\n */\npublic static final byte INFINITE = 1;"
            ],
            [
                "SNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for signaling NaN.\n */\npublic static final byte SNAN = 2;"
            ],
            [
                "QNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for quiet NaN.\n */\npublic static final byte QNAN = 3;"
            ],
            [
                "FLAG_INVALID",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for invalid operation.\n */\npublic static final int FLAG_INVALID = 1;"
            ],
            [
                "FLAG_DIV_ZERO",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for division by zero.\n */\npublic static final int FLAG_DIV_ZERO = 2;"
            ],
            [
                "FLAG_OVERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for overflow.\n */\npublic static final int FLAG_OVERFLOW = 4;"
            ],
            [
                "FLAG_UNDERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for underflow.\n */\npublic static final int FLAG_UNDERFLOW = 8;"
            ],
            [
                "FLAG_INEXACT",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for inexact result.\n */\npublic static final int FLAG_INEXACT = 16;"
            ],
            [
                "DEFAULT_PREFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default prefix: \"{\".\n */\npublic static final String DEFAULT_PREFIX = \"{\";"
            ],
            [
                "DEFAULT_SUFFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default suffix: \"}\".\n */\npublic static final String DEFAULT_SUFFIX = \"}\";"
            ],
            [
                "DEFAULT_SEPARATOR",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default separator: \", \".\n */\npublic static final String DEFAULT_SEPARATOR = \"; \";"
            ],
            [
                "XYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around X, then around Y, then\n * around Z\n */\npublic static final RotationOrder XYZ = new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "XZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around X, then around Z, then\n * around Y\n */\npublic static final RotationOrder XZY = new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "YXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Y, then around X, then\n * around Z\n */\npublic static final RotationOrder YXZ = new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "YZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Y, then around Z, then\n * around X\n */\npublic static final RotationOrder YZX = new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "ZXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Z, then around X, then\n * around Y\n */\npublic static final RotationOrder ZXY = new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "ZYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Z, then around Y, then\n * around X\n */\npublic static final RotationOrder ZYX = new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around X, then around Y, then\n * around X\n */\npublic static final RotationOrder XYX = new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around X, then around Z, then\n * around X\n */\npublic static final RotationOrder XZX = new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "YXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Y, then around X, then\n * around Y\n */\npublic static final RotationOrder YXY = new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "YZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Y, then around Z, then\n * around Y\n */\npublic static final RotationOrder YZY = new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "ZXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Z, then around X, then\n * around Z\n */\npublic static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "ZYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Z, then around Y, then\n * around Z\n */\npublic static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "/**\n * Identity rotation.\n */\npublic static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Null vector (coordinates: 0, 0, 0).\n */\npublic static final Vector3D ZERO = new Vector3D(0, 0, 0);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * First canonical vector (coordinates: 1, 0, 0).\n */\npublic static final Vector3D PLUS_I = new Vector3D(1, 0, 0);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the first canonical vector (coordinates: -1, 0, 0).\n */\npublic static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Second canonical vector (coordinates: 0, 1, 0).\n */\npublic static final Vector3D PLUS_J = new Vector3D(0, 1, 0);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the second canonical vector (coordinates: 0, -1, 0).\n */\npublic static final Vector3D MINUS_J = new Vector3D(0, -1, 0);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Third canonical vector (coordinates: 0, 0, 1).\n */\npublic static final Vector3D PLUS_K = new Vector3D(0, 0, 1);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the third canonical vector (coordinates: 0, 0, -1).\n */\npublic static final Vector3D MINUS_K = new Vector3D(0, 0, -1);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Origin (coordinates: 0).\n */\npublic static final Vector1D ZERO = new Vector1D(0.0);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Unit (coordinates: 1).\n */\npublic static final Vector1D ONE = new Vector1D(1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector1D NaN = new Vector1D(Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector1D POSITIVE_INFINITY = new Vector1D(Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector1D NEGATIVE_INFINITY = new Vector1D(Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Origin (coordinates: 0, 0).\n */\npublic static final Vector2D ZERO = new Vector2D(0, 0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector2D POSITIVE_INFINITY = new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector2D NEGATIVE_INFINITY = new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +I (coordinates: \\( \\theta = 0, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +J (coordinates: \\( \\theta = \\pi/2, \\varphi = \\pi/2 \\))).\n */\npublic static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +K (coordinates: \\( \\theta = any angle, \\varphi = 0 \\)).\n */\npublic static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -I (coordinates: \\( \\theta = \\pi, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -J (coordinates: \\( \\theta = 3\\pi/2, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -K (coordinates: \\( \\theta = any angle, \\varphi = \\pi \\)).\n */\npublic static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);"
            ],
            [
                "DIGEST_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Use empirical distribution.\n */\npublic static final int DIGEST_MODE = 0;"
            ],
            [
                "REPLAY_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Replay data from valuesFilePath.\n */\npublic static final int REPLAY_MODE = 1;"
            ],
            [
                "UNIFORM_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Uniform random deviates with mean = &mu;.\n */\npublic static final int UNIFORM_MODE = 2;"
            ],
            [
                "EXPONENTIAL_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Exponential random deviates with mean = &mu;.\n */\npublic static final int EXPONENTIAL_MODE = 3;"
            ],
            [
                "GAUSSIAN_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Gaussian random deviates with mean = &mu;, std dev = &sigma;.\n */\npublic static final int GAUSSIAN_MODE = 4;"
            ],
            [
                "CONSTANT_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Always return mu\n */\npublic static final int CONSTANT_MODE = 5;"
            ],
            [
                "DEFAULT_BIN_COUNT",
                "org.apache.commons.math3.random",
                "EmpiricalDistribution",
                "/**\n * Default bin count\n */\npublic static final int DEFAULT_BIN_COUNT = 1000;"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2 / 1\".\n */\npublic static final Fraction TWO = new Fraction(2, 1);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1\".\n */\npublic static final Fraction ONE = new Fraction(1, 1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"0\".\n */\npublic static final Fraction ZERO = new Fraction(0, 1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"4/5\".\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/5\".\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/2\".\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/4\".\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/3\".\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"3/5\".\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"3/4\".\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/5\".\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/4\".\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/3\".\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"-1 / 1\".\n */\npublic static final Fraction MINUS_ONE = new Fraction(-1, 1);"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2 / 1\".\n */\npublic static final BigFraction TWO = new BigFraction(2);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1\".\n */\npublic static final BigFraction ONE = new BigFraction(1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"0\".\n */\npublic static final BigFraction ZERO = new BigFraction(0);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"-1 / 1\".\n */\npublic static final BigFraction MINUS_ONE = new BigFraction(-1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"4/5\".\n */\npublic static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/5\".\n */\npublic static final BigFraction ONE_FIFTH = new BigFraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/2\".\n */\npublic static final BigFraction ONE_HALF = new BigFraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/4\".\n */\npublic static final BigFraction ONE_QUARTER = new BigFraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/3\".\n */\npublic static final BigFraction ONE_THIRD = new BigFraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"3/5\".\n */\npublic static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"3/4\".\n */\npublic static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/5\".\n */\npublic static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/4\".\n */\npublic static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/3\".\n */\npublic static final BigFraction TWO_THIRDS = new BigFraction(2, 3);"
            ],
            [
                "INTEGER_ZERO",
                "org.apache.commons.math3.exception",
                "MathIllegalNumberException",
                "/**\n * Helper to avoid boxing warnings. @since 3.3\n */\nprotected static final Integer INTEGER_ZERO = Integer.valueOf(0);"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastSineTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120211L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastFourierTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120210L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastCosineTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120212L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastHadamardTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120211L;"
            ]
        ],
        "tokensMethodJavadocValues": [],
        "tokensMethodArguments": [
            [
                "real",
                "",
                "double"
            ],
            [
                "imaginary",
                "",
                "double"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "log",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n * natural logarithm</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   log(a + bi) = ln(|a + bi|) + arg(a + bi)i\n *  </code>\n * </pre>\n * where ln on the right hand side is {@link FastMath#log},\n * {@code |a + bi|} is the modulus, {@link Complex#abs},  and\n * {@code arg(a + bi) = }{@link FastMath#atan2}(b, a).\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite (or critical) values in real or imaginary parts of the input may\n * result in infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n *   log(INFINITY + i) = INFINITY + 0i\n *   log(-INFINITY + i) = INFINITY + &pi;i\n *   log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n *   log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n *   log(0 + 0i) = -INFINITY + 0i\n *  </code>\n * </pre>\n *\n * @return the value <code>ln &nbsp; this</code>, the natural logarithm\n * of {@code this}.\n * @since 1.2\n */\npublic Complex log() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.log(abs()), FastMath.atan2(imaginary, real));\n}"
            ],
            [
                "getImaginary",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Access the imaginary part.\n *\n * @return the imaginary part.\n */\npublic double getImaginary() {\n    return imaginary;\n}"
            ],
            [
                "divide",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T divide(T arg0) throws NullArgumentException, MathArithmeticException"
            ],
            [
                "multiply",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T multiply(T arg0) throws NullArgumentException"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this - subtrahend)}.\n * Uses the definitional formula\n * <p>\n *  {@code (a + bi) - (c + di) = (a-c) + (b-d)i}\n * </p>\n * If either {@code this} or {@code subtrahend} has a {@code NaN]} value in either part,\n * {@link #NaN} is returned; otherwise infinite and {@code NaN} values are\n * returned in the parts of the result according to the rules for\n * {@link java.lang.Double} arithmetic.\n *\n * @param  subtrahend value to be subtracted from this {@code Complex}.\n * @return {@code this - subtrahend}.\n * @throws NullArgumentException if {@code subtrahend} is {@code null}.\n */\npublic Complex subtract(Complex subtrahend) throws NullArgumentException {\n    MathUtils.checkNotNull(subtrahend);\n    if (isNaN || subtrahend.isNaN) {\n        return NaN;\n    }\n    return createComplex(real - subtrahend.getReal(), imaginary - subtrahend.getImaginary());\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "reciprocal",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T reciprocal() throws MathArithmeticException"
            ],
            [
                "acos",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n * inverse cosine</a> of this complex number.\n * Implements the formula:\n * <p>\n *  {@code acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))}\n * </p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite.\n *\n * @return the inverse cosine of this complex number.\n * @since 1.2\n */\npublic Complex acos() {\n    if (isNaN) {\n        return NaN;\n    }\n    return this.add(this.sqrt1z().multiply(I)).log().multiply(I.negate());\n}"
            ],
            [
                "getField",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * {@inheritDoc}\n */\npublic ComplexField getField() {\n    return ComplexField.getInstance();\n}"
            ],
            [
                "exp",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n * exponential function</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#exp}, {@link FastMath#cos}, and\n * {@link FastMath#sin}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   exp(1 &plusmn; INFINITY i) = NaN + NaN i\n *   exp(INFINITY + i) = INFINITY + INFINITY i\n *   exp(-INFINITY + i) = 0 + 0i\n *   exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return <code><i>e</i><sup>this</sup></code>.\n * @since 1.2\n */\npublic Complex exp() {\n    if (isNaN) {\n        return NaN;\n    }\n    double expReal = FastMath.exp(real);\n    return createComplex(expReal * FastMath.cos(imaginary), expReal * FastMath.sin(imaginary));\n}"
            ],
            [
                "asin",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n * inverse sine</a> of this complex number.\n * Implements the formula:\n * <p>\n *  {@code asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz))}\n * </p><p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite.</p>\n *\n * @return the inverse sine of this complex number.\n * @since 1.2\n */\npublic Complex asin() {\n    if (isNaN) {\n        return NaN;\n    }\n    return sqrt1z().add(this.multiply(I)).log().multiply(I.negate());\n}"
            ],
            [
                "sqrt1z",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n * square root</a> of <code>1 - this<sup>2</sup></code> for this complex\n * number.\n * Computes the result directly as\n * {@code sqrt(ONE.subtract(z.multiply(z)))}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n *\n * @return the square root of <code>1 - this<sup>2</sup></code>.\n * @since 1.2\n */\npublic Complex sqrt1z() {\n    return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code this * factor}.\n * Implements preliminary checks for {@code NaN} and infinity followed by\n * the definitional formula:\n * <p>\n *   {@code (a + bi)(c + di) = (ac - bd) + (ad + bc)i}\n * </p>\n * Returns {@link #NaN} if either {@code this} or {@code factor} has one or\n * more {@code NaN} parts.\n * <p>\n * Returns {@link #INF} if neither {@code this} nor {@code factor} has one\n * or more {@code NaN} parts and if either {@code this} or {@code factor}\n * has one or more infinite parts (same result is returned regardless of\n * the sign of the components).\n * </p><p>\n * Returns finite values in components of the result per the definitional\n * formula in all remaining cases.</p>\n *\n * @param  factor value to be multiplied by this {@code Complex}.\n * @return {@code this * factor}.\n * @throws NullArgumentException if {@code factor} is {@code null}.\n */\npublic Complex multiply(Complex factor) throws NullArgumentException {\n    MathUtils.checkNotNull(factor);\n    if (isNaN || factor.isNaN) {\n        return NaN;\n    }\n    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor.real) || Double.isInfinite(factor.imaginary)) {\n        // we don't use isInfinite() to avoid testing for NaN again\n        return INF;\n    }\n    return createComplex(real * factor.real - imaginary * factor.imaginary, real * factor.imaginary + imaginary * factor.real);\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "pow",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns of value of this complex number raised to the power of {@code x}.\n * Implements the formula:\n * <pre>\n *  <code>\n *   y<sup>x</sup> = exp(x&middot;log(y))\n *  </code>\n * </pre>\n * where {@code exp} and {@code log} are {@link #exp} and\n * {@link #log}, respectively.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite, or if {@code y}\n * equals {@link Complex#ZERO}.</p>\n *\n * @param  x exponent to which this {@code Complex} is to be raised.\n * @return <code> this<sup>x</sup></code>.\n * @throws NullArgumentException if x is {@code null}.\n * @since 1.2\n */\npublic Complex pow(Complex x) throws NullArgumentException {\n    MathUtils.checkNotNull(x);\n    return this.log().multiply(x).exp();\n}"
            ],
            [
                "sinh",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n * hyperbolic sine</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p><p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n *   sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n *   sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the hyperbolic sine of {@code this}.\n * @since 1.2\n */\npublic Complex sinh() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.sinh(real) * FastMath.cos(imaginary), FastMath.cosh(real) * FastMath.sin(imaginary));\n}"
            ],
            [
                "cosh",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n * hyperbolic cosine</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n *   cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n *   cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the hyperbolic cosine of this complex number.\n * @since 1.2\n */\npublic Complex cosh() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.cosh(real) * FastMath.cos(imaginary), FastMath.sinh(real) * FastMath.sin(imaginary));\n}"
            ],
            [
                "hashCode",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Get a hashCode for the complex number.\n * Any {@code Double.NaN} value in real or imaginary part produces\n * the same hash code {@code 7}.\n *\n * @return a hash code value for this object.\n */\n@Override\npublic int hashCode() {\n    if (isNaN) {\n        return 7;\n    }\n    return 37 * (17 * MathUtils.hash(imaginary) + MathUtils.hash(real));\n}"
            ],
            [
                "add",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T add(T arg0) throws NullArgumentException"
            ],
            [
                "reciprocal",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * {@inheritDoc}\n */\npublic Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return INF;\n    }\n    if (isInfinite) {\n        return ZERO;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        double q = real / imaginary;\n        double scale = 1. / (real * q + imaginary);\n        return createComplex(scale * q, -scale);\n    } else {\n        double q = imaginary / real;\n        double scale = 1. / (imaginary * q + real);\n        return createComplex(scale, -scale * q);\n    }\n}"
            ],
            [
                "atan",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n * inverse tangent</a> of this complex number.\n * Implements the formula:\n * <p>\n * {@code atan(z) = (i/2) log((i + z)/(i - z))}\n * </p><p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN} or infinite.</p>\n *\n * @return the inverse tangent of this complex number\n * @since 1.2\n */\npublic Complex atan() {\n    if (isNaN) {\n        return NaN;\n    }\n    return this.add(I).divide(I.subtract(this)).log().multiply(I.divide(createComplex(2.0, 0.0)));\n}"
            ],
            [
                "conjugate",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns the conjugate of this complex number.\n * The conjugate of {@code a + bi} is {@code a - bi}.\n * <p>\n * {@link #NaN} is returned if either the real or imaginary\n * part of this Complex number equals {@code Double.NaN}.\n * </p><p>\n * If the imaginary part is infinite, and the real part is not\n * {@code NaN}, the returned value has infinite imaginary part\n * of the opposite sign, e.g. the conjugate of\n * {@code 1 + POSITIVE_INFINITY i} is {@code 1 - NEGATIVE_INFINITY i}.\n * </p>\n * @return the conjugate of this Complex object.\n */\npublic Complex conjugate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(real, -imaginary);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Test for equality with another object.\n * If both the real and imaginary parts of two complex numbers\n * are exactly the same, and neither is {@code Double.NaN}, the two\n * Complex objects are considered to be equal.\n * The behavior is the same as for JDK's {@link Double#equals(Object)\n * Double}:\n * <ul>\n *  <li>All {@code NaN} values are considered to be equal,\n *   i.e, if either (or both) real and imaginary parts of the complex\n *   number are equal to {@code Double.NaN}, the complex number is equal\n *   to {@code NaN}.\n *  </li>\n *  <li>\n *   Instances constructed with different representations of zero (i.e.\n *   either \"0\" or \"-0\") are <em>not</em> considered to be equal.\n *  </li>\n * </ul>\n *\n * @param other Object to test for equality with this instance.\n * @return {@code true} if the objects are equal, {@code false} if object\n * is {@code null}, not an instance of {@code Complex}, or not equal to\n * this instance.\n */\n@Override\npublic boolean equals(Object other) {\n    if (this == other) {\n        return true;\n    }\n    if (other instanceof Complex) {\n        Complex c = (Complex) other;\n        if (c.isNaN) {\n            return isNaN;\n        } else {\n            return MathUtils.equals(real, c.real) && MathUtils.equals(imaginary, c.imaginary);\n        }\n    }\n    return false;\n}"
            ],
            [
                "nthRoot",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Computes the n-th roots of this complex number.\n * The nth roots are defined by the formula:\n * <pre>\n *  <code>\n *   z<sub>k</sub> = abs<sup>1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))\n *  </code>\n * </pre>\n * for <i>{@code k=0, 1, ..., n-1}</i>, where {@code abs} and {@code phi}\n * are respectively the {@link #abs() modulus} and\n * {@link #getArgument() argument} of this complex number.\n * <p>\n * If one or both parts of this complex number is NaN, a list with just\n * one element, {@link #NaN} is returned.\n * if neither part is NaN, but at least one part is infinite, the result\n * is a one-element list containing {@link #INF}.\n *\n * @param n Degree of root.\n * @return a List of all {@code n}-th roots of {@code this}.\n * @throws NotPositiveException if {@code n <= 0}.\n * @since 2.0\n */\npublic List<Complex> nthRoot(int n) throws NotPositiveException {\n    if (n <= 0) {\n        throw new NotPositiveException(LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N, n);\n    }\n    final List<Complex> result = new ArrayList<Complex>();\n    if (isNaN) {\n        result.add(NaN);\n        return result;\n    }\n    if (isInfinite()) {\n        result.add(INF);\n        return result;\n    }\n    // nth root of abs -- faster / more accurate to use a solver here?\n    final double nthRootOfAbs = FastMath.pow(abs(), 1.0 / n);\n    // Compute nth roots of complex number with k = 0, 1, ... n-1\n    final double nthPhi = getArgument() / n;\n    final double slice = 2 * FastMath.PI / n;\n    double innerPart = nthPhi;\n    for (int k = 0; k < n; k++) {\n        // inner part\n        final double realPart = nthRootOfAbs * FastMath.cos(innerPart);\n        final double imaginaryPart = nthRootOfAbs * FastMath.sin(innerPart);\n        result.add(createComplex(realPart, imaginaryPart));\n        innerPart += slice;\n    }\n    return result;\n}"
            ],
            [
                "tanh",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n * hyperbolic tangent</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n * {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   tanh(a &plusmn; INFINITY i) = NaN + NaN i\n *   tanh(&plusmn;INFINITY + bi) = &plusmn;1 + 0 i\n *   tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *   tanh(0 + (&pi;/2)i) = NaN + INFINITY i\n *  </code>\n * </pre>\n *\n * @return the hyperbolic tangent of {@code this}.\n * @since 1.2\n */\npublic Complex tanh() {\n    if (isNaN || Double.isInfinite(imaginary)) {\n        return NaN;\n    }\n    if (real > 20.0) {\n        return createComplex(1.0, 0.0);\n    }\n    if (real < -20.0) {\n        return createComplex(-1.0, 0.0);\n    }\n    double real2 = 2.0 * real;\n    double imaginary2 = 2.0 * imaginary;\n    double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n    return createComplex(FastMath.sinh(real2) / d, FastMath.sin(imaginary2) / d);\n}"
            ],
            [
                "cos",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n * cosine</a> of this complex number.\n * Implements the formula:\n * <p>\n *  {@code cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i}\n * </p><p>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * </p><p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p><p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.</p>\n * <pre>\n *  Examples:\n *  <code>\n *   cos(1 &plusmn; INFINITY i) = 1 \\u2213 INFINITY i\n *   cos(&plusmn;INFINITY + i) = NaN + NaN i\n *   cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the cosine of this complex number.\n * @since 1.2\n */\npublic Complex cos() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.cos(real) * FastMath.cosh(imaginary), -FastMath.sin(real) * FastMath.sinh(imaginary));\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n * interpreted as a real number.\n *\n * @param  factor value to be multiplied by this {@code Complex}.\n * @return {@code this * factor}.\n * @see #multiply(Complex)\n */\npublic Complex multiply(double factor) {\n    if (isNaN || Double.isNaN(factor)) {\n        return NaN;\n    }\n    if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(factor)) {\n        // we don't use isInfinite() to avoid testing for NaN again\n        return INF;\n    }\n    return createComplex(real * factor, imaginary * factor);\n}"
            ],
            [
                "getField",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract Field<T> getField()"
            ],
            [
                "subtract",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T subtract(T arg0) throws NullArgumentException"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code (this + addend)},\n * with {@code addend} interpreted as a real number.\n *\n * @param addend Value to be added to this {@code Complex}.\n * @return {@code this + addend}.\n * @see #add(Complex)\n */\npublic Complex add(double addend) {\n    if (isNaN || Double.isNaN(addend)) {\n        return NaN;\n    }\n    return createComplex(real + addend, imaginary);\n}"
            ],
            [
                "getArgument",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the argument of this complex number.\n * The argument is the angle phi between the positive real axis and\n * the point representing this number in the complex plane.\n * The value returned is between -PI (not inclusive)\n * and PI (inclusive), with negative values returned for numbers with\n * negative imaginary parts.\n * <p>\n * If either real or imaginary part (or both) is NaN, NaN is returned.\n * Infinite parts are handled as {@code Math.atan2} handles them,\n * essentially treating finite parts as zero in the presence of an\n * infinite coordinate and returning a multiple of pi/4 depending on\n * the signs of the infinite parts.\n * See the javadoc for {@code Math.atan2} for full details.\n *\n * @return the argument of {@code this}.\n */\npublic double getArgument() {\n    return FastMath.atan2(getImaginary(), getReal());\n}"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this - subtrahend)}.\n *\n * @param  subtrahend value to be subtracted from this {@code Complex}.\n * @return {@code this - subtrahend}.\n * @see #subtract(Complex)\n */\npublic Complex subtract(double subtrahend) {\n    if (isNaN || Double.isNaN(subtrahend)) {\n        return NaN;\n    }\n    return createComplex(real - subtrahend, imaginary);\n}"
            ],
            [
                "toString",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * {@inheritDoc}\n */\n@Override\npublic String toString() {\n    return \"(\" + real + \", \" + imaginary + \")\";\n}"
            ],
            [
                "negate",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T negate()"
            ],
            [
                "readResolve",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Resolve the transient fields in a deserialized Complex Object.\n * Subclasses will need to override {@link #createComplex} to\n * deserialize properly.\n *\n * @return A Complex instance with all fields resolved.\n * @since 2.0\n */\nprotected final Object readResolve() {\n    return createComplex(real, imaginary);\n}"
            ],
            [
                "divide",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this / divisor)}.\n * Implements the definitional formula\n * <pre>\n *  <code>\n *    a + bi          ac + bd + (bc - ad)i\n *    ----------- = -------------------------\n *    c + di         c<sup>2</sup> + d<sup>2</sup>\n *  </code>\n * </pre>\n * but uses\n * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n * prescaling of operands</a> to limit the effects of overflows and\n * underflows in the computation.\n * <p>\n * {@code Infinite} and {@code NaN} values are handled according to the\n * following rules, applied in the order presented:\n * <ul>\n *  <li>If either {@code this} or {@code divisor} has a {@code NaN} value\n *   in either part, {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code divisor} equals {@link #ZERO}, {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code this} and {@code divisor} are both infinite,\n *   {@link #NaN} is returned.\n *  </li>\n *  <li>If {@code this} is finite (i.e., has no {@code Infinite} or\n *   {@code NaN} parts) and {@code divisor} is infinite (one or both parts\n *   infinite), {@link #ZERO} is returned.\n *  </li>\n *  <li>If {@code this} is infinite and {@code divisor} is finite,\n *   {@code NaN} values are returned in the parts of the result if the\n *   {@link java.lang.Double} rules applied to the definitional formula\n *   force {@code NaN} results.\n *  </li>\n * </ul>\n *\n * @param divisor Value by which this {@code Complex} is to be divided.\n * @return {@code this / divisor}.\n * @throws NullArgumentException if {@code divisor} is {@code null}.\n */\npublic Complex divide(Complex divisor) throws NullArgumentException {\n    MathUtils.checkNotNull(divisor);\n    if (isNaN || divisor.isNaN) {\n        return NaN;\n    }\n    final double c = divisor.getReal();\n    final double d = divisor.getImaginary();\n    if (c == 0.0 && d == 0.0) {\n        return NaN;\n    }\n    if (divisor.isInfinite() && !isInfinite()) {\n        return ZERO;\n    }\n    if (FastMath.abs(c) < FastMath.abs(d)) {\n        double q = c / d;\n        double denominator = c * q + d;\n        return createComplex((real * q + imaginary) / denominator, (imaginary * q - real) / denominator);\n    } else {\n        double q = d / c;\n        double denominator = d * q + c;\n        return createComplex((imaginary * q + real) / denominator, (imaginary - real * q) / denominator);\n    }\n}"
            ],
            [
                "divide",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code (this / divisor)},\n * with {@code divisor} interpreted as a real number.\n *\n * @param  divisor Value by which this {@code Complex} is to be divided.\n * @return {@code this / divisor}.\n * @see #divide(Complex)\n */\npublic Complex divide(double divisor) {\n    if (isNaN || Double.isNaN(divisor)) {\n        return NaN;\n    }\n    if (divisor == 0d) {\n        return NaN;\n    }\n    if (Double.isInfinite(divisor)) {\n        return !isInfinite() ? ZERO : NaN;\n    }\n    return createComplex(real / divisor, imaginary / divisor);\n}"
            ],
            [
                "createComplex",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Create a complex number given the real and imaginary parts.\n *\n * @param realPart Real part.\n * @param imaginaryPart Imaginary part.\n * @return a new complex number instance.\n * @since 1.2\n * @see #valueOf(double, double)\n */\nprotected Complex createComplex(double realPart, double imaginaryPart) {\n    return new Complex(realPart, imaginaryPart);\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is\n * {@code (this + addend)}.\n * Uses the definitional formula\n * <p>\n *   {@code (a + bi) + (c + di) = (a+c) + (b+d)i}\n * </p>\n * If either {@code this} or {@code addend} has a {@code NaN} value in\n * either part, {@link #NaN} is returned; otherwise {@code Infinite}\n * and {@code NaN} values are returned in the parts of the result\n * according to the rules for {@link java.lang.Double} arithmetic.\n *\n * @param  addend Value to be added to this {@code Complex}.\n * @return {@code this + addend}.\n * @throws NullArgumentException if {@code addend} is {@code null}.\n */\npublic Complex add(Complex addend) throws NullArgumentException {\n    MathUtils.checkNotNull(addend);\n    if (isNaN || addend.isNaN) {\n        return NaN;\n    }\n    return createComplex(real + addend.getReal(), imaginary + addend.getImaginary());\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns of value of this complex number raised to the power of {@code x}.\n *\n * @param  x exponent to which this {@code Complex} is to be raised.\n * @return <code>this<sup>x</sup></code>.\n * @see #pow(Complex)\n */\npublic Complex pow(double x) {\n    return this.log().multiply(x).exp();\n}"
            ],
            [
                "isNaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Checks whether either or both parts of this complex number is\n * {@code NaN}.\n *\n * @return true if either or both parts of this complex number is\n * {@code NaN}; false otherwise.\n */\npublic boolean isNaN() {\n    return isNaN;\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3",
                "FieldElement",
                "public abstract T multiply(int arg0)"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code this * factor}, with {@code factor}\n * interpreted as a integer number.\n *\n * @param  factor value to be multiplied by this {@code Complex}.\n * @return {@code this * factor}.\n * @see #multiply(Complex)\n */\npublic Complex multiply(final int factor) {\n    if (isNaN) {\n        return NaN;\n    }\n    if (Double.isInfinite(real) || Double.isInfinite(imaginary)) {\n        return INF;\n    }\n    return createComplex(real * factor, imaginary * factor);\n}"
            ],
            [
                "negate",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns a {@code Complex} whose value is {@code (-this)}.\n * Returns {@code NaN} if either real or imaginary\n * part of this Complex number is {@code Double.NaN}.\n *\n * @return {@code -this}.\n */\npublic Complex negate() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(-real, -imaginary);\n}"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n * square root</a> of this complex number.\n * Implements the following algorithm to compute {@code sqrt(a + bi)}:\n * <ol><li>Let {@code t = sqrt((|a| + |a + bi|) / 2)}</li>\n * <li><pre>if {@code  a &#8805; 0} return {@code t + (b/2t)i}\n *  else return {@code |b|/2t + sign(b)t i }</pre></li>\n * </ol>\n * where <ul>\n * <li>{@code |a| = }{@link FastMath#abs}(a)</li>\n * <li>{@code |a + bi| = }{@link Complex#abs}(a + bi)</li>\n * <li>{@code sign(b) =  }{@link FastMath#copySign(double,double) copySign(1d, b)}\n * </ul>\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n *   sqrt(INFINITY + i) = INFINITY + 0i\n *   sqrt(-INFINITY + i) = 0 + INFINITY i\n *   sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n *   sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n *  </code>\n * </pre>\n *\n * @return the square root of {@code this}.\n * @since 1.2\n */\npublic Complex sqrt() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n        return createComplex(0.0, 0.0);\n    }\n    double t = FastMath.sqrt((FastMath.abs(real) + abs()) / 2.0);\n    if (real >= 0.0) {\n        return createComplex(t, imaginary / (2.0 * t));\n    } else {\n        return createComplex(FastMath.abs(imaginary) / (2.0 * t), FastMath.copySign(1d, imaginary) * t);\n    }\n}"
            ],
            [
                "getReal",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Access the real part.\n *\n * @return the real part.\n */\npublic double getReal() {\n    return real;\n}"
            ],
            [
                "tan",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n * tangent</a> of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos}, {@link FastMath#cosh} and\n * {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p>\n * Infinite (or critical) values in real or imaginary parts of the input may\n * result in infinite or NaN values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   tan(a &plusmn; INFINITY i) = 0 &plusmn; i\n *   tan(&plusmn;INFINITY + bi) = NaN + NaN i\n *   tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *   tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i\n *  </code>\n * </pre>\n *\n * @return the tangent of {@code this}.\n * @since 1.2\n */\npublic Complex tan() {\n    if (isNaN || Double.isInfinite(real)) {\n        return NaN;\n    }\n    if (imaginary > 20.0) {\n        return createComplex(0.0, 1.0);\n    }\n    if (imaginary < -20.0) {\n        return createComplex(0.0, -1.0);\n    }\n    double real2 = 2.0 * real;\n    double imaginary2 = 2.0 * imaginary;\n    double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n    return createComplex(FastMath.sin(real2) / d, FastMath.sinh(imaginary2) / d);\n}"
            ],
            [
                "sin",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Compute the\n * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n * sine</a>\n * of this complex number.\n * Implements the formula:\n * <pre>\n *  <code>\n *   sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i\n *  </code>\n * </pre>\n * where the (real) functions on the right-hand side are\n * {@link FastMath#sin}, {@link FastMath#cos},\n * {@link FastMath#cosh} and {@link FastMath#sinh}.\n * <p>\n * Returns {@link Complex#NaN} if either real or imaginary part of the\n * input argument is {@code NaN}.\n * </p><p>\n * Infinite values in real or imaginary parts of the input may result in\n * infinite or {@code NaN} values returned in parts of the result.\n * <pre>\n *  Examples:\n *  <code>\n *   sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n *   sin(&plusmn;INFINITY + i) = NaN + NaN i\n *   sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n *  </code>\n * </pre>\n *\n * @return the sine of this complex number.\n * @since 1.2\n */\npublic Complex sin() {\n    if (isNaN) {\n        return NaN;\n    }\n    return createComplex(FastMath.sin(real) * FastMath.cosh(imaginary), FastMath.cos(real) * FastMath.sinh(imaginary));\n}"
            ],
            [
                "isInfinite",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Checks whether either the real or imaginary part of this complex number\n * takes an infinite value (either {@code Double.POSITIVE_INFINITY} or\n * {@code Double.NEGATIVE_INFINITY}) and neither part\n * is {@code NaN}.\n *\n * @return true if one or both parts of this complex number are infinite\n * and neither part is {@code NaN}.\n */\npublic boolean isInfinite() {\n    return isInfinite;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Return the absolute value of this complex number.\n * Returns {@code NaN} if either real or imaginary part is {@code NaN}\n * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},\n * but at least one part is infinite.\n *\n * @return the absolute value.\n */\npublic double abs() {\n    if (isNaN) {\n        return Double.NaN;\n    }\n    if (isInfinite()) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n        if (imaginary == 0.0) {\n            return FastMath.abs(real);\n        }\n        double q = real / imaginary;\n        return FastMath.abs(imaginary) * FastMath.sqrt(1 + q * q);\n    } else {\n        if (real == 0.0) {\n            return FastMath.abs(imaginary);\n        }\n        double q = imaginary / real;\n        return FastMath.abs(real) * FastMath.sqrt(1 + q * q);\n    }\n}"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    },
    {
        "id": 15429,
        "oracle": ";",
        "oracleType": "PRE",
        "projectName": "commons-math3-3.6.1",
        "packageName": "org.apache.commons.math3.optimization.fitting",
        "className": "CurveFitter",
        "javadocTag": "@param x abscissa of the point",
        "methodJavadoc": "    /** Add an observed (x,y) point to the sample with unit weight.\n     * <p>Calling this method is equivalent to call\n     * {@code addObservedPoint(1.0, x, y)}.</p>\n     * @param x abscissa of the point\n     * @param y observed value of the point at x, after fitting we should\n     * have f(x) as close as possible to this value\n     * @see #addObservedPoint(double, double, double)\n     * @see #addObservedPoint(WeightedObservedPoint)\n     * @see #getObservations()\n     */",
        "methodSourceCode": "public void addObservedPoint(double x, double y){\n    addObservedPoint(1.0, x, y);\n}",
        "classJavadoc": "/** Fitter for parametric univariate real functions y = f(x).\n * <br/>\n * When a univariate real function y = f(x) does depend on some\n * unknown parameters p<sub>0</sub>, p<sub>1</sub> ... p<sub>n-1</sub>,\n * this class can be used to find these parameters. It does this\n * by <em>fitting</em> the curve so it remains very close to a set of\n * observed points (x<sub>0</sub>, y<sub>0</sub>), (x<sub>1</sub>,\n * y<sub>1</sub>) ... (x<sub>k-1</sub>, y<sub>k-1</sub>). This fitting\n * is done by finding the parameters values that minimizes the objective\n * function &sum;(y<sub>i</sub>-f(x<sub>i</sub>))<sup>2</sup>. This is\n * really a least squares problem.\n *\n * @param <T> Function to use for the fit.\n *\n * @deprecated As of 3.1 (to be removed in 4.0).\n * @since 2.0\n */",
        "classSourceCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math3.optimization.fitting;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.analysis.DifferentiableMultivariateVectorFunction;\nimport org.apache.commons.math3.analysis.MultivariateMatrixFunction;\nimport org.apache.commons.math3.analysis.ParametricUnivariateFunction;\nimport org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\nimport org.apache.commons.math3.analysis.differentiation.MultivariateDifferentiableVectorFunction;\nimport org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;\nimport org.apache.commons.math3.optimization.MultivariateDifferentiableVectorOptimizer;\nimport org.apache.commons.math3.optimization.PointVectorValuePair;\n\n/** Fitter for parametric univariate real functions y = f(x).\n * <br/>\n * When a univariate real function y = f(x) does depend on some\n * unknown parameters p<sub>0</sub>, p<sub>1</sub> ... p<sub>n-1</sub>,\n * this class can be used to find these parameters. It does this\n * by <em>fitting</em> the curve so it remains very close to a set of\n * observed points (x<sub>0</sub>, y<sub>0</sub>), (x<sub>1</sub>,\n * y<sub>1</sub>) ... (x<sub>k-1</sub>, y<sub>k-1</sub>). This fitting\n * is done by finding the parameters values that minimizes the objective\n * function &sum;(y<sub>i</sub>-f(x<sub>i</sub>))<sup>2</sup>. This is\n * really a least squares problem.\n *\n * @param <T> Function to use for the fit.\n *\n * @deprecated As of 3.1 (to be removed in 4.0).\n * @since 2.0\n */\n@Deprecated\npublic class CurveFitter<T extends ParametricUnivariateFunction> {\n\n    /** Optimizer to use for the fitting.\n     * @deprecated as of 3.1 replaced by {@link #optimizer}\n     */\n    @Deprecated\n    private final DifferentiableMultivariateVectorOptimizer oldOptimizer;\n\n    /** Optimizer to use for the fitting. */\n    private final MultivariateDifferentiableVectorOptimizer optimizer;\n\n    /** Observed points. */\n    private final List<WeightedObservedPoint> observations;\n\n    /** Simple constructor.\n     * @param optimizer optimizer to use for the fitting\n     * @deprecated as of 3.1 replaced by {@link #CurveFitter(MultivariateDifferentiableVectorOptimizer)}\n     */\n    @Deprecated\n    public CurveFitter(final DifferentiableMultivariateVectorOptimizer optimizer) {\n        this.oldOptimizer = optimizer;\n        this.optimizer    = null;\n        observations      = new ArrayList<WeightedObservedPoint>();\n    }\n\n    /** Simple constructor.\n     * @param optimizer optimizer to use for the fitting\n     * @since 3.1\n     */\n    public CurveFitter(final MultivariateDifferentiableVectorOptimizer optimizer) {\n        this.oldOptimizer = null;\n        this.optimizer    = optimizer;\n        observations      = new ArrayList<WeightedObservedPoint>();\n    }\n\n    /** Add an observed (x,y) point to the sample with unit weight.\n     * <p>Calling this method is equivalent to call\n     * {@code addObservedPoint(1.0, x, y)}.</p>\n     * @param x abscissa of the point\n     * @param y observed value of the point at x, after fitting we should\n     * have f(x) as close as possible to this value\n     * @see #addObservedPoint(double, double, double)\n     * @see #addObservedPoint(WeightedObservedPoint)\n     * @see #getObservations()\n     */\n    public void addObservedPoint(double x, double y) {\n        addObservedPoint(1.0, x, y);\n    }\n\n    /** Add an observed weighted (x,y) point to the sample.\n     * @param weight weight of the observed point in the fit\n     * @param x abscissa of the point\n     * @param y observed value of the point at x, after fitting we should\n     * have f(x) as close as possible to this value\n     * @see #addObservedPoint(double, double)\n     * @see #addObservedPoint(WeightedObservedPoint)\n     * @see #getObservations()\n     */\n    public void addObservedPoint(double weight, double x, double y) {\n        observations.add(new WeightedObservedPoint(weight, x, y));\n    }\n\n    /** Add an observed weighted (x,y) point to the sample.\n     * @param observed observed point to add\n     * @see #addObservedPoint(double, double)\n     * @see #addObservedPoint(double, double, double)\n     * @see #getObservations()\n     */\n    public void addObservedPoint(WeightedObservedPoint observed) {\n        observations.add(observed);\n    }\n\n    /** Get the observed points.\n     * @return observed points\n     * @see #addObservedPoint(double, double)\n     * @see #addObservedPoint(double, double, double)\n     * @see #addObservedPoint(WeightedObservedPoint)\n     */\n    public WeightedObservedPoint[] getObservations() {\n        return observations.toArray(new WeightedObservedPoint[observations.size()]);\n    }\n\n    /**\n     * Remove all observations.\n     */\n    public void clearObservations() {\n        observations.clear();\n    }\n\n    /**\n     * Fit a curve.\n     * This method compute the coefficients of the curve that best\n     * fit the sample of observed points previously given through calls\n     * to the {@link #addObservedPoint(WeightedObservedPoint)\n     * addObservedPoint} method.\n     *\n     * @param f parametric function to fit.\n     * @param initialGuess first guess of the function parameters.\n     * @return the fitted parameters.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the start point dimension is wrong.\n     */\n    public double[] fit(T f, final double[] initialGuess) {\n        return fit(Integer.MAX_VALUE, f, initialGuess);\n    }\n\n    /**\n     * Fit a curve.\n     * This method compute the coefficients of the curve that best\n     * fit the sample of observed points previously given through calls\n     * to the {@link #addObservedPoint(WeightedObservedPoint)\n     * addObservedPoint} method.\n     *\n     * @param f parametric function to fit.\n     * @param initialGuess first guess of the function parameters.\n     * @param maxEval Maximum number of function evaluations.\n     * @return the fitted parameters.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the number of allowed evaluations is exceeded.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the start point dimension is wrong.\n     * @since 3.0\n     */\n    public double[] fit(int maxEval, T f,\n                        final double[] initialGuess) {\n        // prepare least squares problem\n        double[] target  = new double[observations.size()];\n        double[] weights = new double[observations.size()];\n        int i = 0;\n        for (WeightedObservedPoint point : observations) {\n            target[i]  = point.getY();\n            weights[i] = point.getWeight();\n            ++i;\n        }\n\n        // perform the fit\n        final PointVectorValuePair optimum;\n        if (optimizer == null) {\n            // to be removed in 4.0\n            optimum = oldOptimizer.optimize(maxEval, new OldTheoreticalValuesFunction(f),\n                                            target, weights, initialGuess);\n        } else {\n            optimum = optimizer.optimize(maxEval, new TheoreticalValuesFunction(f),\n                                         target, weights, initialGuess);\n        }\n\n        // extract the coefficients\n        return optimum.getPointRef();\n    }\n\n    /** Vectorial function computing function theoretical values. */\n    @Deprecated\n    private class OldTheoreticalValuesFunction\n        implements DifferentiableMultivariateVectorFunction {\n        /** Function to fit. */\n        private final ParametricUnivariateFunction f;\n\n        /** Simple constructor.\n         * @param f function to fit.\n         */\n        OldTheoreticalValuesFunction(final ParametricUnivariateFunction f) {\n            this.f = f;\n        }\n\n        /** {@inheritDoc} */\n        public MultivariateMatrixFunction jacobian() {\n            return new MultivariateMatrixFunction() {\n                /** {@inheritDoc} */\n                public double[][] value(double[] point) {\n                    final double[][] jacobian = new double[observations.size()][];\n\n                    int i = 0;\n                    for (WeightedObservedPoint observed : observations) {\n                        jacobian[i++] = f.gradient(observed.getX(), point);\n                    }\n\n                    return jacobian;\n                }\n            };\n        }\n\n        /** {@inheritDoc} */\n        public double[] value(double[] point) {\n            // compute the residuals\n            final double[] values = new double[observations.size()];\n            int i = 0;\n            for (WeightedObservedPoint observed : observations) {\n                values[i++] = f.value(observed.getX(), point);\n            }\n\n            return values;\n        }\n    }\n\n    /** Vectorial function computing function theoretical values. */\n    private class TheoreticalValuesFunction implements MultivariateDifferentiableVectorFunction {\n\n        /** Function to fit. */\n        private final ParametricUnivariateFunction f;\n\n        /** Simple constructor.\n         * @param f function to fit.\n         */\n        TheoreticalValuesFunction(final ParametricUnivariateFunction f) {\n            this.f = f;\n        }\n\n        /** {@inheritDoc} */\n        public double[] value(double[] point) {\n            // compute the residuals\n            final double[] values = new double[observations.size()];\n            int i = 0;\n            for (WeightedObservedPoint observed : observations) {\n                values[i++] = f.value(observed.getX(), point);\n            }\n\n            return values;\n        }\n\n        /** {@inheritDoc} */\n        public DerivativeStructure[] value(DerivativeStructure[] point) {\n\n            // extract parameters\n            final double[] parameters = new double[point.length];\n            for (int k = 0; k < point.length; ++k) {\n                parameters[k] = point[k].getValue();\n            }\n\n            // compute the residuals\n            final DerivativeStructure[] values = new DerivativeStructure[observations.size()];\n            int i = 0;\n            for (WeightedObservedPoint observed : observations) {\n\n                // build the DerivativeStructure by adding first the value as a constant\n                // and then adding derivatives\n                DerivativeStructure vi = new DerivativeStructure(point.length, 1, f.value(observed.getX(), parameters));\n                for (int k = 0; k < point.length; ++k) {\n                    vi = vi.add(new DerivativeStructure(point.length, 1, k, 0.0));\n                }\n\n                values[i++] = vi;\n\n            }\n\n            return values;\n        }\n\n    }\n\n}\n",
        "tokensGeneralGrammar": [
            "null",
            "true",
            "false",
            ",",
            ".",
            ":",
            ";",
            "?",
            "(",
            ")",
            "jdVar",
            "stream",
            "Arrays",
            "allMatch",
            "noneMatch",
            "anyMatch",
            "~",
            ">>",
            "<<",
            ">>>",
            "|",
            "&",
            "^",
            "+",
            "-",
            "/",
            "*",
            "%",
            "&&",
            "||",
            ">=",
            "<=",
            ">",
            "<",
            "==",
            "!=",
            "instanceof",
            "class",
            "methodResultID",
            "this"
        ],
        "tokensGeneralValuesGlobalDictionary": [
            [
                "0",
                "int"
            ],
            [
                "1",
                "int"
            ],
            [
                "-1",
                "int"
            ],
            [
                "0.0",
                "double"
            ],
            [
                "1.0",
                "double"
            ],
            [
                "-1.0",
                "double"
            ],
            [
                "\"\"",
                "String"
            ],
            [
                "\" \"",
                "String"
            ]
        ],
        "tokensProjectClasses": [
            [
                "RealFieldElement",
                "org.apache.commons.math3"
            ],
            [
                "Primes",
                "org.apache.commons.math3.primes"
            ],
            [
                "SmallPrimes",
                "org.apache.commons.math3.primes"
            ],
            [
                "PollardRho",
                "org.apache.commons.math3.primes"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "SimpleCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.fitting"
            ],
            [
                "ParameterValidator",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "EvaluationRmsChecker",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "OptimumImpl",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresAdapter",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "DenseWeightedEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "AbstractEvaluation",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresFactory",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "ValueAndJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "MultivariateJacobianFunction",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresBuilder",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "LeastSquaresProblem",
                "org.apache.commons.math3.fitting.leastsquares"
            ],
            [
                "WeightedObservedPoints",
                "org.apache.commons.math3.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "AbstractCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "HarmonicCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "PolynomialCurveFitter",
                "org.apache.commons.math3.fitting"
            ],
            [
                "UnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "FunctionUtils",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "IterativeLegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "LegendreGaussIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "MidPointIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "RombergIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "SimpsonIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BaseRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "HermiteRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegratorFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "LegendreHighPrecisionRuleFactory",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "SymmetricGaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "GaussIntegrator",
                "org.apache.commons.math3.analysis.integration.gauss"
            ],
            [
                "BaseAbstractUnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "UnivariateIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "TrapezoidIntegrator",
                "org.apache.commons.math3.analysis.integration"
            ],
            [
                "BivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableUnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "AbstractDifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PegasusSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolverUtils",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "FieldBracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonRaphsonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseSecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "SecantSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "DifferentiableUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateDifferentiableSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver2",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractPolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "MullerSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BaseAbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "LaguerreSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "IllinoisSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "PolynomialSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RegulaFalsiSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AllowedSolution",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "NewtonSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "RiddersSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BisectionSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "AbstractUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "UnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketingNthOrderBrentSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "BracketedRealFieldUnivariateSolver",
                "org.apache.commons.math3.analysis.solvers"
            ],
            [
                "Asin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Multiply",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Asinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Rint",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "StepFunction",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Add",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sqrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Inverse",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Gaussian",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Pow",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Exp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Cbrt",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log1p",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Constant",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Identity",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Signum",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logit",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ceil",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Subtract",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Max",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acosh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Min",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Expm1",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Abs",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Divide",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Ulp",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Log10",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Power",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Minus",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atan2",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Logistic",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Acos",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Floor",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sigmoid",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sinc",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Atanh",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "HarmonicOscillator",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Tan",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "Sin",
                "org.apache.commons.math3.analysis.function"
            ],
            [
                "MultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TrivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "MultivariateMatrixFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "ParametricUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "UnivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableMatrixFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DSCompiler",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "SparseGradient",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateMatrixFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "JacobianFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "GradientFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "DerivativeStructure",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateVectorFunctionDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "FiniteDifferencesDifferentiator",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "UnivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis.differentiation"
            ],
            [
                "MultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "DifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "PolynomialFunctionNewtonForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunctionLagrangeForm",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialSplineFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialsUtils",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "PolynomialFunction",
                "org.apache.commons.math3.analysis.polynomials"
            ],
            [
                "RealFieldUnivariateFunction",
                "org.apache.commons.math3.analysis"
            ],
            [
                "TricubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LoessInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "DividedDifferenceInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "HermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TrivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "NevilleInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereProjectionInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "AkimaSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MultivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "FieldHermiteInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "LinearInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BivariateGridInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariatePeriodicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "UnivariateInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SmoothingPolynomialBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "BicubicFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "SplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "TricubicSplineInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "InterpolatingMicrosphere2D",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "PiecewiseBicubicSplineInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolatingFunction",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "MicrosphereInterpolator",
                "org.apache.commons.math3.analysis.interpolation"
            ],
            [
                "Precision",
                "org.apache.commons.math3.util"
            ],
            [
                "MultidimensionalCounter",
                "org.apache.commons.math3.util"
            ],
            [
                "DoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "Incrementor",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToDoubleHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "OpenIntToFieldHashMap",
                "org.apache.commons.math3.util"
            ],
            [
                "MathArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "Pair",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathCalc",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMath",
                "org.apache.commons.math3.util"
            ],
            [
                "ResizableDoubleArray",
                "org.apache.commons.math3.util"
            ],
            [
                "BigRealField",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64Field",
                "org.apache.commons.math3.util"
            ],
            [
                "Combinations",
                "org.apache.commons.math3.util"
            ],
            [
                "MathUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "NumberTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "ContinuedFraction",
                "org.apache.commons.math3.util"
            ],
            [
                "RandomPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationManager",
                "org.apache.commons.math3.util"
            ],
            [
                "CompositeFormat",
                "org.apache.commons.math3.util"
            ],
            [
                "KthSelector",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationEvent",
                "org.apache.commons.math3.util"
            ],
            [
                "TransformerMap",
                "org.apache.commons.math3.util"
            ],
            [
                "IntegerSequence",
                "org.apache.commons.math3.util"
            ],
            [
                "FastMathLiteralArrays",
                "org.apache.commons.math3.util"
            ],
            [
                "CombinatoricsUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "IterationListener",
                "org.apache.commons.math3.util"
            ],
            [
                "PivotingStrategyInterface",
                "org.apache.commons.math3.util"
            ],
            [
                "CentralPivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "Decimal64",
                "org.apache.commons.math3.util"
            ],
            [
                "DefaultTransformer",
                "org.apache.commons.math3.util"
            ],
            [
                "BigReal",
                "org.apache.commons.math3.util"
            ],
            [
                "ArithmeticUtils",
                "org.apache.commons.math3.util"
            ],
            [
                "MedianOf3PivotingStrategy",
                "org.apache.commons.math3.util"
            ],
            [
                "ComplexFormat",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexField",
                "org.apache.commons.math3.complex"
            ],
            [
                "RootsOfUnity",
                "org.apache.commons.math3.complex"
            ],
            [
                "Quaternion",
                "org.apache.commons.math3.complex"
            ],
            [
                "Complex",
                "org.apache.commons.math3.complex"
            ],
            [
                "ComplexUtils",
                "org.apache.commons.math3.complex"
            ],
            [
                "DifferentiableMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "CurveFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "PolynomialFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "HarmonicFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "WeightedObservedPoint",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "GaussianFitter",
                "org.apache.commons.math3.optimization.fitting"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateSimpleBoundsOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "BaseAbstractMultivariateOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optimization.direct"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "AbstractScalarDifferentiableOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "ConjugateGradientFormula",
                "org.apache.commons.math3.optimization.general"
            ],
            [
                "BaseMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "AbstractLinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optimization.linear"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optimization"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseAbstractUnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optimization.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Target",
                "org.apache.commons.math3.optimization"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optimization"
            ],
            [
                "BaseMultivariateVectorOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "MultivariateDifferentiableMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "DifferentiableMultivariateVectorMultiStartOptimizer",
                "org.apache.commons.math3.optimization"
            ],
            [
                "NonSymmetricMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "AnyMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularValueDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "EigenDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldLUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixUtils",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "TriDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "Array2DRowFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "MatrixDimensionMismatchException",
                "org.apache.commons.math3.linear"
            ],
            [
                "ArrayFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "DecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "LUDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "ConjugateGradient",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonPositiveDefiniteOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "OpenMapRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSelfAdjointOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BiDiagonalTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "CholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldDecompositionSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SingularOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "BlockRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "NonSquareMatrixException",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "PreconditionedIterativeLinearSolver",
                "org.apache.commons.math3.linear"
            ],
            [
                "QRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "SymmLQ",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseFieldVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorFormat",
                "org.apache.commons.math3.linear"
            ],
            [
                "IllConditionedOperatorException",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultIterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultRealMatrixPreservingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "IterativeLinearSolverEvent",
                "org.apache.commons.math3.linear"
            ],
            [
                "DiagonalMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "HessenbergTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RectangularCholeskyDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "FieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "DefaultFieldMatrixChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "JacobiPreconditioner",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealLinearOperator",
                "org.apache.commons.math3.linear"
            ],
            [
                "RRQRDecomposition",
                "org.apache.commons.math3.linear"
            ],
            [
                "AbstractFieldMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealMatrix",
                "org.apache.commons.math3.linear"
            ],
            [
                "SchurTransformer",
                "org.apache.commons.math3.linear"
            ],
            [
                "RealVectorChangingVisitor",
                "org.apache.commons.math3.linear"
            ],
            [
                "SparseRealVector",
                "org.apache.commons.math3.linear"
            ],
            [
                "CauchyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LaplaceDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "HypergeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ChiSquaredDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "TriangularDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalMixtureExpectationMaximization",
                "org.apache.commons.math3.distribution.fitting"
            ],
            [
                "BetaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "RealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "SaddlePointExpansion",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GumbelDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ZipfDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "BinomialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "IntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "WeibullDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "NakagamiDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ConstantRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MultivariateNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ExponentialDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "UniformIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogNormalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PascalDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "ParetoDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "FDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GeometricDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "AbstractIntegerDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PoissonDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "KolmogorovSmirnovDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "MixtureMultivariateRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "GammaDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "EnumeratedRealDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LogisticDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "LevyDistribution",
                "org.apache.commons.math3.distribution"
            ],
            [
                "PointValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "AbstractConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "InitialGuess",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxIter",
                "org.apache.commons.math3.optim"
            ],
            [
                "NoFeasibleSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraintSet",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "PivotSelectionRule",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexSolver",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearOptimizer",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "UnboundedSolutionException",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SimplexTableau",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "SolutionCallback",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "LinearObjectiveFunction",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "NonNegativeConstraint",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "Relationship",
                "org.apache.commons.math3.optim.linear"
            ],
            [
                "AbstractOptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleBounds",
                "org.apache.commons.math3.optim"
            ],
            [
                "PointVectorValuePair",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimplePointChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "SimpleVectorValueChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "BaseMultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "MultiStartUnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BrentOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateObjectiveFunction",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SimpleUnivariateValueChecker",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "SearchInterval",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariatePointValuePair",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BracketFinder",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "UnivariateOptimizer",
                "org.apache.commons.math3.optim.univariate"
            ],
            [
                "BaseMultivariateOptimizer",
                "org.apache.commons.math3.optim"
            ],
            [
                "ConvergenceChecker",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationProblem",
                "org.apache.commons.math3.optim"
            ],
            [
                "MaxEval",
                "org.apache.commons.math3.optim"
            ],
            [
                "OptimizationData",
                "org.apache.commons.math3.optim"
            ],
            [
                "Preconditioner",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "NonLinearConjugateGradientOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.gradient"
            ],
            [
                "LeastSquaresConverter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GradientMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionMappingAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "LineSearch",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunction",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "GoalType",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "AbstractSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "SimplexOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "BOBYQAOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "NelderMeadSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "CMAESOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "PowellOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiDirectionalSimplex",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv"
            ],
            [
                "MultiStartMultivariateOptimizer",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "MultivariateFunctionPenaltyAdapter",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ObjectiveFunctionGradient",
                "org.apache.commons.math3.optim.nonlinear.scalar"
            ],
            [
                "ModelFunction",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "LevenbergMarquardtOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "AbstractLeastSquaresOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "GaussNewtonOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector.jacobian"
            ],
            [
                "ModelFunctionJacobian",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "JacobianMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Target",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Weight",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "MultiStartMultivariateVectorOptimizer",
                "org.apache.commons.math3.optim.nonlinear.vector"
            ],
            [
                "Erf",
                "org.apache.commons.math3.special"
            ],
            [
                "BesselJ",
                "org.apache.commons.math3.special"
            ],
            [
                "Gamma",
                "org.apache.commons.math3.special"
            ],
            [
                "Beta",
                "org.apache.commons.math3.special"
            ],
            [
                "FieldODEState",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldODEStateAndDerivative",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ODEIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterConfiguration",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputFieldModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderConverter",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ExpandableStatefulODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "MultistepIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "Parameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "JacobianMatrices",
                "org.apache.commons.math3.ode"
            ],
            [
                "StepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "DummyStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractFieldStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldFixedStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerMode",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "AbstractStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepHandler",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "StepNormalizerBounds",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "NordsieckStepInterpolator",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "FieldStepNormalizer",
                "org.apache.commons.math3.ode.sampling"
            ],
            [
                "RungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EmbeddedRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54FieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "MidpointIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince54Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GraggBulirschStoerStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853FieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldButcherArrayProvider",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "DormandPrince853Integrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "EulerFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsMoultonFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "LutherStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "HighamHall54StepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsNordsieckFieldTransformer",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ThreeEighthesFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "RungeKuttaIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "ClassicalRungeKuttaFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdaptiveStepsizeFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "AdamsBashforthIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldIntegrator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "GillFieldStepInterpolator",
                "org.apache.commons.math3.ode.nonstiff"
            ],
            [
                "FieldSecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "MainStateJacobianProvider",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondaryEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderFieldIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterJacobianWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldEquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "FieldExpandableODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "ParameterizedWrapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "SecondOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "AbstractParameterizable",
                "org.apache.commons.math3.ode"
            ],
            [
                "UnknownParameterException",
                "org.apache.commons.math3.ode"
            ],
            [
                "ContinuousOutputModel",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderDifferentialEquations",
                "org.apache.commons.math3.ode"
            ],
            [
                "EquationsMapper",
                "org.apache.commons.math3.ode"
            ],
            [
                "Transformer",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FieldEventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventHandler",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "Action",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventState",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "EventFilter",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "FilterType",
                "org.apache.commons.math3.ode.events"
            ],
            [
                "ParameterizedODE",
                "org.apache.commons.math3.ode"
            ],
            [
                "FirstOrderIntegrator",
                "org.apache.commons.math3.ode"
            ],
            [
                "NaNStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "NaturalRanking",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "TiesStrategy",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "RankingAlgorithm",
                "org.apache.commons.math3.stat.ranking"
            ],
            [
                "StatUtils",
                "org.apache.commons.math3.stat"
            ],
            [
                "IntervalUtils",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "AgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "WilsonScoreInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "ClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "NormalApproximationInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "BinomialConfidenceInterval",
                "org.apache.commons.math3.stat.interval"
            ],
            [
                "StorelessCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "StorelessBivariateCovariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "KendallsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "Covariance",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "PearsonsCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "SpearmansCorrelation",
                "org.apache.commons.math3.stat.correlation"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanIntegerPoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "EuclideanDoublePoint",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.stat.clustering"
            ],
            [
                "TestUtils",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "TTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "GTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AlternativeHypothesis",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "MannWhitneyUTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "WilcoxonSignedRankTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "OneWayAnova",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "ChiSquareTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "BinomialTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "KolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference"
            ],
            [
                "AbstractUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "DescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "MultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SecondMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Mean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FourthMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Variance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Kurtosis",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "GeometricMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StandardDeviation",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialCovariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "ThirdMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "SemiVariance",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "FirstMoment",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "Skewness",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "VectorialMean",
                "org.apache.commons.math3.stat.descriptive.moment"
            ],
            [
                "StatisticalSummaryValues",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "StatisticalMultivariateSummary",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "AggregateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "WeightedEvaluation",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "UnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "Percentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Max",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "PSquarePercentile",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Min",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "Median",
                "org.apache.commons.math3.stat.descriptive.rank"
            ],
            [
                "SynchronizedDescriptiveStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SynchronizedMultivariateSummaryStatistics",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SumOfSquares",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Product",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "Sum",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "SumOfLogs",
                "org.apache.commons.math3.stat.descriptive.summary"
            ],
            [
                "AbstractStorelessUnivariateStatistic",
                "org.apache.commons.math3.stat.descriptive"
            ],
            [
                "SimpleRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "UpdatingMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "AbstractMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "GLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "ModelSpecificationException",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "RegressionResults",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MillerUpdatingRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "OLSMultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "MultipleLinearRegression",
                "org.apache.commons.math3.stat.regression"
            ],
            [
                "Frequency",
                "org.apache.commons.math3.stat"
            ],
            [
                "ChebyshevDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CanberraDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EuclideanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "ManhattanDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "EarthMoversDistance",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "DistanceMeasure",
                "org.apache.commons.math3.ml.distance"
            ],
            [
                "CentroidCluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DBSCANClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Cluster",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "MultiKMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "Clusterable",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "FuzzyKMeansClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KMeansPlusPlusClusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "SumOfClusterVariances",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "ClusterEvaluator",
                "org.apache.commons.math3.ml.clustering.evaluation"
            ],
            [
                "Clusterer",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "DoublePoint",
                "org.apache.commons.math3.ml.clustering"
            ],
            [
                "KohonenTrainingTask",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "KohonenUpdateAction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "QuasiSigmoidDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "ExponentialDecayFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm.util"
            ],
            [
                "NeighbourhoodSizeFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunctionFactory",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "NeighbourhoodSizeFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "LearningFactorFunction",
                "org.apache.commons.math3.ml.neuralnet.sofm"
            ],
            [
                "MapUtils",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Network",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializerFactory",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "Neuron",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "FeatureInitializer",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "NeuronString",
                "org.apache.commons.math3.ml.neuralnet.oned"
            ],
            [
                "NeuronSquareMesh2D",
                "org.apache.commons.math3.ml.neuralnet.twod"
            ],
            [
                "SmoothedDataHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "UnifiedDistanceMatrix",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapDataVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "MapVisualization",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "LocationFinder",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "HitHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "QuantizationError",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "TopographicErrorHistogram",
                "org.apache.commons.math3.ml.neuralnet.twod.util"
            ],
            [
                "SquareNeighbourhood",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "UpdateAction",
                "org.apache.commons.math3.ml.neuralnet"
            ],
            [
                "BracketingNthOrderBrentSolverDFP",
                "org.apache.commons.math3.dfp"
            ],
            [
                "UnivariateDfpFunction",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpDec",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpMath",
                "org.apache.commons.math3.dfp"
            ],
            [
                "Dfp",
                "org.apache.commons.math3.dfp"
            ],
            [
                "DfpField",
                "org.apache.commons.math3.dfp"
            ],
            [
                "GeneticAlgorithm",
                "org.apache.commons.math3.genetics"
            ],
            [
                "SelectionPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedGenerationCount",
                "org.apache.commons.math3.genetics"
            ],
            [
                "AbstractListChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OnePointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ElitisticListPopulation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Chromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "OrderedCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "InvalidRepresentationException",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKey",
                "org.apache.commons.math3.genetics"
            ],
            [
                "StoppingCondition",
                "org.apache.commons.math3.genetics"
            ],
            [
                "PermutationChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "ChromosomePair",
                "org.apache.commons.math3.genetics"
            ],
            [
                "TournamentSelection",
                "org.apache.commons.math3.genetics"
            ],
            [
                "NPointCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "UniformCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "MutationPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "FixedElapsedTime",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CycleCrossover",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "BinaryChromosome",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Population",
                "org.apache.commons.math3.genetics"
            ],
            [
                "RandomKeyMutation",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Fitness",
                "org.apache.commons.math3.genetics"
            ],
            [
                "CrossoverPolicy",
                "org.apache.commons.math3.genetics"
            ],
            [
                "Vector",
                "org.apache.commons.math3.geometry"
            ],
            [
                "VectorFormat",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Point",
                "org.apache.commons.math3.geometry"
            ],
            [
                "RotationConvention",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubPlane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3DFormat",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "OutlineExtractor",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "PolyhedronsSet",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "RotationOrder",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldVector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Rotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Euclidean3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphericalCoordinates",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "CardanEulerSingularityException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "NotARotationMatrixException",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "FieldRotation",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Vector3D",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Plane",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "SphereGenerator",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.threed"
            ],
            [
                "IntervalsSet",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Interval",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "SubOrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "OrientedPoint",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Euclidean1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1DFormat",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Vector1D",
                "org.apache.commons.math3.geometry.euclidean.oned"
            ],
            [
                "Segment",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "AbstractConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "AklToussaintHeuristic",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHull2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "MonotoneChain",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "ConvexHullGenerator2D",
                "org.apache.commons.math3.geometry.euclidean.twod.hull"
            ],
            [
                "Vector2DFormat",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "PolygonsSet",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "SubLine",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "DiskGenerator",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Vector2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "NestedLoops",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Euclidean2D",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "Line",
                "org.apache.commons.math3.geometry.euclidean.twod"
            ],
            [
                "ConvexHullGenerator",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ConvexHull",
                "org.apache.commons.math3.geometry.hull"
            ],
            [
                "ArcsSet",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "S1Point",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere1D",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Arc",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "LimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "SubLimitAngle",
                "org.apache.commons.math3.geometry.spherical.oned"
            ],
            [
                "Sphere2D",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SubCircle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Vertex",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Circle",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "PropertiesComputer",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SphericalPolygonsSet",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "Edge",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "EdgesBuilder",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "S2Point",
                "org.apache.commons.math3.geometry.spherical.twod"
            ],
            [
                "SupportBallGenerator",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "EnclosingBall",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "WelzlEncloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "Encloser",
                "org.apache.commons.math3.geometry.enclosing"
            ],
            [
                "InsideFinder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjection",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryProjector",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Region",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Transform",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "NodesSet",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractRegion",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Characterization",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AbstractSubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BSPTree",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "RegionFactory",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Side",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundarySizeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "AVLTree",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "OrderedTuple",
                "org.apache.commons.math3.geometry.partitioning.utilities"
            ],
            [
                "BSPTreeVisitor",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Hyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Embedding",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryAttribute",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "SubHyperplane",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "BoundaryBuilder",
                "org.apache.commons.math3.geometry.partitioning"
            ],
            [
                "Space",
                "org.apache.commons.math3.geometry"
            ],
            [
                "Field",
                "org.apache.commons.math3"
            ],
            [
                "ProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "MeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "KalmanFilter",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultProcessModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "DefaultMeasurementModel",
                "org.apache.commons.math3.filter"
            ],
            [
                "NormalizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "GaussianRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "ISAACRandom",
                "org.apache.commons.math3.random"
            ],
            [
                "CorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937a",
                "org.apache.commons.math3.random"
            ],
            [
                "Well1024a",
                "org.apache.commons.math3.random"
            ],
            [
                "UniformRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497a",
                "org.apache.commons.math3.random"
            ],
            [
                "BitsStreamGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "SynchronizedRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "UncorrelatedRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well19937c",
                "org.apache.commons.math3.random"
            ],
            [
                "ValueServer",
                "org.apache.commons.math3.random"
            ],
            [
                "HaltonSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well44497b",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomData",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "Well512a",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "JDKRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "StableRandomGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomAdaptor",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomGeneratorFactory",
                "org.apache.commons.math3.random"
            ],
            [
                "AbstractWell",
                "org.apache.commons.math3.random"
            ],
            [
                "RandomDataImpl",
                "org.apache.commons.math3.random"
            ],
            [
                "EmpiricalDistribution",
                "org.apache.commons.math3.random"
            ],
            [
                "SobolSequenceGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "MersenneTwister",
                "org.apache.commons.math3.random"
            ],
            [
                "UnitSphereRandomVectorGenerator",
                "org.apache.commons.math3.random"
            ],
            [
                "FieldElement",
                "org.apache.commons.math3"
            ],
            [
                "BigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "Fraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFraction",
                "org.apache.commons.math3.fraction"
            ],
            [
                "AbstractFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "BigFractionField",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "FractionConversionException",
                "org.apache.commons.math3.fraction"
            ],
            [
                "ProperBigFractionFormat",
                "org.apache.commons.math3.fraction"
            ],
            [
                "NotFiniteNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoBracketingException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathArithmeticException",
                "org.apache.commons.math3.exception"
            ],
            [
                "InsufficientDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyEvaluationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ExceptionContextProvider",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ExceptionContext",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "ArgUtils",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "DummyLocalizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "Localizable",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "LocalizedFormats",
                "org.apache.commons.math3.exception.util"
            ],
            [
                "NotANumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MultiDimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "OutOfRangeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "TooManyIterationsException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NullArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooLargeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalStateException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathUnsupportedOperationException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotStrictlyPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NonMonotonicSequenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ZeroException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalArgumentException",
                "org.apache.commons.math3.exception"
            ],
            [
                "DimensionMismatchException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathRuntimeException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathParseException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NoDataException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathIllegalNumberException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NotPositiveException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MaxCountExceededException",
                "org.apache.commons.math3.exception"
            ],
            [
                "NumberIsTooSmallException",
                "org.apache.commons.math3.exception"
            ],
            [
                "ConvergenceException",
                "org.apache.commons.math3.exception"
            ],
            [
                "MathInternalError",
                "org.apache.commons.math3.exception"
            ],
            [
                "DftNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "RealTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastSineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "DctNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastFourierTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformType",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastCosineTransformer",
                "org.apache.commons.math3.transform"
            ],
            [
                "TransformUtils",
                "org.apache.commons.math3.transform"
            ],
            [
                "DstNormalization",
                "org.apache.commons.math3.transform"
            ],
            [
                "FastHadamardTransformer",
                "org.apache.commons.math3.transform"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticNonVoidMethods": [
            [
                "isPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Primality test: tells if the argument is a (provable) prime or not.\n * <p>\n * It uses the Miller-Rabin probabilistic test in such a way that a result is guaranteed:\n * it uses the firsts prime numbers as successive base (see Handbook of applied cryptography\n * by Menezes, table 4.1).\n *\n * @param n number to test.\n * @return true if n is prime. (All numbers &lt; 2 return false).\n */\npublic static boolean isPrime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int p : SmallPrimes.PRIMES) {\n        if (0 == (n % p)) {\n            return n == p;\n        }\n    }\n    return SmallPrimes.millerRabinPrimeTest(n);\n}"
            ],
            [
                "nextPrime",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Return the smallest prime greater than or equal to n.\n *\n * @param n a positive number.\n * @return the smallest prime greater than or equal to n.\n * @throws MathIllegalArgumentException if n &lt; 0.\n */\npublic static int nextPrime(int n) {\n    if (n < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL, n, 0);\n    }\n    if (n == 2) {\n        return 2;\n    }\n    //make sure n is odd\n    n |= 1;\n    if (n == 1) {\n        return 2;\n    }\n    if (isPrime(n)) {\n        return n;\n    }\n    // prepare entry in the +2, +4 loop:\n    // n should not be a multiple of 3\n    final int rem = n % 3;\n    if (0 == rem) {\n        // if n % 3 == 0\n        // n % 3 == 2\n        n += 2;\n    } else if (1 == rem) {\n        // if n % 3 == 1\n        // if (isPrime(n)) return n;\n        // n % 3 == 2\n        n += 4;\n    }\n    while (true) {\n        // this loop skips all multiple of 3\n        if (isPrime(n)) {\n            return n;\n        }\n        // n % 3 == 1\n        n += 2;\n        if (isPrime(n)) {\n            return n;\n        }\n        // n % 3 == 2\n        n += 4;\n    }\n}"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "Primes",
                "/**\n * Prime factors decomposition\n *\n * @param n number to factorize: must be &ge; 2\n * @return list of prime factors of n\n * @throws MathIllegalArgumentException if n &lt; 2.\n */\npublic static List<Integer> primeFactors(int n) {\n    if (n < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_TOO_SMALL, n, 2);\n    }\n    // slower than trial div unless we do an awful lot of computation\n    // (then it finally gets JIT-compiled efficiently\n    // List<Integer> out = PollardRho.primeFactors(n);\n    return SmallPrimes.trialDivision(n);\n}"
            ],
            [
                "smallTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Extract small factors.\n * @param n the number to factor, must be &gt; 0.\n * @param factors the list where to add the factors.\n * @return the part of n which remains to be factored, it is either a prime or a semi-prime\n */\npublic static int smallTrialDivision(int n, final List<Integer> factors) {\n    for (int p : PRIMES) {\n        while (0 == n % p) {\n            n /= p;\n            factors.add(p);\n        }\n    }\n    return n;\n}"
            ],
            [
                "boundedTrialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Extract factors in the range <code>PRIME_LAST+2</code> to <code>maxFactors</code>.\n * @param n the number to factorize, must be >= PRIME_LAST+2 and must not contain any factor below PRIME_LAST+2\n * @param maxFactor the upper bound of trial division: if it is reached, the method gives up and returns n.\n * @param factors the list where to add the factors.\n * @return  n or 1 if factorization is completed.\n */\npublic static int boundedTrialDivision(int n, int maxFactor, List<Integer> factors) {\n    int f = PRIMES_LAST + 2;\n    // no check is done about n >= f\n    while (f <= maxFactor) {\n        if (0 == n % f) {\n            n /= f;\n            factors.add(f);\n            break;\n        }\n        f += 4;\n        if (0 == n % f) {\n            n /= f;\n            factors.add(f);\n            break;\n        }\n        f += 2;\n    }\n    if (n != 1) {\n        factors.add(n);\n    }\n    return n;\n}"
            ],
            [
                "trialDivision",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Factorization by trial division.\n * @param n the number to factor\n * @return the list of prime factors of n\n */\npublic static List<Integer> trialDivision(int n) {\n    final List<Integer> factors = new ArrayList<Integer>(32);\n    n = smallTrialDivision(n, factors);\n    if (1 == n) {\n        return factors;\n    }\n    // here we are sure that n is either a prime or a semi prime\n    final int bound = (int) FastMath.sqrt(n);\n    boundedTrialDivision(n, bound, factors);\n    return factors;\n}"
            ],
            [
                "millerRabinPrimeTest",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * Miller-Rabin probabilistic primality test for int type, used in such a way that a result is always guaranteed.\n * <p>\n * It uses the prime numbers as successive base therefore it is guaranteed to be always correct.\n * (see Handbook of applied cryptography by Menezes, table 4.1)\n *\n * @param n number to test: an odd integer &ge; 3\n * @return true if n is prime. false if n is definitely composite.\n */\npublic static boolean millerRabinPrimeTest(final int n) {\n    final int nMinus1 = n - 1;\n    final int s = Integer.numberOfTrailingZeros(nMinus1);\n    final int r = nMinus1 >> s;\n    //r must be odd, it is not checked here\n    int t = 1;\n    if (n >= 2047) {\n        t = 2;\n    }\n    if (n >= 1373653) {\n        t = 3;\n    }\n    if (n >= 25326001) {\n        t = 4;\n    }\n    // works up to 3.2 billion, int range stops at 2.7 so we are safe :-)\n    BigInteger br = BigInteger.valueOf(r);\n    BigInteger bn = BigInteger.valueOf(n);\n    for (int i = 0; i < t; i++) {\n        BigInteger a = BigInteger.valueOf(SmallPrimes.PRIMES[i]);\n        BigInteger bPow = a.modPow(br, bn);\n        int y = bPow.intValue();\n        if ((1 != y) && (y != nMinus1)) {\n            int j = 1;\n            while ((j <= s - 1) && (nMinus1 != y)) {\n                long square = ((long) y) * y;\n                y = (int) (square % n);\n                if (1 == y) {\n                    return false;\n                }\n                // definitely composite\n                j++;\n            }\n            if (nMinus1 != y) {\n                return false;\n            }\n            // definitely composite\n        }\n    }\n    // definitely prime\n    return true;\n}"
            ],
            [
                "primeFactors",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Factorization using Pollard's rho algorithm.\n * @param n number to factors, must be &gt; 0\n * @return the list of prime factors of n.\n */\npublic static List<Integer> primeFactors(int n) {\n    final List<Integer> factors = new ArrayList<Integer>();\n    n = SmallPrimes.smallTrialDivision(n, factors);\n    if (1 == n) {\n        return factors;\n    }\n    if (SmallPrimes.millerRabinPrimeTest(n)) {\n        factors.add(n);\n        return factors;\n    }\n    int divisor = rhoBrent(n);\n    factors.add(divisor);\n    factors.add(n / divisor);\n    return factors;\n}"
            ],
            [
                "rhoBrent",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Implementation of the Pollard's rho factorization algorithm.\n * <p>\n * This implementation follows the paper \"An improved Monte Carlo factorization algorithm\"\n * by Richard P. Brent. This avoids the triple computation of f(x) typically found in Pollard's\n * rho implementations. It also batches several gcd computation into 1.\n * <p>\n * The backtracking is not implemented as we deal only with semi-primes.\n *\n * @param n number to factor, must be semi-prime.\n * @return a prime factor of n.\n */\nstatic int rhoBrent(final int n) {\n    final int x0 = 2;\n    final int m = 25;\n    int cst = SmallPrimes.PRIMES_LAST;\n    int y = x0;\n    int r = 1;\n    do {\n        int x = y;\n        for (int i = 0; i < r; i++) {\n            final long y2 = ((long) y) * y;\n            y = (int) ((y2 + cst) % n);\n        }\n        int k = 0;\n        do {\n            final int bound = FastMath.min(m, r - k);\n            int q = 1;\n            for (int i = -3; i < bound; i++) {\n                //start at -3 to ensure we enter this loop at least 3 times\n                final long y2 = ((long) y) * y;\n                y = (int) ((y2 + cst) % n);\n                final long divisor = FastMath.abs(x - y);\n                if (0 == divisor) {\n                    cst += SmallPrimes.PRIMES_LAST;\n                    k = -m;\n                    y = x0;\n                    r = 1;\n                    break;\n                }\n                final long prod = divisor * q;\n                q = (int) (prod % n);\n                if (0 == q) {\n                    return gcdPositive(FastMath.abs((int) divisor), n);\n                }\n            }\n            final int out = gcdPositive(FastMath.abs(q), n);\n            if (1 != out) {\n                return out;\n            }\n            k += m;\n        } while (k < r);\n        r = 2 * r;\n    } while (true);\n}"
            ],
            [
                "gcdPositive",
                "org.apache.commons.math3.primes",
                "PollardRho",
                "/**\n * Gcd between two positive numbers.\n * <p>\n * Gets the greatest common divisor of two numbers, using the \"binary gcd\" method,\n * which avoids division and modulo operations. See Knuth 4.5.2 algorithm B.\n * This algorithm is due to Josef Stein (1961).\n * </p>\n * Special cases:\n * <ul>\n * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and {@code gcd(x, 0)} is the value of {@code x}.</li>\n * <li>The invocation {@code gcd(0, 0)} is the only one which returns {@code 0}.</li>\n * </ul>\n *\n * @param a first number, must be &ge; 0\n * @param b second number, must be &ge; 0\n * @return gcd(a,b)\n */\nstatic int gcdPositive(int a, int b) {\n    // both a and b must be positive, it is not checked here\n    // gdc(a,0) = a\n    if (a == 0) {\n        return b;\n    } else if (b == 0) {\n        return a;\n    }\n    // make a and b odd, keep in mind the common power of twos\n    final int aTwos = Integer.numberOfTrailingZeros(a);\n    a >>= aTwos;\n    final int bTwos = Integer.numberOfTrailingZeros(b);\n    b >>= bTwos;\n    final int shift = FastMath.min(aTwos, bTwos);\n    // a and b >0\n    // if a > b then gdc(a,b) = gcd(a-b,b)\n    // if a < b then gcd(a,b) = gcd(b-a,a)\n    // so next a is the absolute difference and next b is the minimum of current values\n    while (a != b) {\n        final int delta = a - b;\n        b = FastMath.min(a, b);\n        a = FastMath.abs(delta);\n        // for speed optimization:\n        // remove any power of two in a as b is guaranteed to be odd throughout all iterations\n        a >>= Integer.numberOfTrailingZeros(a);\n    }\n    // gcd(a,a) = a, just \"add\" the common power of twos\n    return a << shift;\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "GaussianCurveFitter",
                "/**\n * Creates a default curve fitter.\n * The initial guess for the parameters will be {@link ParameterGuesser}\n * computed automatically, and the maximum number of iterations of the\n * optimization algorithm is set to {@link Integer#MAX_VALUE}.\n *\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static GaussianCurveFitter create() {\n    return new GaussianCurveFitter(null, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "SimpleCurveFitter",
                "/**\n * Creates a curve fitter.\n * The maximum number of iterations of the optimization algorithm is set\n * to {@link Integer#MAX_VALUE}.\n *\n * @param f Function to fit.\n * @param start Initial guess for the parameters.  Cannot be {@code null}.\n * Its length must be consistent with the number of parameters of the\n * function to fit.\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static SimpleCurveFitter create(ParametricUnivariateFunction f, double[] start) {\n    return new SimpleCurveFitter(f, start, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements. There will be no weights applied (unit weights).\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @param lazyEvaluation Whether the call to {@link Evaluation#evaluate(RealVector)}\n * will defer the evaluation until access to the value is requested.\n * @param paramValidator Model parameters validator.\n * @return the specified General Least Squares problem.\n *\n * @since 3.4\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations, final boolean lazyEvaluation, final ParameterValidator paramValidator) {\n    final LeastSquaresProblem p = new LocalLeastSquaresProblem(model, observed, start, checker, maxEvaluations, maxIterations, lazyEvaluation, paramValidator);\n    if (weight != null) {\n        return weightMatrix(p, weight);\n    } else {\n        return p;\n    }\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements. There will be no weights applied (unit weights).\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return create(model, observed, start, null, checker, maxEvaluations, maxIterations, false, null);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements.\n *\n * @param model          the model function. Produces the computed values.\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateJacobianFunction model, final RealVector observed, final RealVector start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return weightMatrix(create(model, observed, start, checker, maxEvaluations, maxIterations), weight);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Create a {@link org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem}\n * from the given elements.\n * <p>\n * This factory method is provided for continuity with previous interfaces. Newer\n * applications should use {@link #create(MultivariateJacobianFunction, RealVector,\n * RealVector, ConvergenceChecker, int, int)}, or {@link #create(MultivariateJacobianFunction,\n * RealVector, RealVector, RealMatrix, ConvergenceChecker, int, int)}.\n *\n * @param model          the model function. Produces the computed values.\n * @param jacobian       the jacobian of the model with respect to the parameters\n * @param observed       the observed (target) values\n * @param start          the initial guess.\n * @param weight         the weight matrix\n * @param checker        convergence checker\n * @param maxEvaluations the maximum number of times to evaluate the model\n * @param maxIterations  the maximum number to times to iterate in the algorithm\n * @return the specified General Least Squares problem.\n */\npublic static LeastSquaresProblem create(final MultivariateVectorFunction model, final MultivariateMatrixFunction jacobian, final double[] observed, final double[] start, final RealMatrix weight, final ConvergenceChecker<Evaluation> checker, final int maxEvaluations, final int maxIterations) {\n    return create(model(model, jacobian), new ArrayRealVector(observed, false), new ArrayRealVector(start, false), weight, checker, maxEvaluations, maxIterations);\n}"
            ],
            [
                "weightMatrix",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Apply a dense weight matrix to the {@link LeastSquaresProblem}.\n *\n * @param problem the unweighted problem\n * @param weights the matrix of weights\n * @return a new {@link LeastSquaresProblem} with the weights applied. The original\n *         {@code problem} is not modified.\n */\npublic static LeastSquaresProblem weightMatrix(final LeastSquaresProblem problem, final RealMatrix weights) {\n    final RealMatrix weightSquareRoot = squareRoot(weights);\n    return new LeastSquaresAdapter(problem) {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Evaluation evaluate(final RealVector point) {\n            return new DenseWeightedEvaluation(super.evaluate(point), weightSquareRoot);\n        }\n    };\n}"
            ],
            [
                "weightDiagonal",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Apply a diagonal weight matrix to the {@link LeastSquaresProblem}.\n *\n * @param problem the unweighted problem\n * @param weights the diagonal of the weight matrix\n * @return a new {@link LeastSquaresProblem} with the weights applied. The original\n *         {@code problem} is not modified.\n */\npublic static LeastSquaresProblem weightDiagonal(final LeastSquaresProblem problem, final RealVector weights) {\n    // TODO more efficient implementation\n    return weightMatrix(problem, new DiagonalMatrix(weights.toArray()));\n}"
            ],
            [
                "countEvaluations",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Count the evaluations of a particular problem. The {@code counter} will be\n * incremented every time {@link LeastSquaresProblem#evaluate(RealVector)} is called on\n * the <em>returned</em> problem.\n *\n * @param problem the problem to track.\n * @param counter the counter to increment.\n * @return a least squares problem that tracks evaluations\n */\npublic static LeastSquaresProblem countEvaluations(final LeastSquaresProblem problem, final Incrementor counter) {\n    return new LeastSquaresAdapter(problem) {\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Evaluation evaluate(final RealVector point) {\n            counter.incrementCount();\n            return super.evaluate(point);\n        }\n    };\n}"
            ],
            [
                "evaluationChecker",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * View a convergence checker specified for a {@link PointVectorValuePair} as one\n * specified for an {@link Evaluation}.\n *\n * @param checker the convergence checker to adapt.\n * @return a convergence checker that delegates to {@code checker}.\n */\npublic static ConvergenceChecker<Evaluation> evaluationChecker(final ConvergenceChecker<PointVectorValuePair> checker) {\n    return new ConvergenceChecker<Evaluation>() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean converged(final int iteration, final Evaluation previous, final Evaluation current) {\n            return checker.converged(iteration, new PointVectorValuePair(previous.getPoint().toArray(), previous.getResiduals().toArray(), false), new PointVectorValuePair(current.getPoint().toArray(), current.getResiduals().toArray(), false));\n        }\n    };\n}"
            ],
            [
                "model",
                "org.apache.commons.math3.fitting.leastsquares",
                "LeastSquaresFactory",
                "/**\n * Combine a {@link MultivariateVectorFunction} with a {@link\n * MultivariateMatrixFunction} to produce a {@link MultivariateJacobianFunction}.\n *\n * @param value    the vector value function\n * @param jacobian the Jacobian function\n * @return a function that computes both at the same time\n */\npublic static MultivariateJacobianFunction model(final MultivariateVectorFunction value, final MultivariateMatrixFunction jacobian) {\n    return new LocalValueAndJacobianFunction(value, jacobian);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "HarmonicCurveFitter",
                "/**\n * Creates a default curve fitter.\n * The initial guess for the parameters will be {@link ParameterGuesser}\n * computed automatically, and the maximum number of iterations of the\n * optimization algorithm is set to {@link Integer#MAX_VALUE}.\n *\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static HarmonicCurveFitter create() {\n    return new HarmonicCurveFitter(null, Integer.MAX_VALUE);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.fitting",
                "PolynomialCurveFitter",
                "/**\n * Creates a default curve fitter.\n * Zero will be used as initial guess for the coefficients, and the maximum\n * number of iterations of the optimization algorithm is set to\n * {@link Integer#MAX_VALUE}.\n *\n * @param degree Degree of the polynomial to be fitted.\n * @return a curve fitter.\n *\n * @see #withStartPoint(double[])\n * @see #withMaxIterations(int)\n */\npublic static PolynomialCurveFitter create(int degree) {\n    return new PolynomialCurveFitter(new double[degree + 1], Integer.MAX_VALUE);\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n */\npublic static UnivariateFunction compose(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = x;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction compose(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = t;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public DerivativeStructure value(final DerivativeStructure t) {\n            DerivativeStructure r = t;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "compose",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Composes functions.\n * <p>\n * The functions in the argument list are composed sequentially, in the\n * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).</p>\n *\n * @param f List of functions.\n * @return the composite function.\n * @deprecated as of 3.1 replaced by {@link #compose(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction compose(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = x;\n            for (int i = f.length - 1; i >= 0; i--) {\n                r = f[i].value(r);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double p = 1;\n                    double r = x;\n                    for (int i = f.length - 1; i >= 0; i--) {\n                        p *= f[i].derivative().value(r);\n                        r = f[i].value(r);\n                    }\n                    return p;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n */\npublic static UnivariateFunction add(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(x);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction add(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(t);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         * @throws DimensionMismatchException if functions are not consistent with each other\n         */\n        public DerivativeStructure value(final DerivativeStructure t) throws DimensionMismatchException {\n            DerivativeStructure r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r = r.add(f[i].value(t));\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Adds functions.\n *\n * @param f List of functions.\n * @return a function that computes the sum of the functions.\n * @deprecated as of 3.1 replaced by {@link #add(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction add(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r += f[i].value(x);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double r = f[0].derivative().value(x);\n                    for (int i = 1; i < f.length; i++) {\n                        r += f[i].derivative().value(x);\n                    }\n                    return r;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n */\npublic static UnivariateFunction multiply(final UnivariateFunction... f) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(x);\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n * @since 3.1\n */\npublic static UnivariateDifferentiableFunction multiply(final UnivariateDifferentiableFunction... f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double t) {\n            double r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(t);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public DerivativeStructure value(final DerivativeStructure t) {\n            DerivativeStructure r = f[0].value(t);\n            for (int i = 1; i < f.length; i++) {\n                r = r.multiply(f[i].value(t));\n            }\n            return r;\n        }\n    };\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Multiplies functions.\n *\n * @param f List of functions.\n * @return a function that computes the product of the functions.\n * @deprecated as of 3.1 replaced by {@link #multiply(UnivariateDifferentiableFunction...)}\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction multiply(final DifferentiableUnivariateFunction... f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            double r = f[0].value(x);\n            for (int i = 1; i < f.length; i++) {\n                r *= f[i].value(x);\n            }\n            return r;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(double x) {\n                    double sum = 0;\n                    for (int i = 0; i < f.length; i++) {\n                        double prod = f[i].derivative().value(x);\n                        for (int j = 0; j < f.length; j++) {\n                            if (i != j) {\n                                prod *= f[j].value(x);\n                            }\n                        }\n                        sum += prod;\n                    }\n                    return sum;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "combine",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns the univariate function\n * {@code h(x) = combiner(f(x), g(x)).}\n *\n * @param combiner Combiner function.\n * @param f Function.\n * @param g Function.\n * @return the composite function.\n */\npublic static UnivariateFunction combine(final BivariateFunction combiner, final UnivariateFunction f, final UnivariateFunction g) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return combiner.value(f.value(x), g.value(x));\n        }\n    };\n}"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns a MultivariateFunction h(x[]) defined by <pre> <code>\n * h(x[]) = combiner(...combiner(combiner(initialValue,f(x[0])),f(x[1]))...),f(x[x.length-1]))\n * </code></pre>\n *\n * @param combiner Combiner function.\n * @param f Function.\n * @param initialValue Initial value.\n * @return a collector function.\n */\npublic static MultivariateFunction collector(final BivariateFunction combiner, final UnivariateFunction f, final double initialValue) {\n    return new MultivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double[] point) {\n            double result = combiner.value(initialValue, f.value(point[0]));\n            for (int i = 1; i < point.length; i++) {\n                result = combiner.value(result, f.value(point[i]));\n            }\n            return result;\n        }\n    };\n}"
            ],
            [
                "collector",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Returns a MultivariateFunction h(x[]) defined by <pre> <code>\n * h(x[]) = combiner(...combiner(combiner(initialValue,x[0]),x[1])...),x[x.length-1])\n * </code></pre>\n *\n * @param combiner Combiner function.\n * @param initialValue Initial value.\n * @return a collector function.\n */\npublic static MultivariateFunction collector(final BivariateFunction combiner, final double initialValue) {\n    return collector(combiner, new Identity(), initialValue);\n}"
            ],
            [
                "fix1stArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Creates a unary function by fixing the first argument of a binary function.\n *\n * @param f Binary function.\n * @param fixed value to which the first argument of {@code f} is set.\n * @return the unary function h(x) = f(fixed, x)\n */\npublic static UnivariateFunction fix1stArgument(final BivariateFunction f, final double fixed) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return f.value(fixed, x);\n        }\n    };\n}"
            ],
            [
                "fix2ndArgument",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Creates a unary function by fixing the second argument of a binary function.\n *\n * @param f Binary function.\n * @param fixed value to which the second argument of {@code f} is set.\n * @return the unary function h(x) = f(x, fixed)\n */\npublic static UnivariateFunction fix2ndArgument(final BivariateFunction f, final double fixed) {\n    return new UnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(double x) {\n            return f.value(x, fixed);\n        }\n    };\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Samples the specified univariate real function on the specified interval.\n * <p>\n * The interval is divided equally into {@code n} sections and sample points\n * are taken from {@code min} to {@code max - (max - min) / n}; therefore\n * {@code f} is not sampled at the upper bound {@code max}.</p>\n *\n * @param f Function to be sampled\n * @param min Lower bound of the interval (included).\n * @param max Upper bound of the interval (excluded).\n * @param n Number of sample points.\n * @return the array of samples.\n * @throws NumberIsTooLargeException if the lower bound {@code min} is\n * greater than, or equal to the upper bound {@code max}.\n * @throws NotStrictlyPositiveException if the number of sample points\n * {@code n} is negative.\n */\npublic static double[] sample(UnivariateFunction f, double min, double max, int n) throws NumberIsTooLargeException, NotStrictlyPositiveException {\n    if (n <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES, Integer.valueOf(n));\n    }\n    if (min >= max) {\n        throw new NumberIsTooLargeException(min, max, false);\n    }\n    final double[] s = new double[n];\n    final double h = (max - min) / n;\n    for (int i = 0; i < n; i++) {\n        s[i] = f.value(min + i * h);\n    }\n    return s;\n}"
            ],
            [
                "toDifferentiableUnivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link UnivariateDifferentiableFunction} into a {@link DifferentiableUnivariateFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableUnivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableUnivariateFunction toDifferentiableUnivariateFunction(final UnivariateDifferentiableFunction f) {\n    return new DifferentiableUnivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public UnivariateFunction derivative() {\n            return new UnivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(final double x) {\n                    return f.value(new DerivativeStructure(1, 1, 0, x)).getPartialDerivative(1);\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toUnivariateDifferential",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableUnivariateFunction} into a {@link UnivariateDifferentiableFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} up to order one.\n * If the function is called with higher order, a {@link NumberIsTooLargeException} is thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableUnivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static UnivariateDifferentiableFunction toUnivariateDifferential(final DifferentiableUnivariateFunction f) {\n    return new UnivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is greater than 1\n         */\n        public DerivativeStructure value(final DerivativeStructure t) throws NumberIsTooLargeException {\n            switch(t.getOrder()) {\n                case 0:\n                    return new DerivativeStructure(t.getFreeParameters(), 0, f.value(t.getValue()));\n                case 1:\n                    {\n                        final int parameters = t.getFreeParameters();\n                        final double[] derivatives = new double[parameters + 1];\n                        derivatives[0] = f.value(t.getValue());\n                        final double fPrime = f.derivative().value(t.getValue());\n                        int[] orders = new int[parameters];\n                        for (int i = 0; i < parameters; ++i) {\n                            orders[i] = 1;\n                            derivatives[i + 1] = fPrime * t.getPartialDerivative(orders);\n                            orders[i] = 0;\n                        }\n                        return new DerivativeStructure(parameters, 1, derivatives);\n                    }\n                default:\n                    throw new NumberIsTooLargeException(t.getOrder(), 1, true);\n            }\n        }\n    };\n}"
            ],
            [
                "toDifferentiableMultivariateFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link MultivariateDifferentiableFunction} into a {@link DifferentiableMultivariateFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableMultivariateFunction toDifferentiableMultivariateFunction(final MultivariateDifferentiableFunction f) {\n    return new DifferentiableMultivariateFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateFunction partialDerivative(final int k) {\n            return new MultivariateFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        if (i == k) {\n                            dsX[i] = new DerivativeStructure(1, 1, 0, x[i]);\n                        } else {\n                            dsX[i] = new DerivativeStructure(1, 1, x[i]);\n                        }\n                    }\n                    final DerivativeStructure y = f.value(dsX);\n                    // extract partial derivative\n                    return y.getPartialDerivative(1);\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateVectorFunction gradient() {\n            return new MultivariateVectorFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double[] value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        dsX[i] = new DerivativeStructure(n, 1, i, x[i]);\n                    }\n                    final DerivativeStructure y = f.value(dsX);\n                    // extract gradient\n                    final double[] gradient = new double[n];\n                    final int[] orders = new int[n];\n                    for (int i = 0; i < n; ++i) {\n                        orders[i] = 1;\n                        gradient[i] = y.getPartialDerivative(orders);\n                        orders[i] = 0;\n                    }\n                    return gradient;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toMultivariateDifferentiableFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableMultivariateFunction} into a {@link MultivariateDifferentiableFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} elements\n * that all have the same number of free parameters and order, and with order at most 1.\n * If the function is called with inconsistent numbers of free parameters or higher order, a\n * {@link DimensionMismatchException} or a {@link NumberIsTooLargeException} will be thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static MultivariateDifferentiableFunction toMultivariateDifferentiableFunction(final DifferentiableMultivariateFunction f) {\n    return new MultivariateDifferentiableFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is higher than 1\n         * @exception DimensionMismatchException if numbers of free parameters are inconsistent\n         */\n        public DerivativeStructure value(final DerivativeStructure[] t) throws DimensionMismatchException, NumberIsTooLargeException {\n            // check parameters and orders limits\n            final int parameters = t[0].getFreeParameters();\n            final int order = t[0].getOrder();\n            final int n = t.length;\n            if (order > 1) {\n                throw new NumberIsTooLargeException(order, 1, true);\n            }\n            // check all elements in the array are consistent\n            for (int i = 0; i < n; ++i) {\n                if (t[i].getFreeParameters() != parameters) {\n                    throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n                }\n                if (t[i].getOrder() != order) {\n                    throw new DimensionMismatchException(t[i].getOrder(), order);\n                }\n            }\n            // delegate computation to underlying function\n            final double[] point = new double[n];\n            for (int i = 0; i < n; ++i) {\n                point[i] = t[i].getValue();\n            }\n            final double value = f.value(point);\n            final double[] gradient = f.gradient().value(point);\n            // merge value and gradient into one DerivativeStructure\n            final double[] derivatives = new double[parameters + 1];\n            derivatives[0] = value;\n            final int[] orders = new int[parameters];\n            for (int i = 0; i < parameters; ++i) {\n                orders[i] = 1;\n                for (int j = 0; j < n; ++j) {\n                    derivatives[i + 1] += gradient[j] * t[j].getPartialDerivative(orders);\n                }\n                orders[i] = 0;\n            }\n            return new DerivativeStructure(parameters, order, derivatives);\n        }\n    };\n}"
            ],
            [
                "toDifferentiableMultivariateVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link MultivariateDifferentiableVectorFunction} into a {@link DifferentiableMultivariateVectorFunction}.\n *\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateVectorFunction} interface itself is deprecated\n */\n@Deprecated\npublic static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f) {\n    return new DifferentiableMultivariateVectorFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double[] value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public MultivariateMatrixFunction jacobian() {\n            return new MultivariateMatrixFunction() {\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public double[][] value(final double[] x) {\n                    final int n = x.length;\n                    // delegate computation to underlying function\n                    final DerivativeStructure[] dsX = new DerivativeStructure[n];\n                    for (int i = 0; i < n; ++i) {\n                        dsX[i] = new DerivativeStructure(n, 1, i, x[i]);\n                    }\n                    final DerivativeStructure[] y = f.value(dsX);\n                    // extract Jacobian\n                    final double[][] jacobian = new double[y.length][n];\n                    final int[] orders = new int[n];\n                    for (int i = 0; i < y.length; ++i) {\n                        for (int j = 0; j < n; ++j) {\n                            orders[j] = 1;\n                            jacobian[i][j] = y[i].getPartialDerivative(orders);\n                            orders[j] = 0;\n                        }\n                    }\n                    return jacobian;\n                }\n            };\n        }\n    };\n}"
            ],
            [
                "toMultivariateDifferentiableVectorFunction",
                "org.apache.commons.math3.analysis",
                "FunctionUtils",
                "/**\n * Convert a {@link DifferentiableMultivariateVectorFunction} into a {@link MultivariateDifferentiableVectorFunction}.\n * <p>\n * Note that the converted function is able to handle {@link DerivativeStructure} elements\n * that all have the same number of free parameters and order, and with order at most 1.\n * If the function is called with inconsistent numbers of free parameters or higher order, a\n * {@link DimensionMismatchException} or a {@link NumberIsTooLargeException} will be thrown.\n * </p>\n * @param f function to convert\n * @return converted function\n * @deprecated this conversion method is temporary in version 3.1, as the {@link\n * DifferentiableMultivariateFunction} interface itself is deprecated\n */\n@Deprecated\npublic static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f) {\n    return new MultivariateDifferentiableVectorFunction() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double[] value(final double[] x) {\n            return f.value(x);\n        }\n\n        /**\n         * {@inheritDoc}\n         * @exception NumberIsTooLargeException if derivation order is higher than 1\n         * @exception DimensionMismatchException if numbers of free parameters are inconsistent\n         */\n        public DerivativeStructure[] value(final DerivativeStructure[] t) throws DimensionMismatchException, NumberIsTooLargeException {\n            // check parameters and orders limits\n            final int parameters = t[0].getFreeParameters();\n            final int order = t[0].getOrder();\n            final int n = t.length;\n            if (order > 1) {\n                throw new NumberIsTooLargeException(order, 1, true);\n            }\n            // check all elements in the array are consistent\n            for (int i = 0; i < n; ++i) {\n                if (t[i].getFreeParameters() != parameters) {\n                    throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n                }\n                if (t[i].getOrder() != order) {\n                    throw new DimensionMismatchException(t[i].getOrder(), order);\n                }\n            }\n            // delegate computation to underlying function\n            final double[] point = new double[n];\n            for (int i = 0; i < n; ++i) {\n                point[i] = t[i].getValue();\n            }\n            final double[] value = f.value(point);\n            final double[][] jacobian = f.jacobian().value(point);\n            // merge value and Jacobian into a DerivativeStructure array\n            final DerivativeStructure[] merged = new DerivativeStructure[value.length];\n            for (int k = 0; k < merged.length; ++k) {\n                final double[] derivatives = new double[parameters + 1];\n                derivatives[0] = value[k];\n                final int[] orders = new int[parameters];\n                for (int i = 0; i < parameters; ++i) {\n                    orders[i] = 1;\n                    for (int j = 0; j < n; ++j) {\n                        derivatives[i + 1] += jacobian[k][j] * t[j].getPartialDerivative(orders);\n                    }\n                    orders[i] = 0;\n                }\n                merged[k] = new DerivativeStructure(parameters, order, derivatives);\n            }\n            return merged;\n        }\n    };\n}"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Convenience method to find a zero of a univariate real function.  A default\n * solver is used.\n *\n * @param function Function.\n * @param x0 Lower bound for the interval.\n * @param x1 Upper bound for the interval.\n * @return a value where the function is zero.\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double solve(UnivariateFunction function, double x0, double x1) throws NullArgumentException, NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final UnivariateSolver solver = new BrentSolver();\n    return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n}"
            ],
            [
                "solve",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Convenience method to find a zero of a univariate real function.  A default\n * solver is used.\n *\n * @param function Function.\n * @param x0 Lower bound for the interval.\n * @param x1 Upper bound for the interval.\n * @param absoluteAccuracy Accuracy to be used by the solver.\n * @return a value where the function is zero.\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double solve(UnivariateFunction function, double x0, double x1, double absoluteAccuracy) throws NullArgumentException, NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final UnivariateSolver solver = new BrentSolver(absoluteAccuracy);\n    return solver.solve(Integer.MAX_VALUE, function, x0, x1);\n}"
            ],
            [
                "forceSide",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Force a root found by a non-bracketing solver to lie on a specified side,\n * as if the solver were a bracketing one.\n *\n * @param maxEval maximal number of new evaluations of the function\n * (evaluations already done for finding the root should have already been subtracted\n * from this number)\n * @param f function to solve\n * @param bracketing bracketing solver to use for shifting the root\n * @param baseRoot original root found by a previous non-bracketing solver\n * @param min minimal bound of the search interval\n * @param max maximal bound of the search interval\n * @param allowedSolution the kind of solutions that the root-finding algorithm may\n * accept as solutions.\n * @return a root approximation, on the specified side of the exact root\n * @throws NoBracketingException if the function has the same sign at the\n * endpoints.\n */\npublic static double forceSide(final int maxEval, final UnivariateFunction f, final BracketedUnivariateSolver<UnivariateFunction> bracketing, final double baseRoot, final double min, final double max, final AllowedSolution allowedSolution) throws NoBracketingException {\n    if (allowedSolution == AllowedSolution.ANY_SIDE) {\n        // no further bracketing required\n        return baseRoot;\n    }\n    // find a very small interval bracketing the root\n    final double step = FastMath.max(bracketing.getAbsoluteAccuracy(), FastMath.abs(baseRoot * bracketing.getRelativeAccuracy()));\n    double xLo = FastMath.max(min, baseRoot - step);\n    double fLo = f.value(xLo);\n    double xHi = FastMath.min(max, baseRoot + step);\n    double fHi = f.value(xHi);\n    int remainingEval = maxEval - 2;\n    while (remainingEval > 0) {\n        if ((fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0)) {\n            // compute the root on the selected side\n            return bracketing.solve(remainingEval, f, xLo, xHi, baseRoot, allowedSolution);\n        }\n        // try increasing the interval\n        boolean changeLo = false;\n        boolean changeHi = false;\n        if (fLo < fHi) {\n            // increasing function\n            if (fLo >= 0) {\n                changeLo = true;\n            } else {\n                changeHi = true;\n            }\n        } else if (fLo > fHi) {\n            // decreasing function\n            if (fLo <= 0) {\n                changeLo = true;\n            } else {\n                changeHi = true;\n            }\n        } else {\n            // unknown variation\n            changeLo = true;\n            changeHi = true;\n        }\n        // update the lower bound\n        if (changeLo) {\n            xLo = FastMath.max(min, xLo - step);\n            fLo = f.value(xLo);\n            remainingEval--;\n        }\n        // update the higher bound\n        if (changeHi) {\n            xHi = FastMath.min(max, xHi + step);\n            fHi = f.value(xHi);\n            remainingEval--;\n        }\n    }\n    throw new NoBracketingException(LocalizedFormats.FAILED_BRACKETING, xLo, xHi, fLo, fHi, maxEval - remainingEval, maxEval, baseRoot, min, max);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method simply calls {@link #bracket(UnivariateFunction, double, double, double,\n * double, double, int) bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)}\n * with {@code q} and {@code r} set to 1.0 and {@code maximumIterations} set to {@code Integer.MAX_VALUE}.\n * <p>\n * <strong>Note: </strong> this method can take {@code Integer.MAX_VALUE}\n * iterations to throw a {@code ConvergenceException.}  Unless you are\n * confident that there is a root between {@code lowerBound} and\n * {@code upperBound} near {@code initial}, it is better to use\n * {@link #bracket(UnivariateFunction, double, double, double, double,double, int)\n * bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)},\n * explicitly specifying the maximum number of iterations.</p>\n *\n * @param function Function.\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value)\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @return a two-element array holding a and b.\n * @throws NoBracketingException if a root cannot be bracketted.\n * @throws NotStrictlyPositiveException if {@code maximumIterations <= 0}.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException {\n    return bracket(function, initial, lowerBound, upperBound, 1.0, 1.0, Integer.MAX_VALUE);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method simply calls {@link #bracket(UnivariateFunction, double, double, double,\n * double, double, int) bracket(function, initial, lowerBound, upperBound, q, r, maximumIterations)}\n * with {@code q} and {@code r} set to 1.0.\n * @param function Function.\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value).\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @param maximumIterations Maximum number of iterations to perform\n * @return a two element array holding a and b.\n * @throws NoBracketingException if the algorithm fails to find a and b\n * satisfying the desired conditions.\n * @throws NotStrictlyPositiveException if {@code maximumIterations <= 0}.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static double[] bracket(UnivariateFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws NullArgumentException, NotStrictlyPositiveException, NoBracketingException {\n    return bracket(function, initial, lowerBound, upperBound, 1.0, 1.0, maximumIterations);\n}"
            ],
            [
                "bracket",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * This method attempts to find two values a and b satisfying <ul>\n * <li> {@code lowerBound <= a < initial < b <= upperBound} </li>\n * <li> {@code f(a) * f(b) <= 0} </li>\n * </ul>\n * If {@code f} is continuous on {@code [a,b]}, this means that {@code a}\n * and {@code b} bracket a root of {@code f}.\n * <p>\n * The algorithm checks the sign of \\( f(l_k) \\) and \\( f(u_k) \\) for increasing\n * values of k, where \\( l_k = max(lower, initial - \\delta_k) \\),\n * \\( u_k = min(upper, initial + \\delta_k) \\), using recurrence\n * \\( \\delta_{k+1} = r \\delta_k + q, \\delta_0 = 0\\) and starting search with \\( k=1 \\).\n * The algorithm stops when one of the following happens: <ul>\n * <li> at least one positive and one negative value have been found --  success!</li>\n * <li> both endpoints have reached their respective limits -- NoBracketingException </li>\n * <li> {@code maximumIterations} iterations elapse -- NoBracketingException </li></ul>\n * <p>\n * If different signs are found at first iteration ({@code k=1}), then the returned\n * interval will be \\( [a, b] = [l_1, u_1] \\). If different signs are found at a later\n * iteration {@code k>1}, then the returned interval will be either\n * \\( [a, b] = [l_{k+1}, l_{k}] \\) or \\( [a, b] = [u_{k}, u_{k+1}] \\). A root solver called\n * with these parameters will therefore start with the smallest bracketing interval known\n * at this step.\n * </p>\n * <p>\n * Interval expansion rate is tuned by changing the recurrence parameters {@code r} and\n * {@code q}. When the multiplicative factor {@code r} is set to 1, the sequence is a\n * simple arithmetic sequence with linear increase. When the multiplicative factor {@code r}\n * is larger than 1, the sequence has an asymptotically exponential rate. Note than the\n * additive parameter {@code q} should never be set to zero, otherwise the interval would\n * degenerate to the single initial point for all values of {@code k}.\n * </p>\n * <p>\n * As a rule of thumb, when the location of the root is expected to be approximately known\n * within some error margin, {@code r} should be set to 1 and {@code q} should be set to the\n * order of magnitude of the error margin. When the location of the root is really a wild guess,\n * then {@code r} should be set to a value larger than 1 (typically 2 to double the interval\n * length at each iteration) and {@code q} should be set according to half the initial\n * search interval length.\n * </p>\n * <p>\n * As an example, if we consider the trivial function {@code f(x) = 1 - x} and use\n * {@code initial = 4}, {@code r = 1}, {@code q = 2}, the algorithm will compute\n * {@code f(4-2) = f(2) = -1} and {@code f(4+2) = f(6) = -5} for {@code k = 1}, then\n * {@code f(4-4) = f(0) = +1} and {@code f(4+4) = f(8) = -7} for {@code k = 2}. Then it will\n * return the interval {@code [0, 2]} as the smallest one known to be bracketing the root.\n * As shown by this example, the initial value (here {@code 4}) may lie outside of the returned\n * bracketing interval.\n * </p>\n * @param function function to check\n * @param initial Initial midpoint of interval being expanded to\n * bracket a root.\n * @param lowerBound Lower bound (a is never lower than this value).\n * @param upperBound Upper bound (b never is greater than this\n * value).\n * @param q additive offset used to compute bounds sequence (must be strictly positive)\n * @param r multiplicative factor used to compute bounds sequence\n * @param maximumIterations Maximum number of iterations to perform\n * @return a two element array holding the bracketing values.\n * @exception NoBracketingException if function cannot be bracketed in the search interval\n */\npublic static double[] bracket(final UnivariateFunction function, final double initial, final double lowerBound, final double upperBound, final double q, final double r, final int maximumIterations) throws NoBracketingException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    if (q <= 0) {\n        throw new NotStrictlyPositiveException(q);\n    }\n    if (maximumIterations <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.INVALID_MAX_ITERATIONS, maximumIterations);\n    }\n    verifySequence(lowerBound, initial, upperBound);\n    // initialize the recurrence\n    double a = initial;\n    double b = initial;\n    double fa = Double.NaN;\n    double fb = Double.NaN;\n    double delta = 0;\n    for (int numIterations = 0; (numIterations < maximumIterations) && (a > lowerBound || b < upperBound); ++numIterations) {\n        final double previousA = a;\n        final double previousFa = fa;\n        final double previousB = b;\n        final double previousFb = fb;\n        delta = r * delta + q;\n        a = FastMath.max(initial - delta, lowerBound);\n        b = FastMath.min(initial + delta, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        if (numIterations == 0) {\n            // at first iteration, we don't have a previous interval\n            // we simply compare both sides of the initial interval\n            if (fa * fb <= 0) {\n                // the first interval already brackets a root\n                return new double[] { a, b };\n            }\n        } else {\n            // we have a previous interval with constant sign and expand it,\n            // we expect sign changes to occur at boundaries\n            if (fa * previousFa <= 0) {\n                // sign change detected at near lower bound\n                return new double[] { a, previousA };\n            } else if (fb * previousFb <= 0) {\n                // sign change detected at near upper bound\n                return new double[] { previousB, b };\n            }\n        }\n    }\n    // no bracketing found\n    throw new NoBracketingException(a, b, fa, fb);\n}"
            ],
            [
                "midpoint",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Compute the midpoint of two values.\n *\n * @param a first value.\n * @param b second value.\n * @return the midpoint.\n */\npublic static double midpoint(double a, double b) {\n    return (a + b) * 0.5;\n}"
            ],
            [
                "isBracketing",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Check whether the interval bounds bracket a root. That is, if the\n * values at the endpoints are not equal to zero, then the function takes\n * opposite signs at the endpoints.\n *\n * @param function Function.\n * @param lower Lower endpoint.\n * @param upper Upper endpoint.\n * @return {@code true} if the function values have opposite signs at the\n * given points.\n * @throws NullArgumentException if {@code function} is {@code null}.\n */\npublic static boolean isBracketing(UnivariateFunction function, final double lower, final double upper) throws NullArgumentException {\n    if (function == null) {\n        throw new NullArgumentException(LocalizedFormats.FUNCTION);\n    }\n    final double fLo = function.value(lower);\n    final double fHi = function.value(upper);\n    return (fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0);\n}"
            ],
            [
                "isSequence",
                "org.apache.commons.math3.analysis.solvers",
                "UnivariateSolverUtils",
                "/**\n * Check whether the arguments form a (strictly) increasing sequence.\n *\n * @param start First number.\n * @param mid Second number.\n * @param end Third number.\n * @return {@code true} if the arguments form an increasing sequence.\n */\npublic static boolean isSequence(final double start, final double mid, final double end) {\n    return (start < mid) && (mid < end);\n}"
            ],
            [
                "getCompiler",
                "org.apache.commons.math3.analysis.differentiation",
                "DSCompiler",
                "/**\n * Get the compiler for number of free parameters and order.\n * @param parameters number of free parameters\n * @param order derivation order\n * @return cached rules set\n * @throws NumberIsTooLargeException if order is too large\n */\npublic static DSCompiler getCompiler(int parameters, int order) throws NumberIsTooLargeException {\n    // get the cached compilers\n    final DSCompiler[][] cache = compilers.get();\n    if (cache != null && cache.length > parameters && cache[parameters].length > order && cache[parameters][order] != null) {\n        // the compiler has already been created\n        return cache[parameters][order];\n    }\n    // we need to create more compilers\n    final int maxParameters = FastMath.max(parameters, cache == null ? 0 : cache.length);\n    final int maxOrder = FastMath.max(order, cache == null ? 0 : cache[0].length);\n    final DSCompiler[][] newCache = new DSCompiler[maxParameters + 1][maxOrder + 1];\n    if (cache != null) {\n        // preserve the already created compilers\n        for (int i = 0; i < cache.length; ++i) {\n            System.arraycopy(cache[i], 0, newCache[i], 0, cache[i].length);\n        }\n    }\n    // create the array in increasing diagonal order\n    for (int diag = 0; diag <= parameters + order; ++diag) {\n        for (int o = FastMath.max(0, diag - parameters); o <= FastMath.min(order, diag); ++o) {\n            final int p = diag - o;\n            if (newCache[p][o] == null) {\n                final DSCompiler valueCompiler = (p == 0) ? null : newCache[p - 1][o];\n                final DSCompiler derivativeCompiler = (o == 0) ? null : newCache[p][o - 1];\n                newCache[p][o] = new DSCompiler(p, o, valueCompiler, derivativeCompiler);\n            }\n        }\n    }\n    // atomically reset the cached compilers array\n    compilers.compareAndSet(cache, newCache);\n    return newCache[parameters][order];\n}"
            ],
            [
                "createConstant",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Factory method creating a constant.\n * @param value value of the constant\n * @return a new instance\n */\npublic static SparseGradient createConstant(final double value) {\n    return new SparseGradient(value, Collections.<Integer, Double>emptyMap());\n}"
            ],
            [
                "createVariable",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Factory method creating an independent variable.\n * @param idx index of the variable\n * @param value value of the variable\n * @return a new instance\n */\npublic static SparseGradient createVariable(final int idx, final double value) {\n    return new SparseGradient(value, Collections.singletonMap(idx, 1.0));\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n */\npublic static SparseGradient hypot(final SparseGradient x, final SparseGradient y) {\n    return x.hypot(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Compute a<sup>x</sup> where a is a double and x a {@link SparseGradient}\n * @param a number to exponentiate\n * @param x power to apply\n * @return a<sup>x</sup>\n */\npublic static SparseGradient pow(final double a, final SparseGradient x) {\n    if (a == 0) {\n        if (x.value == 0) {\n            return x.compose(1.0, Double.NEGATIVE_INFINITY);\n        } else if (x.value < 0) {\n            return x.compose(Double.NaN, Double.NaN);\n        } else {\n            return x.getField().getZero();\n        }\n    } else {\n        final double ax = FastMath.pow(a, x.value);\n        return new SparseGradient(ax, ax * FastMath.log(a), x.derivatives);\n    }\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "SparseGradient",
                "/**\n * Two arguments arc tangent operation.\n * @param y first argument of the arc tangent\n * @param x second argument of the arc tangent\n * @return atan2(y, x)\n */\npublic static SparseGradient atan2(final SparseGradient y, final SparseGradient x) {\n    return y.atan2(x);\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n * @exception DimensionMismatchException if number of free parameters\n * or orders do not match\n * @since 3.2\n */\npublic static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y) throws DimensionMismatchException {\n    return x.hypot(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Compute a<sup>x</sup> where a is a double and x a {@link DerivativeStructure}\n * @param a number to exponentiate\n * @param x power to apply\n * @return a<sup>x</sup>\n * @since 3.3\n */\npublic static DerivativeStructure pow(final double a, final DerivativeStructure x) {\n    final DerivativeStructure result = new DerivativeStructure(x.compiler);\n    x.compiler.pow(a, x.data, 0, result.data, 0);\n    return result;\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.analysis.differentiation",
                "DerivativeStructure",
                "/**\n * Two arguments arc tangent operation.\n * @param y first argument of the arc tangent\n * @param x second argument of the arc tangent\n * @return atan2(y, x)\n * @exception DimensionMismatchException if number of free parameters\n * or orders do not match\n * @since 3.2\n */\npublic static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException {\n    return y.atan2(x);\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionNewtonForm",
                "/**\n * Evaluate the Newton polynomial using nested multiplication. It is\n * also called <a href=\"http://mathworld.wolfram.com/HornersRule.html\">\n * Horner's Rule</a> and takes O(N) time.\n *\n * @param a Coefficients in Newton form formula.\n * @param c Centers.\n * @param z Point at which the function value is to be computed.\n * @return the function value.\n * @throws NullArgumentException if any argument is {@code null}.\n * @throws NoDataException if any array has zero length.\n * @throws DimensionMismatchException if the size difference between\n * {@code a} and {@code c} is not equal to 1.\n */\npublic static double evaluate(double[] a, double[] c, double z) throws NullArgumentException, DimensionMismatchException, NoDataException {\n    verifyInputArray(a, c);\n    final int n = c.length;\n    double value = a[n];\n    for (int i = n - 1; i >= 0; i--) {\n        value = a[i] + (z - c[i]) * value;\n    }\n    return value;\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "/**\n * Evaluate the Lagrange polynomial using\n * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n * Neville's Algorithm</a>. It takes O(n^2) time.\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @param z Point at which the function value is to be computed.\n * @return the function value.\n * @throws DimensionMismatchException if {@code x} and {@code y} have\n * different lengths.\n * @throws NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order.\n * @throws NumberIsTooSmallException if the size of {@code x} is less\n * than 2.\n */\npublic static double evaluate(double[] x, double[] y, double z) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    if (verifyInterpolationArray(x, y, false)) {\n        return evaluateInternal(x, y, z);\n    }\n    // Array is not sorted.\n    final double[] xNew = new double[x.length];\n    final double[] yNew = new double[y.length];\n    System.arraycopy(x, 0, xNew, 0, x.length);\n    System.arraycopy(y, 0, yNew, 0, y.length);\n    MathArrays.sortInPlace(xNew, yNew);\n    // Second check in case some abscissa is duplicated.\n    verifyInterpolationArray(xNew, yNew, true);\n    return evaluateInternal(xNew, yNew, z);\n}"
            ],
            [
                "verifyInterpolationArray",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunctionLagrangeForm",
                "/**\n * Check that the interpolation arrays are valid.\n * The arrays features checked by this method are that both arrays have the\n * same length and this length is at least 2.\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @param abort Whether to throw an exception if {@code x} is not sorted.\n * @throws DimensionMismatchException if the array lengths are different.\n * @throws NumberIsTooSmallException if the number of points is less than 2.\n * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order and {@code abort}\n * is {@code true}.\n * @return {@code false} if the {@code x} is not sorted in increasing order,\n * {@code true} otherwise.\n * @see #evaluate(double[], double[], double)\n * @see #computeCoefficients()\n */\npublic static boolean verifyInterpolationArray(double[] x, double[] y, boolean abort) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    if (x.length != y.length) {\n        throw new DimensionMismatchException(x.length, y.length);\n    }\n    if (x.length < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.WRONG_NUMBER_OF_POINTS, 2, x.length, true);\n    }\n    return MathArrays.checkOrder(x, MathArrays.OrderDirection.INCREASING, true, abort);\n}"
            ],
            [
                "createChebyshevPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Chebyshev polynomial of the first kind.\n * <p><a href=\"https://en.wikipedia.org/wiki/Chebyshev_polynomials\">Chebyshev\n * polynomials of the first kind</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *    T_0(x) = 1 \\\\\n *    T_1(x) = x \\\\\n *    T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Chebyshev polynomial of specified degree\n */\npublic static PolynomialFunction createChebyshevPolynomial(final int degree) {\n    return buildPolynomial(degree, CHEBYSHEV_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * Fixed recurrence coefficients.\n         */\n        private final BigFraction[] coeffs = { BigFraction.ZERO, BigFraction.TWO, BigFraction.ONE };\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            return coeffs;\n        }\n    });\n}"
            ],
            [
                "createHermitePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Hermite polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/HermitePolynomial.html\">Hermite\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *  H_0(x) = 1 \\\\\n *  H_1(x) = 2x \\\\\n *  H_{k+1}(x) = 2x H_k(X) - 2k H_{k-1}(x)\n * \\)\n * </p>\n *\n * @param degree degree of the polynomial\n * @return Hermite polynomial of specified degree\n */\npublic static PolynomialFunction createHermitePolynomial(final int degree) {\n    return buildPolynomial(degree, HERMITE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            return new BigFraction[] { BigFraction.ZERO, BigFraction.TWO, new BigFraction(2 * k) };\n        }\n    });\n}"
            ],
            [
                "createLaguerrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Laguerre polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/LaguerrePolynomial.html\">Laguerre\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *   L_0(x) = 1 \\\\\n *   L_1(x) = 1 - x \\\\\n *   (k+1) L_{k+1}(x) = (2k + 1 - x) L_k(x) - k L_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Laguerre polynomial of specified degree\n */\npublic static PolynomialFunction createLaguerrePolynomial(final int degree) {\n    return buildPolynomial(degree, LAGUERRE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            final int kP1 = k + 1;\n            return new BigFraction[] { new BigFraction(2 * k + 1, kP1), new BigFraction(-1, kP1), new BigFraction(k, kP1) };\n        }\n    });\n}"
            ],
            [
                "createLegendrePolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Legendre polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/LegendrePolynomial.html\">Legendre\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *   P_0(x) = 1 \\\\\n *   P_1(x) = x \\\\\n *   (k+1) P_{k+1}(x) = (2k+1) x P_k(x) - k P_{k-1}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @return Legendre polynomial of specified degree\n */\npublic static PolynomialFunction createLegendrePolynomial(final int degree) {\n    return buildPolynomial(degree, LEGENDRE_COEFFICIENTS, new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            final int kP1 = k + 1;\n            return new BigFraction[] { BigFraction.ZERO, new BigFraction(k + kP1, kP1), new BigFraction(k, kP1) };\n        }\n    });\n}"
            ],
            [
                "createJacobiPolynomial",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Create a Jacobi polynomial.\n * <p><a href=\"http://mathworld.wolfram.com/JacobiPolynomial.html\">Jacobi\n * polynomials</a> are orthogonal polynomials.\n * They can be defined by the following recurrence relations:</p><p>\n * \\(\n *    P_0^{vw}(x) = 1 \\\\\n *    P_{-1}^{vw}(x) = 0 \\\\\n *    2k(k + v + w)(2k + v + w - 2) P_k^{vw}(x) = \\\\\n *    (2k + v + w - 1)[(2k + v + w)(2k + v + w - 2) x + v^2 - w^2] P_{k-1}^{vw}(x) \\\\\n *  - 2(k + v - 1)(k + w - 1)(2k + v + w) P_{k-2}^{vw}(x)\n * \\)\n * </p>\n * @param degree degree of the polynomial\n * @param v first exponent\n * @param w second exponent\n * @return Jacobi polynomial of specified degree\n */\npublic static PolynomialFunction createJacobiPolynomial(final int degree, final int v, final int w) {\n    // select the appropriate list\n    final JacobiKey key = new JacobiKey(v, w);\n    if (!JACOBI_COEFFICIENTS.containsKey(key)) {\n        // allocate a new list for v, w\n        final List<BigFraction> list = new ArrayList<BigFraction>();\n        JACOBI_COEFFICIENTS.put(key, list);\n        // Pv,w,0(x) = 1;\n        list.add(BigFraction.ONE);\n        // P1(x) = (v - w) / 2 + (2 + v + w) * X / 2\n        list.add(new BigFraction(v - w, 2));\n        list.add(new BigFraction(2 + v + w, 2));\n    }\n    return buildPolynomial(degree, JACOBI_COEFFICIENTS.get(key), new RecurrenceCoefficientsGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public BigFraction[] generate(int k) {\n            k++;\n            final int kvw = k + v + w;\n            final int twoKvw = kvw + k;\n            final int twoKvwM1 = twoKvw - 1;\n            final int twoKvwM2 = twoKvw - 2;\n            final int den = 2 * k * kvw * twoKvwM2;\n            return new BigFraction[] { new BigFraction(twoKvwM1 * (v * v - w * w), den), new BigFraction(twoKvwM1 * twoKvw * twoKvwM2, den), new BigFraction(2 * (k + v - 1) * (k + w - 1) * twoKvw, den) };\n        }\n    });\n}"
            ],
            [
                "shift",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialsUtils",
                "/**\n * Compute the coefficients of the polynomial \\(P_s(x)\\)\n * whose values at point {@code x} will be the same as the those from the\n * original polynomial \\(P(x)\\) when computed at {@code x + shift}.\n * <p>\n * More precisely, let \\(\\Delta = \\) {@code shift} and let\n * \\(P_s(x) = P(x + \\Delta)\\).  The returned array\n * consists of the coefficients of \\(P_s\\).  So if \\(a_0, ..., a_{n-1}\\)\n * are the coefficients of \\(P\\), then the returned array\n * \\(b_0, ..., b_{n-1}\\) satisfies the identity\n * \\(\\sum_{i=0}^{n-1} b_i x^i = \\sum_{i=0}^{n-1} a_i (x + \\Delta)^i\\) for all \\(x\\).\n *\n * @param coefficients Coefficients of the original polynomial.\n * @param shift Shift value.\n * @return the coefficients \\(b_i\\) of the shifted\n * polynomial.\n */\npublic static double[] shift(final double[] coefficients, final double shift) {\n    final int dp1 = coefficients.length;\n    final double[] newCoefficients = new double[dp1];\n    // Pascal triangle.\n    final int[][] coeff = new int[dp1][dp1];\n    for (int i = 0; i < dp1; i++) {\n        for (int j = 0; j <= i; j++) {\n            coeff[i][j] = (int) CombinatoricsUtils.binomialCoefficient(i, j);\n        }\n    }\n    // First polynomial coefficient.\n    for (int i = 0; i < dp1; i++) {\n        newCoefficients[0] += coefficients[i] * FastMath.pow(shift, i);\n    }\n    // Superior order.\n    final int d = dp1 - 1;\n    for (int i = 0; i < d; i++) {\n        for (int j = i; j < d; j++) {\n            newCoefficients[i + 1] += coeff[j + 1][j - i] * coefficients[j + 1] * FastMath.pow(shift, j - i);\n        }\n    }\n    return newCoefficients;\n}"
            ],
            [
                "evaluate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "/**\n * Uses Horner's Method to evaluate the polynomial with the given coefficients at\n * the argument.\n *\n * @param coefficients Coefficients of the polynomial to evaluate.\n * @param argument Input value.\n * @return the value of the polynomial.\n * @throws NoDataException if {@code coefficients} is empty.\n * @throws NullArgumentException if {@code coefficients} is {@code null}.\n */\nprotected static double evaluate(double[] coefficients, double argument) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(coefficients);\n    int n = coefficients.length;\n    if (n == 0) {\n        throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n    }\n    double result = coefficients[n - 1];\n    for (int j = n - 2; j >= 0; j--) {\n        result = argument * result + coefficients[j];\n    }\n    return result;\n}"
            ],
            [
                "differentiate",
                "org.apache.commons.math3.analysis.polynomials",
                "PolynomialFunction",
                "/**\n * Returns the coefficients of the derivative of the polynomial with the given coefficients.\n *\n * @param coefficients Coefficients of the polynomial to differentiate.\n * @return the coefficients of the derivative or {@code null} if coefficients has length 1.\n * @throws NoDataException if {@code coefficients} is empty.\n * @throws NullArgumentException if {@code coefficients} is {@code null}.\n */\nprotected static double[] differentiate(double[] coefficients) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(coefficients);\n    int n = coefficients.length;\n    if (n == 0) {\n        throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n    }\n    if (n == 1) {\n        return new double[] { 0 };\n    }\n    double[] result = new double[n - 1];\n    for (int i = n - 1; i > 0; i--) {\n        result[i - 1] = i * coefficients[i];\n    }\n    return result;\n}"
            ],
            [
                "computeDividedDifference",
                "org.apache.commons.math3.analysis.interpolation",
                "DividedDifferenceInterpolator",
                "/**\n * Return a copy of the divided difference array.\n * <p>\n * The divided difference array is defined recursively by <pre>\n * f[x0] = f(x0)\n * f[x0,x1,...,xk] = (f[x1,...,xk] - f[x0,...,x[k-1]]) / (xk - x0)\n * </pre>\n * <p>\n * The computational complexity is \\(O(n^2)\\) where \\(n\\) is the common\n * length of {@code x} and {@code y}.</p>\n *\n * @param x Interpolating points array.\n * @param y Interpolating values array.\n * @return a fresh copy of the divided difference array.\n * @throws DimensionMismatchException if the array lengths are different.\n * @throws NumberIsTooSmallException if the number of points is less than 2.\n * @throws NonMonotonicSequenceException\n * if {@code x} is not sorted in strictly increasing order.\n */\nprotected static double[] computeDividedDifference(final double[] x, final double[] y) throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n    PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y, true);\n    // initialization\n    final double[] divdiff = y.clone();\n    final int n = x.length;\n    final double[] a = new double[n];\n    a[0] = divdiff[0];\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n - i; j++) {\n            final double denominator = x[j + i] - x[j];\n            divdiff[j] = (divdiff[j + 1] - divdiff[j]) / denominator;\n        }\n        a[i] = divdiff[0];\n    }\n    return a;\n}"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Compares two numbers given some amount of allowed error.\n *\n * @param x the first number\n * @param y the second number\n * @param eps the amount of error to allow when checking for equality\n * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y or\n *       either argument is NaN</li></ul>\n */\npublic static int compareTo(double x, double y, double eps) {\n    if (equals(x, y, eps)) {\n        return 0;\n    } else if (x < y) {\n        return -1;\n    }\n    return 1;\n}"
            ],
            [
                "compareTo",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Compares two numbers given some amount of allowed error.\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>. Returns {@code false} if either of the arguments is NaN.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return <ul><li>0 if  {@link #equals(double, double, int) equals(x, y, maxUlps)}</li>\n *       <li>&lt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y</li>\n *       <li>&gt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x > y\n *       or either argument is NaN</li></ul>\n */\npublic static int compareTo(final double x, final double y, final int maxUlps) {\n    if (equals(x, y, maxUlps)) {\n        return 0;\n    } else if (x < y) {\n        return -1;\n    }\n    return 1;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true iff they are equal as defined by\n * {@link #equals(float,float,int) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\npublic static boolean equals(float x, float y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if both arguments are NaN or they are\n * equal as defined by {@link #equals(float,float) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).  Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other.\n * @since 2.2\n */\npublic static boolean equals(float x, float y, float eps) {\n    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN, are equal, or are within the range\n * of allowed error (inclusive).\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,\n * or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y, float eps) {\n    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent floating\n * point numbers are considered equal.\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>.  Returns {@code false} if either of the arguments is NaN.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equals(final float x, final float y, final int maxUlps) {\n    final int xInt = Float.floatToRawIntBits(x);\n    final int yInt = Float.floatToRawIntBits(y);\n    final boolean isEqual;\n    if (((xInt ^ yInt) & SGN_MASK_FLOAT) == 0) {\n        // number have same sign, there is no risk of overflow\n        isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    } else {\n        // number have opposite signs, take care of overflow\n        final int deltaPlus;\n        final int deltaMinus;\n        if (xInt < yInt) {\n            deltaPlus = yInt - POSITIVE_ZERO_FLOAT_BITS;\n            deltaMinus = xInt - NEGATIVE_ZERO_FLOAT_BITS;\n        } else {\n            deltaPlus = xInt - POSITIVE_ZERO_FLOAT_BITS;\n            deltaMinus = yInt - NEGATIVE_ZERO_FLOAT_BITS;\n        }\n        if (deltaPlus > maxUlps) {\n            isEqual = false;\n        } else {\n            isEqual = deltaMinus <= (maxUlps - deltaPlus);\n        }\n    }\n    return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN or if they are equal as defined\n * by {@link #equals(float,float,int) equals(x, y, maxUlps)}.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than\n * {@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float x, float y, int maxUlps) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, maxUlps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true iff they are equal as defined by\n * {@link #equals(double,double,int) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\npublic static boolean equals(double x, double y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN or they are\n * equal as defined by {@link #equals(double,double) equals(x, y, 1)}.\n *\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns {@code true} if there is no double value strictly between the\n * arguments or the difference between them is within the range of allowed\n * error (inclusive). Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed absolute error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n */\npublic static boolean equals(double x, double y, double eps) {\n    return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n}"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns {@code true} if there is no double value strictly between the\n * arguments or the relative difference between them is less than or equal\n * to the given tolerance. Returns {@code false} if either of the arguments\n * is NaN.\n *\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed relative error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n * @since 3.1\n */\npublic static boolean equalsWithRelativeTolerance(double x, double y, double eps) {\n    if (equals(x, y, 1)) {\n        return true;\n    }\n    final double absoluteMax = FastMath.max(FastMath.abs(x), FastMath.abs(y));\n    final double relativeDifference = FastMath.abs((x - y) / absoluteMax);\n    return relativeDifference <= eps;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are both NaN, are equal or are within the range\n * of allowed error (inclusive).\n *\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,\n * or both are NaN.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y, double eps) {\n    return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if the arguments are equal or within the range of allowed\n * error (inclusive).\n * <p>\n * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n * (or fewer) floating point numbers between them, i.e. two adjacent\n * floating point numbers are considered equal.\n * </p>\n * <p>\n * Adapted from <a\n * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n * Bruce Dawson</a>. Returns {@code false} if either of the arguments is NaN.\n * </p>\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between {@code x} and {@code y}.\n */\npublic static boolean equals(final double x, final double y, final int maxUlps) {\n    final long xInt = Double.doubleToRawLongBits(x);\n    final long yInt = Double.doubleToRawLongBits(y);\n    final boolean isEqual;\n    if (((xInt ^ yInt) & SGN_MASK) == 0l) {\n        // number have same sign, there is no risk of overflow\n        isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n    } else {\n        // number have opposite signs, take care of overflow\n        final long deltaPlus;\n        final long deltaMinus;\n        if (xInt < yInt) {\n            deltaPlus = yInt - POSITIVE_ZERO_DOUBLE_BITS;\n            deltaMinus = xInt - NEGATIVE_ZERO_DOUBLE_BITS;\n        } else {\n            deltaPlus = xInt - POSITIVE_ZERO_DOUBLE_BITS;\n            deltaMinus = yInt - NEGATIVE_ZERO_DOUBLE_BITS;\n        }\n        if (deltaPlus > maxUlps) {\n            isEqual = false;\n        } else {\n            isEqual = deltaMinus <= (maxUlps - deltaPlus);\n        }\n    }\n    return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Returns true if both arguments are NaN or if they are equal as defined\n * by {@link #equals(double,double,int) equals(x, y, maxUlps)}.\n *\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than\n * {@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n    return (x != x || y != y) ? !(x != x ^ y != y) : equals(x, y, maxUlps);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double round(double x, int scale) {\n    return round(x, scale, BigDecimal.ROUND_HALF_UP);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n * If {@code x} is infinite or {@code NaN}, then the value of {@code x} is\n * returned unchanged, regardless of the other parameters.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws ArithmeticException if {@code roundingMethod == ROUND_UNNECESSARY}\n * and the specified scaling operation would require rounding.\n * @throws IllegalArgumentException if {@code roundingMethod} does not\n * represent a valid rounding mode.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double round(double x, int scale, int roundingMethod) {\n    try {\n        final double rounded = (new BigDecimal(Double.toString(x)).setScale(scale, roundingMethod)).doubleValue();\n        // MATH-1089: negative values rounded to zero should result in negative zero\n        return rounded == POSITIVE_ZERO ? POSITIVE_ZERO * x : rounded;\n    } catch (NumberFormatException ex) {\n        if (Double.isInfinite(x)) {\n            return x;\n        } else {\n            return Double.NaN;\n        }\n    }\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static float round(float x, int scale) {\n    return round(x, scale, BigDecimal.ROUND_HALF_UP);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Rounds the given value to the specified number of decimal places.\n * The value is rounded using the given method which is any method defined\n * in {@link BigDecimal}.\n *\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n * @throws MathArithmeticException if an exact operation is required but result is not exact\n * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n */\npublic static float round(float x, int scale, int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException {\n    final float sign = FastMath.copySign(1f, x);\n    final float factor = (float) FastMath.pow(10.0f, scale) * sign;\n    return (float) roundUnscaled(x * factor, sign, roundingMethod) / factor;\n}"
            ],
            [
                "representableDelta",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Computes a number {@code delta} close to {@code originalDelta} with\n * the property that <pre><code>\n *   x + delta - x\n * </code></pre>\n * is exactly machine-representable.\n * This is useful when computing numerical derivatives, in order to reduce\n * roundoff errors.\n *\n * @param x Value.\n * @param originalDelta Offset value.\n * @return a number {@code delta} so that {@code x + delta} and {@code x}\n * differ by a representable floating number.\n */\npublic static double representableDelta(double x, double originalDelta) {\n    return x + originalDelta - x;\n}"
            ],
            [
                "wrap",
                "org.apache.commons.math3.util",
                "Incrementor",
                "/**\n * Create an instance that delegates everything to a {@link IntegerSequence.Incrementor}.\n * <p>\n * This factory method is intended only as a temporary hack for internal use in\n * Apache Commons Math 3.X series, when {@code Incrementor} is required in\n * interface (as a return value or in protected fields). It should <em>not</em>\n * be used in other cases. The {@link IntegerSequence.Incrementor} class should\n * be used instead of {@code Incrementor}.\n * </p>\n * <p>\n * All methods are mirrored to the underlying {@link IntegerSequence.Incrementor},\n * as long as neither {@link #setMaximalCount(int)} nor {@link #resetCount()} are called.\n * If one of these two methods is called, the created instance becomes independent\n * of the {@link IntegerSequence.Incrementor} used at creation. The rationale is that\n * {@link IntegerSequence.Incrementor} cannot change their maximal count and cannot be reset.\n * </p>\n * @param incrementor wrapped {@link IntegerSequence.Incrementor}\n * @return an incrementor wrapping an {@link IntegerSequence.Incrementor}\n * @since 3.6\n */\npublic static Incrementor wrap(final IntegerSequence.Incrementor incrementor) {\n    return new Incrementor() {\n\n        /**\n         * Underlying incrementor.\n         */\n        private IntegerSequence.Incrementor delegate;\n\n        {\n            // set up matching values at initialization\n            delegate = incrementor;\n            super.setMaximalCount(delegate.getMaximalCount());\n            super.incrementCount(delegate.getCount());\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void setMaximalCount(int max) {\n            super.setMaximalCount(max);\n            delegate = delegate.withMaximalCount(max);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void resetCount() {\n            super.resetCount();\n            delegate = delegate.withStart(0);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void incrementCount() {\n            super.incrementCount();\n            delegate.increment();\n        }\n    };\n}"
            ],
            [
                "scale",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Create a copy of an array scaled by a value.\n *\n * @param arr Array to scale.\n * @param val Scalar.\n * @return scaled copy of array with each entry multiplied by val.\n * @since 3.2\n */\npublic static double[] scale(double val, final double[] arr) {\n    double[] newArr = new double[arr.length];\n    for (int i = 0; i < arr.length; i++) {\n        newArr[i] = arr[i] * val;\n    }\n    return newArr;\n}"
            ],
            [
                "ebeAdd",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * addition of the arguments.\n *\n * @param a First term of the addition.\n * @param b Second term of the addition.\n * @return a new array {@code r} where {@code r[i] = a[i] + b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeAdd(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] += b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeSubtract",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * subtraction of the second argument from the first.\n *\n * @param a First term.\n * @param b Element to be subtracted.\n * @return a new array {@code r} where {@code r[i] = a[i] - b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeSubtract(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] -= b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeMultiply",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * multiplication of the arguments.\n *\n * @param a First factor of the multiplication.\n * @param b Second factor of the multiplication.\n * @return a new array {@code r} where {@code r[i] = a[i] * b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeMultiply(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] *= b[i];\n    }\n    return result;\n}"
            ],
            [
                "ebeDivide",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates an array whose contents will be the element-by-element\n * division of the first argument by the second.\n *\n * @param a Numerator of the division.\n * @param b Denominator of the division.\n * @return a new array {@code r} where {@code r[i] = a[i] / b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\npublic static double[] ebeDivide(double[] a, double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final double[] result = a.clone();\n    for (int i = 0; i < a.length; i++) {\n        result[i] /= b[i];\n    }\n    return result;\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>1</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance1(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        sum += FastMath.abs(p1[i] - p2[i]);\n    }\n    return sum;\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>1</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static int distance1(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    int sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        sum += FastMath.abs(p1[i] - p2[i]);\n    }\n    return sum;\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>2</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final double dp = p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return FastMath.sqrt(sum);\n}"
            ],
            [
                "cosAngle",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the cosine of the angle between two vectors.\n *\n * @param v1 Cartesian coordinates of the first vector.\n * @param v2 Cartesian coordinates of the second vector.\n * @return the cosine of the angle between the vectors.\n * @since 3.6\n */\npublic static double cosAngle(double[] v1, double[] v2) {\n    return linearCombination(v1, v2) / (safeNorm(v1) * safeNorm(v2));\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>2</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distance(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final double dp = p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return FastMath.sqrt(sum);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>&infin;</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static double distanceInf(double[] p1, double[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    double max = 0;\n    for (int i = 0; i < p1.length; i++) {\n        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n    }\n    return max;\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n *\n * @param p1 the first point\n * @param p2 the second point\n * @return the L<sub>&infin;</sub> distance between the two points\n * @throws DimensionMismatchException if the array lengths differ.\n */\npublic static int distanceInf(int[] p1, int[] p2) throws DimensionMismatchException {\n    checkEqualLength(p1, p2);\n    int max = 0;\n    for (int i = 0; i < p1.length; i++) {\n        max = FastMath.max(max, FastMath.abs(p1[i] - p2[i]));\n    }\n    return max;\n}"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that an array is monotonically increasing or decreasing.\n *\n * @param <T> the type of the elements in the specified array\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\npublic static <T extends Comparable<? super T>> boolean isMonotonic(T[] val, OrderDirection dir, boolean strict) {\n    T previous = val[0];\n    final int max = val.length;\n    for (int i = 1; i < max; i++) {\n        final int comp;\n        switch(dir) {\n            case INCREASING:\n                comp = previous.compareTo(val[i]);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            case DECREASING:\n                comp = val[i].compareTo(previous);\n                if (strict) {\n                    if (comp >= 0) {\n                        return false;\n                    }\n                } else {\n                    if (comp > 0) {\n                        return false;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n        }\n        previous = val[i];\n    }\n    return true;\n}"
            ],
            [
                "isMonotonic",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that an array is monotonically increasing or decreasing.\n *\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\npublic static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {\n    return checkOrder(val, dir, strict, false);\n}"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that both arrays have the same length.\n *\n * @param a Array.\n * @param b Array.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the arrays have the same length.\n * @throws DimensionMismatchException if the lengths differ and\n * {@code abort} is {@code true}.\n * @since 3.6\n */\npublic static boolean checkEqualLength(double[] a, double[] b, boolean abort) {\n    if (a.length == b.length) {\n        return true;\n    } else {\n        if (abort) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n        return false;\n    }\n}"
            ],
            [
                "checkEqualLength",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that both arrays have the same length.\n *\n * @param a Array.\n * @param b Array.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the arrays have the same length.\n * @throws DimensionMismatchException if the lengths differ and\n * {@code abort} is {@code true}.\n * @since 3.6\n */\npublic static boolean checkEqualLength(int[] a, int[] b, boolean abort) {\n    if (a.length == b.length) {\n        return true;\n    } else {\n        if (abort) {\n            throw new DimensionMismatchException(a.length, b.length);\n        }\n        return false;\n    }\n}"
            ],
            [
                "checkOrder",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Check that the given array is sorted.\n *\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the array is sorted.\n * @throws NonMonotonicSequenceException if the array is not sorted\n * and {@code abort} is {@code true}.\n */\npublic static boolean checkOrder(double[] val, OrderDirection dir, boolean strict, boolean abort) throws NonMonotonicSequenceException {\n    double previous = val[0];\n    final int max = val.length;\n    int index;\n    ITEM: for (index = 1; index < max; index++) {\n        switch(dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[index] <= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] < previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[index] >= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] > previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n        }\n        previous = val[index];\n    }\n    if (index == max) {\n        // Loop completed.\n        return true;\n    }\n    // Loop early exit means wrong ordering.\n    if (abort) {\n        throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n    } else {\n        return false;\n    }\n}"
            ],
            [
                "safeNorm",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns the Cartesian norm (2-norm), handling both overflow and underflow.\n * Translation of the minpack enorm subroutine.\n *\n * The redistribution policy for MINPACK is available\n * <a href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n * convenience, it is reproduced below.</p>\n *\n * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n * <tr><td>\n *    Minpack Copyright Notice (1999) University of Chicago.\n *    All rights reserved\n * </td></tr>\n * <tr><td>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * <ol>\n *  <li>Redistributions of source code must retain the above copyright\n *      notice, this list of conditions and the following disclaimer.</li>\n * <li>Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.</li>\n * <li>The end-user documentation included with the redistribution, if any,\n *     must include the following acknowledgment:\n *     {@code This product includes software developed by the University of\n *           Chicago, as Operator of Argonne National Laboratory.}\n *     Alternately, this acknowledgment may appear in the software itself,\n *     if and wherever such third-party acknowledgments normally appear.</li>\n * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n *     BE CORRECTED.</strong></li>\n * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n * <ol></td></tr>\n * </table>\n *\n * @param v Vector of doubles.\n * @return the 2-norm of the vector.\n * @since 2.2\n */\npublic static double safeNorm(double[] v) {\n    double rdwarf = 3.834e-20;\n    double rgiant = 1.304e+19;\n    double s1 = 0;\n    double s2 = 0;\n    double s3 = 0;\n    double x1max = 0;\n    double x3max = 0;\n    double floatn = v.length;\n    double agiant = rgiant / floatn;\n    for (int i = 0; i < v.length; i++) {\n        double xabs = FastMath.abs(v[i]);\n        if (xabs < rdwarf || xabs > agiant) {\n            if (xabs > rdwarf) {\n                if (xabs > x1max) {\n                    double r = x1max / xabs;\n                    s1 = 1 + s1 * r * r;\n                    x1max = xabs;\n                } else {\n                    double r = xabs / x1max;\n                    s1 += r * r;\n                }\n            } else {\n                if (xabs > x3max) {\n                    double r = x3max / xabs;\n                    s3 = 1 + s3 * r * r;\n                    x3max = xabs;\n                } else {\n                    if (xabs != 0) {\n                        double r = xabs / x3max;\n                        s3 += r * r;\n                    }\n                }\n            }\n        } else {\n            s2 += xabs * xabs;\n        }\n    }\n    double norm;\n    if (s1 != 0) {\n        norm = x1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n    } else {\n        if (s2 == 0) {\n            norm = x3max * Math.sqrt(s3);\n        } else {\n            if (s2 >= x3max) {\n                norm = Math.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n            } else {\n                norm = Math.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n            }\n        }\n    }\n    return norm;\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @return the copied array.\n */\npublic static int[] copyOf(int[] source) {\n    return copyOf(source, source.length);\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @return the copied array.\n */\npublic static double[] copyOf(double[] source) {\n    return copyOf(source, source.length);\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the source\n * length, the copy will be truncated, if larger it will padded with\n * zeroes.\n * @return the copied array.\n */\npublic static int[] copyOf(int[] source, int len) {\n    final int[] output = new int[len];\n    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n    return output;\n}"
            ],
            [
                "copyOf",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the source\n * length, the copy will be truncated, if larger it will padded with\n * zeroes.\n * @return the copied array.\n */\npublic static double[] copyOf(double[] source, int len) {\n    final double[] output = new double[len];\n    System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n    return output;\n}"
            ],
            [
                "copyOfRange",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Creates a copy of the {@code source} array.\n *\n * @param source Array to be copied.\n * @param from Initial index of the range to be copied, inclusive.\n * @param to Final index of the range to be copied, exclusive. (This index may lie outside the array.)\n * @return the copied array.\n */\npublic static double[] copyOfRange(double[] source, int from, int to) {\n    final int len = to - from;\n    final double[] output = new double[len];\n    System.arraycopy(source, from, output, 0, FastMath.min(len, source.length - from));\n    return output;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * This method computes the sum of the products\n * <code>a<sub>i</sub> b<sub>i</sub></code> to high accuracy.\n * It does so by using specific multiplication and addition algorithms to\n * preserve accuracy and reduce cancellation effects.\n * <br/>\n * It is based on the 2005 paper\n * <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump,\n * and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n *\n * @param a Factors.\n * @param b Factors.\n * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n * @throws DimensionMismatchException if arrays dimensions don't match\n */\npublic static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n    checkEqualLength(a, b);\n    final int len = a.length;\n    if (len == 1) {\n        // Revert to scalar multiplication.\n        return a[0] * b[0];\n    }\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double aHigh = Double.longBitsToDouble(Double.doubleToRawLongBits(ai) & ((-1L) << 27));\n        final double aLow = ai - aHigh;\n        final double bi = b[i];\n        final double bHigh = Double.longBitsToDouble(Double.doubleToRawLongBits(bi) & ((-1L) << 27));\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n    final double prodHighCur = prodHigh[0];\n    double prodHighNext = prodHigh[1];\n    double sHighPrev = prodHighCur + prodHighNext;\n    double sPrime = sHighPrev - prodHighNext;\n    double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n    final int lenMinusOne = len - 1;\n    for (int i = 1; i < lenMinusOne; i++) {\n        prodHighNext = prodHigh[i + 1];\n        final double sHighCur = sHighPrev + prodHighNext;\n        sPrime = sHighCur - prodHighNext;\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n        sHighPrev = sHighCur;\n    }\n    double result = sHighPrev + (prodLowSum + sLowSum);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does\n * so by using specific multiplication and addition algorithms to\n * preserve accuracy and reduce cancellation effects. It is based\n * on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub>\n * @see #linearCombination(double, double, double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // use IEEE754 floating point arithmetic rounding properties.\n    // The variable naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // final rounding, s12 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s12High + (prod1Low + prod2Low + s12Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2;\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n * to high accuracy. It does so by using specific multiplication and\n * addition algorithms to preserve accuracy and reduce cancellation effects.\n * It is based on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub>\n * @see #linearCombination(double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // do use IEEE754 floating point arithmetic rounding properties.\n    // The variables naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // split a3 and b3 as one 26 bits number and one 27 bits number\n    final double a3High = Double.longBitsToDouble(Double.doubleToRawLongBits(a3) & ((-1L) << 27));\n    final double a3Low = a3 - a3High;\n    final double b3High = Double.longBitsToDouble(Double.doubleToRawLongBits(b3) & ((-1L) << 27));\n    final double b3Low = b3 - b3High;\n    // accurate multiplication a3 * b3\n    final double prod3High = a3 * b3;\n    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n    final double s123High = s12High + prod3High;\n    final double s123Prime = s123High - prod3High;\n    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n    // final rounding, s123 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2 + a3 * b3;\n    }\n    return result;\n}"
            ],
            [
                "linearCombination",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Compute a linear combination accurately.\n * <p>\n * This method computes a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n * a<sub>4</sub>&times;b<sub>4</sub>\n * to high accuracy. It does so by using specific multiplication and\n * addition algorithms to preserve accuracy and reduce cancellation effects.\n * It is based on the 2005 paper <a\n * href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\">\n * Accurate Sum and Dot Product</a> by Takeshi Ogita,\n * Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput.\n * </p>\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @param a4 first factor of the third term\n * @param b4 second factor of the third term\n * @return a<sub>1</sub>&times;b<sub>1</sub> +\n * a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> +\n * a<sub>4</sub>&times;b<sub>4</sub>\n * @see #linearCombination(double, double, double, double)\n * @see #linearCombination(double, double, double, double, double, double)\n */\npublic static double linearCombination(final double a1, final double b1, final double a2, final double b2, final double a3, final double b3, final double a4, final double b4) {\n    // the code below is split in many additions/subtractions that may\n    // appear redundant. However, they should NOT be simplified, as they\n    // do use IEEE754 floating point arithmetic rounding properties.\n    // The variables naming conventions are that xyzHigh contains the most significant\n    // bits of xyz and xyzLow contains its least significant bits. So theoretically\n    // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n    // be represented in only one double precision number so we preserve two numbers\n    // to hold it as long as we can, combining the high and low order bits together\n    // only at the end, after cancellation may have occurred on high order bits\n    // split a1 and b1 as one 26 bits number and one 27 bits number\n    final double a1High = Double.longBitsToDouble(Double.doubleToRawLongBits(a1) & ((-1L) << 27));\n    final double a1Low = a1 - a1High;\n    final double b1High = Double.longBitsToDouble(Double.doubleToRawLongBits(b1) & ((-1L) << 27));\n    final double b1Low = b1 - b1High;\n    // accurate multiplication a1 * b1\n    final double prod1High = a1 * b1;\n    final double prod1Low = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n    // split a2 and b2 as one 26 bits number and one 27 bits number\n    final double a2High = Double.longBitsToDouble(Double.doubleToRawLongBits(a2) & ((-1L) << 27));\n    final double a2Low = a2 - a2High;\n    final double b2High = Double.longBitsToDouble(Double.doubleToRawLongBits(b2) & ((-1L) << 27));\n    final double b2Low = b2 - b2High;\n    // accurate multiplication a2 * b2\n    final double prod2High = a2 * b2;\n    final double prod2Low = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n    // split a3 and b3 as one 26 bits number and one 27 bits number\n    final double a3High = Double.longBitsToDouble(Double.doubleToRawLongBits(a3) & ((-1L) << 27));\n    final double a3Low = a3 - a3High;\n    final double b3High = Double.longBitsToDouble(Double.doubleToRawLongBits(b3) & ((-1L) << 27));\n    final double b3Low = b3 - b3High;\n    // accurate multiplication a3 * b3\n    final double prod3High = a3 * b3;\n    final double prod3Low = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n    // split a4 and b4 as one 26 bits number and one 27 bits number\n    final double a4High = Double.longBitsToDouble(Double.doubleToRawLongBits(a4) & ((-1L) << 27));\n    final double a4Low = a4 - a4High;\n    final double b4High = Double.longBitsToDouble(Double.doubleToRawLongBits(b4) & ((-1L) << 27));\n    final double b4Low = b4 - b4High;\n    // accurate multiplication a4 * b4\n    final double prod4High = a4 * b4;\n    final double prod4Low = a4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n    // accurate addition a1 * b1 + a2 * b2\n    final double s12High = prod1High + prod2High;\n    final double s12Prime = s12High - prod2High;\n    final double s12Low = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n    final double s123High = s12High + prod3High;\n    final double s123Prime = s123High - prod3High;\n    final double s123Low = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n    // accurate addition a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4\n    final double s1234High = s123High + prod4High;\n    final double s1234Prime = s1234High - prod4High;\n    final double s1234Low = (prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n    // final rounding, s1234 may have suffered many cancellations, we try\n    // to recover some bits from the extra words we have saved up to now\n    double result = s1234High + (prod1Low + prod2Low + prod3Low + prod4Low + s12Low + s123Low + s1234Low);\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = a1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n    }\n    return result;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns true iff both arguments are null or have same dimensions and all\n * their elements are equal as defined by\n * {@link Precision#equals(float,float)}.\n *\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension\n * and equal elements.\n */\npublic static boolean equals(float[] x, float[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equals(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns true iff both arguments are null or have same dimensions and all\n * their elements are equal as defined by\n * {@link Precision#equalsIncludingNaN(double,double) this method}.\n *\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension and\n * equal elements\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(float[] x, float[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns {@code true} iff both arguments are {@code null} or have same\n * dimensions and all their elements are equal as defined by\n * {@link Precision#equals(double,double)}.\n *\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have same\n * dimension and equal elements.\n */\npublic static boolean equals(double[] x, double[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equals(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "equalsIncludingNaN",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns {@code true} iff both arguments are {@code null} or have same\n * dimensions and all their elements are equal as defined by\n * {@link Precision#equalsIncludingNaN(double,double) this method}.\n *\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have same\n * dimension and equal elements.\n * @since 2.2\n */\npublic static boolean equalsIncludingNaN(double[] x, double[] y) {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
            ],
            [
                "normalizeArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Normalizes an array to make it sum to a specified value.\n * Returns the result of the transformation\n * <pre>\n *    x |-> x * normalizedSum / sum\n * </pre>\n * applied to each non-NaN element x of the input array, where sum is the\n * sum of the non-NaN entries in the input array.\n * <p>\n * Throws IllegalArgumentException if {@code normalizedSum} is infinite\n * or NaN and ArithmeticException if the input array contains any infinite elements\n * or sums to 0.\n * <p>\n * Ignores (i.e., copies unchanged to the output array) NaNs in the input array.\n *\n * @param values Input array to be normalized\n * @param normalizedSum Target sum for the normalized array\n * @return the normalized array.\n * @throws MathArithmeticException if the input array contains infinite\n * elements or sums to zero.\n * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.\n * @since 2.1\n */\npublic static double[] normalizeArray(double[] values, double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n    }\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n    }\n    double sum = 0d;\n    final int len = values.length;\n    double[] out = new double[len];\n    for (int i = 0; i < len; i++) {\n        if (Double.isInfinite(values[i])) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, values[i], i);\n        }\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n    }\n    for (int i = 0; i < len; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Build an array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n *\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param length of the array\n * @return a new array\n * @since 3.2\n */\npublic static <T> T[] buildArray(final Field<T> field, final int length) {\n    // OK because field must be correct class\n    @SuppressWarnings(\"unchecked\")\n    T[] array = (T[]) Array.newInstance(field.getRuntimeClass(), length);\n    Arrays.fill(array, field.getZero());\n    return array;\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Build a double dimension  array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n *\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param rows number of rows in the array\n * @param columns number of columns (may be negative to build partial\n * arrays in the same way <code>new Field[rows][]</code> works)\n * @return a new array\n * @since 3.2\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n    final T[][] array;\n    if (columns < 0) {\n        T[] dummyRow = buildArray(field, 0);\n        array = (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n    } else {\n        array = (T[][]) Array.newInstance(field.getRuntimeClass(), new int[] { rows, columns });\n        for (int i = 0; i < rows; ++i) {\n            Arrays.fill(array[i], field.getZero());\n        }\n    }\n    return array;\n}"
            ],
            [
                "convolve",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Calculates the <a href=\"http://en.wikipedia.org/wiki/Convolution\">\n * convolution</a> between two sequences.\n * <p>\n * The solution is obtained via straightforward computation of the\n * convolution sum (and not via FFT). Whenever the computation needs\n * an element that would be located at an index outside the input arrays,\n * the value is assumed to be zero.\n *\n * @param x First sequence.\n * Typically, this sequence will represent an input signal to a system.\n * @param h Second sequence.\n * Typically, this sequence will represent the impulse response of the system.\n * @return the convolution of {@code x} and {@code h}.\n * This array's length will be {@code x.length + h.length - 1}.\n * @throws NullArgumentException if either {@code x} or {@code h} is {@code null}.\n * @throws NoDataException if either {@code x} or {@code h} is empty.\n *\n * @since 3.3\n */\npublic static double[] convolve(double[] x, double[] h) throws NullArgumentException, NoDataException {\n    MathUtils.checkNotNull(x);\n    MathUtils.checkNotNull(h);\n    final int xLen = x.length;\n    final int hLen = h.length;\n    if (xLen == 0 || hLen == 0) {\n        throw new NoDataException();\n    }\n    // initialize the output array\n    final int totalLength = xLen + hLen - 1;\n    final double[] y = new double[totalLength];\n    // straightforward implementation of the convolution sum\n    for (int n = 0; n < totalLength; n++) {\n        double yn = 0;\n        int k = FastMath.max(0, n + 1 - xLen);\n        int j = n - k;\n        while (k < hLen && j >= 0) {\n            yn += x[j--] * h[k++];\n        }\n        y[n] = yn;\n    }\n    return y;\n}"
            ],
            [
                "natural",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array representing the natural number {@code n}.\n *\n * @param n Natural number.\n * @return an array whose entries are the numbers 0, 1, ..., {@code n}-1.\n * If {@code n == 0}, the returned array is empty.\n */\npublic static int[] natural(int n) {\n    return sequence(n, 0, 1);\n}"
            ],
            [
                "sequence",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array of {@code size} integers starting at {@code start},\n * skipping {@code stride} numbers.\n *\n * @param size Natural number.\n * @param start Natural number.\n * @param stride Natural number.\n * @return an array whose entries are the numbers\n * {@code start, start + stride, ..., start + (size - 1) * stride}.\n * If {@code size == 0}, the returned array is empty.\n *\n * @since 3.4\n */\npublic static int[] sequence(int size, int start, int stride) {\n    final int[] a = new int[size];\n    for (int i = 0; i < size; i++) {\n        a[i] = start + i * stride;\n    }\n    return a;\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the input parameters designate a subarray of positive length.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * positive length</li>\n * <li>throws <code>MathIllegalArgumentException</code> if the array is null or\n * or the indices are invalid</li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0.\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return true if the parameters are valid and designate a subarray of positive length\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return verifyValues(values, begin, length, false);\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the input parameters designate a subarray of positive length.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * non-negative length</li>\n * <li>throws <code>IllegalArgumentException</code> if the array is null or\n * or the indices are invalid</li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @param allowEmpty if <code>true</code> then zero length arrays are allowed\n * @return true if the parameters are valid\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {\n    if (values == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    if (begin < 0) {\n        throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));\n    }\n    if (length < 0) {\n        throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));\n    }\n    if (begin + length > values.length) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END, Integer.valueOf(begin + length), Integer.valueOf(values.length), true);\n    }\n    if (length == 0 && !allowEmpty) {\n        return false;\n    }\n    return true;\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the begin and length parameters designate a subarray of positive length\n * and the weights are all non-negative, non-NaN, finite, and not all zero.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * positive length and the weights array contains legitimate values.</li>\n * <li>throws <code>IllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li></ul>\n * </li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0.\n * </ul></p>\n *\n * @param values the input array\n * @param weights the weights array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return true if the parameters are valid and designate a subarray of positive length\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length) throws MathIllegalArgumentException {\n    return verifyValues(values, weights, begin, length, false);\n}"
            ],
            [
                "verifyValues",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * This method is used\n * to verify that the begin and length parameters designate a subarray of positive length\n * and the weights are all non-negative, non-NaN, finite, and not all zero.\n * <p>\n * <ul>\n * <li>returns <code>true</code> iff the parameters designate a subarray of\n * non-negative length and the weights array contains legitimate values.</li>\n * <li>throws <code>MathIllegalArgumentException</code> if any of the following are true:\n * <ul><li>the values array is null</li>\n *     <li>the weights array is null</li>\n *     <li>the weights array does not have the same length as the values array</li>\n *     <li>the weights array contains one or more infinite values</li>\n *     <li>the weights array contains one or more NaN values</li>\n *     <li>the weights array contains negative values</li>\n *     <li>the start and length arguments do not determine a valid array</li></ul>\n * </li>\n * <li>returns <code>false</li> if the array is non-null, but\n * <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code>.\n * </ul></p>\n *\n * @param values the input array.\n * @param weights the weights array.\n * @param begin index of the first array element to include.\n * @param length the number of elements to include.\n * @param allowEmpty if {@code true} than allow zero length arrays to pass.\n * @return {@code true} if the parameters are valid.\n * @throws NullArgumentException if either of the arrays are null\n * @throws MathIllegalArgumentException if the array indices are not valid,\n * the weights array contains NaN, infinite or negative elements, or there\n * are no positive weights.\n * @since 3.3\n */\npublic static boolean verifyValues(final double[] values, final double[] weights, final int begin, final int length, final boolean allowEmpty) throws MathIllegalArgumentException {\n    if (weights == null || values == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    checkEqualLength(weights, values);\n    boolean containsPositiveWeight = false;\n    for (int i = begin; i < begin + length; i++) {\n        final double weight = weights[i];\n        if (Double.isNaN(weight)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_ELEMENT_AT_INDEX, Integer.valueOf(i));\n        }\n        if (Double.isInfinite(weight)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT, Double.valueOf(weight), Integer.valueOf(i));\n        }\n        if (weight < 0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX, Integer.valueOf(i), Double.valueOf(weight));\n        }\n        if (!containsPositiveWeight && weight > 0.0) {\n            containsPositiveWeight = true;\n        }\n    }\n    if (!containsPositiveWeight) {\n        throw new MathIllegalArgumentException(LocalizedFormats.WEIGHT_AT_LEAST_ONE_NON_ZERO);\n    }\n    return verifyValues(values, begin, length, allowEmpty);\n}"
            ],
            [
                "concatenate",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Concatenates a sequence of arrays. The return array consists of the\n * entries of the input arrays concatenated in the order they appear in\n * the argument list.  Null arrays cause NullPointerExceptions; zero\n * length arrays are allowed (contributing nothing to the output array).\n *\n * @param x list of double[] arrays to concatenate\n * @return a new array consisting of the entries of the argument arrays\n * @throws NullPointerException if any of the arrays are null\n * @since 3.6\n */\npublic static double[] concatenate(double[]... x) {\n    int combinedLength = 0;\n    for (double[] a : x) {\n        combinedLength += a.length;\n    }\n    int offset = 0;\n    int curLength = 0;\n    final double[] combined = new double[combinedLength];\n    for (int i = 0; i < x.length; i++) {\n        curLength = x[i].length;\n        System.arraycopy(x[i], 0, combined, offset, curLength);\n        offset += curLength;\n    }\n    return combined;\n}"
            ],
            [
                "unique",
                "org.apache.commons.math3.util",
                "MathArrays",
                "/**\n * Returns an array consisting of the unique values in {@code data}.\n * The return array is sorted in descending order.  Empty arrays\n * are allowed, but null arrays result in NullPointerException.\n * Infinities are allowed.  NaN values are allowed with maximum\n * sort order - i.e., if there are NaN values in {@code data},\n * {@code Double.NaN} will be the first element of the output array,\n * even if the array also contains {@code Double.POSITIVE_INFINITY}.\n *\n * @param data array to scan\n * @return descending list of values included in the input array\n * @throws NullPointerException if data is null\n * @since 3.6\n */\npublic static double[] unique(double[] data) {\n    TreeSet<Double> values = new TreeSet<Double>();\n    for (int i = 0; i < data.length; i++) {\n        values.add(data[i]);\n    }\n    final int count = values.size();\n    final double[] out = new double[count];\n    Iterator<Double> iterator = values.iterator();\n    int i = 0;\n    while (iterator.hasNext()) {\n        out[count - ++i] = iterator.next();\n    }\n    return out;\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Pair",
                "/**\n * Convenience factory method that calls the\n * {@link #Pair(Object, Object) constructor}.\n *\n * @param <K> the key type\n * @param <V> the value type\n * @param k First element of the pair.\n * @param v Second element of the pair.\n * @return a new {@code Pair} containing {@code k} and {@code v}.\n * @since 3.3\n */\npublic static <K, V> Pair<K, V> create(K k, V v) {\n    return new Pair<K, V>(k, v);\n}"
            ],
            [
                "slowCos",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n *  For x between 0 and pi/4 compute cosine using Talor series\n *  cos(x) = 1 - x^2/2! + x^4/4! ...\n * @param x number from which cosine is requested\n * @param result placeholder where to put the result in extended precision\n * (may be null)\n * @return cos(x)\n */\nstatic double slowCos(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        if ((i & 1) != 0) {\n            // skip odd entries\n            continue;\n        }\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        if ((i & 2) != 0) {\n            // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowSin",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * For x between 0 and pi/4 compute sine using Taylor expansion:\n * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...\n * @param x number from which sine is requested\n * @param result placeholder where to put the result in extended precision\n * (may be null)\n * @return sin(x)\n */\nstatic double slowSin(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        if ((i & 1) == 0) {\n            // Ignore even numbers\n            continue;\n        }\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        if ((i & 2) != 0) {\n            // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowexp",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n *  For x between 0 and 1, returns exp(x), uses extended precision\n *  @param x argument of exponential\n *  @param result placeholder where to place exp(x) split in two terms\n *  for extra precision (i.e. exp(x) = result[0] + result[1]\n *  @return exp(x)\n */\nstatic double slowexp(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "expint",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * Compute exp(p) for a integer p in extended precision.\n * @param p integer whose exponential is requested\n * @param result placeholder where to put the result in extended precision\n * @return exp(p) in standard precision (equal to result[0] + result[1])\n */\nstatic double expint(int p, final double[] result) {\n    //double x = M_E;\n    final double[] xs = new double[2];\n    final double[] as = new double[2];\n    final double[] ys = new double[2];\n    //split(x, xs);\n    //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n    //xs[0] = 2.71827697753906250000;\n    //xs[1] = 4.85091998273542816811e-06;\n    //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n    //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n    /* E */\n    xs[0] = 2.718281828459045;\n    xs[1] = 1.4456468917292502E-16;\n    split(1.0, ys);\n    while (p > 0) {\n        if ((p & 1) != 0) {\n            quadMult(ys, xs, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n        quadMult(xs, xs, as);\n        xs[0] = as[0];\n        xs[1] = as[1];\n        p >>= 1;\n    }\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n        resplit(result);\n    }\n    return ys[0] + ys[1];\n}"
            ],
            [
                "slowLog",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * xi in the range of [1, 2].\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      1-x           \\          3        5        7          /\n *\n * So, compute a Remez approximation of the following function\n *\n *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n *\n * This will be an even function with only positive coefficents.\n * x is in the range [0 - 1/3].\n *\n * Transform xi for input to the above function by setting\n * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n * the result is multiplied by x.\n * @param xi number from which log is requested\n * @return log(xi)\n */\nstatic double[] slowLog(double xi) {\n    double[] x = new double[2];\n    double[] x2 = new double[2];\n    double[] y = new double[2];\n    double[] a = new double[2];\n    split(xi, x);\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a, y);\n    x[0] = y[0];\n    x[1] = y[1];\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n    //x[0] -= 1.0;\n    //resplit(x);\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][1];\n    for (int i = LN_SPLIT_COEF.length - 2; i >= 0; i--) {\n        splitMult(y, x2, a);\n        y[0] = a[0];\n        y[1] = a[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a);\n        y[0] = a[0];\n        y[1] = a[1];\n    }\n    splitMult(y, x, a);\n    y[0] = a[0];\n    y[1] = a[1];\n    return y;\n}"
            ],
            [
                "format",
                "org.apache.commons.math3.util",
                "FastMathCalc",
                "/**\n * Format a double.\n * @param d double number to format\n * @return formatted number\n */\nstatic String format(double d) {\n    if (d != d) {\n        return \"Double.NaN,\";\n    } else {\n        return ((d >= 0) ? \"+\" : \"\") + Double.toString(d) + \"d,\";\n    }\n}"
            ],
            [
                "sqrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the square root of a number.\n * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n * @param a number on which evaluation is done\n * @return square root of a\n */\npublic static double sqrt(final double a) {\n    return Math.sqrt(a);\n}"
            ],
            [
                "cosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic cosine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic cosine of x\n */\npublic static double cosh(double x) {\n    if (x != x) {\n        return x;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        if (x >= LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(x);\n        }\n    } else if (x < -20) {\n        if (x <= -LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(-0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(-x);\n        }\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}"
            ],
            [
                "sinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic sine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic sine of x\n */\npublic static double sinh(double x) {\n    boolean negate = false;\n    if (x != x) {\n        return x;\n    }\n    // sinh[z] = (exp(z) - exp(-z) / 2\n    // for values of z larger than about 20,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        if (x >= LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(0.5 * x);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(x);\n        }\n    } else if (x < -20) {\n        if (x <= -LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(-0.5 * x);\n            return (-0.5 * t) * t;\n        } else {\n            return -0.5 * exp(-x);\n        }\n    }\n    if (x == 0) {\n        return x;\n    }\n    if (x < 0.0) {\n        x = -x;\n        negate = true;\n    }\n    double result;\n    if (x > 0.25) {\n        double[] hiPrec = new double[2];\n        exp(x, 0.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n        // recip = 1/y\n        double recip = 1.0 / ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n        // Correct for rounding in division\n        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n        // Account for yb\n        recipb += -yb * recip * recip;\n        recipa = -recipa;\n        recipb = -recipb;\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n        result = ya + yb;\n        result *= 0.5;\n    } else {\n        double[] hiPrec = new double[2];\n        expm1(x, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n        double denom = 1.0 + ya;\n        double denomr = 1.0 / denom;\n        double denomb = -(denom - 1.0 - ya) + yb;\n        double ratio = ya * denomr;\n        double temp = ratio * HEX_40000000;\n        double ra = ratio + temp - temp;\n        double rb = ratio - ra;\n        temp = denom * HEX_40000000;\n        double za = denom + temp - temp;\n        double zb = denom - za;\n        rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n        // Adjust for yb\n        // numerator\n        rb += yb * denomr;\n        // denominator\n        rb += -ya * denomb * denomr * denomr;\n        // y = y - 1/y\n        temp = ya + ra;\n        yb += -(temp - ya - ra);\n        ya = temp;\n        temp = ya + rb;\n        yb += -(temp - ya - rb);\n        ya = temp;\n        result = ya + yb;\n        result *= 0.5;\n    }\n    if (negate) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "tanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the hyperbolic tangent of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic tangent of x\n */\npublic static double tanh(double x) {\n    boolean negate = false;\n    if (x != x) {\n        return x;\n    }\n    // tanh[z] = sinh[z] / cosh[z]\n    // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n    // = (exp(2x) - 1) / (exp(2x) + 1)\n    // for magnitude > 20, sinh[z] == cosh[z] in double precision\n    if (x > 20.0) {\n        return 1.0;\n    }\n    if (x < -20) {\n        return -1.0;\n    }\n    if (x == 0) {\n        return x;\n    }\n    if (x < 0.0) {\n        x = -x;\n        negate = true;\n    }\n    double result;\n    if (x >= 0.5) {\n        double[] hiPrec = new double[2];\n        // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n        exp(x * 2.0, 0.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Numerator */\n        double na = -1.0 + ya;\n        double nb = -(na + 1.0 - ya);\n        double temp = na + yb;\n        nb += -(temp - na - yb);\n        na = temp;\n        /* Denominator */\n        double da = 1.0 + ya;\n        double db = -(da - 1.0 - ya);\n        temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n        result = ratioa + ratiob;\n    } else {\n        double[] hiPrec = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x * 2.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n        // ratio = na/da\n        double ratio = na / da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n        // Correct for rounding in division\n        ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n        result = ratioa + ratiob;\n    }\n    if (negate) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "acosh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic cosine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic cosine of a\n */\npublic static double acosh(final double a) {\n    return FastMath.log(a + FastMath.sqrt(a * a - 1));\n}"
            ],
            [
                "asinh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic sine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic sine of a\n */\npublic static double asinh(double a) {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAsinh;\n    if (a > 0.167) {\n        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);\n        }\n    }\n    return negative ? -absAsinh : absAsinh;\n}"
            ],
            [
                "atanh",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the inverse hyperbolic tangent of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic tangent of a\n */\npublic static double atanh(double a) {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.15) {\n        absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n    } else {\n        final double a2 = a * a;\n        if (a > 0.087) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n        } else if (a > 0.031) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n        } else if (a > 0.003) {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n        } else {\n            absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n        }\n    }\n    return negative ? -absAtanh : absAtanh;\n}"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the signum of a number.\n * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\npublic static double signum(final double a) {\n    // return +0.0/-0.0/NaN depending on a\n    return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a);\n}"
            ],
            [
                "signum",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the signum of a number.\n * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\npublic static float signum(final float a) {\n    // return +0.0/-0.0/NaN depending on a\n    return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a);\n}"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\npublic static double nextUp(final double a) {\n    return nextAfter(a, Double.POSITIVE_INFINITY);\n}"
            ],
            [
                "nextUp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\npublic static float nextUp(final float a) {\n    return nextAfter(a, Float.POSITIVE_INFINITY);\n}"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards negative infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards negative infinity\n * @since 3.4\n */\npublic static double nextDown(final double a) {\n    return nextAfter(a, Double.NEGATIVE_INFINITY);\n}"
            ],
            [
                "nextDown",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute next number towards negative infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards negative infinity\n * @since 3.4\n */\npublic static float nextDown(final float a) {\n    return nextAfter(a, Float.NEGATIVE_INFINITY);\n}"
            ],
            [
                "random",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns a pseudo-random number between 0.0 and 1.0.\n * <p><b>Note:</b> this implementation currently delegates to {@link Math#random}\n * @return a random number between 0.0 and 1.0\n */\npublic static double random() {\n    return Math.random();\n}"
            ],
            [
                "exp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Exponential function.\n *\n * Computes exp(x), function result is nearly rounded.   It will be correctly\n * rounded to the theoretical value for 99.9% of input values, otherwise it will\n * have a 1 ULP error.\n *\n * Method:\n *    Lookup intVal = exp(int(x))\n *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );\n *    Compute z as the exponential of the remaining bits by a polynomial minus one\n *    exp(x) = intVal * fracVal * (1 + z)\n *\n * Accuracy:\n *    Calculation is done with 63 bits of precision, so result should be correctly\n *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n *\n * @param x   a double\n * @return double e<sup>x</sup>\n */\npublic static double exp(double x) {\n    return exp(x, 0.0, null);\n}"
            ],
            [
                "expm1",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute exp(x) - 1\n * @param x number to compute shifted exponential\n * @return exp(x) - 1\n */\npublic static double expm1(double x) {\n    return expm1(x, null);\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Natural logarithm.\n *\n * @param x   a double\n * @return log(x)\n */\npublic static double log(final double x) {\n    return log(x, null);\n}"
            ],
            [
                "log1p",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes log(1 + x).\n *\n * @param x Number.\n * @return {@code log(1 + x)}.\n */\npublic static double log1p(final double x) {\n    if (x == -1) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (x == Double.POSITIVE_INFINITY) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (x > 1e-6 || x < -1e-6) {\n        final double xpa = 1 + x;\n        final double xpb = -(xpa - 1 - x);\n        final double[] hiPrec = new double[2];\n        final double lores = log(xpa, hiPrec);\n        if (Double.isInfinite(lores)) {\n            // Don't allow this to be converted to NaN\n            return lores;\n        }\n        // Do a taylor series expansion around xpa:\n        //   f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2\n        final double fx1 = xpb / xpa;\n        final double epsilon = 0.5 * fx1 + 1;\n        return epsilon * fx1 + hiPrec[1] + hiPrec[0];\n    } else {\n        // Value is small |x| < 1e6, do a Taylor series centered on 1.\n        final double y = (x * F_1_3 - F_1_2) * x + 1;\n        return y * x;\n    }\n}"
            ],
            [
                "log10",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the base 10 logarithm.\n * @param x a number\n * @return log10(x)\n */\npublic static double log10(final double x) {\n    final double[] hiPrec = new double[2];\n    final double lores = log(x, hiPrec);\n    if (Double.isInfinite(lores)) {\n        // don't allow this to be converted to NaN\n        return lores;\n    }\n    final double tmp = hiPrec[0] * HEX_40000000;\n    final double lna = hiPrec[0] + tmp - tmp;\n    final double lnb = hiPrec[0] - lna + hiPrec[1];\n    final double rln10a = 0.4342944622039795;\n    final double rln10b = 1.9699272335463627E-8;\n    return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes the <a href=\"http://mathworld.wolfram.com/Logarithm.html\">\n * logarithm</a> in a given base.\n *\n * Returns {@code NaN} if either argument is negative.\n * If {@code base} is 0 and {@code x} is positive, 0 is returned.\n * If {@code base} is positive and {@code x} is 0,\n * {@code Double.NEGATIVE_INFINITY} is returned.\n * If both arguments are 0, the result is {@code NaN}.\n *\n * @param base Base of the logarithm, must be greater than 0.\n * @param x Argument, must be greater than 0.\n * @return the value of the logarithm, i.e. the number {@code y} such that\n * <code>base<sup>y</sup> = x</code>.\n * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0)\n */\npublic static double log(double base, double x) {\n    return log(x) / log(base);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Power function.  Compute x^y.\n *\n * @param x   a double\n * @param y   a double\n * @return double\n */\npublic static double pow(final double x, final double y) {\n    if (y == 0) {\n        // y = -0 or y = +0\n        return 1.0;\n    } else {\n        final long yBits = Double.doubleToRawLongBits(y);\n        final int yRawExp = (int) ((yBits & MASK_DOUBLE_EXPONENT) >> 52);\n        final long yRawMantissa = yBits & MASK_DOUBLE_MANTISSA;\n        final long xBits = Double.doubleToRawLongBits(x);\n        final int xRawExp = (int) ((xBits & MASK_DOUBLE_EXPONENT) >> 52);\n        final long xRawMantissa = xBits & MASK_DOUBLE_MANTISSA;\n        if (yRawExp > 1085) {\n            // y is either a very large integral value that does not fit in a long or it is a special number\n            if ((yRawExp == 2047 && yRawMantissa != 0) || (xRawExp == 2047 && xRawMantissa != 0)) {\n                // NaN\n                return Double.NaN;\n            } else if (xRawExp == 1023 && xRawMantissa == 0) {\n                // x = -1.0 or x = +1.0\n                if (yRawExp == 2047) {\n                    // y is infinite\n                    return Double.NaN;\n                } else {\n                    // y is a large even integer\n                    return 1.0;\n                }\n            } else {\n                // the absolute value of x is either greater or smaller than 1.0\n                // if yRawExp == 2047 and mantissa is 0, y = -infinity or y = +infinity\n                // if 1085 < yRawExp < 2047, y is simply a large number, however, due to limited\n                // accuracy, at this magnitude it behaves just like infinity with regards to x\n                if ((y > 0) ^ (xRawExp < 1023)) {\n                    // either y = +infinity (or large engouh) and abs(x) > 1.0\n                    // or     y = -infinity (or large engouh) and abs(x) < 1.0\n                    return Double.POSITIVE_INFINITY;\n                } else {\n                    // either y = +infinity (or large engouh) and abs(x) < 1.0\n                    // or     y = -infinity (or large engouh) and abs(x) > 1.0\n                    return +0.0;\n                }\n            }\n        } else {\n            // y is a regular non-zero number\n            if (yRawExp >= 1023) {\n                // y may be an integral value, which should be handled specifically\n                final long yFullMantissa = IMPLICIT_HIGH_BIT | yRawMantissa;\n                if (yRawExp < 1075) {\n                    // normal number with negative shift that may have a fractional part\n                    final long integralMask = (-1L) << (1075 - yRawExp);\n                    if ((yFullMantissa & integralMask) == yFullMantissa) {\n                        // all fractional bits are 0, the number is really integral\n                        final long l = yFullMantissa >> (1075 - yRawExp);\n                        return FastMath.pow(x, (y < 0) ? -l : l);\n                    }\n                } else {\n                    // normal number with positive shift, always an integral value\n                    // we know it fits in a primitive long because yRawExp > 1085 has been handled above\n                    final long l = yFullMantissa << (yRawExp - 1075);\n                    return FastMath.pow(x, (y < 0) ? -l : l);\n                }\n            }\n            // y is a non-integral value\n            if (x == 0) {\n                // x = -0 or x = +0\n                // the integer powers have already been handled above\n                return y < 0 ? Double.POSITIVE_INFINITY : +0.0;\n            } else if (xRawExp == 2047) {\n                if (xRawMantissa == 0) {\n                    // x = -infinity or x = +infinity\n                    return (y < 0) ? +0.0 : Double.POSITIVE_INFINITY;\n                } else {\n                    // NaN\n                    return Double.NaN;\n                }\n            } else if (x < 0) {\n                // the integer powers have already been handled above\n                return Double.NaN;\n            } else {\n                // this is the general case, for regular fractional numbers x and y\n                // Split y into ya and yb such that y = ya+yb\n                final double tmp = y * HEX_40000000;\n                final double ya = (y + tmp) - tmp;\n                final double yb = y - ya;\n                /* Compute ln(x) */\n                final double[] lns = new double[2];\n                final double lores = log(x, lns);\n                if (Double.isInfinite(lores)) {\n                    // don't allow this to be converted to NaN\n                    return lores;\n                }\n                double lna = lns[0];\n                double lnb = lns[1];\n                /* resplit lns */\n                final double tmp1 = lna * HEX_40000000;\n                final double tmp2 = (lna + tmp1) - tmp1;\n                lnb += lna - tmp2;\n                lna = tmp2;\n                // y*ln(x) = (aa+ab)\n                final double aa = lna * ya;\n                final double ab = lna * yb + lnb * ya + lnb * yb;\n                lna = aa + ab;\n                lnb = -(lna - aa - ab);\n                double z = 1.0 / 120.0;\n                z = z * lnb + (1.0 / 24.0);\n                z = z * lnb + (1.0 / 6.0);\n                z = z * lnb + 0.5;\n                z = z * lnb + 1.0;\n                z *= lnb;\n                final double result = exp(lna, z, null);\n                //result = result + result * z;\n                return result;\n            }\n        }\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Raise a double to an int power.\n *\n * @param d Number to raise.\n * @param e Exponent.\n * @return d<sup>e</sup>\n * @since 3.1\n */\npublic static double pow(double d, int e) {\n    return pow(d, (long) e);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Raise a double to a long power.\n *\n * @param d Number to raise.\n * @param e Exponent.\n * @return d<sup>e</sup>\n * @since 3.6\n */\npublic static double pow(double d, long e) {\n    if (e == 0) {\n        return 1.0;\n    } else if (e > 0) {\n        return new Split(d).pow(e).full;\n    } else {\n        return new Split(d).reciprocal().pow(-e).full;\n    }\n}"
            ],
            [
                "sin",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Sine function.\n *\n * @param x Argument.\n * @return sin(x)\n */\npublic static double sin(double x) {\n    boolean negative = false;\n    int quadrant = 0;\n    double xa;\n    double xb = 0.0;\n    /* Take absolute value of the input */\n    xa = x;\n    if (x < 0) {\n        negative = true;\n        xa = -xa;\n    }\n    /* Check for zero and negative zero */\n    if (xa == 0.0) {\n        long bits = Double.doubleToRawLongBits(x);\n        if (bits < 0) {\n            return -0.0;\n        }\n        return 0.0;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    if (negative) {\n        // Flip bit 1\n        quadrant ^= 2;\n    }\n    switch(quadrant) {\n        case 0:\n            return sinQ(xa, xb);\n        case 1:\n            return cosQ(xa, xb);\n        case 2:\n            return -sinQ(xa, xb);\n        case 3:\n            return -cosQ(xa, xb);\n        default:\n            return Double.NaN;\n    }\n}"
            ],
            [
                "cos",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Cosine function.\n *\n * @param x Argument.\n * @return cos(x)\n */\npublic static double cos(double x) {\n    int quadrant = 0;\n    /* Take absolute value of the input */\n    double xa = x;\n    if (x < 0) {\n        xa = -xa;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    double xb = 0;\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    //if (negative)\n    //  quadrant = (quadrant + 2) % 4;\n    switch(quadrant) {\n        case 0:\n            return cosQ(xa, xb);\n        case 1:\n            return -sinQ(xa, xb);\n        case 2:\n            return -cosQ(xa, xb);\n        case 3:\n            return sinQ(xa, xb);\n        default:\n            return Double.NaN;\n    }\n}"
            ],
            [
                "tan",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Tangent function.\n *\n * @param x Argument.\n * @return tan(x)\n */\npublic static double tan(double x) {\n    boolean negative = false;\n    int quadrant = 0;\n    /* Take absolute value of the input */\n    double xa = x;\n    if (x < 0) {\n        negative = true;\n        xa = -xa;\n    }\n    /* Check for zero and negative zero */\n    if (xa == 0.0) {\n        long bits = Double.doubleToRawLongBits(x);\n        if (bits < 0) {\n            return -0.0;\n        }\n        return 0.0;\n    }\n    if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n        return Double.NaN;\n    }\n    /* Perform any argument reduction */\n    double xb = 0;\n    if (xa > 3294198.0) {\n        // PI * (2**20)\n        // Argument too big for CodyWaite reduction.  Must use\n        // PayneHanek.\n        double[] reduceResults = new double[3];\n        reducePayneHanek(xa, reduceResults);\n        quadrant = ((int) reduceResults[0]) & 3;\n        xa = reduceResults[1];\n        xb = reduceResults[2];\n    } else if (xa > 1.5707963267948966) {\n        final CodyWaite cw = new CodyWaite(xa);\n        quadrant = cw.getK() & 3;\n        xa = cw.getRemA();\n        xb = cw.getRemB();\n    }\n    if (xa > 1.5) {\n        // Accuracy suffers between 1.5 and PI/2\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n        xa = a + b;\n        xb = -(xa - a - b);\n        quadrant ^= 1;\n        negative ^= true;\n    }\n    double result;\n    if ((quadrant & 1) == 0) {\n        result = tanQ(xa, xb, false);\n    } else {\n        result = -tanQ(xa, xb, true);\n    }\n    if (negative) {\n        result = -result;\n    }\n    return result;\n}"
            ],
            [
                "atan",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Arctangent function\n *  @param x a number\n *  @return atan(x)\n */\npublic static double atan(double x) {\n    return atan(x, 0.0, false);\n}"
            ],
            [
                "atan2",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Two arguments arctangent function\n * @param y ordinate\n * @param x abscissa\n * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\n */\npublic static double atan2(double y, double x) {\n    if (x != x || y != y) {\n        return Double.NaN;\n    }\n    if (y == 0) {\n        final double result = x * y;\n        final double invx = 1d / x;\n        final double invy = 1d / y;\n        if (invx == 0) {\n            // X is infinite\n            if (x > 0) {\n                // return +/- 0.0\n                return y;\n            } else {\n                return copySign(Math.PI, y);\n            }\n        }\n        if (x < 0 || invx < 0) {\n            if (y < 0 || invy < 0) {\n                return -Math.PI;\n            } else {\n                return Math.PI;\n            }\n        } else {\n            return result;\n        }\n    }\n    // y cannot now be zero\n    if (y == Double.POSITIVE_INFINITY) {\n        if (x == Double.POSITIVE_INFINITY) {\n            return Math.PI * F_1_4;\n        }\n        if (x == Double.NEGATIVE_INFINITY) {\n            return Math.PI * F_3_4;\n        }\n        return Math.PI * F_1_2;\n    }\n    if (y == Double.NEGATIVE_INFINITY) {\n        if (x == Double.POSITIVE_INFINITY) {\n            return -Math.PI * F_1_4;\n        }\n        if (x == Double.NEGATIVE_INFINITY) {\n            return -Math.PI * F_3_4;\n        }\n        return -Math.PI * F_1_2;\n    }\n    if (x == Double.POSITIVE_INFINITY) {\n        if (y > 0 || 1 / y > 0) {\n            return 0d;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -0d;\n        }\n    }\n    if (x == Double.NEGATIVE_INFINITY) {\n        if (y > 0.0 || 1 / y > 0.0) {\n            return Math.PI;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -Math.PI;\n        }\n    }\n    // Neither y nor x can be infinite or NAN here\n    if (x == 0) {\n        if (y > 0 || 1 / y > 0) {\n            return Math.PI * F_1_2;\n        }\n        if (y < 0 || 1 / y < 0) {\n            return -Math.PI * F_1_2;\n        }\n    }\n    // Compute ratio r = y/x\n    final double r = y / x;\n    if (Double.isInfinite(r)) {\n        // bypass calculations that can create NaN\n        return atan(r, 0, x < 0);\n    }\n    double ra = doubleHighPart(r);\n    double rb = r - ra;\n    // Split x\n    final double xa = doubleHighPart(x);\n    final double xb = x - xa;\n    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n    final double temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    if (ra == 0) {\n        // Fix up the sign so atan works correctly\n        ra = copySign(0d, y);\n    }\n    // Call atan\n    final double result = atan(ra, rb, x < 0);\n    return result;\n}"
            ],
            [
                "asin",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the arc sine of a number.\n * @param x number on which evaluation is done\n * @return arc sine of x\n */\npublic static double asin(double x) {\n    if (x != x) {\n        return Double.NaN;\n    }\n    if (x > 1.0 || x < -1.0) {\n        return Double.NaN;\n    }\n    if (x == 1.0) {\n        return Math.PI / 2.0;\n    }\n    if (x == -1.0) {\n        return -Math.PI / 2.0;\n    }\n    if (x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    /* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n    /* Split x */\n    double temp = x * HEX_40000000;\n    final double xa = x + temp - temp;\n    final double xb = x - xa;\n    /* Square it */\n    double ya = xa * xa;\n    double yb = xa * xb * 2.0 + xb * xb;\n    /* Subtract from 1 */\n    ya = -ya;\n    yb = -yb;\n    double za = 1.0 + ya;\n    double zb = -(za - 1.0 - ya);\n    temp = za + yb;\n    zb += -(temp - za - yb);\n    za = temp;\n    /* Square root */\n    double y;\n    y = sqrt(za);\n    temp = y * HEX_40000000;\n    ya = y + temp - temp;\n    yb = y - ya;\n    /* Extend precision of sqrt */\n    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);\n    /* Contribution of zb to sqrt */\n    double dx = zb / (2.0 * y);\n    // Compute ratio r = x/y\n    double r = x / y;\n    temp = r * HEX_40000000;\n    double ra = r + temp - temp;\n    double rb = r - ra;\n    // Correct for rounding in division\n    rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y;\n    // Add in effect additional bits of sqrt.\n    rb += -x * dx / y / y;\n    temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    return atan(ra, rb, false);\n}"
            ],
            [
                "acos",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the arc cosine of a number.\n * @param x number on which evaluation is done\n * @return arc cosine of x\n */\npublic static double acos(double x) {\n    if (x != x) {\n        return Double.NaN;\n    }\n    if (x > 1.0 || x < -1.0) {\n        return Double.NaN;\n    }\n    if (x == -1.0) {\n        return Math.PI;\n    }\n    if (x == 1.0) {\n        return 0.0;\n    }\n    if (x == 0) {\n        return Math.PI / 2.0;\n    }\n    /* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n    /* Split x */\n    double temp = x * HEX_40000000;\n    final double xa = x + temp - temp;\n    final double xb = x - xa;\n    /* Square it */\n    double ya = xa * xa;\n    double yb = xa * xb * 2.0 + xb * xb;\n    /* Subtract from 1 */\n    ya = -ya;\n    yb = -yb;\n    double za = 1.0 + ya;\n    double zb = -(za - 1.0 - ya);\n    temp = za + yb;\n    zb += -(temp - za - yb);\n    za = temp;\n    /* Square root */\n    double y = sqrt(za);\n    temp = y * HEX_40000000;\n    ya = y + temp - temp;\n    yb = y - ya;\n    /* Extend precision of sqrt */\n    yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);\n    /* Contribution of zb to sqrt */\n    yb += zb / (2.0 * y);\n    y = ya + yb;\n    yb = -(y - ya - yb);\n    // Compute ratio r = y/x\n    double r = y / x;\n    // Did r overflow?\n    if (Double.isInfinite(r)) {\n        // x is effectively zero\n        // so return the appropriate value\n        return Math.PI / 2;\n    }\n    double ra = doubleHighPart(r);\n    double rb = r - ra;\n    // Correct for rounding in division\n    rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n    // Add in effect additional bits of sqrt.\n    rb += yb / x;\n    temp = ra + rb;\n    rb = -(temp - ra - rb);\n    ra = temp;\n    return atan(ra, rb, x < 0);\n}"
            ],
            [
                "cbrt",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the cubic root of a number.\n * @param x number on which evaluation is done\n * @return cubic root of x\n */\npublic static double cbrt(double x) {\n    /* Convert input double to bits */\n    long inbits = Double.doubleToRawLongBits(x);\n    int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n    boolean subnormal = false;\n    if (exponent == -1023) {\n        if (x == 0) {\n            return x;\n        }\n        /* Subnormal, so normalize */\n        subnormal = true;\n        // 2^54\n        x *= 1.8014398509481984E16;\n        inbits = Double.doubleToRawLongBits(x);\n        exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n    }\n    if (exponent == 1024) {\n        // Nan or infinity.  Don't care which.\n        return x;\n    }\n    /* Divide the exponent by 3 */\n    int exp3 = exponent / 3;\n    /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\n    double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | (long) (((exp3 + 1023) & 0x7ff)) << 52);\n    /* This will be a number between 1 and 2 */\n    final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n    /* Estimate the cube root of mant by polynomial */\n    double est = -0.010714690733195933;\n    est = est * mant + 0.0875862700108075;\n    est = est * mant + -0.3058015757857271;\n    est = est * mant + 0.7249995199969751;\n    est = est * mant + 0.5039018405998233;\n    est *= CBRTTWO[exponent % 3 + 2];\n    // est should now be good to about 15 bits of precision.   Do 2 rounds of\n    // Newton's method to get closer,  this should get us full double precision\n    // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n    final double xs = x / (p2 * p2 * p2);\n    est += (xs - est * est * est) / (3 * est * est);\n    est += (xs - est * est * est) / (3 * est * est);\n    // Do one round of Newton's method in extended precision to get the last bit right.\n    double temp = est * HEX_40000000;\n    double ya = est + temp - temp;\n    double yb = est - ya;\n    double za = ya * ya;\n    double zb = ya * yb * 2.0 + yb * yb;\n    temp = za * HEX_40000000;\n    double temp2 = za + temp - temp;\n    zb += za - temp2;\n    za = temp2;\n    zb = za * yb + ya * zb + zb * yb;\n    za *= ya;\n    double na = xs - za;\n    double nb = -(na - xs + za);\n    nb -= zb;\n    est += (na + nb) / (3 * est * est);\n    /* Scale by a power of two, so this is exact. */\n    est *= p2;\n    if (subnormal) {\n        // 2^-18\n        est *= 3.814697265625E-6;\n    }\n    return est;\n}"
            ],
            [
                "toRadians",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n *  Convert degrees to radians, with error of less than 0.5 ULP\n *  @param x angle in degrees\n *  @return x converted into radians\n */\npublic static double toRadians(double x) {\n    if (Double.isInfinite(x) || x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    // These are PI/180 split into high and low order bits\n    final double facta = 0.01745329052209854;\n    final double factb = 1.997844754509471E-9;\n    double xa = doubleHighPart(x);\n    double xb = x - xa;\n    double result = xb * factb + xb * facta + xa * factb + xa * facta;\n    if (result == 0) {\n        // ensure correct sign if calculation underflows\n        result *= x;\n    }\n    return result;\n}"
            ],
            [
                "toDegrees",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n *  Convert radians to degrees, with error of less than 0.5 ULP\n *  @param x angle in radians\n *  @return x converted into degrees\n */\npublic static double toDegrees(double x) {\n    if (Double.isInfinite(x) || x == 0.0) {\n        // Matches +/- 0.0; return correct sign\n        return x;\n    }\n    // These are 180/PI split into high and low order bits\n    final double facta = 57.2957763671875;\n    final double factb = 3.145894820876798E-6;\n    double xa = doubleHighPart(x);\n    double xb = x - xa;\n    return xb * factb + xb * facta + xa * factb + xa * facta;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static int abs(final int x) {\n    final int i = x >>> 31;\n    return (x ^ (~i + 1)) + i;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static long abs(final long x) {\n    final long l = x >>> 63;\n    // l is one if x negative zero else\n    // ~l+1 is zero if x is positive, -1 if x is negative\n    // x^(~l+1) is x is x is positive, ~x if x is negative\n    // add around\n    return (x ^ (~l + 1)) + l;\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static float abs(final float x) {\n    return Float.intBitsToFloat(MASK_NON_SIGN_INT & Float.floatToRawIntBits(x));\n}"
            ],
            [
                "abs",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\npublic static double abs(double x) {\n    return Double.longBitsToDouble(MASK_NON_SIGN_LONG & Double.doubleToRawLongBits(x));\n}"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\npublic static double ulp(double x) {\n    if (Double.isInfinite(x)) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1));\n}"
            ],
            [
                "ulp",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\npublic static float ulp(float x) {\n    if (Float.isInfinite(x)) {\n        return Float.POSITIVE_INFINITY;\n    }\n    return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));\n}"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply a double number by a power of 2.\n * @param d number to multiply\n * @param n power of 2\n * @return d &times; 2<sup>n</sup>\n */\npublic static double scalb(final double d, final int n) {\n    // first simple and fast handling when 2^n can be represented using normal numbers\n    if ((n > -1023) && (n < 1024)) {\n        return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n    }\n    // handle special cases\n    if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n        return d;\n    }\n    if (n < -2098) {\n        return (d > 0) ? 0.0 : -0.0;\n    }\n    if (n > 2097) {\n        return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n    }\n    // decompose d\n    final long bits = Double.doubleToRawLongBits(d);\n    final long sign = bits & 0x8000000000000000L;\n    int exponent = ((int) (bits >>> 52)) & 0x7ff;\n    long mantissa = bits & 0x000fffffffffffffL;\n    // compute scaled exponent\n    int scaledExponent = exponent + n;\n    if (n < 0) {\n        // we are really in the case n <= -1023\n        if (scaledExponent > 0) {\n            // both the input and the result are normal numbers, we only adjust the exponent\n            return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n        } else if (scaledExponent > -53) {\n            // the input is a normal number and the result is a subnormal number\n            // recover the hidden mantissa bit\n            mantissa |= 1L << 52;\n            // scales down complete mantissa, hence losing least significant bits\n            final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n            mantissa >>>= 1 - scaledExponent;\n            if (mostSignificantLostBit != 0) {\n                // we need to add 1 bit to round up the result\n                mantissa++;\n            }\n            return Double.longBitsToDouble(sign | mantissa);\n        } else {\n            // no need to compute the mantissa, the number scales down to 0\n            return (sign == 0L) ? 0.0 : -0.0;\n        }\n    } else {\n        // we are really in the case n >= 1024\n        if (exponent == 0) {\n            // the input number is subnormal, normalize it\n            while ((mantissa >>> 52) != 1) {\n                mantissa <<= 1;\n                --scaledExponent;\n            }\n            ++scaledExponent;\n            mantissa &= 0x000fffffffffffffL;\n            if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        } else if (scaledExponent < 2047) {\n            return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n        } else {\n            return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n    }\n}"
            ],
            [
                "scalb",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply a float number by a power of 2.\n * @param f number to multiply\n * @param n power of 2\n * @return f &times; 2<sup>n</sup>\n */\npublic static float scalb(final float f, final int n) {\n    // first simple and fast handling when 2^n can be represented using normal numbers\n    if ((n > -127) && (n < 128)) {\n        return f * Float.intBitsToFloat((n + 127) << 23);\n    }\n    // handle special cases\n    if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n        return f;\n    }\n    if (n < -277) {\n        return (f > 0) ? 0.0f : -0.0f;\n    }\n    if (n > 276) {\n        return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n    }\n    // decompose f\n    final int bits = Float.floatToIntBits(f);\n    final int sign = bits & 0x80000000;\n    int exponent = (bits >>> 23) & 0xff;\n    int mantissa = bits & 0x007fffff;\n    // compute scaled exponent\n    int scaledExponent = exponent + n;\n    if (n < 0) {\n        // we are really in the case n <= -127\n        if (scaledExponent > 0) {\n            // both the input and the result are normal numbers, we only adjust the exponent\n            return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n        } else if (scaledExponent > -24) {\n            // the input is a normal number and the result is a subnormal number\n            // recover the hidden mantissa bit\n            mantissa |= 1 << 23;\n            // scales down complete mantissa, hence losing least significant bits\n            final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n            mantissa >>>= 1 - scaledExponent;\n            if (mostSignificantLostBit != 0) {\n                // we need to add 1 bit to round up the result\n                mantissa++;\n            }\n            return Float.intBitsToFloat(sign | mantissa);\n        } else {\n            // no need to compute the mantissa, the number scales down to 0\n            return (sign == 0) ? 0.0f : -0.0f;\n        }\n    } else {\n        // we are really in the case n >= 128\n        if (exponent == 0) {\n            // the input number is subnormal, normalize it\n            while ((mantissa >>> 23) != 1) {\n                mantissa <<= 1;\n                --scaledExponent;\n            }\n            ++scaledExponent;\n            mantissa &= 0x007fffff;\n            if (scaledExponent < 255) {\n                return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n            } else {\n                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n            }\n        } else if (scaledExponent < 255) {\n            return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n        } else {\n            return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n        }\n    }\n}"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the next machine representable number after a number, moving\n * in the direction of another number.\n * <p>\n * The ordering is as follows (increasing):\n * <ul>\n * <li>-INFINITY</li>\n * <li>-MAX_VALUE</li>\n * <li>-MIN_VALUE</li>\n * <li>-0.0</li>\n * <li>+0.0</li>\n * <li>+MIN_VALUE</li>\n * <li>+MAX_VALUE</li>\n * <li>+INFINITY</li>\n * <li></li>\n * <p>\n * If arguments compare equal, then the second argument is returned.\n * <p>\n * If {@code direction} is greater than {@code d},\n * the smallest machine representable number strictly greater than\n * {@code d} is returned; if less, then the largest representable number\n * strictly less than {@code d} is returned.</p>\n * <p>\n * If {@code d} is infinite and direction does not\n * bring it back to finite numbers, it is returned unchanged.</p>\n *\n * @param d base number\n * @param direction (the only important thing is whether\n * {@code direction} is greater or smaller than {@code d})\n * @return the next machine representable number in the specified direction\n */\npublic static double nextAfter(double d, double direction) {\n    // handling of some important special cases\n    if (Double.isNaN(d) || Double.isNaN(direction)) {\n        return Double.NaN;\n    } else if (d == direction) {\n        return direction;\n    } else if (Double.isInfinite(d)) {\n        return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n    } else if (d == 0) {\n        return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n    }\n    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n    // are handled just as normal numbers\n    // can use raw bits since already dealt with infinity and NaN\n    final long bits = Double.doubleToRawLongBits(d);\n    final long sign = bits & 0x8000000000000000L;\n    if ((direction < d) ^ (sign == 0L)) {\n        return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n    } else {\n        return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n    }\n}"
            ],
            [
                "nextAfter",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the next machine representable number after a number, moving\n * in the direction of another number.\n * <p>\n * The ordering is as follows (increasing):\n * <ul>\n * <li>-INFINITY</li>\n * <li>-MAX_VALUE</li>\n * <li>-MIN_VALUE</li>\n * <li>-0.0</li>\n * <li>+0.0</li>\n * <li>+MIN_VALUE</li>\n * <li>+MAX_VALUE</li>\n * <li>+INFINITY</li>\n * <li></li>\n * <p>\n * If arguments compare equal, then the second argument is returned.\n * <p>\n * If {@code direction} is greater than {@code f},\n * the smallest machine representable number strictly greater than\n * {@code f} is returned; if less, then the largest representable number\n * strictly less than {@code f} is returned.</p>\n * <p>\n * If {@code f} is infinite and direction does not\n * bring it back to finite numbers, it is returned unchanged.</p>\n *\n * @param f base number\n * @param direction (the only important thing is whether\n * {@code direction} is greater or smaller than {@code f})\n * @return the next machine representable number in the specified direction\n */\npublic static float nextAfter(final float f, final double direction) {\n    // handling of some important special cases\n    if (Double.isNaN(f) || Double.isNaN(direction)) {\n        return Float.NaN;\n    } else if (f == direction) {\n        return (float) direction;\n    } else if (Float.isInfinite(f)) {\n        return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n    } else if (f == 0f) {\n        return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n    }\n    // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n    // are handled just as normal numbers\n    final int bits = Float.floatToIntBits(f);\n    final int sign = bits & 0x80000000;\n    if ((direction < f) ^ (sign == 0)) {\n        return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n    } else {\n        return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1));\n    }\n}"
            ],
            [
                "floor",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the largest whole number smaller than x.\n * @param x number from which floor is requested\n * @return a double number f such that f is an integer f <= x < f + 1.0\n */\npublic static double floor(double x) {\n    long y;\n    if (x != x) {\n        // NaN\n        return x;\n    }\n    if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n        return x;\n    }\n    y = (long) x;\n    if (x < 0 && y != x) {\n        y--;\n    }\n    if (y == 0) {\n        return x * y;\n    }\n    return y;\n}"
            ],
            [
                "ceil",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the smallest whole number larger than x.\n * @param x number from which ceil is requested\n * @return a double number c such that c is an integer c - 1.0 < x <= c\n */\npublic static double ceil(double x) {\n    double y;\n    if (x != x) {\n        // NaN\n        return x;\n    }\n    y = floor(x);\n    if (y == x) {\n        return y;\n    }\n    y += 1.0;\n    if (y == 0) {\n        return x * y;\n    }\n    return y;\n}"
            ],
            [
                "rint",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\n * @param x number from which nearest whole number is requested\n * @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5\n */\npublic static double rint(double x) {\n    double y = floor(x);\n    double d = x - y;\n    if (d > 0.5) {\n        if (y == -1.0) {\n            // Preserve sign of operand\n            return -0.0;\n        }\n        return y + 1.0;\n    }\n    if (d < 0.5) {\n        return y;\n    }\n    /* half way, round to even */\n    long z = (long) y;\n    return (z & 1) == 0 ? y : y + 1.0;\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the closest long to x.\n * @param x number from which closest long is requested\n * @return closest long to x\n */\npublic static long round(double x) {\n    return (long) floor(x + 0.5);\n}"
            ],
            [
                "round",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Get the closest int to x.\n * @param x number from which closest int is requested\n * @return closest int to x\n */\npublic static int round(final float x) {\n    return (int) floor(x + 0.5f);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static int min(final int a, final int b) {\n    return (a <= b) ? a : b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static long min(final long a, final long b) {\n    return (a <= b) ? a : b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static float min(final float a, final float b) {\n    if (a > b) {\n        return b;\n    }\n    if (a < b) {\n        return a;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Float.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */\n    int bits = Float.floatToRawIntBits(a);\n    if (bits == 0x80000000) {\n        return a;\n    }\n    return b;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\npublic static double min(final double a, final double b) {\n    if (a > b) {\n        return b;\n    }\n    if (a < b) {\n        return a;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Double.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n    long bits = Double.doubleToRawLongBits(a);\n    if (bits == 0x8000000000000000L) {\n        return a;\n    }\n    return b;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static int max(final int a, final int b) {\n    return (a <= b) ? b : a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static long max(final long a, final long b) {\n    return (a <= b) ? b : a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static float max(final float a, final float b) {\n    if (a > b) {\n        return a;\n    }\n    if (a < b) {\n        return b;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Float.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */\n    int bits = Float.floatToRawIntBits(a);\n    if (bits == 0x80000000) {\n        return b;\n    }\n    return a;\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\npublic static double max(final double a, final double b) {\n    if (a > b) {\n        return a;\n    }\n    if (a < b) {\n        return b;\n    }\n    /* if either arg is NaN, return NaN */\n    if (a != b) {\n        return Double.NaN;\n    }\n    /* min(+0.0,-0.0) == -0.0 */\n    /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n    long bits = Double.doubleToRawLongBits(a);\n    if (bits == 0x8000000000000000L) {\n        return b;\n    }\n    return a;\n}"
            ],
            [
                "hypot",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\n * avoiding intermediate overflow or underflow.\n *\n * <ul>\n * <li> If either argument is infinite, then the result is positive infinity.</li>\n * <li> else, if either argument is NaN then the result is NaN.</li>\n * </ul>\n *\n * @param x a value\n * @param y a value\n * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n */\npublic static double hypot(final double x, final double y) {\n    if (Double.isInfinite(x) || Double.isInfinite(y)) {\n        return Double.POSITIVE_INFINITY;\n    } else if (Double.isNaN(x) || Double.isNaN(y)) {\n        return Double.NaN;\n    } else {\n        final int expX = getExponent(x);\n        final int expY = getExponent(y);\n        if (expX > expY + 27) {\n            // y is neglectible with respect to x\n            return abs(x);\n        } else if (expY > expX + 27) {\n            // x is neglectible with respect to y\n            return abs(y);\n        } else {\n            // find an intermediate scale to avoid both overflow and underflow\n            final int middleExp = (expX + expY) / 2;\n            // scale parameters without losing precision\n            final double scaledX = scalb(x, -middleExp);\n            final double scaledY = scalb(y, -middleExp);\n            // compute scaled hypotenuse\n            final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n            // remove scaling\n            return scalb(scaledH, middleExp);\n        }\n    }\n}"
            ],
            [
                "IEEEremainder",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Computes the remainder as prescribed by the IEEE 754 standard.\n * The remainder value is mathematically equal to {@code x - y*n}\n * where {@code n} is the mathematical integer closest to the exact mathematical value\n * of the quotient {@code x/y}.\n * If two mathematical integers are equally close to {@code x/y} then\n * {@code n} is the integer that is even.\n * <p>\n * <ul>\n * <li>If either operand is NaN, the result is NaN.</li>\n * <li>If the result is not NaN, the sign of the result equals the sign of the dividend.</li>\n * <li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.</li>\n * <li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</li>\n * <li>If the dividend is a zero and the divisor is finite, the result equals the dividend.</li>\n * </ul>\n * <p><b>Note:</b> this implementation currently delegates to {@link StrictMath#IEEEremainder}\n * @param dividend the number to be divided\n * @param divisor the number by which to divide\n * @return the remainder, rounded\n */\npublic static double IEEEremainder(double dividend, double divisor) {\n    // TODO provide our own implementation\n    return StrictMath.IEEEremainder(dividend, divisor);\n}"
            ],
            [
                "toIntExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Convert a long to interger, detecting overflows\n * @param n number to convert to int\n * @return integer with same valie as n if no overflows occur\n * @exception MathArithmeticException if n cannot fit into an int\n * @since 3.4\n */\npublic static int toIntExact(final long n) throws MathArithmeticException {\n    if (n < Integer.MIN_VALUE || n > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    }\n    return (int) n;\n}"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Increment a number, detecting overflows.\n * @param n number to increment\n * @return n+1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int incrementExact(final int n) throws MathArithmeticException {\n    if (n == Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);\n    }\n    return n + 1;\n}"
            ],
            [
                "incrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Increment a number, detecting overflows.\n * @param n number to increment\n * @return n+1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long incrementExact(final long n) throws MathArithmeticException {\n    if (n == Long.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);\n    }\n    return n + 1;\n}"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Decrement a number, detecting overflows.\n * @param n number to decrement\n * @return n-1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int decrementExact(final int n) throws MathArithmeticException {\n    if (n == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);\n    }\n    return n - 1;\n}"
            ],
            [
                "decrementExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Decrement a number, detecting overflows.\n * @param n number to decrement\n * @return n-1 if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long decrementExact(final long n) throws MathArithmeticException {\n    if (n == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);\n    }\n    return n - 1;\n}"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Add two numbers, detecting overflows.\n * @param a first number to add\n * @param b second number to add\n * @return a+b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int addExact(final int a, final int b) throws MathArithmeticException {\n    // compute sum\n    final int sum = a + b;\n    // check for overflow\n    if ((a ^ b) >= 0 && (sum ^ b) < 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);\n    }\n    return sum;\n}"
            ],
            [
                "addExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Add two numbers, detecting overflows.\n * @param a first number to add\n * @param b second number to add\n * @return a+b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long addExact(final long a, final long b) throws MathArithmeticException {\n    // compute sum\n    final long sum = a + b;\n    // check for overflow\n    if ((a ^ b) >= 0 && (sum ^ b) < 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);\n    }\n    return sum;\n}"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Subtract two numbers, detecting overflows.\n * @param a first number\n * @param b second number to subtract from a\n * @return a-b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int subtractExact(final int a, final int b) {\n    // compute subtraction\n    final int sub = a - b;\n    // check for overflow\n    if ((a ^ b) < 0 && (sub ^ b) >= 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);\n    }\n    return sub;\n}"
            ],
            [
                "subtractExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Subtract two numbers, detecting overflows.\n * @param a first number\n * @param b second number to subtract from a\n * @return a-b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long subtractExact(final long a, final long b) {\n    // compute subtraction\n    final long sub = a - b;\n    // check for overflow\n    if ((a ^ b) < 0 && (sub ^ b) >= 0) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);\n    }\n    return sub;\n}"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply two numbers, detecting overflows.\n * @param a first number to multiply\n * @param b second number to multiply\n * @return a*b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static int multiplyExact(final int a, final int b) {\n    if (((b > 0) && (a > Integer.MAX_VALUE / b || a < Integer.MIN_VALUE / b)) || ((b < -1) && (a > Integer.MIN_VALUE / b || a < Integer.MAX_VALUE / b)) || ((b == -1) && (a == Integer.MIN_VALUE))) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);\n    }\n    return a * b;\n}"
            ],
            [
                "multiplyExact",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Multiply two numbers, detecting overflows.\n * @param a first number to multiply\n * @param b second number to multiply\n * @return a*b if no overflows occur\n * @exception MathArithmeticException if an overflow occurs\n * @since 3.4\n */\npublic static long multiplyExact(final long a, final long b) {\n    if (((b > 0l) && (a > Long.MAX_VALUE / b || a < Long.MIN_VALUE / b)) || ((b < -1l) && (a > Long.MIN_VALUE / b || a < Long.MAX_VALUE / b)) || ((b == -1l) && (a == Long.MIN_VALUE))) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);\n    }\n    return a * b;\n}"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer division when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorMod(int, int)\n * @since 3.4\n */\npublic static int floorDiv(final int a, final int b) throws MathArithmeticException {\n    if (b == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final int m = a % b;\n    if ((a ^ b) >= 0 || m == 0) {\n        // a an b have same sign, or division is exact\n        return a / b;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return (a / b) - 1;\n    }\n}"
            ],
            [
                "floorDiv",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer division when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return q such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorMod(long, long)\n * @since 3.4\n */\npublic static long floorDiv(final long a, final long b) throws MathArithmeticException {\n    if (b == 0l) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final long m = a % b;\n    if ((a ^ b) >= 0l || m == 0l) {\n        // a an b have same sign, or division is exact\n        return a / b;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return (a / b) - 1l;\n    }\n}"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer modulo when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorDiv(int, int)\n * @since 3.4\n */\npublic static int floorMod(final int a, final int b) throws MathArithmeticException {\n    if (b == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final int m = a % b;\n    if ((a ^ b) >= 0 || m == 0) {\n        // a an b have same sign, or division is exact\n        return m;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return b + m;\n    }\n}"
            ],
            [
                "floorMod",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Finds r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0.\n * <p>\n * This methods returns the same value as integer modulo when\n * a and b are same signs, but returns a different value when\n * they are opposite (i.e. q is negative).\n * </p>\n * @param a dividend\n * @param b divisor\n * @return r such that a = q b + r with 0 <= r < b if b > 0 and b < r <= 0 if b < 0\n * @exception MathArithmeticException if b == 0\n * @see #floorDiv(long, long)\n * @since 3.4\n */\npublic static long floorMod(final long a, final long b) {\n    if (b == 0l) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n    final long m = a % b;\n    if ((a ^ b) >= 0l || m == 0l) {\n        // a an b have same sign, or division is exact\n        return m;\n    } else {\n        // a and b have opposite signs and division is not exact\n        return b + m;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the first argument with the sign of the second argument.\n * A NaN {@code sign} argument is treated as positive.\n *\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\npublic static double copySign(double magnitude, double sign) {\n    // The highest order bit is going to be zero if the\n    // highest order bit of m and s is the same and one otherwise.\n    // So (m^s) will be positive if both m and s have the same sign\n    // and negative otherwise.\n    // don't care about NaN\n    final long m = Double.doubleToRawLongBits(magnitude);\n    final long s = Double.doubleToRawLongBits(sign);\n    if ((m ^ s) >= 0) {\n        return magnitude;\n    }\n    // flip sign\n    return -magnitude;\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Returns the first argument with the sign of the second argument.\n * A NaN {@code sign} argument is treated as positive.\n *\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\npublic static float copySign(float magnitude, float sign) {\n    // The highest order bit is going to be zero if the\n    // highest order bit of m and s is the same and one otherwise.\n    // So (m^s) will be positive if both m and s have the same sign\n    // and negative otherwise.\n    final int m = Float.floatToRawIntBits(magnitude);\n    final int s = Float.floatToRawIntBits(sign);\n    if ((m ^ s) >= 0) {\n        return magnitude;\n    }\n    // flip sign\n    return -magnitude;\n}"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Return the exponent of a double number, removing the bias.\n * <p>\n * For double numbers of the form 2<sup>x</sup>, the unbiased\n * exponent is exactly x.\n * </p>\n * @param d number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\npublic static int getExponent(final double d) {\n    // NaN and Infinite will return 1024 anywho so can use raw bits\n    return (int) ((Double.doubleToRawLongBits(d) >>> 52) & 0x7ff) - 1023;\n}"
            ],
            [
                "getExponent",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Return the exponent of a float number, removing the bias.\n * <p>\n * For float numbers of the form 2<sup>x</sup>, the unbiased\n * exponent is exactly x.\n * </p>\n * @param f number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\npublic static int getExponent(final float f) {\n    // NaN and Infinite will return the same exponent anywho so can use raw bits\n    return ((Float.floatToRawIntBits(f) >>> 23) & 0xff) - 127;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "BigRealField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static BigRealField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.util",
                "Decimal64Field",
                "/**\n * Returns the unique instance of this class.\n *\n * @return the unique instance of this class\n */\npublic static final Decimal64Field getInstance() {\n    return INSTANCE;\n}"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns an integer hash code representing the given double value.\n *\n * @param value the value to be hashed\n * @return the hash code\n */\npublic static int hash(double value) {\n    return new Double(value).hashCode();\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns {@code true} if the values are equal according to semantics of\n * {@link Double#equals(Object)}.\n *\n * @param x Value\n * @param y Value\n * @return {@code new Double(x).equals(new Double(y))}\n */\npublic static boolean equals(double x, double y) {\n    return new Double(x).equals(new Double(y));\n}"
            ],
            [
                "hash",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns an integer hash code representing the given double array.\n *\n * @param value the value to be hashed (may be null)\n * @return the hash code\n * @since 1.2\n */\npublic static int hash(double[] value) {\n    return Arrays.hashCode(value);\n}"
            ],
            [
                "normalizeAngle",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Normalize an angle in a 2&pi; wide interval around a center value.\n * <p>This method has three main uses:</p>\n * <ul>\n *   <li>normalize an angle between 0 and 2&pi;:<br/>\n *       {@code a = MathUtils.normalizeAngle(a, FastMath.PI);}</li>\n *   <li>normalize an angle between -&pi; and +&pi;<br/>\n *       {@code a = MathUtils.normalizeAngle(a, 0.0);}</li>\n *   <li>compute the angle between two defining angular positions:<br>\n *       {@code angle = MathUtils.normalizeAngle(end, start) - start;}</li>\n * </ul>\n * <p>Note that due to numerical accuracy and since &pi; cannot be represented\n * exactly, the result interval is <em>closed</em>, it cannot be half-closed\n * as would be more satisfactory in a purely mathematical view.</p>\n * @param a angle to normalize\n * @param center center of the desired 2&pi; interval for the result\n * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;\n * @since 1.2\n */\npublic static double normalizeAngle(double a, double center) {\n    return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Find the maximum of two field elements.\n * @param <T> the type of the field elements\n * @param e1 first element\n * @param e2 second element\n * @return max(a1, e2)\n * @since 3.6\n */\npublic static <T extends RealFieldElement<T>> T max(final T e1, final T e2) {\n    return e1.subtract(e2).getReal() >= 0 ? e1 : e2;\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Find the minimum of two field elements.\n * @param <T> the type of the field elements\n * @param e1 first element\n * @param e2 second element\n * @return min(a1, e2)\n * @since 3.6\n */\npublic static <T extends RealFieldElement<T>> T min(final T e1, final T e2) {\n    return e1.subtract(e2).getReal() >= 0 ? e2 : e1;\n}"
            ],
            [
                "reduce",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * <p>Reduce {@code |a - offset|} to the primary interval\n * {@code [0, |period|)}.</p>\n *\n * <p>Specifically, the value returned is <br/>\n * {@code a - |period| * floor((a - offset) / |period|) - offset}.</p>\n *\n * <p>If any of the parameters are {@code NaN} or infinite, the result is\n * {@code NaN}.</p>\n *\n * @param a Value to reduce.\n * @param period Period.\n * @param offset Value that will be mapped to {@code 0}.\n * @return the value, within the interval {@code [0 |period|)},\n * that corresponds to {@code a}.\n */\npublic static double reduce(double a, double period, double offset) {\n    final double p = FastMath.abs(period);\n    return a - p * FastMath.floor((a - offset) / p) - offset;\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Byte.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static byte copySign(byte magnitude, byte sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Byte.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return (byte) -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Short.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static short copySign(short magnitude, short sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Short.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return (short) -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Integer.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static int copySign(int magnitude, int sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return -magnitude;\n    }\n}"
            ],
            [
                "copySign",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * Returns the first argument with the sign of the second argument.\n *\n * @param magnitude Magnitude of the returned value.\n * @param sign Sign of the returned value.\n * @return a value with magnitude equal to {@code magnitude} and with the\n * same sign as the {@code sign} argument.\n * @throws MathArithmeticException if {@code magnitude == Long.MIN_VALUE}\n * and {@code sign >= 0}.\n */\npublic static long copySign(long magnitude, long sign) throws MathArithmeticException {\n    if ((magnitude >= 0 && sign >= 0) || (magnitude < 0 && sign < 0)) {\n        // Sign is OK.\n        return magnitude;\n    } else if (sign >= 0 && magnitude == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n    } else {\n        // Flip sign.\n        return -magnitude;\n    }\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getInstance()} with the only customizing that the\n * maximum number of fraction digits is set to 10.\n * @return the default number format.\n */\npublic static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n * customizing that the maximum number of fraction digits is set to 10.\n * @param locale the specific locale used by the format.\n * @return the default number format specific to the given locale.\n */\npublic static NumberFormat getDefaultNumberFormat(final Locale locale) {\n    final NumberFormat nf = NumberFormat.getInstance(locale);\n    nf.setMaximumFractionDigits(10);\n    return nf;\n}"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parses <code>source</code> until a non-whitespace character is found.\n *\n * @param source the string to parse\n * @param pos input/output parsing parameter.\n * @return the first non-whitespace character.\n */\npublic static char parseNextCharacter(final String source, final ParsePosition pos) {\n    int index = pos.getIndex();\n    final int n = source.length();\n    char ret = 0;\n    if (index < n) {\n        char c;\n        do {\n            c = source.charAt(index++);\n        } while (Character.isWhitespace(c) && index < n);\n        pos.setIndex(index);\n        if (index < n) {\n            ret = c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "parseNumber",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parses <code>source</code> for a number.  This method can parse normal,\n * numeric values as well as special values.  These special values include\n * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n *\n * @param source the string to parse\n * @param format the number format used to parse normal, numeric values.\n * @param pos input/output parsing parameter.\n * @return the parsed number.\n */\npublic static Number parseNumber(final String source, final NumberFormat format, final ParsePosition pos) {\n    final int startIndex = pos.getIndex();\n    Number number = format.parse(source, pos);\n    final int endIndex = pos.getIndex();\n    // check for error parsing number\n    if (startIndex == endIndex) {\n        // try parsing special numbers\n        final double[] special = { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY };\n        for (int i = 0; i < special.length; ++i) {\n            number = parseNumber(source, special[i], pos);\n            if (number != null) {\n                break;\n            }\n        }\n    }\n    return number;\n}"
            ],
            [
                "parseFixedstring",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Parse <code>source</code> for an expected fixed string.\n * @param source the string to parse\n * @param expected expected string\n * @param pos input/output parsing parameter.\n * @return true if the expected string was there\n */\npublic static boolean parseFixedstring(final String source, final String expected, final ParsePosition pos) {\n    final int startIndex = pos.getIndex();\n    final int endIndex = startIndex + expected.length();\n    if ((startIndex >= source.length()) || (endIndex > source.length()) || (source.substring(startIndex, endIndex).compareTo(expected) != 0)) {\n        // set index back to start, error index should be the start index\n        pos.setIndex(startIndex);\n        pos.setErrorIndex(startIndex);\n        return false;\n    }\n    // the string was here\n    pos.setIndex(endIndex);\n    return true;\n}"
            ],
            [
                "formatDouble",
                "org.apache.commons.math3.util",
                "CompositeFormat",
                "/**\n * Formats a double value to produce a string.  In general, the value is\n * formatted using the formatting rules of <code>format</code>.  There are\n * three exceptions to this:\n * <ol>\n * <li>NaN is formatted as '(NaN)'</li>\n * <li>Positive infinity is formatted as '(Infinity)'</li>\n * <li>Negative infinity is formatted as '(-Infinity)'</li>\n * </ol>\n *\n * @param value the double to format.\n * @param format the format used.\n * @param toAppendTo where the text is to be appended\n * @param pos On input: an alignment field, if desired. On output: the\n *            offsets of the alignment field\n * @return the value passed in as toAppendTo.\n */\npublic static StringBuffer formatDouble(final double value, final NumberFormat format, final StringBuffer toAppendTo, final FieldPosition pos) {\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n        toAppendTo.append('(');\n        toAppendTo.append(value);\n        toAppendTo.append(')');\n    } else {\n        format.format(value, toAppendTo, pos);\n    }\n    return toAppendTo;\n}"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Creates a sequence {@code [start .. end]}.\n * It calls {@link #range(int,int,int) range(start, end, 1)}.\n *\n * @param start First value of the range.\n * @param end Last value of the range.\n * @return a range.\n */\npublic static Range range(int start, int end) {\n    return range(start, end, 1);\n}"
            ],
            [
                "range",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Creates a sequence \\( a_i, i < 0 <= n \\)\n * where \\( a_i = start + i * step \\)\n * and \\( n \\) is such that \\( a_n <= max \\) and \\( a_{n+1} > max \\).\n *\n * @param start First value of the range.\n * @param max Last value of the range that satisfies the above\n * construction rule.\n * @param step Increment.\n * @return a range.\n */\npublic static Range range(final int start, final int max, final int step) {\n    return new Range(start, max, step);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "IntegerSequence",
                "/**\n * Factory method that creates a default instance.\n * The initial and maximal values are set to 0.\n * For the new instance to be useful, the maximal count must be set\n * by calling {@link #withMaximalCount(int) withMaximalCount}.\n *\n * @return an new instance.\n */\npublic static Incrementor create() {\n    return new Incrementor(0, 0, 1, CALLBACK);\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.util",
                "Incrementor",
                "/**\n * Factory method that creates a default instance.\n * The initial and maximal values are set to 0.\n * For the new instance to be useful, the maximal count must be set\n * by calling {@link #withMaximalCount(int) withMaximalCount}.\n *\n * @return an new instance.\n */\npublic static Incrementor create() {\n    return new Incrementor(0, 0, 1, CALLBACK);\n}"
            ],
            [
                "loadExpIntA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_INT_A\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpIntA() {\n    return EXP_INT_A.clone();\n}"
            ],
            [
                "loadExpIntB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_INT_B\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpIntB() {\n    return EXP_INT_B.clone();\n}"
            ],
            [
                "loadExpFracA",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_FRAC_A\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpFracA() {\n    return EXP_FRAC_A.clone();\n}"
            ],
            [
                "loadExpFracB",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"EXP_FRAC_B\".\n *\n * @return a clone of the data array.\n */\nstatic double[] loadExpFracB() {\n    return EXP_FRAC_B.clone();\n}"
            ],
            [
                "loadLnMant",
                "org.apache.commons.math3.util",
                "FastMathLiteralArrays",
                "/**\n * Load \"LN_MANT\".\n *\n * @return a clone of the data array.\n */\nstatic double[][] loadLnMant() {\n    return LN_MANT.clone();\n}"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns an exact representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which all coefficients are\n * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n * {@code Long.MAX_VALUE} a {@code MathArithMeticException} is\n * thrown.</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    // Use symmetry for large k\n    if (k > n / 2) {\n        return binomialCoefficient(n, n - k);\n    }\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    long result = 1;\n    if (n <= 61) {\n        // For n <= 61, the naive implementation cannot overflow.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            result = result * i / j;\n            i++;\n        }\n    } else if (n <= 66) {\n        // For n > 61 but n <= 66, the result cannot overflow,\n        // but we must take care not to overflow intermediate values.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            // We know that (result * i) is divisible by j,\n            // but (result * i) may overflow, so we split j:\n            // Filter out the gcd, d, so j/d and i/d are integer.\n            // result is divisible by (j/d) because (j/d)\n            // is relative prime to (i/d) and is a divisor of\n            // result * (i/d).\n            final long d = ArithmeticUtils.gcd(i, j);\n            result = (result / (j / d)) * (i / d);\n            i++;\n        }\n    } else {\n        // For n > 66, a result overflow might occur, so we check\n        // the multiplication, taking care to not overflow\n        // unnecessary.\n        int i = n - k + 1;\n        for (int j = 1; j <= k; j++) {\n            final long d = ArithmeticUtils.gcd(i, j);\n            result = ArithmeticUtils.mulAndCheck(result / (j / d), i / d);\n            i++;\n        }\n    }\n    return result;\n}"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns a {@code double} representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code double}. The\n * largest value of {@code n} for which all coefficients are less than\n * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n * Double.POSITIVE_INFINITY is returned</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 1d;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    if (k > n / 2) {\n        return binomialCoefficientDouble(n, n - k);\n    }\n    if (n < 67) {\n        return binomialCoefficient(n, k);\n    }\n    double result = 1d;\n    for (int i = 1; i <= k; i++) {\n        result *= (double) (n - k + i) / (double) i;\n    }\n    return FastMath.floor(result + 0.5);\n}"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns the natural {@code log} of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n */\npublic static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    CombinatoricsUtils.checkBinomial(n, k);\n    if ((n == k) || (k == 0)) {\n        return 0;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return FastMath.log(n);\n    }\n    /*\n         * For values small enough to do exact integer computation,\n         * return the log of the exact value\n         */\n    if (n < 67) {\n        return FastMath.log(binomialCoefficient(n, k));\n    }\n    /*\n         * Return the log of binomialCoefficientDouble for values that will not\n         * overflow binomialCoefficientDouble\n         */\n    if (n < 1030) {\n        return FastMath.log(binomialCoefficientDouble(n, k));\n    }\n    if (k > n / 2) {\n        return binomialCoefficientLog(n, n - k);\n    }\n    /*\n         * Sum logs for values that could overflow\n         */\n    double logSum = 0;\n    // n!/(n-k)!\n    for (int i = n - k + 1; i <= n; i++) {\n        logSum += FastMath.log(i);\n    }\n    // divide by k!\n    for (int i = 2; i <= k; i++) {\n        logSum -= FastMath.log(i);\n    }\n    return logSum;\n}"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns n!. Shorthand for {@code n} <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers {@code 1,...,n}.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code n >= 0} (otherwise\n * {@code MathIllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which {@code n!} does not exceed\n * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n * an {@code MathArithMeticException } is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return {@code n!}\n * @throws MathArithmeticException if the result is too large to be represented\n * by a {@code long}.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n * large to fit in a {@code long}.\n */\npublic static long factorial(final int n) throws NotPositiveException, MathArithmeticException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n > 20) {\n        throw new MathArithmeticException();\n    }\n    return FACTORIALS[n];\n}"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n * {@code double}.\n * The result should be small enough to fit into a {@code double}: The\n * largest {@code n} for which {@code n!} does not exceed\n * {@code Double.MAX_VALUE} is 170. If the computed value exceeds\n * {@code Double.MAX_VALUE}, {@code Double.POSITIVE_INFINITY} is returned.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n */\npublic static double factorialDouble(final int n) throws NotPositiveException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n < 21) {\n        return FACTORIALS[n];\n    }\n    return FastMath.floor(FastMath.exp(CombinatoricsUtils.factorialLog(n)) + 0.5);\n}"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Compute the natural logarithm of the factorial of {@code n}.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n */\npublic static double factorialLog(final int n) throws NotPositiveException {\n    if (n < 0) {\n        throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);\n    }\n    if (n < 21) {\n        return FastMath.log(FACTORIALS[n]);\n    }\n    double logSum = 0;\n    for (int i = 2; i <= n; i++) {\n        logSum += FastMath.log(i);\n    }\n    return logSum;\n}"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns the <a\n * href=\"http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html\">\n * Stirling number of the second kind</a>, \"{@code S(n,k)}\", the number of\n * ways of partitioning an {@code n}-element set into {@code k} non-empty\n * subsets.\n * <p>\n * The preconditions are {@code 0 <= k <= n } (otherwise\n * {@code NotPositiveException} is thrown)\n * </p>\n * @param n the size of the set\n * @param k the number of non-empty subsets\n * @return {@code S(n,k)}\n * @throws NotPositiveException if {@code k < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\n * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)\n * @since 3.1\n */\npublic static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    if (k < 0) {\n        throw new NotPositiveException(k);\n    }\n    if (k > n) {\n        throw new NumberIsTooLargeException(k, n, true);\n    }\n    long[][] stirlingS2 = STIRLING_S2.get();\n    if (stirlingS2 == null) {\n        // the cache has never been initialized, compute the first numbers\n        // by direct recurrence relation\n        // as S(26,9) = 11201516780955125625 is larger than Long.MAX_VALUE\n        // we must stop computation at row 26\n        final int maxIndex = 26;\n        stirlingS2 = new long[maxIndex][];\n        stirlingS2[0] = new long[] { 1l };\n        for (int i = 1; i < stirlingS2.length; ++i) {\n            stirlingS2[i] = new long[i + 1];\n            stirlingS2[i][0] = 0;\n            stirlingS2[i][1] = 1;\n            stirlingS2[i][i] = 1;\n            for (int j = 2; j < i; ++j) {\n                stirlingS2[i][j] = j * stirlingS2[i - 1][j] + stirlingS2[i - 1][j - 1];\n            }\n        }\n        // atomically save the cache\n        STIRLING_S2.compareAndSet(null, stirlingS2);\n    }\n    if (n < stirlingS2.length) {\n        // the number is in the small cache\n        return stirlingS2[n][k];\n    } else {\n        // use explicit formula to compute the number without caching it\n        if (k == 0) {\n            return 0;\n        } else if (k == 1 || k == n) {\n            return 1;\n        } else if (k == 2) {\n            return (1l << (n - 1)) - 1l;\n        } else if (k == n - 1) {\n            return binomialCoefficient(n, 2);\n        } else {\n            // definition formula: note that this may trigger some overflow\n            long sum = 0;\n            long sign = ((k & 0x1) == 0) ? 1 : -1;\n            for (int j = 1; j <= k; ++j) {\n                sign = -sign;\n                sum += sign * binomialCoefficient(k, j) * ArithmeticUtils.pow(j, n);\n                if (sum < 0) {\n                    // there was an overflow somewhere\n                    throw new MathArithmeticException(LocalizedFormats.ARGUMENT_OUTSIDE_DOMAIN, n, 0, stirlingS2.length - 1);\n                }\n            }\n            return sum / factorial(k);\n        }\n    }\n}"
            ],
            [
                "combinationsIterator",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Returns an iterator whose range is the k-element subsets of {0, ..., n - 1}\n * represented as {@code int[]} arrays.\n * <p>\n * The arrays returned by the iterator are sorted in descending order and\n * they are visited in lexicographic order with significance from right to\n * left. For example, combinationsIterator(4, 2) returns an Iterator that\n * will generate the following sequence of arrays on successive calls to\n * {@code next()}:</p><p>\n * {@code [0, 1], [0, 2], [1, 2], [0, 3], [1, 3], [2, 3]}\n * </p><p>\n * If {@code k == 0} an Iterator containing an empty array is returned and\n * if {@code k == n} an Iterator containing [0, ..., n -1] is returned.</p>\n *\n * @param n Size of the set from which subsets are selected.\n * @param k Size of the subsets to be enumerated.\n * @return an {@link Iterator iterator} over the k-sets in n.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n */\npublic static Iterator<int[]> combinationsIterator(int n, int k) {\n    return new Combinations(n, k).iterator();\n}"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Add two integers, checking for overflow.\n *\n * @param x an addend\n * @param y an addend\n * @return the sum {@code x+y}\n * @throws MathArithmeticException if the result can not be represented\n * as an {@code int}.\n * @since 1.1\n */\npublic static int addAndCheck(int x, int y) throws MathArithmeticException {\n    long s = (long) x + (long) y;\n    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n    }\n    return (int) s;\n}"
            ],
            [
                "addAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Add two long integers, checking for overflow.\n *\n * @param a an addend\n * @param b an addend\n * @return the sum {@code a+b}\n * @throws MathArithmeticException if the result can not be represented as an long\n * @since 1.2\n */\npublic static long addAndCheck(long a, long b) throws MathArithmeticException {\n    return addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n}"
            ],
            [
                "binomialCoefficient",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns an exact representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which all coefficients are\n * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n * {@code Long.MAX_VALUE} an {@code ArithMeticException} is\n * thrown.</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficient(int, int)}\n */\n@Deprecated\npublic static long binomialCoefficient(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficient(n, k);\n}"
            ],
            [
                "binomialCoefficientDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns a {@code double} representation of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code double}. The\n * largest value of {@code n} for which all coefficients are <\n * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n * Double.POSITIVE_INFINITY is returned</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficientDouble(int, int)}\n */\n@Deprecated\npublic static double binomialCoefficientDouble(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficientDouble(n, k);\n}"
            ],
            [
                "binomialCoefficientLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns the natural {@code log} of the <a\n * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n * Coefficient</a>, \"{@code n choose k}\", the number of\n * {@code k}-element subsets that can be selected from an\n * {@code n}-element set.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code 0 <= k <= n } (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * </ul></p>\n *\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return {@code n choose k}\n * @throws NotPositiveException if {@code n < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if the result is too large to be\n * represented by a long integer.\n * @deprecated use {@link CombinatoricsUtils#binomialCoefficientLog(int, int)}\n */\n@Deprecated\npublic static double binomialCoefficientLog(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.binomialCoefficientLog(n, k);\n}"
            ],
            [
                "factorial",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns n!. Shorthand for {@code n} <a\n * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n * product of the numbers {@code 1,...,n}.\n * <p>\n * <Strong>Preconditions</strong>:\n * <ul>\n * <li> {@code n >= 0} (otherwise\n * {@code IllegalArgumentException} is thrown)</li>\n * <li> The result is small enough to fit into a {@code long}. The\n * largest value of {@code n} for which {@code n!} <\n * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n * an {@code ArithMeticException } is thrown.</li>\n * </ul>\n * </p>\n *\n * @param n argument\n * @return {@code n!}\n * @throws MathArithmeticException if the result is too large to be represented\n * by a {@code long}.\n * @throws NotPositiveException if {@code n < 0}.\n * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n * large to fit in a {@code long}.\n * @deprecated use {@link CombinatoricsUtils#factorial(int)}\n */\n@Deprecated\npublic static long factorial(final int n) throws NotPositiveException, MathArithmeticException {\n    return CombinatoricsUtils.factorial(n);\n}"
            ],
            [
                "factorialDouble",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n * {@code double}.\n * The result should be small enough to fit into a {@code double}: The\n * largest {@code n} for which {@code n! < Double.MAX_VALUE} is 170.\n * If the computed value exceeds {@code Double.MAX_VALUE},\n * {@code Double.POSITIVE_INFINITY} is returned.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n * @deprecated use {@link CombinatoricsUtils#factorialDouble(int)}\n */\n@Deprecated\npublic static double factorialDouble(final int n) throws NotPositiveException {\n    return CombinatoricsUtils.factorialDouble(n);\n}"
            ],
            [
                "factorialLog",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Compute the natural logarithm of the factorial of {@code n}.\n *\n * @param n Argument.\n * @return {@code n!}\n * @throws NotPositiveException if {@code n < 0}.\n * @deprecated use {@link CombinatoricsUtils#factorialLog(int)}\n */\n@Deprecated\npublic static double factorialLog(final int n) throws NotPositiveException {\n    return CombinatoricsUtils.factorialLog(n);\n}"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Computes the greatest common divisor of the absolute value of two\n * numbers, using a modified version of the \"binary gcd\" method.\n * See Knuth 4.5.2 algorithm B.\n * The algorithm is due to Josef Stein (1961).\n * <br/>\n * Special cases:\n * <ul>\n *  <li>The invocations\n *   {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n *   {@code gcd(Integer.MIN_VALUE, 0)} and\n *   {@code gcd(0, Integer.MIN_VALUE)} throw an\n *   {@code ArithmeticException}, because the result would be 2^31, which\n *   is too large for an int value.</li>\n *  <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n *   {@code gcd(x, 0)} is the absolute value of {@code x}, except\n *   for the special cases above.</li>\n *  <li>The invocation {@code gcd(0, 0)} is the only one which returns\n *   {@code 0}.</li>\n * </ul>\n *\n * @param p Number.\n * @param q Number.\n * @return the greatest common divisor (never negative).\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code int} value.\n * @since 1.1\n */\npublic static int gcd(int p, int q) throws MathArithmeticException {\n    int a = p;\n    int b = q;\n    if (a == 0 || b == 0) {\n        if (a == Integer.MIN_VALUE || b == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        return FastMath.abs(a + b);\n    }\n    long al = a;\n    long bl = b;\n    boolean useLong = false;\n    if (a < 0) {\n        if (Integer.MIN_VALUE == a) {\n            useLong = true;\n        } else {\n            a = -a;\n        }\n        al = -al;\n    }\n    if (b < 0) {\n        if (Integer.MIN_VALUE == b) {\n            useLong = true;\n        } else {\n            b = -b;\n        }\n        bl = -bl;\n    }\n    if (useLong) {\n        if (al == bl) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n        }\n        long blbu = bl;\n        bl = al;\n        al = blbu % al;\n        if (al == 0) {\n            if (bl > Integer.MAX_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);\n            }\n            return (int) bl;\n        }\n        blbu = bl;\n        // Now \"al\" and \"bl\" fit in an \"int\".\n        b = (int) al;\n        a = (int) (blbu % al);\n    }\n    return gcdPositive(a, b);\n}"
            ],
            [
                "gcd",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Gets the greatest common divisor of the absolute value of two numbers,\n * using the \"binary gcd\" method which avoids division and modulo\n * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n * Stein (1961).\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations\n * {@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)},\n * {@code gcd(Long.MIN_VALUE, 0L)} and\n * {@code gcd(0L, Long.MIN_VALUE)} throw an\n * {@code ArithmeticException}, because the result would be 2^63, which\n * is too large for a long value.</li>\n * <li>The result of {@code gcd(x, x)}, {@code gcd(0L, x)} and\n * {@code gcd(x, 0L)} is the absolute value of {@code x}, except\n * for the special cases above.\n * <li>The invocation {@code gcd(0L, 0L)} is the only one which returns\n * {@code 0L}.</li>\n * </ul>\n *\n * @param p Number.\n * @param q Number.\n * @return the greatest common divisor, never negative.\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code long} value.\n * @since 2.1\n */\npublic static long gcd(final long p, final long q) throws MathArithmeticException {\n    long u = p;\n    long v = q;\n    if ((u == 0) || (v == 0)) {\n        if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);\n        }\n        return FastMath.abs(u) + FastMath.abs(v);\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^63, while positive numbers can only be as large as 2^63-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    /* assert u!=0 && v!=0; */\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 63) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 63) {\n        throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS, p, q);\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    long t = ((u & 1) == 1) ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1L << k);\n}"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Returns the least common multiple of the absolute value of two numbers,\n * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations {@code lcm(Integer.MIN_VALUE, n)} and\n * {@code lcm(n, Integer.MIN_VALUE)}, where {@code abs(n)} is a\n * power of 2, throw an {@code ArithmeticException}, because the result\n * would be 2^31, which is too large for an int value.</li>\n * <li>The result of {@code lcm(0, x)} and {@code lcm(x, 0)} is\n * {@code 0} for any {@code x}.\n * </ul>\n *\n * @param a Number.\n * @param b Number.\n * @return the least common multiple, never negative.\n * @throws MathArithmeticException if the result cannot be represented as\n * a non-negative {@code int} value.\n * @since 1.1\n */\npublic static int lcm(int a, int b) throws MathArithmeticException {\n    if (a == 0 || b == 0) {\n        return 0;\n    }\n    int lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));\n    if (lcm == Integer.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS, a, b);\n    }\n    return lcm;\n}"
            ],
            [
                "lcm",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * <p>\n * Returns the least common multiple of the absolute value of two numbers,\n * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n * </p>\n * Special cases:\n * <ul>\n * <li>The invocations {@code lcm(Long.MIN_VALUE, n)} and\n * {@code lcm(n, Long.MIN_VALUE)}, where {@code abs(n)} is a\n * power of 2, throw an {@code ArithmeticException}, because the result\n * would be 2^63, which is too large for an int value.</li>\n * <li>The result of {@code lcm(0L, x)} and {@code lcm(x, 0L)} is\n * {@code 0L} for any {@code x}.\n * </ul>\n *\n * @param a Number.\n * @param b Number.\n * @return the least common multiple, never negative.\n * @throws MathArithmeticException if the result cannot be represented\n * as a non-negative {@code long} value.\n * @since 2.1\n */\npublic static long lcm(long a, long b) throws MathArithmeticException {\n    if (a == 0 || b == 0) {\n        return 0;\n    }\n    long lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));\n    if (lcm == Long.MIN_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS, a, b);\n    }\n    return lcm;\n}"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Multiply two integers, checking for overflow.\n *\n * @param x Factor.\n * @param y Factor.\n * @return the product {@code x * y}.\n * @throws MathArithmeticException if the result can not be\n * represented as an {@code int}.\n * @since 1.1\n */\npublic static int mulAndCheck(int x, int y) throws MathArithmeticException {\n    long m = ((long) x) * ((long) y);\n    if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n        throw new MathArithmeticException();\n    }\n    return (int) m;\n}"
            ],
            [
                "mulAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Multiply two long integers, checking for overflow.\n *\n * @param a Factor.\n * @param b Factor.\n * @return the product {@code a * b}.\n * @throws MathArithmeticException if the result can not be represented\n * as a {@code long}.\n * @since 1.2\n */\npublic static long mulAndCheck(long a, long b) throws MathArithmeticException {\n    long ret;\n    if (a > b) {\n        // use symmetry to reduce boundary cases\n        ret = mulAndCheck(b, a);\n    } else {\n        if (a < 0) {\n            if (b < 0) {\n                // check for positive overflow with negative a, negative b\n                if (a >= Long.MAX_VALUE / b) {\n                    ret = a * b;\n                } else {\n                    throw new MathArithmeticException();\n                }\n            } else if (b > 0) {\n                // check for negative overflow with negative a, positive b\n                if (Long.MIN_VALUE / b <= a) {\n                    ret = a * b;\n                } else {\n                    throw new MathArithmeticException();\n                }\n            } else {\n                // assert b == 0\n                ret = 0;\n            }\n        } else if (a > 0) {\n            // assert a > 0\n            // assert b > 0\n            // check for positive overflow with positive a, positive b\n            if (a <= Long.MAX_VALUE / b) {\n                ret = a * b;\n            } else {\n                throw new MathArithmeticException();\n            }\n        } else {\n            // assert a == 0\n            ret = 0;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Subtract two integers, checking for overflow.\n *\n * @param x Minuend.\n * @param y Subtrahend.\n * @return the difference {@code x - y}.\n * @throws MathArithmeticException if the result can not be represented\n * as an {@code int}.\n * @since 1.1\n */\npublic static int subAndCheck(int x, int y) throws MathArithmeticException {\n    long s = (long) x - (long) y;\n    if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n        throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n    }\n    return (int) s;\n}"
            ],
            [
                "subAndCheck",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Subtract two long integers, checking for overflow.\n *\n * @param a Value.\n * @param b Value.\n * @return the difference {@code a - b}.\n * @throws MathArithmeticException if the result can not be represented as a\n * {@code long}.\n * @since 1.2\n */\npublic static long subAndCheck(long a, long b) throws MathArithmeticException {\n    long ret;\n    if (b == Long.MIN_VALUE) {\n        if (a < 0) {\n            ret = a - b;\n        } else {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);\n        }\n    } else {\n        // use additive inverse\n        ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n    }\n    return ret;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise an int to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return \\( k^e \\)\n * @throws NotPositiveException if {@code e < 0}.\n * @throws MathArithmeticException if the result would overflow.\n */\npublic static int pow(final int k, final int e) throws NotPositiveException, MathArithmeticException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    try {\n        int exp = e;\n        int result = 1;\n        int k2p = k;\n        while (true) {\n            if ((exp & 0x1) != 0) {\n                result = mulAndCheck(result, k2p);\n            }\n            exp >>= 1;\n            if (exp == 0) {\n                break;\n            }\n            k2p = mulAndCheck(k2p, k2p);\n        }\n        return result;\n    } catch (MathArithmeticException mae) {\n        // Add context information.\n        mae.getContext().addMessage(LocalizedFormats.OVERFLOW);\n        mae.getContext().addMessage(LocalizedFormats.BASE, k);\n        mae.getContext().addMessage(LocalizedFormats.EXPONENT, e);\n        // Rethrow.\n        throw mae;\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise an int to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n * @deprecated As of 3.3. Please use {@link #pow(int,int)} instead.\n */\n@Deprecated\npublic static int pow(final int k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    int result = 1;\n    int k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result *= k2p;\n        }\n        k2p *= k2p;\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a long to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return \\( k^e \\)\n * @throws NotPositiveException if {@code e < 0}.\n * @throws MathArithmeticException if the result would overflow.\n */\npublic static long pow(final long k, final int e) throws NotPositiveException, MathArithmeticException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    try {\n        int exp = e;\n        long result = 1;\n        long k2p = k;\n        while (true) {\n            if ((exp & 0x1) != 0) {\n                result = mulAndCheck(result, k2p);\n            }\n            exp >>= 1;\n            if (exp == 0) {\n                break;\n            }\n            k2p = mulAndCheck(k2p, k2p);\n        }\n        return result;\n    } catch (MathArithmeticException mae) {\n        // Add context information.\n        mae.getContext().addMessage(LocalizedFormats.OVERFLOW);\n        mae.getContext().addMessage(LocalizedFormats.BASE, k);\n        mae.getContext().addMessage(LocalizedFormats.EXPONENT, e);\n        // Rethrow.\n        throw mae;\n    }\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a long to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n * @deprecated As of 3.3. Please use {@link #pow(long,int)} instead.\n */\n@Deprecated\npublic static long pow(final long k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    long result = 1l;\n    long k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result *= k2p;\n        }\n        k2p *= k2p;\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to an int power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, int e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    return k.pow(e);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to a long power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, long e) throws NotPositiveException {\n    if (e < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    BigInteger result = BigInteger.ONE;\n    BigInteger k2p = k;\n    while (e != 0) {\n        if ((e & 0x1) != 0) {\n            result = result.multiply(k2p);\n        }\n        k2p = k2p.multiply(k2p);\n        e >>= 1;\n    }\n    return result;\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Raise a BigInteger to a BigInteger power.\n *\n * @param k Number to raise.\n * @param e Exponent (must be positive or zero).\n * @return k<sup>e</sup>\n * @throws NotPositiveException if {@code e < 0}.\n */\npublic static BigInteger pow(final BigInteger k, BigInteger e) throws NotPositiveException {\n    if (e.compareTo(BigInteger.ZERO) < 0) {\n        throw new NotPositiveException(LocalizedFormats.EXPONENT, e);\n    }\n    BigInteger result = BigInteger.ONE;\n    BigInteger k2p = k;\n    while (!BigInteger.ZERO.equals(e)) {\n        if (e.testBit(0)) {\n            result = result.multiply(k2p);\n        }\n        k2p = k2p.multiply(k2p);\n        e = e.shiftRight(1);\n    }\n    return result;\n}"
            ],
            [
                "stirlingS2",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns the <a\n * href=\"http://mathworld.wolfram.com/StirlingNumberoftheSecondKind.html\">\n * Stirling number of the second kind</a>, \"{@code S(n,k)}\", the number of\n * ways of partitioning an {@code n}-element set into {@code k} non-empty\n * subsets.\n * <p>\n * The preconditions are {@code 0 <= k <= n } (otherwise\n * {@code NotPositiveException} is thrown)\n * </p>\n * @param n the size of the set\n * @param k the number of non-empty subsets\n * @return {@code S(n,k)}\n * @throws NotPositiveException if {@code k < 0}.\n * @throws NumberIsTooLargeException if {@code k > n}.\n * @throws MathArithmeticException if some overflow happens, typically for n exceeding 25 and\n * k between 20 and n-2 (S(n,n-1) is handled specifically and does not overflow)\n * @since 3.1\n * @deprecated use {@link CombinatoricsUtils#stirlingS2(int, int)}\n */\n@Deprecated\npublic static long stirlingS2(final int n, final int k) throws NotPositiveException, NumberIsTooLargeException, MathArithmeticException {\n    return CombinatoricsUtils.stirlingS2(n, k);\n}"
            ],
            [
                "isPowerOfTwo",
                "org.apache.commons.math3.util",
                "ArithmeticUtils",
                "/**\n * Returns true if the argument is a power of two.\n *\n * @param n the number to test\n * @return true if the argument is a power of two\n */\npublic static boolean isPowerOfTwo(long n) {\n    return (n > 0) && ((n & (n - 1)) == 0);\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Get the set of locales for which complex formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static ComplexFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static ComplexFormat getInstance(Locale locale) {\n    NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n    return new ComplexFormat(f);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @param imaginaryCharacter Imaginary character.\n * @return the complex format specific to the given locale.\n * @throws NullArgumentException if {@code imaginaryCharacter} is\n * {@code null}.\n * @throws NoDataException if {@code imaginaryCharacter} is an\n * empty string.\n */\npublic static ComplexFormat getInstance(String imaginaryCharacter, Locale locale) throws NullArgumentException, NoDataException {\n    NumberFormat f = CompositeFormat.getDefaultNumberFormat(locale);\n    return new ComplexFormat(imaginaryCharacter, f);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.complex",
                "ComplexField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static ComplexField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "multiply",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Returns the Hamilton product of two quaternions.\n *\n * @param q1 First quaternion.\n * @param q2 Second quaternion.\n * @return the product {@code q1} and {@code q2}, in that order.\n */\npublic static Quaternion multiply(final Quaternion q1, final Quaternion q2) {\n    // Components of the first quaternion.\n    final double q1a = q1.getQ0();\n    final double q1b = q1.getQ1();\n    final double q1c = q1.getQ2();\n    final double q1d = q1.getQ3();\n    // Components of the second quaternion.\n    final double q2a = q2.getQ0();\n    final double q2b = q2.getQ1();\n    final double q2c = q2.getQ2();\n    final double q2d = q2.getQ3();\n    // Components of the product.\n    final double w = q1a * q2a - q1b * q2b - q1c * q2c - q1d * q2d;\n    final double x = q1a * q2b + q1b * q2a + q1c * q2d - q1d * q2c;\n    final double y = q1a * q2c - q1b * q2d + q1c * q2a + q1d * q2b;\n    final double z = q1a * q2d + q1b * q2c - q1c * q2b + q1d * q2a;\n    return new Quaternion(w, x, y, z);\n}"
            ],
            [
                "add",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Computes the sum of two quaternions.\n *\n * @param q1 Quaternion.\n * @param q2 Quaternion.\n * @return the sum of {@code q1} and {@code q2}.\n */\npublic static Quaternion add(final Quaternion q1, final Quaternion q2) {\n    return new Quaternion(q1.getQ0() + q2.getQ0(), q1.getQ1() + q2.getQ1(), q1.getQ2() + q2.getQ2(), q1.getQ3() + q2.getQ3());\n}"
            ],
            [
                "subtract",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Subtracts two quaternions.\n *\n * @param q1 First Quaternion.\n * @param q2 Second quaternion.\n * @return the difference between {@code q1} and {@code q2}.\n */\npublic static Quaternion subtract(final Quaternion q1, final Quaternion q2) {\n    return new Quaternion(q1.getQ0() - q2.getQ0(), q1.getQ1() - q2.getQ1(), q1.getQ2() - q2.getQ2(), q1.getQ3() - q2.getQ3());\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Computes the dot-product of two quaternions.\n *\n * @param q1 Quaternion.\n * @param q2 Quaternion.\n * @return the dot product of {@code q1} and {@code q2}.\n */\npublic static double dotProduct(final Quaternion q1, final Quaternion q2) {\n    return q1.getQ0() * q2.getQ0() + q1.getQ1() * q2.getQ1() + q1.getQ2() * q2.getQ2() + q1.getQ3() * q2.getQ3();\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Test for the floating-point equality between Complex objects.\n * It returns {@code true} if both arguments are equal or within the\n * range of allowed error (inclusive).\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n * values between the real (resp. imaginary) parts of {@code x} and\n * {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floating\n * point values between the real (resp. imaginary) parts of {@code x}\n * and {@code y}.\n *\n * @see Precision#equals(double,double,int)\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y, int maxUlps) {\n    return Precision.equals(x.real, y.real, maxUlps) && Precision.equals(x.imaginary, y.imaginary, maxUlps);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} iff the values are equal as defined by\n * {@link #equals(Complex,Complex,int) equals(x, y, 1)}.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @return {@code true} if the values are equal.\n *\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y) {\n    return equals(x, y, 1);\n}"
            ],
            [
                "equals",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} if, both for the real part and for the imaginary\n * part, there is no double value strictly between the arguments or the\n * difference between them is within the range of allowed error\n * (inclusive).  Returns {@code false} if either of the arguments is NaN.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param eps Amount of allowed absolute error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n *\n * @see Precision#equals(double,double,double)\n * @since 3.3\n */\npublic static boolean equals(Complex x, Complex y, double eps) {\n    return Precision.equals(x.real, y.real, eps) && Precision.equals(x.imaginary, y.imaginary, eps);\n}"
            ],
            [
                "equalsWithRelativeTolerance",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Returns {@code true} if, both for the real part and for the imaginary\n * part, there is no double value strictly between the arguments or the\n * relative difference between them is smaller or equal to the given\n * tolerance. Returns {@code false} if either of the arguments is NaN.\n *\n * @param x First value (cannot be {@code null}).\n * @param y Second value (cannot be {@code null}).\n * @param eps Amount of allowed relative error.\n * @return {@code true} if the values are two adjacent floating point\n * numbers or they are within range of each other.\n *\n * @see Precision#equalsWithRelativeTolerance(double,double,double)\n * @since 3.3\n */\npublic static boolean equalsWithRelativeTolerance(Complex x, Complex y, double eps) {\n    return Precision.equalsWithRelativeTolerance(x.real, y.real, eps) && Precision.equalsWithRelativeTolerance(x.imaginary, y.imaginary, eps);\n}"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Create a complex number given the real and imaginary parts.\n *\n * @param realPart Real part.\n * @param imaginaryPart Imaginary part.\n * @return a Complex instance.\n */\npublic static Complex valueOf(double realPart, double imaginaryPart) {\n    if (Double.isNaN(realPart) || Double.isNaN(imaginaryPart)) {\n        return NaN;\n    }\n    return new Complex(realPart, imaginaryPart);\n}"
            ],
            [
                "valueOf",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * Create a complex number given only the real part.\n *\n * @param realPart Real part.\n * @return a Complex instance.\n */\npublic static Complex valueOf(double realPart) {\n    if (Double.isNaN(realPart)) {\n        return NaN;\n    }\n    return new Complex(realPart);\n}"
            ],
            [
                "polar2Complex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "/**\n * Creates a complex number from the given polar representation.\n * <p>\n * The value returned is <code>r&middot;e<sup>i&middot;theta</sup></code>,\n * computed as <code>r&middot;cos(theta) + r&middot;sin(theta)i</code></p>\n * <p>\n * If either <code>r</code> or <code>theta</code> is NaN, or\n * <code>theta</code> is infinite, {@link Complex#NaN} is returned.</p>\n * <p>\n * If <code>r</code> is infinite and <code>theta</code> is finite,\n * infinite or NaN values may be returned in parts of the result, following\n * the rules for double arithmetic.<pre>\n * Examples:\n * <code>\n * polar2Complex(INFINITY, &pi;/4) = INFINITY + INFINITY i\n * polar2Complex(INFINITY, 0) = INFINITY + NaN i\n * polar2Complex(INFINITY, -&pi;/4) = INFINITY - INFINITY i\n * polar2Complex(INFINITY, 5&pi;/4) = -INFINITY - INFINITY i </code></pre></p>\n *\n * @param r the modulus of the complex number to create\n * @param theta  the argument of the complex number to create\n * @return <code>r&middot;e<sup>i&middot;theta</sup></code>\n * @throws MathIllegalArgumentException if {@code r} is negative.\n * @since 1.1\n */\npublic static Complex polar2Complex(double r, double theta) throws MathIllegalArgumentException {\n    if (r < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_COMPLEX_MODULE, r);\n    }\n    return new Complex(r * FastMath.cos(theta), r * FastMath.sin(theta));\n}"
            ],
            [
                "convertToComplex",
                "org.apache.commons.math3.complex",
                "ComplexUtils",
                "/**\n * Convert an array of primitive doubles to an array of {@code Complex} objects.\n *\n * @param real Array of numbers to be converted to their {@code Complex}\n * equivalent.\n * @return an array of {@code Complex} objects.\n *\n * @since 3.1\n */\npublic static Complex[] convertToComplex(double[] real) {\n    final Complex[] c = new Complex[real.length];\n    for (int i = 0; i < real.length; i++) {\n        c[i] = new Complex(real[i], 0);\n    }\n    return c;\n}"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optimization.linear",
                "SimplexTableau",
                "/**\n * Get the -1 times the sum of all coefficients in the given array.\n * @param coefficients coefficients to sum\n * @return the -1 times the sum of all coefficients in the given array.\n */\nprotected static double getInvertedCoefficientSum(final RealVector coefficients) {\n    double sum = 0;\n    for (double coefficient : coefficients.toArray()) {\n        sum -= coefficient;\n    }\n    return sum;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Get the set of locales for which real vectors formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available real vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Returns the default real vector format for the current locale.\n * @return the default real vector format.\n */\npublic static RealMatrixFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealMatrixFormat",
                "/**\n * Returns the default real vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the real vector format specific to the given locale.\n */\npublic static RealMatrixFormat getInstance(final Locale locale) {\n    return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link RealMatrix} with specified dimensions.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix) which can be stored in a 32kB array, a {@link\n * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n * BlockRealMatrix} instance is built.</p>\n * <p>The matrix elements are all set to 0.0.</p>\n * @param rows number of rows of the matrix\n * @param columns number of columns of the matrix\n * @return  RealMatrix with specified dimensions\n * @see #createRealMatrix(double[][])\n */\npublic static RealMatrix createRealMatrix(final int rows, final int columns) {\n    return (rows * columns <= 4096) ? new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n}"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link FieldMatrix} with specified dimensions.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix), a {@link FieldMatrix} instance is built. Above\n * this threshold a {@link BlockFieldMatrix} instance is built.</p>\n * <p>The matrix elements are all set to field.getZero().</p>\n * @param <T> the type of the field elements\n * @param field field to which the matrix elements belong\n * @param rows number of rows of the matrix\n * @param columns number of columns of the matrix\n * @return  FieldMatrix with specified dimensions\n * @see #createFieldMatrix(FieldElement[][])\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field, final int rows, final int columns) {\n    return (rows * columns <= 4096) ? new Array2DRowFieldMatrix<T>(field, rows, columns) : new BlockFieldMatrix<T>(field, rows, columns);\n}"
            ],
            [
                "createRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link RealMatrix} whose entries are the the values in the\n * the input array.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix) which can be stored in a 32kB array, a {@link\n * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n * BlockRealMatrix} instance is built.</p>\n * <p>The input array is copied, not referenced.</p>\n *\n * @param data input array\n * @return  RealMatrix containing the values of the array\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if {@code data} is not rectangular (not all rows have the same length).\n * @throws NoDataException if a row or column is empty.\n * @throws NullArgumentException if either {@code data} or {@code data[0]}\n * is {@code null}.\n * @throws DimensionMismatchException if {@code data} is not rectangular.\n * @see #createRealMatrix(int, int)\n */\npublic static RealMatrix createRealMatrix(double[][] data) throws NullArgumentException, DimensionMismatchException, NoDataException {\n    if (data == null || data[0] == null) {\n        throw new NullArgumentException();\n    }\n    return (data.length * data[0].length <= 4096) ? new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n}"
            ],
            [
                "createFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a {@link FieldMatrix} whose entries are the the values in the\n * the input array.\n * <p>The type of matrix returned depends on the dimension. Below\n * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n * square matrix), a {@link FieldMatrix} instance is built. Above\n * this threshold a {@link BlockFieldMatrix} instance is built.</p>\n * <p>The input array is copied, not referenced.</p>\n * @param <T> the type of the field elements\n * @param data input array\n * @return a matrix containing the values of the array.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if {@code data} is not rectangular (not all rows have the same length).\n * @throws NoDataException if a row or column is empty.\n * @throws NullArgumentException if either {@code data} or {@code data[0]}\n * is {@code null}.\n * @see #createFieldMatrix(Field, int, int)\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) throws DimensionMismatchException, NoDataException, NullArgumentException {\n    if (data == null || data[0] == null) {\n        throw new NullArgumentException();\n    }\n    return (data.length * data[0].length <= 4096) ? new Array2DRowFieldMatrix<T>(data) : new BlockFieldMatrix<T>(data);\n}"
            ],
            [
                "createRealIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns <code>dimension x dimension</code> identity matrix.\n *\n * @param dimension dimension of identity matrix to generate\n * @return identity matrix\n * @throws IllegalArgumentException if dimension is not positive\n * @since 1.1\n */\npublic static RealMatrix createRealIdentityMatrix(int dimension) {\n    final RealMatrix m = createRealMatrix(dimension, dimension);\n    for (int i = 0; i < dimension; ++i) {\n        m.setEntry(i, i, 1.0);\n    }\n    return m;\n}"
            ],
            [
                "createFieldIdentityMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns <code>dimension x dimension</code> identity matrix.\n *\n * @param <T> the type of the field elements\n * @param field field to which the elements belong\n * @param dimension dimension of identity matrix to generate\n * @return identity matrix\n * @throws IllegalArgumentException if dimension is not positive\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldIdentityMatrix(final Field<T> field, final int dimension) {\n    final T zero = field.getZero();\n    final T one = field.getOne();\n    final T[][] d = MathArrays.buildArray(field, dimension, dimension);\n    for (int row = 0; row < dimension; row++) {\n        final T[] dRow = d[row];\n        Arrays.fill(dRow, zero);\n        dRow[row] = one;\n    }\n    return new Array2DRowFieldMatrix<T>(field, d, false);\n}"
            ],
            [
                "createRealDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a diagonal matrix with specified elements.\n *\n * @param diagonal diagonal elements of the matrix (the array elements\n * will be copied)\n * @return diagonal matrix\n * @since 2.0\n */\npublic static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n    final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n    for (int i = 0; i < diagonal.length; ++i) {\n        m.setEntry(i, i, diagonal[i]);\n    }\n    return m;\n}"
            ],
            [
                "createFieldDiagonalMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Returns a diagonal matrix with specified elements.\n *\n * @param <T> the type of the field elements\n * @param diagonal diagonal elements of the matrix (the array elements\n * will be copied)\n * @return diagonal matrix\n * @since 2.0\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createFieldDiagonalMatrix(final T[] diagonal) {\n    final FieldMatrix<T> m = createFieldMatrix(diagonal[0].getField(), diagonal.length, diagonal.length);\n    for (int i = 0; i < diagonal.length; ++i) {\n        m.setEntry(i, i, diagonal[i]);\n    }\n    return m;\n}"
            ],
            [
                "createRealVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a {@link RealVector} using the data from the input array.\n *\n * @param data the input data\n * @return a data.length RealVector\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code data} is {@code null}.\n */\npublic static RealVector createRealVector(double[] data) throws NoDataException, NullArgumentException {\n    if (data == null) {\n        throw new NullArgumentException();\n    }\n    return new ArrayRealVector(data, true);\n}"
            ],
            [
                "createFieldVector",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a {@link FieldVector} using the data from the input array.\n *\n * @param <T> the type of the field elements\n * @param data the input data\n * @return a data.length FieldVector\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code data} is {@code null}.\n * @throws ZeroException if {@code data} has 0 elements\n */\npublic static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) throws NoDataException, NullArgumentException, ZeroException {\n    if (data == null) {\n        throw new NullArgumentException();\n    }\n    if (data.length == 0) {\n        throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);\n    }\n    return new ArrayFieldVector<T>(data[0].getField(), data, true);\n}"
            ],
            [
                "createRowRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Create a row {@link RealMatrix} using the data from the input\n * array.\n *\n * @param rowData the input row data\n * @return a 1 x rowData.length RealMatrix\n * @throws NoDataException if {@code rowData} is empty.\n * @throws NullArgumentException if {@code rowData} is {@code null}.\n */\npublic static RealMatrix createRowRealMatrix(double[] rowData) throws NoDataException, NullArgumentException {\n    if (rowData == null) {\n        throw new NullArgumentException();\n    }\n    final int nCols = rowData.length;\n    final RealMatrix m = createRealMatrix(1, nCols);\n    for (int i = 0; i < nCols; ++i) {\n        m.setEntry(0, i, rowData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createRowFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Create a row {@link FieldMatrix} using the data from the input\n * array.\n *\n * @param <T> the type of the field elements\n * @param rowData the input row data\n * @return a 1 x rowData.length FieldMatrix\n * @throws NoDataException if {@code rowData} is empty.\n * @throws NullArgumentException if {@code rowData} is {@code null}.\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createRowFieldMatrix(final T[] rowData) throws NoDataException, NullArgumentException {\n    if (rowData == null) {\n        throw new NullArgumentException();\n    }\n    final int nCols = rowData.length;\n    if (nCols == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n    for (int i = 0; i < nCols; ++i) {\n        m.setEntry(0, i, rowData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createColumnRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a column {@link RealMatrix} using the data from the input\n * array.\n *\n * @param columnData  the input column data\n * @return a columnData x 1 RealMatrix\n * @throws NoDataException if {@code columnData} is empty.\n * @throws NullArgumentException if {@code columnData} is {@code null}.\n */\npublic static RealMatrix createColumnRealMatrix(double[] columnData) throws NoDataException, NullArgumentException {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
            ],
            [
                "createColumnFieldMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Creates a column {@link FieldMatrix} using the data from the input\n * array.\n *\n * @param <T> the type of the field elements\n * @param columnData  the input column data\n * @return a columnData x 1 FieldMatrix\n * @throws NoDataException if {@code data} is empty.\n * @throws NullArgumentException if {@code columnData} is {@code null}.\n */\npublic static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) throws NoDataException, NullArgumentException {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final FieldMatrix<T> m = createFieldMatrix(columnData[0].getField(), nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
            ],
            [
                "isSymmetric",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Checks whether a matrix is symmetric.\n *\n * @param matrix Matrix to check.\n * @param eps Relative tolerance.\n * @return {@code true} if {@code matrix} is symmetric.\n * @since 3.1\n */\npublic static boolean isSymmetric(RealMatrix matrix, double eps) {\n    return isSymmetricInternal(matrix, eps, false);\n}"
            ],
            [
                "fractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Convert a {@link FieldMatrix}/{@link Fraction} matrix to a {@link RealMatrix}.\n * @param m Matrix to convert.\n * @return the converted matrix.\n */\npublic static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m) {\n    final FractionMatrixConverter converter = new FractionMatrixConverter();\n    m.walkInOptimizedOrder(converter);\n    return converter.getConvertedMatrix();\n}"
            ],
            [
                "bigFractionMatrixToRealMatrix",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Convert a {@link FieldMatrix}/{@link BigFraction} matrix to a {@link RealMatrix}.\n *\n * @param m Matrix to convert.\n * @return the converted matrix.\n */\npublic static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m) {\n    final BigFractionMatrixConverter converter = new BigFractionMatrixConverter();\n    m.walkInOptimizedOrder(converter);\n    return converter.getConvertedMatrix();\n}"
            ],
            [
                "blockInverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix by splitting it into\n * 4 sub-matrices.\n *\n * @param m Matrix whose inverse must be computed.\n * @param splitIndex Index that determines the \"split\" line and\n * column.\n * The element corresponding to this index will part of the\n * upper-left sub-matrix.\n * @return the inverse of {@code m}.\n * @throws NonSquareMatrixException if {@code m} is not square.\n */\npublic static RealMatrix blockInverse(RealMatrix m, int splitIndex) {\n    final int n = m.getRowDimension();\n    if (m.getColumnDimension() != n) {\n        throw new NonSquareMatrixException(m.getRowDimension(), m.getColumnDimension());\n    }\n    final int splitIndex1 = splitIndex + 1;\n    final RealMatrix a = m.getSubMatrix(0, splitIndex, 0, splitIndex);\n    final RealMatrix b = m.getSubMatrix(0, splitIndex, splitIndex1, n - 1);\n    final RealMatrix c = m.getSubMatrix(splitIndex1, n - 1, 0, splitIndex);\n    final RealMatrix d = m.getSubMatrix(splitIndex1, n - 1, splitIndex1, n - 1);\n    final SingularValueDecomposition aDec = new SingularValueDecomposition(a);\n    final DecompositionSolver aSolver = aDec.getSolver();\n    if (!aSolver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix aInv = aSolver.getInverse();\n    final SingularValueDecomposition dDec = new SingularValueDecomposition(d);\n    final DecompositionSolver dSolver = dDec.getSolver();\n    if (!dSolver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix dInv = dSolver.getInverse();\n    final RealMatrix tmp1 = a.subtract(b.multiply(dInv).multiply(c));\n    final SingularValueDecomposition tmp1Dec = new SingularValueDecomposition(tmp1);\n    final DecompositionSolver tmp1Solver = tmp1Dec.getSolver();\n    if (!tmp1Solver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix result00 = tmp1Solver.getInverse();\n    final RealMatrix tmp2 = d.subtract(c.multiply(aInv).multiply(b));\n    final SingularValueDecomposition tmp2Dec = new SingularValueDecomposition(tmp2);\n    final DecompositionSolver tmp2Solver = tmp2Dec.getSolver();\n    if (!tmp2Solver.isNonSingular()) {\n        throw new SingularMatrixException();\n    }\n    final RealMatrix result11 = tmp2Solver.getInverse();\n    final RealMatrix result01 = aInv.multiply(b).multiply(result11).scalarMultiply(-1);\n    final RealMatrix result10 = dInv.multiply(c).multiply(result00).scalarMultiply(-1);\n    final RealMatrix result = new Array2DRowRealMatrix(n, n);\n    result.setSubMatrix(result00.getData(), 0, 0);\n    result.setSubMatrix(result01.getData(), 0, splitIndex1);\n    result.setSubMatrix(result10.getData(), splitIndex1, 0);\n    result.setSubMatrix(result11.getData(), splitIndex1, splitIndex1);\n    return result;\n}"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix.\n * <p>\n * By default, the inverse of the matrix is computed using the QR-decomposition,\n * unless a more efficient method can be determined for the input matrix.\n * <p>\n * Note: this method will use a singularity threshold of 0,\n * use {@link #inverse(RealMatrix, double)} if a different threshold is needed.\n *\n * @param matrix Matrix whose inverse shall be computed\n * @return the inverse of {@code matrix}\n * @throws NullArgumentException if {@code matrix} is {@code null}\n * @throws SingularMatrixException if m is singular\n * @throws NonSquareMatrixException if matrix is not square\n * @since 3.3\n */\npublic static RealMatrix inverse(RealMatrix matrix) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException {\n    return inverse(matrix, 0);\n}"
            ],
            [
                "inverse",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * Computes the inverse of the given matrix.\n * <p>\n * By default, the inverse of the matrix is computed using the QR-decomposition,\n * unless a more efficient method can be determined for the input matrix.\n *\n * @param matrix Matrix whose inverse shall be computed\n * @param threshold Singularity threshold\n * @return the inverse of {@code m}\n * @throws NullArgumentException if {@code matrix} is {@code null}\n * @throws SingularMatrixException if matrix is singular\n * @throws NonSquareMatrixException if matrix is not square\n * @since 3.3\n */\npublic static RealMatrix inverse(RealMatrix matrix, double threshold) throws NullArgumentException, SingularMatrixException, NonSquareMatrixException {\n    MathUtils.checkNotNull(matrix);\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n    }\n    if (matrix instanceof DiagonalMatrix) {\n        return ((DiagonalMatrix) matrix).inverse(threshold);\n    } else {\n        QRDecomposition decomposition = new QRDecomposition(matrix, threshold);\n        return decomposition.getSolver().getInverse();\n    }\n}"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Convert a data array from raw layout to blocks layout.\n * <p>\n * Raw layout is the straightforward layout where element at row i and\n * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n * is the layout used in {@link BlockFieldMatrix} instances, where the matrix\n * is split in square blocks (except at right and bottom side where blocks may\n * be rectangular to fit matrix size) and each block is stored in a flattened\n * one-dimensional array.\n * </p>\n * <p>\n * This method creates an array in blocks layout from an input array in raw layout.\n * It can be used to provide the array argument of the {@link\n * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n * constructor.\n * </p>\n * @param <T> Type of the field elements.\n * @param rawData Data array in raw layout.\n * @return a new data array containing the same entries but in blocks layout\n * @throws DimensionMismatchException if {@code rawData} is not rectangular\n *  (not all rows have the same length).\n * @see #createBlocksLayout(Field, int, int)\n * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n */\npublic static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) throws DimensionMismatchException {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n    // convert array\n    final Field<T> field = extractField(rawData);\n    final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            // allocate new block\n            final T[] block = MathArrays.buildArray(field, iHeight * jWidth);\n            blocks[blockIndex] = block;\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Create a data array in blocks layout.\n * <p>\n * This method can be used to create the array argument of the {@link\n * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n * constructor.\n * </p>\n * @param <T> Type of the field elements.\n * @param field Field to which the elements belong.\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(FieldElement[][])\n * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n */\npublic static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field, final int rows, final int columns) {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final T[][] blocks = MathArrays.buildArray(field, blockRows * blockColumns, -1);\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = MathArrays.buildArray(field, iHeight * jWidth);\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "toBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Convert a data array from raw layout to blocks layout.\n * <p>\n * Raw layout is the straightforward layout where element at row i and\n * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n * is the layout used in {@link BlockRealMatrix} instances, where the matrix\n * is split in square blocks (except at right and bottom side where blocks may\n * be rectangular to fit matrix size) and each block is stored in a flattened\n * one-dimensional array.\n * </p>\n * <p>\n * This method creates an array in blocks layout from an input array in raw layout.\n * It can be used to provide the array argument of the {@link\n * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n * </p>\n * @param rawData Data array in raw layout.\n * @return a new data array containing the same entries but in blocks layout.\n * @throws DimensionMismatchException if {@code rawData} is not rectangular.\n * @see #createBlocksLayout(int, int)\n * @see #BlockRealMatrix(int, int, double[][], boolean)\n */\npublic static double[][] toBlocksLayout(final double[][] rawData) throws DimensionMismatchException {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n    // convert array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "createBlocksLayout",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Create a data array in blocks layout.\n * <p>\n * This method can be used to create the array argument of the {@link\n * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n * </p>\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(double[][])\n * @see #BlockRealMatrix(int, int, double[][], boolean)\n */\npublic static double[][] createBlocksLayout(final int rows, final int columns) {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}"
            ],
            [
                "unmodifiableRealVector",
                "org.apache.commons.math3.linear",
                "RealVector",
                "/**\n * Returns an unmodifiable view of the specified vector.\n * The returned vector has read-only access. An attempt to modify it will\n * result in a {@link MathUnsupportedOperationException}. However, the\n * returned vector is <em>not</em> immutable, since any modification of\n * {@code v} will also change the returned view.\n * For example, in the following piece of code\n * <pre>\n *     RealVector v = new ArrayRealVector(2);\n *     RealVector w = RealVector.unmodifiableRealVector(v);\n *     v.setEntry(0, 1.2);\n *     v.setEntry(1, -3.4);\n * </pre>\n * the changes will be seen in the {@code w} view of {@code v}.\n *\n * @param v Vector for which an unmodifiable view is to be returned.\n * @return an unmodifiable view of {@code v}.\n */\npublic static RealVector unmodifiableRealVector(final RealVector v) {\n    /**\n     * This anonymous class is an implementation of {@link RealVector}\n     * with read-only access.\n     * It wraps any {@link RealVector}, and exposes all methods which\n     * do not modify it. Invoking methods which should normally result\n     * in the modification of the calling {@link RealVector} results in\n     * a {@link MathUnsupportedOperationException}. It should be noted\n     * that {@link UnmodifiableVector} is <em>not</em> immutable.\n     */\n    return new RealVector() {\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all circumstances.\n         */\n        @Override\n        public RealVector mapToSelf(UnivariateFunction function) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector map(UnivariateFunction function) {\n            return v.map(function);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Iterator<Entry> iterator() {\n            final Iterator<Entry> i = v.iterator();\n            return new Iterator<Entry>() {\n\n                /**\n                 * The current entry.\n                 */\n                private final UnmodifiableEntry e = new UnmodifiableEntry();\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public boolean hasNext() {\n                    return i.hasNext();\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public Entry next() {\n                    e.setIndex(i.next().getIndex());\n                    return e;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 *\n                 * @throws MathUnsupportedOperationException in all\n                 * circumstances.\n                 */\n                public void remove() throws MathUnsupportedOperationException {\n                    throw new MathUnsupportedOperationException();\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Iterator<Entry> sparseIterator() {\n            final Iterator<Entry> i = v.sparseIterator();\n            return new Iterator<Entry>() {\n\n                /**\n                 * The current entry.\n                 */\n                private final UnmodifiableEntry e = new UnmodifiableEntry();\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public boolean hasNext() {\n                    return i.hasNext();\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                public Entry next() {\n                    e.setIndex(i.next().getIndex());\n                    return e;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 *\n                 * @throws MathUnsupportedOperationException in all\n                 * circumstances.\n                 */\n                public void remove() throws MathUnsupportedOperationException {\n                    throw new MathUnsupportedOperationException();\n                }\n            };\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector copy() {\n            return v.copy();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector add(RealVector w) throws DimensionMismatchException {\n            return v.add(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector subtract(RealVector w) throws DimensionMismatchException {\n            return v.subtract(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapAdd(double d) {\n            return v.mapAdd(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapAddToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapSubtract(double d) {\n            return v.mapSubtract(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapSubtractToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapMultiply(double d) {\n            return v.mapMultiply(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapMultiplyToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector mapDivide(double d) {\n            return v.mapDivide(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector mapDivideToSelf(double d) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector ebeMultiply(RealVector w) throws DimensionMismatchException {\n            return v.ebeMultiply(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector ebeDivide(RealVector w) throws DimensionMismatchException {\n            return v.ebeDivide(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double dotProduct(RealVector w) throws DimensionMismatchException {\n            return v.dotProduct(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double cosine(RealVector w) throws DimensionMismatchException, MathArithmeticException {\n            return v.cosine(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getNorm() {\n            return v.getNorm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getL1Norm() {\n            return v.getL1Norm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getLInfNorm() {\n            return v.getLInfNorm();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getDistance(RealVector w) throws DimensionMismatchException {\n            return v.getDistance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getL1Distance(RealVector w) throws DimensionMismatchException {\n            return v.getL1Distance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getLInfDistance(RealVector w) throws DimensionMismatchException {\n            return v.getLInfDistance(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector unitVector() throws MathArithmeticException {\n            return v.unitVector();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void unitize() throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealMatrix outerProduct(RealVector w) {\n            return v.outerProduct(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double getEntry(int index) throws OutOfRangeException {\n            return v.getEntry(index);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void setEntry(int index, double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void addToEntry(int index, double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getDimension() {\n            return v.getDimension();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector append(RealVector w) {\n            return v.append(w);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector append(double d) {\n            return v.append(d);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector getSubVector(int index, int n) throws OutOfRangeException, NotPositiveException {\n            return v.getSubVector(index, n);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void setSubVector(int index, RealVector w) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public void set(double value) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public double[] toArray() {\n            return v.toArray();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isNaN() {\n            return v.isNaN();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isInfinite() {\n            return v.isInfinite();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public RealVector combine(double a, double b, RealVector y) throws DimensionMismatchException {\n            return v.combine(a, b, y);\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * @throws MathUnsupportedOperationException in all\n         * circumstances.\n         */\n        @Override\n        public RealVector combineToSelf(double a, double b, RealVector y) throws MathUnsupportedOperationException {\n            throw new MathUnsupportedOperationException();\n        }\n\n        /**\n         * An entry in the vector.\n         */\n        class UnmodifiableEntry extends Entry {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            public double getValue() {\n                return v.getEntry(getIndex());\n            }\n\n            /**\n             * {@inheritDoc}\n             *\n             * @throws MathUnsupportedOperationException in all\n             * circumstances.\n             */\n            @Override\n            public void setValue(double value) throws MathUnsupportedOperationException {\n                throw new MathUnsupportedOperationException();\n            }\n        }\n    };\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Get the set of locales for which real vectors formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available real vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Returns the default real vector format for the current locale.\n * @return the default real vector format.\n */\npublic static RealVectorFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.linear",
                "RealVectorFormat",
                "/**\n * Returns the default real vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the real vector format specific to the given locale.\n */\npublic static RealVectorFormat getInstance(final Locale locale) {\n    return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "create",
                "org.apache.commons.math3.linear",
                "JacobiPreconditioner",
                "/**\n * Creates a new instance of this class. This method extracts the diagonal\n * coefficients of the specified linear operator. If {@code a} does not\n * extend {@link AbstractRealMatrix}, then the coefficients of the\n * underlying matrix are not accessible, coefficient extraction is made by\n * matrix-vector products with the basis vectors (and might therefore take\n * some time). With matrices, direct entry access is carried out.\n *\n * @param a the linear operator for which the preconditioner should be built\n * @return the diagonal preconditioner made of the inverse of the diagonal\n * coefficients of the specified linear operator\n * @throws NonSquareOperatorException if {@code a} is not square\n */\npublic static JacobiPreconditioner create(final RealLinearOperator a) throws NonSquareOperatorException {\n    final int n = a.getColumnDimension();\n    if (a.getRowDimension() != n) {\n        throw new NonSquareOperatorException(a.getRowDimension(), n);\n    }\n    final double[] diag = new double[n];\n    if (a instanceof AbstractRealMatrix) {\n        final AbstractRealMatrix m = (AbstractRealMatrix) a;\n        for (int i = 0; i < n; i++) {\n            diag[i] = m.getEntry(i, i);\n        }\n    } else {\n        final ArrayRealVector x = new ArrayRealVector(n);\n        for (int i = 0; i < n; i++) {\n            x.set(0.);\n            x.setEntry(i, 1.);\n            diag[i] = a.operate(x).getEntry(i);\n        }\n    }\n    return new JacobiPreconditioner(diag, false);\n}"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Get the elements type from an array.\n *\n * @param <T> Type of the field elements.\n * @param d Data array.\n * @return the field to which the array elements belong.\n * @throws NullArgumentException if the array is {@code null}.\n * @throws NoDataException if the array is empty.\n */\nprotected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) throws NoDataException, NullArgumentException {\n    if (d == null) {\n        throw new NullArgumentException();\n    }\n    if (d.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    if (d[0].length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n    }\n    return d[0][0].getField();\n}"
            ],
            [
                "extractField",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Get the elements type from an array.\n *\n * @param <T> Type of the field elements.\n * @param d Data array.\n * @return the field to which the array elements belong.\n * @throws NoDataException if array is empty.\n */\nprotected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) throws NoDataException {\n    if (d.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    return d[0].getField();\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Build an array of elements.\n * <p>\n * Complete arrays are filled with field.getZero()\n * </p>\n * @param <T> Type of the field elements\n * @param field field to which array elements belong\n * @param rows number of rows\n * @param columns number of columns (may be negative to build partial\n * arrays in the same way <code>new Field[rows][]</code> works)\n * @return a new array\n * @deprecated as of 3.2, replaced by {@link MathArrays#buildArray(Field, int, int)}\n */\n@Deprecated\nprotected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field, final int rows, final int columns) {\n    return MathArrays.buildArray(field, rows, columns);\n}"
            ],
            [
                "buildArray",
                "org.apache.commons.math3.linear",
                "AbstractFieldMatrix",
                "/**\n * Build an array of elements.\n * <p>\n * Arrays are filled with field.getZero()\n * </p>\n * @param <T> the type of the field elements\n * @param field field to which array elements belong\n * @param length of the array\n * @return a new array\n * @deprecated as of 3.2, replaced by {@link MathArrays#buildArray(Field, int)}\n */\n@Deprecated\nprotected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field, final int length) {\n    return MathArrays.buildArray(field, length);\n}"
            ],
            [
                "estimate",
                "org.apache.commons.math3.distribution.fitting",
                "MultivariateNormalMixtureExpectationMaximization",
                "/**\n * Helper method to create a multivariate normal mixture model which can be\n * used to initialize {@link #fit(MixtureMultivariateNormalDistribution)}.\n *\n * This method uses the data supplied to the constructor to try to determine\n * a good mixture model at which to start the fit, but it is not guaranteed\n * to supply a model which will find the optimal solution or even converge.\n *\n * @param data Data to estimate distribution\n * @param numComponents Number of components for estimated mixture\n * @return Multivariate normal mixture model estimated from the data\n * @throws NumberIsTooLargeException if {@code numComponents} is greater\n * than the number of data rows.\n * @throws NumberIsTooSmallException if {@code numComponents < 2}.\n * @throws NotStrictlyPositiveException if data has less than 2 rows\n * @throws DimensionMismatchException if rows of data have different numbers\n *             of columns\n */\npublic static MixtureMultivariateNormalDistribution estimate(final double[][] data, final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException {\n    if (data.length < 2) {\n        throw new NotStrictlyPositiveException(data.length);\n    }\n    if (numComponents < 2) {\n        throw new NumberIsTooSmallException(numComponents, 2, true);\n    }\n    if (numComponents > data.length) {\n        throw new NumberIsTooLargeException(numComponents, data.length, true);\n    }\n    final int numRows = data.length;\n    final int numCols = data[0].length;\n    // sort the data\n    final DataRow[] sortedData = new DataRow[numRows];\n    for (int i = 0; i < numRows; i++) {\n        sortedData[i] = new DataRow(data[i]);\n    }\n    Arrays.sort(sortedData);\n    // uniform weight for each bin\n    final double weight = 1d / numComponents;\n    // components of mixture model to be created\n    final List<Pair<Double, MultivariateNormalDistribution>> components = new ArrayList<Pair<Double, MultivariateNormalDistribution>>(numComponents);\n    // create a component based on data in each bin\n    for (int binIndex = 0; binIndex < numComponents; binIndex++) {\n        // minimum index (inclusive) from sorted data for this bin\n        final int minIndex = (binIndex * numRows) / numComponents;\n        // maximum index (exclusive) from sorted data for this bin\n        final int maxIndex = ((binIndex + 1) * numRows) / numComponents;\n        // number of data records that will be in this bin\n        final int numBinRows = maxIndex - minIndex;\n        // data for this bin\n        final double[][] binData = new double[numBinRows][numCols];\n        // mean of each column for the data in the this bin\n        final double[] columnMeans = new double[numCols];\n        // populate bin and create component\n        for (int i = minIndex, iBin = 0; i < maxIndex; i++, iBin++) {\n            for (int j = 0; j < numCols; j++) {\n                final double val = sortedData[i].getRow()[j];\n                columnMeans[j] += val;\n                binData[iBin][j] = val;\n            }\n        }\n        MathArrays.scaleInPlace(1d / numBinRows, columnMeans);\n        // covariance matrix for this bin\n        final double[][] covMat = new Covariance(binData).getCovarianceMatrix().getData();\n        final MultivariateNormalDistribution mvn = new MultivariateNormalDistribution(columnMeans, covMat);\n        components.add(new Pair<Double, MultivariateNormalDistribution>(weight, mvn));\n    }\n    return new MixtureMultivariateNormalDistribution(components);\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "/**\n * Returns one sample using Cheng's sampling algorithm.\n * @param random random generator to use\n * @param alpha distribution first shape parameter\n * @param beta distribution second shape parameter\n * @return sampled value\n */\nstatic double sample(RandomGenerator random, final double alpha, final double beta) {\n    final double a = FastMath.min(alpha, beta);\n    final double b = FastMath.max(alpha, beta);\n    if (a > 1) {\n        return algorithmBB(random, alpha, a, b);\n    } else {\n        return algorithmBC(random, alpha, b, a);\n    }\n}"
            ],
            [
                "sample",
                "org.apache.commons.math3.distribution",
                "ChengBetaSampler",
                "/**\n * Returns one sample using Cheng's sampling algorithm.\n * @param random random generator to use\n * @param alpha distribution first shape parameter\n * @param beta distribution second shape parameter\n * @return sampled value\n */\nstatic double sample(RandomGenerator random, final double alpha, final double beta) {\n    final double a = FastMath.min(alpha, beta);\n    final double b = FastMath.max(alpha, beta);\n    if (a > 1) {\n        return algorithmBB(random, alpha, a, b);\n    } else {\n        return algorithmBC(random, alpha, b, a);\n    }\n}"
            ],
            [
                "getStirlingError",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * Compute the error of Stirling's series at the given value.\n * <p>\n * References:\n * <ol>\n * <li>Eric W. Weisstein. \"Stirling's Series.\" From MathWorld--A Wolfram Web\n * Resource. <a target=\"_blank\"\n * href=\"http://mathworld.wolfram.com/StirlingsSeries.html\">\n * http://mathworld.wolfram.com/StirlingsSeries.html</a></li>\n * </ol>\n * </p>\n *\n * @param z the value.\n * @return the Striling's series error.\n */\nstatic double getStirlingError(double z) {\n    double ret;\n    if (z < 15.0) {\n        double z2 = 2.0 * z;\n        if (FastMath.floor(z2) == z2) {\n            ret = EXACT_STIRLING_ERRORS[(int) z2];\n        } else {\n            ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * FastMath.log(z) + z - HALF_LOG_2_PI;\n        }\n    } else {\n        double z2 = z * z;\n        ret = (0.083333333333333333333 - (0.00277777777777777777778 - (0.00079365079365079365079365 - (0.000595238095238095238095238 - 0.0008417508417508417508417508 / z2) / z2) / z2) / z2) / z;\n    }\n    return ret;\n}"
            ],
            [
                "getDeviancePart",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * A part of the deviance portion of the saddle point approximation.\n * <p>\n * References:\n * <ol>\n * <li>Catherine Loader (2000). \"Fast and Accurate Computation of Binomial\n * Probabilities.\". <a target=\"_blank\"\n * href=\"http://www.herine.net/stat/papers/dbinom.pdf\">\n * http://www.herine.net/stat/papers/dbinom.pdf</a></li>\n * </ol>\n * </p>\n *\n * @param x the x value.\n * @param mu the average.\n * @return a part of the deviance.\n */\nstatic double getDeviancePart(double x, double mu) {\n    double ret;\n    if (FastMath.abs(x - mu) < 0.1 * (x + mu)) {\n        double d = x - mu;\n        double v = d / (x + mu);\n        double s1 = v * d;\n        double s = Double.NaN;\n        double ej = 2.0 * x * v;\n        v *= v;\n        int j = 1;\n        while (s1 != s) {\n            s = s1;\n            ej *= v;\n            s1 = s + ej / ((j * 2) + 1);\n            ++j;\n        }\n        ret = s1;\n    } else {\n        ret = x * FastMath.log(x / mu) + mu - x;\n    }\n    return ret;\n}"
            ],
            [
                "logBinomialProbability",
                "org.apache.commons.math3.distribution",
                "SaddlePointExpansion",
                "/**\n * Compute the logarithm of the PMF for a binomial distribution\n * using the saddle point expansion.\n *\n * @param x the value at which the probability is evaluated.\n * @param n the number of trials.\n * @param p the probability of success.\n * @param q the probability of failure (1 - p).\n * @return log(p(x)).\n */\nstatic double logBinomialProbability(int x, int n, double p, double q) {\n    double ret;\n    if (x == 0) {\n        if (p < 0.1) {\n            ret = -getDeviancePart(n, n * q) - n * p;\n        } else {\n            ret = n * FastMath.log(q);\n        }\n    } else if (x == n) {\n        if (q < 0.1) {\n            ret = -getDeviancePart(n, n * p) - n * q;\n        } else {\n            ret = n * FastMath.log(p);\n        }\n    } else {\n        ret = getStirlingError(n) - getStirlingError(x) - getStirlingError(n - x) - getDeviancePart(x, n * p) - getDeviancePart(n - x, n * q);\n        double f = (MathUtils.TWO_PI * x * (n - x)) / n;\n        ret = -0.5 * FastMath.log(f) + ret;\n    }\n    return ret;\n}"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "/**\n * Helper function that calculates {@code log(1+x)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x a value larger than or equal to -1\n * @return {@code log(1+x)/x}\n */\nstatic double helper1(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.log1p(x) / x;\n    } else {\n        return 1. - x * ((1. / 2.) - x * ((1. / 3.) - x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfDistribution",
                "/**\n * Helper function to calculate {@code (exp(x)-1)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x free parameter\n * @return {@code (exp(x)-1)/x} if x is non-zero, or 1 if x=0\n */\nstatic double helper2(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.expm1(x) / x;\n    } else {\n        return 1. + x * (1. / 2.) * (1. + x * (1. / 3.) * (1. + x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper1",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "/**\n * Helper function that calculates {@code log(1+x)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x a value larger than or equal to -1\n * @return {@code log(1+x)/x}\n */\nstatic double helper1(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.log1p(x) / x;\n    } else {\n        return 1. - x * ((1. / 2.) - x * ((1. / 3.) - x * (1. / 4.)));\n    }\n}"
            ],
            [
                "helper2",
                "org.apache.commons.math3.distribution",
                "ZipfRejectionInversionSampler",
                "/**\n * Helper function to calculate {@code (exp(x)-1)/x}.\n * <p>\n * A Taylor series expansion is used, if x is close to 0.\n *\n * @param x free parameter\n * @return {@code (exp(x)-1)/x} if x is non-zero, or 1 if x=0\n */\nstatic double helper2(final double x) {\n    if (FastMath.abs(x) > 1e-8) {\n        return FastMath.expm1(x) / x;\n    } else {\n        return 1. + x * (1. / 2.) * (1. + x * (1. / 3.) * (1. + x * (1. / 4.)));\n    }\n}"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxIter",
                "/**\n * Factory method that creates instance of this class that represents\n * a virtually unlimited number of iterations.\n *\n * @return a new instance suitable for allowing {@link Integer#MAX_VALUE}\n * evaluations.\n */\npublic static MaxIter unlimited() {\n    return new MaxIter(Integer.MAX_VALUE);\n}"
            ],
            [
                "getInvertedCoefficientSum",
                "org.apache.commons.math3.optim.linear",
                "SimplexTableau",
                "/**\n * Get the -1 times the sum of all coefficients in the given array.\n * @param coefficients coefficients to sum\n * @return the -1 times the sum of all coefficients in the given array.\n */\nprotected static double getInvertedCoefficientSum(final RealVector coefficients) {\n    double sum = 0;\n    for (double coefficient : coefficients.toArray()) {\n        sum -= coefficient;\n    }\n    return sum;\n}"
            ],
            [
                "unbounded",
                "org.apache.commons.math3.optim",
                "SimpleBounds",
                "/**\n * Factory method that creates instance of this class that represents\n * unbounded ranges.\n *\n * @param dim Number of parameters.\n * @return a new instance suitable for passing to an optimizer that\n * requires bounds specification.\n */\npublic static SimpleBounds unbounded(int dim) {\n    final double[] lB = new double[dim];\n    Arrays.fill(lB, Double.NEGATIVE_INFINITY);\n    final double[] uB = new double[dim];\n    Arrays.fill(uB, Double.POSITIVE_INFINITY);\n    return new SimpleBounds(lB, uB);\n}"
            ],
            [
                "unlimited",
                "org.apache.commons.math3.optim",
                "MaxEval",
                "/**\n * Factory method that creates instance of this class that represents\n * a virtually unlimited number of evaluations.\n *\n * @return a new instance suitable for allowing {@link Integer#MAX_VALUE}\n * evaluations.\n */\npublic static MaxEval unlimited() {\n    return new MaxEval(Integer.MAX_VALUE);\n}"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the error function.\n *\n * <p>erf(x) = 2/&radic;&pi; <sub>0</sub>&int;<sup>x</sup> e<sup>-t<sup>2</sup></sup>dt </p>\n *\n * <p>This implementation computes erf(x) using the\n * {@link Gamma#regularizedGammaP(double, double, double, int) regularized gamma function},\n * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3)</p>\n *\n * <p>The value returned is always between -1 and 1 (inclusive).\n * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from\n * either 1 or -1 as a double, so the appropriate extreme value is returned.\n * </p>\n *\n * @param x the value.\n * @return the error function erf(x)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n * @see Gamma#regularizedGammaP(double, double, double, int)\n */\npublic static double erf(double x) {\n    if (FastMath.abs(x) > 40) {\n        return x > 0 ? 1 : -1;\n    }\n    final double ret = Gamma.regularizedGammaP(0.5, x * x, 1.0e-15, 10000);\n    return x < 0 ? -ret : ret;\n}"
            ],
            [
                "erfc",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the complementary error function.\n *\n * <p>erfc(x) = 2/&radic;&pi; <sub>x</sub>&int;<sup>&infin;</sup> e<sup>-t<sup>2</sup></sup>dt\n * <br/>\n *    = 1 - {@link #erf(double) erf(x)} </p>\n *\n * <p>This implementation computes erfc(x) using the\n * {@link Gamma#regularizedGammaQ(double, double, double, int) regularized gamma function},\n * following <a href=\"http://mathworld.wolfram.com/Erf.html\"> Erf</a>, equation (3).</p>\n *\n * <p>The value returned is always between 0 and 2 (inclusive).\n * If {@code abs(x) > 40}, then {@code erf(x)} is indistinguishable from\n * either 0 or 2 as a double, so the appropriate extreme value is returned.\n * </p>\n *\n * @param x the value\n * @return the complementary error function erfc(x)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n * @see Gamma#regularizedGammaQ(double, double, double, int)\n * @since 2.2\n */\npublic static double erfc(double x) {\n    if (FastMath.abs(x) > 40) {\n        return x > 0 ? 0 : 2;\n    }\n    final double ret = Gamma.regularizedGammaQ(0.5, x * x, 1.0e-15, 10000);\n    return x < 0 ? 2 - ret : ret;\n}"
            ],
            [
                "erf",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the difference between erf(x1) and erf(x2).\n *\n * The implementation uses either erf(double) or erfc(double)\n * depending on which provides the most precise result.\n *\n * @param x1 the first value\n * @param x2 the second value\n * @return erf(x2) - erf(x1)\n */\npublic static double erf(double x1, double x2) {\n    if (x1 > x2) {\n        return -erf(x2, x1);\n    }\n    return x1 < -X_CRIT ? x2 < 0.0 ? erfc(-x2) - erfc(-x1) : erf(x2) - erf(x1) : x2 > X_CRIT && x1 > 0.0 ? erfc(x1) - erfc(x2) : erf(x2) - erf(x1);\n}"
            ],
            [
                "erfInv",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the inverse erf.\n * <p>\n * This implementation is described in the paper:\n * <a href=\"http://people.maths.ox.ac.uk/gilesm/files/gems_erfinv.pdf\">Approximating\n * the erfinv function</a> by Mike Giles, Oxford-Man Institute of Quantitative Finance,\n * which was published in GPU Computing Gems, volume 2, 2010.\n * The source code is available <a href=\"http://gpucomputing.net/?q=node/1828\">here</a>.\n * </p>\n * @param x the value\n * @return t such that x = erf(t)\n * @since 3.2\n */\npublic static double erfInv(final double x) {\n    // beware that the logarithm argument must be\n    // commputed as (1.0 - x) * (1.0 + x),\n    // it must NOT be simplified as 1.0 - x * x as this\n    // would induce rounding errors near the boundaries +/-1\n    double w = -FastMath.log((1.0 - x) * (1.0 + x));\n    double p;\n    if (w < 6.25) {\n        w -= 3.125;\n        p = -3.6444120640178196996e-21;\n        p = -1.685059138182016589e-19 + p * w;\n        p = 1.2858480715256400167e-18 + p * w;\n        p = 1.115787767802518096e-17 + p * w;\n        p = -1.333171662854620906e-16 + p * w;\n        p = 2.0972767875968561637e-17 + p * w;\n        p = 6.6376381343583238325e-15 + p * w;\n        p = -4.0545662729752068639e-14 + p * w;\n        p = -8.1519341976054721522e-14 + p * w;\n        p = 2.6335093153082322977e-12 + p * w;\n        p = -1.2975133253453532498e-11 + p * w;\n        p = -5.4154120542946279317e-11 + p * w;\n        p = 1.051212273321532285e-09 + p * w;\n        p = -4.1126339803469836976e-09 + p * w;\n        p = -2.9070369957882005086e-08 + p * w;\n        p = 4.2347877827932403518e-07 + p * w;\n        p = -1.3654692000834678645e-06 + p * w;\n        p = -1.3882523362786468719e-05 + p * w;\n        p = 0.0001867342080340571352 + p * w;\n        p = -0.00074070253416626697512 + p * w;\n        p = -0.0060336708714301490533 + p * w;\n        p = 0.24015818242558961693 + p * w;\n        p = 1.6536545626831027356 + p * w;\n    } else if (w < 16.0) {\n        w = FastMath.sqrt(w) - 3.25;\n        p = 2.2137376921775787049e-09;\n        p = 9.0756561938885390979e-08 + p * w;\n        p = -2.7517406297064545428e-07 + p * w;\n        p = 1.8239629214389227755e-08 + p * w;\n        p = 1.5027403968909827627e-06 + p * w;\n        p = -4.013867526981545969e-06 + p * w;\n        p = 2.9234449089955446044e-06 + p * w;\n        p = 1.2475304481671778723e-05 + p * w;\n        p = -4.7318229009055733981e-05 + p * w;\n        p = 6.8284851459573175448e-05 + p * w;\n        p = 2.4031110387097893999e-05 + p * w;\n        p = -0.0003550375203628474796 + p * w;\n        p = 0.00095328937973738049703 + p * w;\n        p = -0.0016882755560235047313 + p * w;\n        p = 0.0024914420961078508066 + p * w;\n        p = -0.0037512085075692412107 + p * w;\n        p = 0.005370914553590063617 + p * w;\n        p = 1.0052589676941592334 + p * w;\n        p = 3.0838856104922207635 + p * w;\n    } else if (!Double.isInfinite(w)) {\n        w = FastMath.sqrt(w) - 5.0;\n        p = -2.7109920616438573243e-11;\n        p = -2.5556418169965252055e-10 + p * w;\n        p = 1.5076572693500548083e-09 + p * w;\n        p = -3.7894654401267369937e-09 + p * w;\n        p = 7.6157012080783393804e-09 + p * w;\n        p = -1.4960026627149240478e-08 + p * w;\n        p = 2.9147953450901080826e-08 + p * w;\n        p = -6.7711997758452339498e-08 + p * w;\n        p = 2.2900482228026654717e-07 + p * w;\n        p = -9.9298272942317002539e-07 + p * w;\n        p = 4.5260625972231537039e-06 + p * w;\n        p = -1.9681778105531670567e-05 + p * w;\n        p = 7.5995277030017761139e-05 + p * w;\n        p = -0.00021503011930044477347 + p * w;\n        p = -0.00013871931833623122026 + p * w;\n        p = 1.0103004648645343977 + p * w;\n        p = 4.8499064014085844221 + p * w;\n    } else {\n        // this branch does not appears in the original code, it\n        // was added because the previous branch does not handle\n        // x = +/-1 correctly. In this case, w is positive infinity\n        // and as the first coefficient (-2.71e-11) is negative.\n        // Once the first multiplication is done, p becomes negative\n        // infinity and remains so throughout the polynomial evaluation.\n        // So the branch above incorrectly returns negative infinity\n        // instead of the correct positive infinity.\n        p = Double.POSITIVE_INFINITY;\n    }\n    return p * x;\n}"
            ],
            [
                "erfcInv",
                "org.apache.commons.math3.special",
                "Erf",
                "/**\n * Returns the inverse erfc.\n * @param x the value\n * @return t such that x = erfc(t)\n * @since 3.2\n */\npublic static double erfcInv(final double x) {\n    return erfInv(1 - x);\n}"
            ],
            [
                "value",
                "org.apache.commons.math3.special",
                "BesselJ",
                "/**\n * Returns the first Bessel function, \\(J_{order}(x)\\).\n *\n * @param order Order of the Bessel function\n * @param x Argument\n * @return Value of the Bessel function of the first kind, \\(J_{order}(x)\\)\n * @throws MathIllegalArgumentException if {@code x} is too large relative to {@code order}\n * @throws ConvergenceException if the algorithm fails to converge\n */\npublic static double value(double order, double x) throws MathIllegalArgumentException, ConvergenceException {\n    final int n = (int) order;\n    final double alpha = order - n;\n    final int nb = n + 1;\n    final BesselJResult res = rjBesl(x, alpha, nb);\n    if (res.nVals >= nb) {\n        return res.vals[n];\n    } else if (res.nVals < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.BESSEL_FUNCTION_BAD_ARGUMENT, order, x);\n    } else if (FastMath.abs(res.vals[res.nVals - 1]) < 1e-100) {\n        // underflow; return value (will be zero)\n        return res.vals[n];\n    }\n    throw new ConvergenceException(LocalizedFormats.BESSEL_FUNCTION_FAILED_CONVERGENCE, order, x);\n}"
            ],
            [
                "rjBesl",
                "org.apache.commons.math3.special",
                "BesselJ",
                "/**\n * Calculates Bessel functions \\(J_{n+alpha}(x)\\) for\n * non-negative argument x, and non-negative order n + alpha.\n * <p>\n * Before using the output vector, the user should check that\n * nVals = nb, i.e., all orders have been calculated to the desired accuracy.\n * See BesselResult class javadoc for details on return values.\n * </p>\n * @param x non-negative real argument for which J's are to be calculated\n * @param alpha fractional part of order for which J's or exponentially\n * scaled J's (\\(J\\cdot e^{x}\\)) are to be calculated. 0 <= alpha < 1.0.\n * @param nb integer number of functions to be calculated, nb > 0. The first\n * function calculated is of order alpha, and the last is of order\n * nb - 1 + alpha.\n * @return BesselJResult a vector of the functions\n * \\(J_{alpha}(x)\\) through \\(J_{nb-1+alpha}(x)\\), or the corresponding exponentially\n * scaled functions and an integer output variable indicating possible errors\n */\npublic static BesselJResult rjBesl(double x, double alpha, int nb) {\n    final double[] b = new double[nb];\n    int ncalc = 0;\n    double alpem = 0;\n    double alp2em = 0;\n    // ---------------------------------------------------------------------\n    // Check for out of range arguments.\n    // ---------------------------------------------------------------------\n    final int magx = (int) x;\n    if ((nb > 0) && (x >= X_MIN) && (x <= X_MAX) && (alpha >= 0) && (alpha < 1)) {\n        // ---------------------------------------------------------------------\n        // Initialize result array to zero.\n        // ---------------------------------------------------------------------\n        ncalc = nb;\n        for (int i = 0; i < nb; ++i) {\n            b[i] = 0;\n        }\n        // ---------------------------------------------------------------------\n        // Branch to use 2-term ascending series for small X and asymptotic\n        // form for large X when NB is not too large.\n        // ---------------------------------------------------------------------\n        double tempa;\n        double tempb;\n        double tempc;\n        double tover;\n        if (x < RTNSIG) {\n            // ---------------------------------------------------------------------\n            // Two-term ascending series for small X.\n            // ---------------------------------------------------------------------\n            tempa = 1;\n            alpem = 1 + alpha;\n            double halfx = 0;\n            if (x > ENMTEN) {\n                halfx = 0.5 * x;\n            }\n            if (alpha != 0) {\n                tempa = FastMath.pow(halfx, alpha) / (alpha * Gamma.gamma(alpha));\n            }\n            tempb = 0;\n            if (x + 1 > 1) {\n                tempb = -halfx * halfx;\n            }\n            b[0] = tempa + (tempa * tempb / alpem);\n            if ((x != 0) && (b[0] == 0)) {\n                ncalc = 0;\n            }\n            if (nb != 1) {\n                if (x <= 0) {\n                    for (int n = 1; n < nb; ++n) {\n                        b[n] = 0;\n                    }\n                } else {\n                    // ---------------------------------------------------------------------\n                    // Calculate higher order functions.\n                    // ---------------------------------------------------------------------\n                    tempc = halfx;\n                    tover = tempb != 0 ? ENMTEN / tempb : 2 * ENMTEN / x;\n                    for (int n = 1; n < nb; ++n) {\n                        tempa /= alpem;\n                        alpem += 1;\n                        tempa *= tempc;\n                        if (tempa <= tover * alpem) {\n                            tempa = 0;\n                        }\n                        b[n] = tempa + (tempa * tempb / alpem);\n                        if ((b[n] == 0) && (ncalc > n)) {\n                            ncalc = n;\n                        }\n                    }\n                }\n            }\n        } else if ((x > 25.0) && (nb <= magx + 1)) {\n            // ---------------------------------------------------------------------\n            // Asymptotic series for X > 25\n            // ---------------------------------------------------------------------\n            final double xc = FastMath.sqrt(PI2 / x);\n            final double mul = 0.125 / x;\n            final double xin = mul * mul;\n            int m = 0;\n            if (x >= 130.0) {\n                m = 4;\n            } else if (x >= 35.0) {\n                m = 8;\n            } else {\n                m = 11;\n            }\n            final double xm = 4.0 * m;\n            // ---------------------------------------------------------------------\n            // Argument reduction for SIN and COS routines.\n            // ---------------------------------------------------------------------\n            double t = (double) ((int) ((x / TWOPI) + 0.5));\n            final double z = x - t * TOWPI1 - t * TWOPI2 - (alpha + 0.5) / PI2;\n            double vsin = FastMath.sin(z);\n            double vcos = FastMath.cos(z);\n            double gnu = 2 * alpha;\n            double capq;\n            double capp;\n            double s;\n            double t1;\n            double xk;\n            for (int i = 1; i <= 2; i++) {\n                s = (xm - 1 - gnu) * (xm - 1 + gnu) * xin * 0.5;\n                t = (gnu - (xm - 3.0)) * (gnu + (xm - 3.0));\n                capp = (s * t) / FACT[2 * m];\n                t1 = (gnu - (xm + 1)) * (gnu + (xm + 1));\n                capq = (s * t1) / FACT[2 * m + 1];\n                xk = xm;\n                int k = 2 * m;\n                t1 = t;\n                for (int j = 2; j <= m; j++) {\n                    xk -= 4.0;\n                    s = (xk - 1 - gnu) * (xk - 1 + gnu);\n                    t = (gnu - (xk - 3.0)) * (gnu + (xk - 3.0));\n                    capp = (capp + 1 / FACT[k - 2]) * s * t * xin;\n                    capq = (capq + 1 / FACT[k - 1]) * s * t1 * xin;\n                    k -= 2;\n                    t1 = t;\n                }\n                capp += 1;\n                capq = (capq + 1) * ((gnu * gnu) - 1) * (0.125 / x);\n                b[i - 1] = xc * (capp * vcos - capq * vsin);\n                if (nb == 1) {\n                    return new BesselJResult(MathArrays.copyOf(b, b.length), ncalc);\n                }\n                t = vsin;\n                vsin = -vcos;\n                vcos = t;\n                gnu += 2.0;\n            }\n            // ---------------------------------------------------------------------\n            // If NB > 2, compute J(X,ORDER+I) I = 2, NB-1\n            // ---------------------------------------------------------------------\n            if (nb > 2) {\n                gnu = 2 * alpha + 2.0;\n                for (int j = 2; j < nb; ++j) {\n                    b[j] = gnu * b[j - 1] / x - b[j - 2];\n                    gnu += 2.0;\n                }\n            }\n        } else {\n            // ---------------------------------------------------------------------\n            // Use recurrence to generate results. First initialize the\n            // calculation of P*S.\n            // ---------------------------------------------------------------------\n            final int nbmx = nb - magx;\n            int n = magx + 1;\n            int nstart = 0;\n            int nend = 0;\n            double en = 2 * (n + alpha);\n            double plast = 1;\n            double p = en / x;\n            double pold;\n            // ---------------------------------------------------------------------\n            // Calculate general significance test.\n            // ---------------------------------------------------------------------\n            double test = 2 * ENSIG;\n            boolean readyToInitialize = false;\n            if (nbmx >= 3) {\n                // ---------------------------------------------------------------------\n                // Calculate P*S until N = NB-1. Check for possible\n                // overflow.\n                // ---------------------------------------------------------------------\n                tover = ENTEN / ENSIG;\n                nstart = magx + 2;\n                nend = nb - 1;\n                en = 2 * (nstart - 1 + alpha);\n                double psave;\n                double psavel;\n                for (int k = nstart; k <= nend; k++) {\n                    n = k;\n                    en += 2.0;\n                    pold = plast;\n                    plast = p;\n                    p = (en * plast / x) - pold;\n                    if (p > tover) {\n                        // ---------------------------------------------------------------------\n                        // To avoid overflow, divide P*S by TOVER. Calculate\n                        // P*S until\n                        // ABS(P) > 1.\n                        // ---------------------------------------------------------------------\n                        tover = ENTEN;\n                        p /= tover;\n                        plast /= tover;\n                        psave = p;\n                        psavel = plast;\n                        nstart = n + 1;\n                        do {\n                            n += 1;\n                            en += 2.0;\n                            pold = plast;\n                            plast = p;\n                            p = (en * plast / x) - pold;\n                        } while (p <= 1);\n                        tempb = en / x;\n                        // ---------------------------------------------------------------------\n                        // Calculate backward test and find NCALC, the\n                        // highest N such that\n                        // the test is passed.\n                        // ---------------------------------------------------------------------\n                        test = pold * plast * (0.5 - 0.5 / (tempb * tempb));\n                        test /= ENSIG;\n                        p = plast * tover;\n                        n -= 1;\n                        en -= 2.0;\n                        nend = FastMath.min(nb, n);\n                        for (int l = nstart; l <= nend; l++) {\n                            pold = psavel;\n                            psavel = psave;\n                            psave = (en * psavel / x) - pold;\n                            if (psave * psavel > test) {\n                                ncalc = l - 1;\n                                readyToInitialize = true;\n                                break;\n                            }\n                        }\n                        ncalc = nend;\n                        readyToInitialize = true;\n                        break;\n                    }\n                }\n                if (!readyToInitialize) {\n                    n = nend;\n                    en = 2 * (n + alpha);\n                    // ---------------------------------------------------------------------\n                    // Calculate special significance test for NBMX > 2.\n                    // ---------------------------------------------------------------------\n                    test = FastMath.max(test, FastMath.sqrt(plast * ENSIG) * FastMath.sqrt(2 * p));\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Calculate P*S until significance test passes.\n            // ---------------------------------------------------------------------\n            if (!readyToInitialize) {\n                do {\n                    n += 1;\n                    en += 2.0;\n                    pold = plast;\n                    plast = p;\n                    p = (en * plast / x) - pold;\n                } while (p < test);\n            }\n            // ---------------------------------------------------------------------\n            // Initialize the backward recursion and the normalization sum.\n            // ---------------------------------------------------------------------\n            n += 1;\n            en += 2.0;\n            tempb = 0;\n            tempa = 1 / p;\n            int m = (2 * n) - 4 * (n / 2);\n            double sum = 0;\n            double em = (double) (n / 2);\n            alpem = em - 1 + alpha;\n            alp2em = 2 * em + alpha;\n            if (m != 0) {\n                sum = tempa * alpem * alp2em / em;\n            }\n            nend = n - nb;\n            boolean readyToNormalize = false;\n            boolean calculatedB0 = false;\n            // ---------------------------------------------------------------------\n            // Recur backward via difference equation, calculating (but not\n            // storing) B(N), until N = NB.\n            // ---------------------------------------------------------------------\n            for (int l = 1; l <= nend; l++) {\n                n -= 1;\n                en -= 2.0;\n                tempc = tempb;\n                tempb = tempa;\n                tempa = (en * tempb / x) - tempc;\n                m = 2 - m;\n                if (m != 0) {\n                    em -= 1;\n                    alp2em = 2 * em + alpha;\n                    if (n == 1) {\n                        break;\n                    }\n                    alpem = em - 1 + alpha;\n                    if (alpem == 0) {\n                        alpem = 1;\n                    }\n                    sum = (sum + tempa * alp2em) * alpem / em;\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Store B(NB).\n            // ---------------------------------------------------------------------\n            b[n - 1] = tempa;\n            if (nend >= 0) {\n                if (nb <= 1) {\n                    alp2em = alpha;\n                    if (alpha + 1 == 1) {\n                        alp2em = 1;\n                    }\n                    sum += b[0] * alp2em;\n                    readyToNormalize = true;\n                } else {\n                    // ---------------------------------------------------------------------\n                    // Calculate and store B(NB-1).\n                    // ---------------------------------------------------------------------\n                    n -= 1;\n                    en -= 2.0;\n                    b[n - 1] = (en * tempa / x) - tempb;\n                    if (n == 1) {\n                        calculatedB0 = true;\n                    } else {\n                        m = 2 - m;\n                        if (m != 0) {\n                            em -= 1;\n                            alp2em = 2 * em + alpha;\n                            alpem = em - 1 + alpha;\n                            if (alpem == 0) {\n                                alpem = 1;\n                            }\n                            sum = (sum + (b[n - 1] * alp2em)) * alpem / em;\n                        }\n                    }\n                }\n            }\n            if (!readyToNormalize && !calculatedB0) {\n                nend = n - 2;\n                if (nend != 0) {\n                    // ---------------------------------------------------------------------\n                    // Calculate via difference equation and store B(N),\n                    // until N = 2.\n                    // ---------------------------------------------------------------------\n                    for (int l = 1; l <= nend; l++) {\n                        n -= 1;\n                        en -= 2.0;\n                        b[n - 1] = (en * b[n] / x) - b[n + 1];\n                        m = 2 - m;\n                        if (m != 0) {\n                            em -= 1;\n                            alp2em = 2 * em + alpha;\n                            alpem = em - 1 + alpha;\n                            if (alpem == 0) {\n                                alpem = 1;\n                            }\n                            sum = (sum + b[n - 1] * alp2em) * alpem / em;\n                        }\n                    }\n                }\n            }\n            // ---------------------------------------------------------------------\n            // Calculate b[0]\n            // ---------------------------------------------------------------------\n            if (!readyToNormalize) {\n                if (!calculatedB0) {\n                    b[0] = 2.0 * (alpha + 1) * b[1] / x - b[2];\n                }\n                em -= 1;\n                alp2em = 2 * em + alpha;\n                if (alp2em == 0) {\n                    alp2em = 1;\n                }\n                sum += b[0] * alp2em;\n            }\n            // ---------------------------------------------------------------------\n            // Normalize. Divide all B(N) by sum.\n            // ---------------------------------------------------------------------\n            if (FastMath.abs(alpha) > 1e-16) {\n                sum *= Gamma.gamma(alpha) * FastMath.pow(x * 0.5, -alpha);\n            }\n            tempa = ENMTEN;\n            if (sum > 1) {\n                tempa *= sum;\n            }\n            for (n = 0; n < nb; n++) {\n                if (FastMath.abs(b[n]) < tempa) {\n                    b[n] = 0;\n                }\n                b[n] /= sum;\n            }\n        }\n        // ---------------------------------------------------------------------\n        // Error return -- X, NB, or ALPHA is out of range.\n        // ---------------------------------------------------------------------\n    } else {\n        if (b.length > 0) {\n            b[0] = 0;\n        }\n        ncalc = FastMath.min(nb, 0) - 1;\n    }\n    return new BesselJResult(MathArrays.copyOf(b, b.length), ncalc);\n}"
            ],
            [
                "logGamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>\n * Returns the value of log&nbsp;&Gamma;(x) for x&nbsp;&gt;&nbsp;0.\n * </p>\n * <p>\n * For x &le; 8, the implementation is based on the double precision\n * implementation in the <em>NSWC Library of Mathematics Subroutines</em>,\n * {@code DGAMLN}. For x &gt; 8, the implementation is based on\n * </p>\n * <ul>\n * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">Gamma\n *     Function</a>, equation (28).</li>\n * <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">\n *     Lanczos Approximation</a>, equations (1) through (5).</li>\n * <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on\n *     the computation of the convergent Lanczos complex Gamma\n *     approximation</a></li>\n * </ul>\n *\n * @param x Argument.\n * @return the value of {@code log(Gamma(x))}, {@code Double.NaN} if\n * {@code x <= 0.0}.\n */\npublic static double logGamma(double x) {\n    double ret;\n    if (Double.isNaN(x) || (x <= 0.0)) {\n        ret = Double.NaN;\n    } else if (x < 0.5) {\n        return logGamma1p(x) - FastMath.log(x);\n    } else if (x <= 2.5) {\n        return logGamma1p((x - 0.5) - 0.5);\n    } else if (x <= 8.0) {\n        final int n = (int) FastMath.floor(x - 1.5);\n        double prod = 1.0;\n        for (int i = 1; i <= n; i++) {\n            prod *= x - i;\n        }\n        return logGamma1p(x - (n + 1)) + FastMath.log(prod);\n    } else {\n        double sum = lanczos(x);\n        double tmp = x + LANCZOS_G + .5;\n        ret = ((x + .5) * FastMath.log(tmp)) - tmp + HALF_LOG_2_PI + FastMath.log(sum / x);\n    }\n    return ret;\n}"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function P(a, x).\n *\n * @param a Parameter.\n * @param x Value.\n * @return the regularized gamma function P(a, x).\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaP(double a, double x) {\n    return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedGammaP",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function P(a, x).\n *\n * The implementation of this method is based on:\n * <ul>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n *   Regularized Gamma Function</a>, equation (1)\n *  </li>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n *   Incomplete Gamma Function</a>, equation (4).\n *  </li>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n *   Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n *  </li>\n * </ul>\n *\n * @param a the a parameter.\n * @param x the value.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized gamma function P(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n        ret = Double.NaN;\n    } else if (x == 0.0) {\n        ret = 0.0;\n    } else if (x >= a + 1) {\n        // use regularizedGammaQ because it should converge faster in this\n        // case.\n        ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n    } else {\n        // calculate series\n        // current element index\n        double n = 0.0;\n        // n-th element in the series\n        double an = 1.0 / a;\n        // partial sum\n        double sum = an;\n        while (FastMath.abs(an / sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) {\n            // compute next element in the series\n            n += 1.0;\n            an *= x / (a + n);\n            // update partial sum\n            sum += an;\n        }\n        if (n >= maxIterations) {\n            throw new MaxCountExceededException(maxIterations);\n        } else if (Double.isInfinite(sum)) {\n            ret = 1.0;\n        } else {\n            ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * sum;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n *\n * @param a the a parameter.\n * @param x the value.\n * @return the regularized gamma function Q(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaQ(double a, double x) {\n    return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedGammaQ",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n *\n * The implementation of this method is based on:\n * <ul>\n *  <li>\n *   <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n *   Regularized Gamma Function</a>, equation (1).\n *  </li>\n *  <li>\n *   <a href=\"http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\">\n *   Regularized incomplete gamma function: Continued fraction representations\n *   (formula 06.08.10.0003)</a>\n *  </li>\n * </ul>\n *\n * @param a the a parameter.\n * @param x the value.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized gamma function P(a, x)\n * @throws MaxCountExceededException if the algorithm fails to converge.\n */\npublic static double regularizedGammaQ(final double a, double x, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n        ret = Double.NaN;\n    } else if (x == 0.0) {\n        ret = 1.0;\n    } else if (x < a + 1.0) {\n        // use regularizedGammaP because it should converge faster in this\n        // case.\n        ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n    } else {\n        // create continued fraction\n        ContinuedFraction cf = new ContinuedFraction() {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getA(int n, double x) {\n                return ((2.0 * n) + 1.0) - a + x;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getB(int n, double x) {\n                return n * (a - n);\n            }\n        };\n        ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\n        ret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret;\n    }\n    return ret;\n}"
            ],
            [
                "digamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>Computes the digamma function of x.</p>\n *\n * <p>This is an independently written implementation of the algorithm described in\n * Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976.</p>\n *\n * <p>Some of the constants have been changed to increase accuracy at the moderate expense\n * of run-time.  The result should be accurate to within 10^-8 absolute tolerance for\n * x >= 10^-5 and within 10^-8 relative tolerance for x > 0.</p>\n *\n * <p>Performance for large negative values of x will be quite expensive (proportional to\n * |x|).  Accuracy for negative values of x should be about 10^-8 absolute for results\n * less than 10^5 and 10^-8 relative for results larger than that.</p>\n *\n * @param x Argument.\n * @return digamma(x) to within 10-8 relative or absolute error whichever is smaller.\n * @see <a href=\"http://en.wikipedia.org/wiki/Digamma_function\">Digamma</a>\n * @see <a href=\"http://www.uv.es/~bernardo/1976AppStatist.pdf\">Bernardo&apos;s original article </a>\n * @since 2.0\n */\npublic static double digamma(double x) {\n    if (Double.isNaN(x) || Double.isInfinite(x)) {\n        return x;\n    }\n    if (x > 0 && x <= S_LIMIT) {\n        // use method 5 from Bernardo AS103\n        // accurate to O(x)\n        return -GAMMA - 1 / x;\n    }\n    if (x >= C_LIMIT) {\n        // use method 4 (accurate to O(1/x^8)\n        double inv = 1 / (x * x);\n        //            1       1        1         1\n        // log(x) -  --- - ------ + ------- - -------\n        //           2 x   12 x^2   120 x^4   252 x^6\n        return FastMath.log(x) - 0.5 / x - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));\n    }\n    return digamma(x + 1) - 1 / x;\n}"
            ],
            [
                "trigamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Computes the trigamma function of x.\n * This function is derived by taking the derivative of the implementation\n * of digamma.\n *\n * @param x Argument.\n * @return trigamma(x) to within 10-8 relative or absolute error whichever is smaller\n * @see <a href=\"http://en.wikipedia.org/wiki/Trigamma_function\">Trigamma</a>\n * @see Gamma#digamma(double)\n * @since 2.0\n */\npublic static double trigamma(double x) {\n    if (Double.isNaN(x) || Double.isInfinite(x)) {\n        return x;\n    }\n    if (x > 0 && x <= S_LIMIT) {\n        return 1 / (x * x);\n    }\n    if (x >= C_LIMIT) {\n        double inv = 1 / (x * x);\n        //  1    1      1       1       1\n        //  - + ---- + ---- - ----- + -----\n        //  x      2      3       5       7\n        //      2 x    6 x    30 x    42 x\n        return 1 / x + inv / 2 + inv / x * (1.0 / 6 - inv * (1.0 / 30 + inv / 42));\n    }\n    return trigamma(x + 1) + 1 / (x * x);\n}"
            ],
            [
                "lanczos",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <p>\n * Returns the Lanczos approximation used to compute the gamma function.\n * The Lanczos approximation is related to the Gamma function by the\n * following equation\n * <center>\n * {@code gamma(x) = sqrt(2 * pi) / x * (x + g + 0.5) ^ (x + 0.5)\n *                   * exp(-x - g - 0.5) * lanczos(x)},\n * </center>\n * where {@code g} is the Lanczos constant.\n * </p>\n *\n * @param x Argument.\n * @return The Lanczos approximation.\n * @see <a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">Lanczos Approximation</a>\n * equations (1) through (5), and Paul Godfrey's\n * <a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Note on the computation\n * of the convergent Lanczos complex Gamma approximation</a>\n * @since 3.1\n */\npublic static double lanczos(final double x) {\n    double sum = 0.0;\n    for (int i = LANCZOS.length - 1; i > 0; --i) {\n        sum += LANCZOS[i] / (x + i);\n    }\n    return sum + LANCZOS[0];\n}"
            ],
            [
                "invGamma1pm1",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of 1 / &Gamma;(1 + x) - 1 for -0&#46;5 &le; x &le;\n * 1&#46;5. This implementation is based on the double precision\n * implementation in the <em>NSWC Library of Mathematics Subroutines</em>,\n * {@code DGAM1}.\n *\n * @param x Argument.\n * @return The value of {@code 1.0 / Gamma(1.0 + x) - 1.0}.\n * @throws NumberIsTooSmallException if {@code x < -0.5}\n * @throws NumberIsTooLargeException if {@code x > 1.5}\n * @since 3.1\n */\npublic static double invGamma1pm1(final double x) {\n    if (x < -0.5) {\n        throw new NumberIsTooSmallException(x, -0.5, true);\n    }\n    if (x > 1.5) {\n        throw new NumberIsTooLargeException(x, 1.5, true);\n    }\n    final double ret;\n    final double t = x <= 0.5 ? x : (x - 0.5) - 0.5;\n    if (t < 0.0) {\n        final double a = INV_GAMMA1P_M1_A0 + t * INV_GAMMA1P_M1_A1;\n        double b = INV_GAMMA1P_M1_B8;\n        b = INV_GAMMA1P_M1_B7 + t * b;\n        b = INV_GAMMA1P_M1_B6 + t * b;\n        b = INV_GAMMA1P_M1_B5 + t * b;\n        b = INV_GAMMA1P_M1_B4 + t * b;\n        b = INV_GAMMA1P_M1_B3 + t * b;\n        b = INV_GAMMA1P_M1_B2 + t * b;\n        b = INV_GAMMA1P_M1_B1 + t * b;\n        b = 1.0 + t * b;\n        double c = INV_GAMMA1P_M1_C13 + t * (a / b);\n        c = INV_GAMMA1P_M1_C12 + t * c;\n        c = INV_GAMMA1P_M1_C11 + t * c;\n        c = INV_GAMMA1P_M1_C10 + t * c;\n        c = INV_GAMMA1P_M1_C9 + t * c;\n        c = INV_GAMMA1P_M1_C8 + t * c;\n        c = INV_GAMMA1P_M1_C7 + t * c;\n        c = INV_GAMMA1P_M1_C6 + t * c;\n        c = INV_GAMMA1P_M1_C5 + t * c;\n        c = INV_GAMMA1P_M1_C4 + t * c;\n        c = INV_GAMMA1P_M1_C3 + t * c;\n        c = INV_GAMMA1P_M1_C2 + t * c;\n        c = INV_GAMMA1P_M1_C1 + t * c;\n        c = INV_GAMMA1P_M1_C + t * c;\n        if (x > 0.5) {\n            ret = t * c / x;\n        } else {\n            ret = x * ((c + 0.5) + 0.5);\n        }\n    } else {\n        double p = INV_GAMMA1P_M1_P6;\n        p = INV_GAMMA1P_M1_P5 + t * p;\n        p = INV_GAMMA1P_M1_P4 + t * p;\n        p = INV_GAMMA1P_M1_P3 + t * p;\n        p = INV_GAMMA1P_M1_P2 + t * p;\n        p = INV_GAMMA1P_M1_P1 + t * p;\n        p = INV_GAMMA1P_M1_P0 + t * p;\n        double q = INV_GAMMA1P_M1_Q4;\n        q = INV_GAMMA1P_M1_Q3 + t * q;\n        q = INV_GAMMA1P_M1_Q2 + t * q;\n        q = INV_GAMMA1P_M1_Q1 + t * q;\n        q = 1.0 + t * q;\n        double c = INV_GAMMA1P_M1_C13 + (p / q) * t;\n        c = INV_GAMMA1P_M1_C12 + t * c;\n        c = INV_GAMMA1P_M1_C11 + t * c;\n        c = INV_GAMMA1P_M1_C10 + t * c;\n        c = INV_GAMMA1P_M1_C9 + t * c;\n        c = INV_GAMMA1P_M1_C8 + t * c;\n        c = INV_GAMMA1P_M1_C7 + t * c;\n        c = INV_GAMMA1P_M1_C6 + t * c;\n        c = INV_GAMMA1P_M1_C5 + t * c;\n        c = INV_GAMMA1P_M1_C4 + t * c;\n        c = INV_GAMMA1P_M1_C3 + t * c;\n        c = INV_GAMMA1P_M1_C2 + t * c;\n        c = INV_GAMMA1P_M1_C1 + t * c;\n        c = INV_GAMMA1P_M1_C0 + t * c;\n        if (x > 0.5) {\n            ret = (t / x) * ((c - 0.5) - 0.5);\n        } else {\n            ret = x * c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "logGamma1p",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of log &Gamma;(1 + x) for -0&#46;5 &le; x &le; 1&#46;5.\n * This implementation is based on the double precision implementation in\n * the <em>NSWC Library of Mathematics Subroutines</em>, {@code DGMLN1}.\n *\n * @param x Argument.\n * @return The value of {@code log(Gamma(1 + x))}.\n * @throws NumberIsTooSmallException if {@code x < -0.5}.\n * @throws NumberIsTooLargeException if {@code x > 1.5}.\n * @since 3.1\n */\npublic static double logGamma1p(final double x) throws NumberIsTooSmallException, NumberIsTooLargeException {\n    if (x < -0.5) {\n        throw new NumberIsTooSmallException(x, -0.5, true);\n    }\n    if (x > 1.5) {\n        throw new NumberIsTooLargeException(x, 1.5, true);\n    }\n    return -FastMath.log1p(invGamma1pm1(x));\n}"
            ],
            [
                "gamma",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * Returns the value of \u0393(x). Based on the <em>NSWC Library of\n * Mathematics Subroutines</em> double precision implementation,\n * {@code DGAMMA}.\n *\n * @param x Argument.\n * @return the value of {@code Gamma(x)}.\n * @since 3.1\n */\npublic static double gamma(final double x) {\n    if ((x == FastMath.rint(x)) && (x <= 0.0)) {\n        return Double.NaN;\n    }\n    final double ret;\n    final double absX = FastMath.abs(x);\n    if (absX <= 20.0) {\n        if (x >= 1.0) {\n            /*\n                 * From the recurrence relation\n                 * Gamma(x) = (x - 1) * ... * (x - n) * Gamma(x - n),\n                 * then\n                 * Gamma(t) = 1 / [1 + invGamma1pm1(t - 1)],\n                 * where t = x - n. This means that t must satisfy\n                 * -0.5 <= t - 1 <= 1.5.\n                 */\n            double prod = 1.0;\n            double t = x;\n            while (t > 2.5) {\n                t -= 1.0;\n                prod *= t;\n            }\n            ret = prod / (1.0 + invGamma1pm1(t - 1.0));\n        } else {\n            /*\n                 * From the recurrence relation\n                 * Gamma(x) = Gamma(x + n + 1) / [x * (x + 1) * ... * (x + n)]\n                 * then\n                 * Gamma(x + n + 1) = 1 / [1 + invGamma1pm1(x + n)],\n                 * which requires -0.5 <= x + n <= 1.5.\n                 */\n            double prod = x;\n            double t = x;\n            while (t < -0.5) {\n                t += 1.0;\n                prod *= t;\n            }\n            ret = 1.0 / (prod * (1.0 + invGamma1pm1(t)));\n        }\n    } else {\n        final double y = absX + LANCZOS_G + 0.5;\n        final double gammaAbs = SQRT_TWO_PI / absX * FastMath.pow(y, absX + 0.5) * FastMath.exp(-y) * lanczos(absX);\n        if (x > 0.0) {\n            ret = gammaAbs;\n        } else {\n            /*\n                 * From the reflection formula\n                 * Gamma(x) * Gamma(1 - x) * sin(pi * x) = pi,\n                 * and the recurrence relation\n                 * Gamma(1 - x) = -x * Gamma(-x),\n                 * it is found\n                 * Gamma(x) = -pi / [x * sin(pi * x) * Gamma(-x)].\n                 */\n            ret = -FastMath.PI / (x * FastMath.sin(FastMath.PI * x) * gammaAbs);\n        }\n    }\n    return ret;\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * regularized beta function</a> I(x, a, b).\n *\n * @param x Value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @return the regularized beta function I(x, a, b).\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b) {\n    return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * regularized beta function</a> I(x, a, b).\n *\n * @param x Value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b, double epsilon) {\n    return regularizedBeta(x, a, b, epsilon, Integer.MAX_VALUE);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, double a, double b, int maxIterations) {\n    return regularizedBeta(x, a, b, DEFAULT_EPSILON, maxIterations);\n}"
            ],
            [
                "regularizedBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the regularized beta function I(x, a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li>\n * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n * Regularized Beta Function</a>.</li>\n * <li>\n * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n * Regularized Beta Function</a>.</li>\n * </ul>\n *\n * @param x the value.\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon When the absolute value of the nth item in the\n * series is less than epsilon the approximation ceases to calculate\n * further elements in the series.\n * @param maxIterations Maximum number of \"iterations\" to complete.\n * @return the regularized beta function I(x, a, b)\n * @throws org.apache.commons.math3.exception.MaxCountExceededException\n * if the algorithm fails to converge.\n */\npublic static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n    double ret;\n    if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || x < 0 || x > 1 || a <= 0 || b <= 0) {\n        ret = Double.NaN;\n    } else if (x > (a + 1) / (2 + b + a) && 1 - x <= (b + 1) / (2 + b + a)) {\n        ret = 1 - regularizedBeta(1 - x, b, a, epsilon, maxIterations);\n    } else {\n        ContinuedFraction fraction = new ContinuedFraction() {\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getB(int n, double x) {\n                double ret;\n                double m;\n                if (n % 2 == 0) {\n                    // even\n                    m = n / 2.0;\n                    ret = (m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));\n                } else {\n                    m = (n - 1.0) / 2.0;\n                    ret = -((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                }\n                return ret;\n            }\n\n            /**\n             * {@inheritDoc}\n             */\n            @Override\n            protected double getA(int n, double x) {\n                return 1.0;\n            }\n        };\n        ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log1p(-x)) - FastMath.log(a) - logBeta(a, b)) * 1.0 / fraction.evaluate(x, epsilon, maxIterations);\n    }\n    return ret;\n}"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the natural logarithm of the beta function B(a, b).\n *\n * The implementation of this method is based on:\n * <ul>\n * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n * Beta Function</a>, equation (1).</li>\n * </ul>\n *\n * @param a Parameter {@code a}.\n * @param b Parameter {@code b}.\n * @param epsilon This parameter is ignored.\n * @param maxIterations This parameter is ignored.\n * @return log(B(a, b)).\n * @deprecated as of version 3.1, this method is deprecated as the\n * computation of the beta function is no longer iterative; it will be\n * removed in version 4.0. Current implementation of this method\n * internally calls {@link #logBeta(double, double)}.\n */\n@Deprecated\npublic static double logBeta(double a, double b, double epsilon, int maxIterations) {\n    return logBeta(a, b);\n}"
            ],
            [
                "logBeta",
                "org.apache.commons.math3.special",
                "Beta",
                "/**\n * Returns the value of log B(p, q) for 0 \u2264 x \u2264 1 and p, q > 0. Based on the\n * <em>NSWC Library of Mathematics Subroutines</em> implementation,\n * {@code DBETLN}.\n *\n * @param p First argument.\n * @param q Second argument.\n * @return the value of {@code log(Beta(p, q))}, {@code NaN} if\n * {@code p <= 0} or {@code q <= 0}.\n */\npublic static double logBeta(final double p, final double q) {\n    if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n        return Double.NaN;\n    }\n    final double a = FastMath.min(p, q);\n    final double b = FastMath.max(p, q);\n    if (a >= 10.0) {\n        final double w = sumDeltaMinusDeltaSum(a, b);\n        final double h = a / b;\n        final double c = h / (1.0 + h);\n        final double u = -(a - 0.5) * FastMath.log(c);\n        final double v = b * FastMath.log1p(h);\n        if (u <= v) {\n            return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;\n        } else {\n            return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n        }\n    } else if (a > 2.0) {\n        if (b > 1000.0) {\n            final int n = (int) FastMath.floor(a - 1.0);\n            double prod = 1.0;\n            double ared = a;\n            for (int i = 0; i < n; i++) {\n                ared -= 1.0;\n                prod *= ared / (1.0 + ared / b);\n            }\n            return (FastMath.log(prod) - n * FastMath.log(b)) + (Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared, b));\n        } else {\n            double prod1 = 1.0;\n            double ared = a;\n            while (ared > 2.0) {\n                ared -= 1.0;\n                final double h = ared / b;\n                prod1 *= h / (1.0 + h);\n            }\n            if (b < 10.0) {\n                double prod2 = 1.0;\n                double bred = b;\n                while (bred > 2.0) {\n                    bred -= 1.0;\n                    prod2 *= bred / (ared + bred);\n                }\n                return FastMath.log(prod1) + FastMath.log(prod2) + (Gamma.logGamma(ared) + (Gamma.logGamma(bred) - logGammaSum(ared, bred)));\n            } else {\n                return FastMath.log(prod1) + Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared, b);\n            }\n        }\n    } else if (a >= 1.0) {\n        if (b > 2.0) {\n            if (b < 10.0) {\n                double prod = 1.0;\n                double bred = b;\n                while (bred > 2.0) {\n                    bred -= 1.0;\n                    prod *= bred / (a + bred);\n                }\n                return FastMath.log(prod) + (Gamma.logGamma(a) + (Gamma.logGamma(bred) - logGammaSum(a, bred)));\n            } else {\n                return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a, b);\n            }\n        } else {\n            return Gamma.logGamma(a) + Gamma.logGamma(b) - logGammaSum(a, b);\n        }\n    } else {\n        if (b >= 10.0) {\n            return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a, b);\n        } else {\n            // The following command is the original NSWC implementation.\n            // return Gamma.logGamma(a) +\n            // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n            // The following command turns out to be more accurate.\n            return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) / Gamma.gamma(a + b));\n        }\n    }\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.sampling",
                "DummyStepHandler",
                "/**\n * Get the only instance.\n * @return the only instance\n */\npublic static DummyStepHandler getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckTransformer",
                "/**\n * Get the Nordsieck transformer for a given number of steps.\n * @param nSteps number of steps of the multistep method\n * (excluding the one being computed)\n * @return Nordsieck transformer for the specified number of steps\n */\npublic static AdamsNordsieckTransformer getInstance(final int nSteps) {\n    synchronized (CACHE) {\n        AdamsNordsieckTransformer t = CACHE.get(nSteps);\n        if (t == null) {\n            t = new AdamsNordsieckTransformer(nSteps);\n            CACHE.put(nSteps, t);\n        }\n        return t;\n    }\n}"
            ],
            [
                "taylor",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsFieldStepInterpolator",
                "/**\n * Estimate state by applying Taylor formula.\n * @param reference reference state\n * @param time time at which state must be estimated\n * @param stepSize step size used in the scaled and Nordsieck arrays\n * @param scaled first scaled derivative\n * @param nordsieck Nordsieck vector\n * @return estimated state\n * @param <S> the type of the field elements\n */\npublic static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference, final S time, final S stepSize, final S[] scaled, final Array2DRowFieldMatrix<S> nordsieck) {\n    final S x = time.subtract(reference.getTime());\n    final S normalizedAbscissa = x.divide(stepSize);\n    S[] stateVariation = MathArrays.buildArray(time.getField(), scaled.length);\n    Arrays.fill(stateVariation, time.getField().getZero());\n    S[] estimatedDerivatives = MathArrays.buildArray(time.getField(), scaled.length);\n    Arrays.fill(estimatedDerivatives, time.getField().getZero());\n    // apply Taylor formula from high order to low order,\n    // for the sake of numerical accuracy\n    final S[][] nData = nordsieck.getDataRef();\n    for (int i = nData.length - 1; i >= 0; --i) {\n        final int order = i + 2;\n        final S[] nDataI = nData[i];\n        final S power = normalizedAbscissa.pow(order);\n        for (int j = 0; j < nDataI.length; ++j) {\n            final S d = nDataI[j].multiply(power);\n            stateVariation[j] = stateVariation[j].add(d);\n            estimatedDerivatives[j] = estimatedDerivatives[j].add(d.multiply(order));\n        }\n    }\n    S[] estimatedState = reference.getState();\n    for (int j = 0; j < stateVariation.length; ++j) {\n        stateVariation[j] = stateVariation[j].add(scaled[j].multiply(normalizedAbscissa));\n        estimatedState[j] = estimatedState[j].add(stateVariation[j]);\n        estimatedDerivatives[j] = estimatedDerivatives[j].add(scaled[j].multiply(normalizedAbscissa)).divide(x);\n    }\n    return new FieldODEStateAndDerivative<S>(time, estimatedState, estimatedDerivatives);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.ode.nonstiff",
                "AdamsNordsieckFieldTransformer",
                "/**\n * Get the Nordsieck transformer for a given field and number of steps.\n * @param field field to which the time and state vector elements belong\n * @param nSteps number of steps of the multistep method\n * (excluding the one being computed)\n * @return Nordsieck transformer for the specified field and number of steps\n * @param <T> the type of the field elements\n */\n@SuppressWarnings(\"unchecked\")\npublic static <T extends RealFieldElement<T>> AdamsNordsieckFieldTransformer<T> getInstance(final Field<T> field, final int nSteps) {\n    synchronized (CACHE) {\n        Map<Field<? extends RealFieldElement<?>>, AdamsNordsieckFieldTransformer<? extends RealFieldElement<?>>> map = CACHE.get(nSteps);\n        if (map == null) {\n            map = new HashMap<Field<? extends RealFieldElement<?>>, AdamsNordsieckFieldTransformer<? extends RealFieldElement<?>>>();\n            CACHE.put(nSteps, map);\n        }\n        // use rawtype to avoid compilation problems with java 1.5\n        @SuppressWarnings(\"rawtypes\")\n        AdamsNordsieckFieldTransformer t = map.get(field);\n        if (t == null) {\n            t = new AdamsNordsieckFieldTransformer<T>(field, nSteps);\n            map.put(field, (AdamsNordsieckFieldTransformer<T>) t);\n        }\n        return (AdamsNordsieckFieldTransformer<T>) t;\n    }\n}"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the values in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the input array\n * is null.</p>\n *\n * @param values  array of values to sum\n * @return the sum of the values or <code>Double.NaN</code> if the array\n * is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sum(final double[] values) throws MathIllegalArgumentException {\n    return SUM.evaluate(values);\n}"
            ],
            [
                "sum",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double sum(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM.evaluate(values, begin, length);\n}"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the squares of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values  input array\n * @return the sum of the squared values or <code>Double.NaN</code> if the\n * array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sumSq(final double[] values) throws MathIllegalArgumentException {\n    return SUM_OF_SQUARES.evaluate(values);\n}"
            ],
            [
                "sumSq",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the squares of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the squares of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double sumSq(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM_OF_SQUARES.evaluate(values, begin, length);\n}"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the product of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the product of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double product(final double[] values) throws MathIllegalArgumentException {\n    return PRODUCT.evaluate(values);\n}"
            ],
            [
                "product",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the product of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the product of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double product(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return PRODUCT.evaluate(values, begin, length);\n}"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the natural logs of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.summary.SumOfLogs}.\n * </p>\n *\n * @param values the input array\n * @return the sum of the natural logs of the values or Double.NaN if\n * the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double sumLog(final double[] values) throws MathIllegalArgumentException {\n    return SUM_OF_LOGS.evaluate(values);\n}"
            ],
            [
                "sumLog",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the natural logs of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.summary.SumOfLogs}.\n * </p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the sum of the natural logs of the values or Double.NaN if\n * length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double sumLog(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return SUM_OF_LOGS.evaluate(values, begin, length);\n}"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the arithmetic mean of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Mean} for\n * details on the computing algorithm.</p>\n *\n * @param values the input array\n * @return the mean of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double mean(final double[] values) throws MathIllegalArgumentException {\n    return MEAN.evaluate(values);\n}"
            ],
            [
                "mean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the arithmetic mean of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Mean} for\n * details on the computing algorithm.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the mean of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double mean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MEAN.evaluate(values, begin, length);\n}"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the geometric mean of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.GeometricMean}\n * for details on the computing algorithm.</p>\n *\n * @param values the input array\n * @return the geometric mean of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double geometricMean(final double[] values) throws MathIllegalArgumentException {\n    return GEOMETRIC_MEAN.evaluate(values);\n}"
            ],
            [
                "geometricMean",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the geometric mean of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.GeometricMean}\n * for details on the computing algorithm.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the geometric mean of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double geometricMean(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return GEOMETRIC_MEAN.evaluate(values, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[])} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double variance(final double[] values) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], int, int)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double variance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the specified portion of\n * the input array, using the precomputed mean value.  Returns\n * <code>Double.NaN</code> if the designated subarray is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], double, int, int)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double variance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, mean, begin, length);\n}"
            ],
            [
                "variance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the entries in the input array, using the\n * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n * is empty.\n *\n * <p>This method returns the bias-corrected sample variance (using {@code n - 1} in\n * the denominator).  Use {@link #populationVariance(double[], double)} for the non-bias-corrected\n * population variance.</p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @return the variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double variance(final double[] values, final double mean) throws MathIllegalArgumentException {\n    return VARIANCE.evaluate(values, mean);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the formula and computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @return the population variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double populationVariance(final double[] values) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the population variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double populationVariance(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, begin, length);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the specified portion of\n * the input array, using the precomputed mean value.  Returns\n * <code>Double.NaN</code> if the designated subarray is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or the\n * array index parameters are not valid.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the population variance of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n *  parameters are not valid\n */\npublic static double populationVariance(final double[] values, final double mean, final int begin, final int length) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, mean, begin, length);\n}"
            ],
            [
                "populationVariance",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the <a href=\"http://en.wikibooks.org/wiki/Statistics/Summary/Variance\">\n * population variance</a> of the entries in the input array, using the\n * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n * is empty.\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.moment.Variance} for\n * details on the computing algorithm.</p>\n * <p>\n * The formula used assumes that the supplied mean value is the arithmetic\n * mean of the sample data, not a known population parameter.  This method\n * is supplied only to save computation when the mean has already been\n * computed.</p>\n * <p>\n * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n *\n * @param values the input array\n * @param mean the precomputed mean value\n * @return the population variance of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double populationVariance(final double[] values, final double mean) throws MathIllegalArgumentException {\n    return new Variance(false).evaluate(values, mean);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the maximum of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @return the maximum of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double max(final double[] values) throws MathIllegalArgumentException {\n    return MAX.evaluate(values);\n}"
            ],
            [
                "max",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the maximum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or\n * the array index parameters are not valid.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the maximum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double max(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MAX.evaluate(values, begin, length);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the minimum of the entries in the input array, or\n * <code>Double.NaN</code> if the array is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n * </ul> </p>\n *\n * @param values the input array\n * @return the minimum of the values or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if the array is null\n */\npublic static double min(final double[] values) throws MathIllegalArgumentException {\n    return MIN.evaluate(values);\n}"
            ],
            [
                "min",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the minimum of the entries in the specified portion of\n * the input array, or <code>Double.NaN</code> if the designated subarray\n * is empty.\n * <p>\n * Throws <code>MathIllegalArgumentException</code> if the array is null or\n * the array index parameters are not valid.</p>\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n * </ul></p>\n *\n * @param values the input array\n * @param begin index of the first array element to include\n * @param length the number of elements to include\n * @return the minimum of the values or Double.NaN if length = 0\n * @throws MathIllegalArgumentException if the array is null or the array index\n * parameters are not valid\n */\npublic static double min(final double[] values, final int begin, final int length) throws MathIllegalArgumentException {\n    return MIN.evaluate(values, begin, length);\n}"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns an estimate of the <code>p</code>th percentile of the values\n * in the <code>values</code> array.\n * <p>\n * <ul>\n * <li>Returns <code>Double.NaN</code> if <code>values</code> has length\n * <code>0</code></li></p>\n * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n *  if <code>values</code> has length <code>1</code></li>\n * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n * is null  or p is not a valid quantile value (p must be greater than 0\n * and less than or equal to 100)</li>\n * </ul></p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n * a description of the percentile estimation algorithm used.</p>\n *\n * @param values input array of values\n * @param p the percentile value to compute\n * @return the percentile value or Double.NaN if the array is empty\n * @throws MathIllegalArgumentException if <code>values</code> is null\n * or p is invalid\n */\npublic static double percentile(final double[] values, final double p) throws MathIllegalArgumentException {\n    return PERCENTILE.evaluate(values, p);\n}"
            ],
            [
                "percentile",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns an estimate of the <code>p</code>th percentile of the values\n * in the <code>values</code> array, starting with the element in (0-based)\n * position <code>begin</code> in the array and including <code>length</code>\n * values.\n * <p>\n * <ul>\n * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n *  if <code>length = 1 </code></li>\n * <li>Throws <code>MathIllegalArgumentException</code> if <code>values</code>\n *  is null , <code>begin</code> or <code>length</code> is invalid, or\n * <code>p</code> is not a valid quantile value (p must be greater than 0\n * and less than or equal to 100)</li>\n * </ul></p>\n * <p>\n * See {@link org.apache.commons.math3.stat.descriptive.rank.Percentile} for\n * a description of the percentile estimation algorithm used.</p>\n *\n * @param values array of input values\n * @param p  the percentile to compute\n * @param begin  the first (0-based) element to include in the computation\n * @param length  the number of array elements to include\n * @return  the percentile value\n * @throws MathIllegalArgumentException if the parameters are not valid or the\n * input array is null\n */\npublic static double percentile(final double[] values, final int begin, final int length, final double p) throws MathIllegalArgumentException {\n    return PERCENTILE.evaluate(values, begin, length, p);\n}"
            ],
            [
                "sumDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sum of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., sum(sample1[i] - sample2[i]).\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @return sum of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * (positive) length.\n * @throws NoDataException if the sample arrays are empty.\n */\npublic static double sumDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n <= 0) {\n        throw new NoDataException(LocalizedFormats.INSUFFICIENT_DIMENSION);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        result += sample1[i] - sample2[i];\n    }\n    return result;\n}"
            ],
            [
                "meanDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the mean of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., sum(sample1[i] - sample2[i]) / sample1.length.\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @return mean of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * (positive) length.\n * @throws NoDataException if the sample arrays are empty.\n */\npublic static double meanDifference(final double[] sample1, final double[] sample2) throws DimensionMismatchException, NoDataException {\n    return sumDifference(sample1, sample2) / sample1.length;\n}"
            ],
            [
                "varianceDifference",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the variance of the (signed) differences between corresponding elements of the\n * input arrays -- i.e., var(sample1[i] - sample2[i]).\n *\n * @param sample1  the first array\n * @param sample2  the second array\n * @param meanDifference   the mean difference between corresponding entries\n * @see #meanDifference(double[],double[])\n * @return variance of paired differences\n * @throws DimensionMismatchException if the arrays do not have the same\n * length.\n * @throws NumberIsTooSmallException if the arrays length is less than 2.\n */\npublic static double varianceDifference(final double[] sample1, final double[] sample2, double meanDifference) throws DimensionMismatchException, NumberIsTooSmallException {\n    double sum1 = 0d;\n    double sum2 = 0d;\n    double diff = 0d;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    for (int i = 0; i < n; i++) {\n        diff = sample1[i] - sample2[i];\n        sum1 += (diff - meanDifference) * (diff - meanDifference);\n        sum2 += diff - meanDifference;\n    }\n    return (sum1 - (sum2 * sum2 / n)) / (n - 1);\n}"
            ],
            [
                "normalize",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Normalize (standardize) the sample, so it is has a mean of 0 and a standard deviation of 1.\n *\n * @param sample Sample to normalize.\n * @return normalized (standardized) sample.\n * @since 2.2\n */\npublic static double[] normalize(final double[] sample) {\n    DescriptiveStatistics stats = new DescriptiveStatistics();\n    // Add the data from the series to stats\n    for (int i = 0; i < sample.length; i++) {\n        stats.addValue(sample[i]);\n    }\n    // Compute mean and standard deviation\n    double mean = stats.getMean();\n    double standardDeviation = stats.getStandardDeviation();\n    // initialize the standardizedSample, which has the same length as the sample\n    double[] standardizedSample = new double[sample.length];\n    for (int i = 0; i < sample.length; i++) {\n        // z = (x- mean)/standardDeviation\n        standardizedSample[i] = (sample[i] - mean) / standardDeviation;\n    }\n    return standardizedSample;\n}"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sample mode(s).  The mode is the most frequently occurring\n * value in the sample. If there is a unique value with maximum frequency,\n * this value is returned as the only element of the output array. Otherwise,\n * the returned array contains the maximum frequency elements in increasing\n * order.  For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},\n * the returned array will have length two, with 0 in the first element and\n * 5 in the second.\n *\n * <p>NaN values are ignored when computing the mode - i.e., NaNs will never\n * appear in the output array.  If the sample includes only NaNs or has\n * length 0, an empty array is returned.</p>\n *\n * @param sample input data\n * @return array of array of the most frequently occurring element(s) sorted in ascending order.\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static double[] mode(double[] sample) throws MathIllegalArgumentException {\n    if (sample == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    return getMode(sample, 0, sample.length);\n}"
            ],
            [
                "mode",
                "org.apache.commons.math3.stat",
                "StatUtils",
                "/**\n * Returns the sample mode(s).  The mode is the most frequently occurring\n * value in the sample. If there is a unique value with maximum frequency,\n * this value is returned as the only element of the output array. Otherwise,\n * the returned array contains the maximum frequency elements in increasing\n * order.  For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},\n * the returned array will have length two, with 0 in the first element and\n * 5 in the second.\n *\n * <p>NaN values are ignored when computing the mode - i.e., NaNs will never\n * appear in the output array.  If the sample includes only NaNs or has\n * length 0, an empty array is returned.</p>\n *\n * @param sample input data\n * @param begin index (0-based) of the first array element to include\n * @param length the number of elements to include\n *\n * @return array of array of the most frequently occurring element(s) sorted in ascending order.\n * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n * @since 3.3\n */\npublic static double[] mode(double[] sample, final int begin, final int length) {\n    if (sample == null) {\n        throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n    }\n    if (begin < 0) {\n        throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));\n    }\n    if (length < 0) {\n        throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));\n    }\n    return getMode(sample, begin, length);\n}"
            ],
            [
                "getAgrestiCoullInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create an Agresti-Coull binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getAgrestiCoullInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return AGRESTI_COULL.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getClopperPearsonInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a Clopper-Pearson binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n * <p>\n * Preconditions:\n * <ul>\n * <li>{@code numberOfTrials} must be positive</li>\n * <li>{@code numberOfSuccesses} may not exceed {@code numberOfTrials}</li>\n * <li>{@code confidenceLevel} must be strictly between 0 and 1 (exclusive)</li>\n * </ul>\n * </p>\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getClopperPearsonInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return CLOPPER_PEARSON.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getNormalApproximationInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a binomial confidence interval for the true probability of success\n * of an unknown binomial distribution with the given observed number of\n * trials, successes and confidence level using the Normal approximation to\n * the binomial distribution.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n */\npublic static ConfidenceInterval getNormalApproximationInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return NORMAL_APPROXIMATION.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "getWilsonScoreInterval",
                "org.apache.commons.math3.stat.interval",
                "IntervalUtils",
                "/**\n * Create a Wilson score binomial confidence interval for the true\n * probability of success of an unknown binomial distribution with the given\n * observed number of trials, successes and confidence level.\n *\n * @param numberOfTrials number of trials\n * @param numberOfSuccesses number of successes\n * @param confidenceLevel desired probability that the true probability of\n *        success falls within the returned interval\n * @return Confidence interval containing the probability of success with\n *         probability {@code confidenceLevel}\n * @throws NotStrictlyPositiveException if {@code numberOfTrials <= 0}.\n * @throws NotPositiveException if {@code numberOfSuccesses < 0}.\n * @throws NumberIsTooLargeException if {@code numberOfSuccesses > numberOfTrials}.\n * @throws OutOfRangeException if {@code confidenceLevel} is not in the interval {@code (0, 1)}.\n */\npublic static ConfidenceInterval getWilsonScoreInterval(int numberOfTrials, int numberOfSuccesses, double confidenceLevel) {\n    return WILSON_SCORE.createInterval(numberOfTrials, numberOfSuccesses, confidenceLevel);\n}"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "// CHECKSTYLE: stop JavadocMethodCheck\n/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticT(double[], double[])\n */\npublic static double homoscedasticT(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.homoscedasticT(sample1, sample2);\n}"
            ],
            [
                "homoscedasticT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticT(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double homoscedasticT(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.homoscedasticT(sampleStats1, sampleStats2);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(double[], double[], double)\n */\npublic static boolean homoscedasticTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sample1, sample2, alpha);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(double[], double[])\n */\npublic static double homoscedasticTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sample1, sample2);\n}"
            ],
            [
                "homoscedasticTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#homoscedasticTTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double homoscedasticTTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.homoscedasticTTest(sampleStats1, sampleStats2);\n}"
            ],
            [
                "pairedT",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedT(double[], double[])\n */\npublic static double pairedT(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException {\n    return T_TEST.pairedT(sample1, sample2);\n}"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedTTest(double[], double[], double)\n */\npublic static boolean pairedTTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.pairedTTest(sample1, sample2, alpha);\n}"
            ],
            [
                "pairedTTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#pairedTTest(double[], double[])\n */\npublic static double pairedTTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NoDataException, DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.pairedTTest(sample1, sample2);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double, double[])\n */\npublic static double t(final double mu, final double[] observed) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(mu, observed);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double t(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(mu, sampleStats);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(double[], double[])\n */\npublic static double t(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(sample1, sample2);\n}"
            ],
            [
                "t",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#t(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double t(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException {\n    return T_TEST.t(sampleStats1, sampleStats2);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, double[], double)\n */\npublic static boolean tTest(final double mu, final double[] sample, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sample, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, double[])\n */\npublic static double tTest(final double mu, final double[] sample) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sample);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary, double)\n */\npublic static boolean tTest(final double mu, final StatisticalSummary sampleStats, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sampleStats, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double tTest(final double mu, final StatisticalSummary sampleStats) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(mu, sampleStats);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double[], double[], double)\n */\npublic static boolean tTest(final double[] sample1, final double[] sample2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(sample1, sample2, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(double[], double[])\n */\npublic static double tTest(final double[] sample1, final double[] sample2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(sample1, sample2);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary, double)\n */\npublic static boolean tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2, final double alpha) throws NullArgumentException, NumberIsTooSmallException, OutOfRangeException, MaxCountExceededException {\n    return T_TEST.tTest(sampleStats1, sampleStats2, alpha);\n}"
            ],
            [
                "tTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.TTest#tTest(org.apache.commons.math3.stat.descriptive.StatisticalSummary, org.apache.commons.math3.stat.descriptive.StatisticalSummary)\n */\npublic static double tTest(final StatisticalSummary sampleStats1, final StatisticalSummary sampleStats2) throws NullArgumentException, NumberIsTooSmallException, MaxCountExceededException {\n    return T_TEST.tTest(sampleStats1, sampleStats2);\n}"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquare(double[], long[])\n */\npublic static double chiSquare(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException {\n    return CHI_SQUARE_TEST.chiSquare(expected, observed);\n}"
            ],
            [
                "chiSquare",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquare(long[][])\n */\npublic static double chiSquare(final long[][] counts) throws NullArgumentException, NotPositiveException, DimensionMismatchException {\n    return CHI_SQUARE_TEST.chiSquare(counts);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(double[], long[], double)\n */\npublic static boolean chiSquareTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(expected, observed, alpha);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(double[], long[])\n */\npublic static double chiSquareTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(expected, observed);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(long[][], double)\n */\npublic static boolean chiSquareTest(final long[][] counts, final double alpha) throws NullArgumentException, DimensionMismatchException, NotPositiveException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(counts, alpha);\n}"
            ],
            [
                "chiSquareTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTest(long[][])\n */\npublic static double chiSquareTest(final long[][] counts) throws NullArgumentException, DimensionMismatchException, NotPositiveException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTest(counts);\n}"
            ],
            [
                "chiSquareDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareDataSetsComparison(long[], long[])\n *\n * @since 1.2\n */\npublic static double chiSquareDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return CHI_SQUARE_TEST.chiSquareDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTestDataSetsComparison(long[], long[])\n *\n * @since 1.2\n */\npublic static double chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTestDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "chiSquareTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.ChiSquareTest#chiSquareTestDataSetsComparison(long[], long[], double)\n *\n * @since 1.2\n */\npublic static boolean chiSquareTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException {\n    return CHI_SQUARE_TEST.chiSquareTestDataSetsComparison(observed1, observed2, alpha);\n}"
            ],
            [
                "oneWayAnovaFValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaFValue(Collection)\n *\n * @since 1.2\n */\npublic static double oneWayAnovaFValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException {\n    return ONE_WAY_ANANOVA.anovaFValue(categoryData);\n}"
            ],
            [
                "oneWayAnovaPValue",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaPValue(Collection)\n *\n * @since 1.2\n */\npublic static double oneWayAnovaPValue(final Collection<double[]> categoryData) throws NullArgumentException, DimensionMismatchException, ConvergenceException, MaxCountExceededException {\n    return ONE_WAY_ANANOVA.anovaPValue(categoryData);\n}"
            ],
            [
                "oneWayAnovaTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.OneWayAnova#anovaTest(Collection,double)\n *\n * @since 1.2\n */\npublic static boolean oneWayAnovaTest(final Collection<double[]> categoryData, final double alpha) throws NullArgumentException, DimensionMismatchException, OutOfRangeException, ConvergenceException, MaxCountExceededException {\n    return ONE_WAY_ANANOVA.anovaTest(categoryData, alpha);\n}"
            ],
            [
                "g",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#g(double[], long[])\n * @since 3.1\n */\npublic static double g(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException {\n    return G_TEST.g(expected, observed);\n}"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTest( double[],  long[] )\n * @since 3.1\n */\npublic static double gTest(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return G_TEST.gTest(expected, observed);\n}"
            ],
            [
                "gTestIntrinsic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestIntrinsic(double[], long[] )\n * @since 3.1\n */\npublic static double gTestIntrinsic(final double[] expected, final long[] observed) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, MaxCountExceededException {\n    return G_TEST.gTestIntrinsic(expected, observed);\n}"
            ],
            [
                "gTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTest( double[],long[],double)\n * @since 3.1\n */\npublic static boolean gTest(final double[] expected, final long[] observed, final double alpha) throws NotPositiveException, NotStrictlyPositiveException, DimensionMismatchException, OutOfRangeException, MaxCountExceededException {\n    return G_TEST.gTest(expected, observed, alpha);\n}"
            ],
            [
                "gDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gDataSetsComparison(long[], long[])\n * @since 3.1\n */\npublic static double gDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return G_TEST.gDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "rootLogLikelihoodRatio",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#rootLogLikelihoodRatio(long, long, long, long)\n * @since 3.1\n */\npublic static double rootLogLikelihoodRatio(final long k11, final long k12, final long k21, final long k22) throws DimensionMismatchException, NotPositiveException, ZeroException {\n    return G_TEST.rootLogLikelihoodRatio(k11, k12, k21, k22);\n}"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestDataSetsComparison(long[], long[])\n * @since 3.1\n */\npublic static double gTestDataSetsComparison(final long[] observed1, final long[] observed2) throws DimensionMismatchException, NotPositiveException, ZeroException, MaxCountExceededException {\n    return G_TEST.gTestDataSetsComparison(observed1, observed2);\n}"
            ],
            [
                "gTestDataSetsComparison",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.GTest#gTestDataSetsComparison(long[],long[],double)\n * @since 3.1\n */\npublic static boolean gTestDataSetsComparison(final long[] observed1, final long[] observed2, final double alpha) throws DimensionMismatchException, NotPositiveException, ZeroException, OutOfRangeException, MaxCountExceededException {\n    return G_TEST.gTestDataSetsComparison(observed1, observed2, alpha);\n}"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovStatistic(RealDistribution, double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovStatistic(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovStatistic(dist, data);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(RealDistribution dist, double[] data) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[], boolean)\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(RealDistribution dist, double[] data, boolean strict) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data, strict);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(RealDistribution, double[], double)\n * @since 3.3\n */\npublic static boolean kolmogorovSmirnovTest(RealDistribution dist, double[] data, double alpha) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(dist, data, alpha);\n}"
            ],
            [
                "kolmogorovSmirnovStatistic",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovStatistic(double[], double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovStatistic(double[] x, double[] y) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovStatistic(x, y);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(double[], double[])\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(double[] x, double[] y) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(x, y);\n}"
            ],
            [
                "kolmogorovSmirnovTest",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#kolmogorovSmirnovTest(double[], double[], boolean)\n * @since 3.3\n */\npublic static double kolmogorovSmirnovTest(double[] x, double[] y, boolean strict) throws InsufficientDataException, NullArgumentException {\n    return KS_TEST.kolmogorovSmirnovTest(x, y, strict);\n}"
            ],
            [
                "exactP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#exactP(double, int, int, boolean)\n * @since 3.3\n */\npublic static double exactP(double d, int m, int n, boolean strict) {\n    return KS_TEST.exactP(d, n, m, strict);\n}"
            ],
            [
                "approximateP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#approximateP(double, int, int)\n * @since 3.3\n */\npublic static double approximateP(double d, int n, int m) {\n    return KS_TEST.approximateP(d, n, m);\n}"
            ],
            [
                "monteCarloP",
                "org.apache.commons.math3.stat.inference",
                "TestUtils",
                "/**\n * @see org.apache.commons.math3.stat.inference.KolmogorovSmirnovTest#monteCarloP(double, int, int, boolean, int)\n * @since 3.3\n */\npublic static double monteCarloP(double d, int n, int m, boolean strict, int iterations) {\n    return KS_TEST.monteCarloP(d, n, m, strict, iterations);\n}"
            ],
            [
                "aggregate",
                "org.apache.commons.math3.stat.descriptive",
                "AggregateSummaryStatistics",
                "/**\n * Computes aggregate summary statistics. This method can be used to combine statistics\n * computed over partitions or subsamples - i.e., the StatisticalSummaryValues returned\n * should contain the same values that would have been obtained by computing a single\n * StatisticalSummary over the combined dataset.\n * <p>\n * Returns null if the collection is empty or null.\n * </p>\n *\n * @param statistics collection of SummaryStatistics to aggregate\n * @return summary statistics for the combined dataset\n */\npublic static StatisticalSummaryValues aggregate(Collection<? extends StatisticalSummary> statistics) {\n    if (statistics == null) {\n        return null;\n    }\n    Iterator<? extends StatisticalSummary> iterator = statistics.iterator();\n    if (!iterator.hasNext()) {\n        return null;\n    }\n    StatisticalSummary current = iterator.next();\n    long n = current.getN();\n    double min = current.getMin();\n    double sum = current.getSum();\n    double max = current.getMax();\n    double var = current.getVariance();\n    double m2 = var * (n - 1d);\n    double mean = current.getMean();\n    while (iterator.hasNext()) {\n        current = iterator.next();\n        if (current.getMin() < min || Double.isNaN(min)) {\n            min = current.getMin();\n        }\n        if (current.getMax() > max || Double.isNaN(max)) {\n            max = current.getMax();\n        }\n        sum += current.getSum();\n        final double oldN = n;\n        final double curN = current.getN();\n        n += curN;\n        final double meanDiff = current.getMean() - mean;\n        mean = sum / n;\n        final double curM2 = current.getVariance() * (curN - 1d);\n        m2 = m2 + curM2 + meanDiff * meanDiff * oldN * curN / n;\n    }\n    final double variance;\n    if (n == 0) {\n        variance = Double.NaN;\n    } else if (n == 1) {\n        variance = 0d;\n    } else {\n        variance = m2 / (n - 1);\n    }\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}"
            ],
            [
                "newMarkers",
                "org.apache.commons.math3.stat.descriptive.rank",
                "PSquarePercentile",
                "/**\n * A creation method to build Markers\n *\n * @param initialFive list of initial five elements\n * @param p the quantile desired\n * @return an instance of PSquareMarkers\n */\npublic static PSquareMarkers newMarkers(final List<Double> initialFive, final double p) {\n    return new Markers(initialFive, p);\n}"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "/**\n * Creates an exponential decay {@link NeighbourhoodSizeFunction function}.\n * It will compute <code>a e<sup>-x / b</sup></code>,\n * where {@code x} is the (integer) independent variable and\n * <ul>\n *  <li><code>a = initValue</code>\n *  <li><code>b = -numCall / ln(valueAtNumCall / initValue)</code>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link NeighbourhoodSizeFunction#value(long) value(0)}.\n * @param valueAtNumCall Value of the function at {@code numCall}.\n * @param numCall Argument for which the function returns\n * {@code valueAtNumCall}.\n * @return the neighbourhood size function.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code initValue <= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code valueAtNumCall <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code valueAtNumCall >= initValue}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static NeighbourhoodSizeFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall) {\n    return new NeighbourhoodSizeFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final ExponentialDecayFunction decay = new ExponentialDecayFunction(initValue, valueAtNumCall, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public int value(long n) {\n            return (int) FastMath.rint(decay.value(n));\n        }\n    };\n}"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "NeighbourhoodSizeFunctionFactory",
                "/**\n * Creates an sigmoid-like {@code NeighbourhoodSizeFunction function}.\n * The function {@code f} will have the following properties:\n * <ul>\n *  <li>{@code f(0) = initValue}</li>\n *  <li>{@code numCall} is the inflexion point</li>\n *  <li>{@code slope = f'(numCall)}</li>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link NeighbourhoodSizeFunction#value(long) value(0)}.\n * @param slope Value of the function derivative at {@code numCall}.\n * @param numCall Inflexion point.\n * @return the neighbourhood size function.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code initValue <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code slope >= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static NeighbourhoodSizeFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall) {\n    return new NeighbourhoodSizeFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final QuasiSigmoidDecayFunction decay = new QuasiSigmoidDecayFunction(initValue, slope, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public int value(long n) {\n            return (int) FastMath.rint(decay.value(n));\n        }\n    };\n}"
            ],
            [
                "exponentialDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "/**\n * Creates an exponential decay {@link LearningFactorFunction function}.\n * It will compute <code>a e<sup>-x / b</sup></code>,\n * where {@code x} is the (integer) independent variable and\n * <ul>\n *  <li><code>a = initValue</code>\n *  <li><code>b = -numCall / ln(valueAtNumCall / initValue)</code>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link LearningFactorFunction#value(long) value(0)}.\n * @param valueAtNumCall Value of the function at {@code numCall}.\n * @param numCall Argument for which the function returns\n * {@code valueAtNumCall}.\n * @return the learning factor function.\n * @throws org.apache.commons.math3.exception.OutOfRangeException\n * if {@code initValue <= 0} or {@code initValue > 1}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code valueAtNumCall <= 0}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code valueAtNumCall >= initValue}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static LearningFactorFunction exponentialDecay(final double initValue, final double valueAtNumCall, final long numCall) {\n    if (initValue <= 0 || initValue > 1) {\n        throw new OutOfRangeException(initValue, 0, 1);\n    }\n    return new LearningFactorFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final ExponentialDecayFunction decay = new ExponentialDecayFunction(initValue, valueAtNumCall, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(long n) {\n            return decay.value(n);\n        }\n    };\n}"
            ],
            [
                "quasiSigmoidDecay",
                "org.apache.commons.math3.ml.neuralnet.sofm",
                "LearningFactorFunctionFactory",
                "/**\n * Creates an sigmoid-like {@code LearningFactorFunction function}.\n * The function {@code f} will have the following properties:\n * <ul>\n *  <li>{@code f(0) = initValue}</li>\n *  <li>{@code numCall} is the inflexion point</li>\n *  <li>{@code slope = f'(numCall)}</li>\n * </ul>\n *\n * @param initValue Initial value, i.e.\n * {@link LearningFactorFunction#value(long) value(0)}.\n * @param slope Value of the function derivative at {@code numCall}.\n * @param numCall Inflexion point.\n * @return the learning factor function.\n * @throws org.apache.commons.math3.exception.OutOfRangeException\n * if {@code initValue <= 0} or {@code initValue > 1}.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code slope >= 0}.\n * @throws org.apache.commons.math3.exception.NotStrictlyPositiveException\n * if {@code numCall <= 0}.\n */\npublic static LearningFactorFunction quasiSigmoidDecay(final double initValue, final double slope, final long numCall) {\n    if (initValue <= 0 || initValue > 1) {\n        throw new OutOfRangeException(initValue, 0, 1);\n    }\n    return new LearningFactorFunction() {\n\n        /**\n         * DecayFunction.\n         */\n        private final QuasiSigmoidDecayFunction decay = new QuasiSigmoidDecayFunction(initValue, slope, numCall);\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value(long n) {\n            return decay.value(n);\n        }\n    };\n}"
            ],
            [
                "findBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Finds the neuron that best matches the given features.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If the list is empty\n * {@code null} will be returned.\n * @param distance Distance function. The neuron's features are\n * passed as the first argument to {@link DistanceMeasure#compute(double[],double[])}.\n * @return the neuron whose features are closest to the given data.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n */\npublic static Neuron findBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    Neuron best = null;\n    double min = Double.POSITIVE_INFINITY;\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        if (d < min) {\n            min = d;\n            best = n;\n        }\n    }\n    return best;\n}"
            ],
            [
                "findBestAndSecondBest",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Finds the two neurons that best match the given features.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If the list is empty\n * {@code null} will be returned.\n * @param distance Distance function. The neuron's features are\n * passed as the first argument to {@link DistanceMeasure#compute(double[],double[])}.\n * @return the two neurons whose features are closest to the given data.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n */\npublic static Pair<Neuron, Neuron> findBestAndSecondBest(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    Neuron[] best = { null, null };\n    double[] min = { Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY };\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        if (d < min[0]) {\n            // Replace second best with old best.\n            min[1] = min[0];\n            best[1] = best[0];\n            // Store current as new best.\n            min[0] = d;\n            best[0] = n;\n        } else if (d < min[1]) {\n            // Replace old second best with current.\n            min[1] = d;\n            best[1] = n;\n        }\n    }\n    return new Pair<Neuron, Neuron>(best[0], best[1]);\n}"
            ],
            [
                "sort",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Creates a list of neurons sorted in increased order of the distance\n * to the given {@code features}.\n *\n * @param features Data.\n * @param neurons List of neurons to scan. If it is empty, an empty array\n * will be returned.\n * @param distance Distance function.\n * @return the neurons, sorted in increasing order of distance in data\n * space.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the size of the input is not compatible with the neurons features\n * size.\n *\n * @see #findBest(double[],Iterable,DistanceMeasure)\n * @see #findBestAndSecondBest(double[],Iterable,DistanceMeasure)\n *\n * @since 3.6\n */\npublic static Neuron[] sort(double[] features, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    final List<PairNeuronDouble> list = new ArrayList<PairNeuronDouble>();\n    for (final Neuron n : neurons) {\n        final double d = distance.compute(n.getFeatures(), features);\n        list.add(new PairNeuronDouble(n, d));\n    }\n    Collections.sort(list, PairNeuronDouble.COMPARATOR);\n    final int len = list.size();\n    final Neuron[] sorted = new Neuron[len];\n    for (int i = 0; i < len; i++) {\n        sorted[i] = list.get(i).getNeuron();\n    }\n    return sorted;\n}"
            ],
            [
                "computeU",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the <a href=\"http://en.wikipedia.org/wiki/U-Matrix\">\n *  U-matrix</a> of a two-dimensional map.\n *\n * @param map Network.\n * @param distance Function to use for computing the average\n * distance from a neuron to its neighbours.\n * @return the matrix of average distances.\n */\npublic static double[][] computeU(NeuronSquareMesh2D map, DistanceMeasure distance) {\n    final int numRows = map.getNumberOfRows();\n    final int numCols = map.getNumberOfColumns();\n    final double[][] uMatrix = new double[numRows][numCols];\n    final Network net = map.getNetwork();\n    for (int i = 0; i < numRows; i++) {\n        for (int j = 0; j < numCols; j++) {\n            final Neuron neuron = map.getNeuron(i, j);\n            final Collection<Neuron> neighbours = net.getNeighbours(neuron);\n            final double[] features = neuron.getFeatures();\n            double d = 0;\n            int count = 0;\n            for (Neuron n : neighbours) {\n                ++count;\n                d += distance.compute(features, n.getFeatures());\n            }\n            uMatrix[i][j] = d / count;\n        }\n    }\n    return uMatrix;\n}"
            ],
            [
                "computeHitHistogram",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the \"hit\" histogram of a two-dimensional map.\n *\n * @param data Feature vectors.\n * @param map Network.\n * @param distance Function to use for determining the best matching unit.\n * @return the number of hits for each neuron in the map.\n */\npublic static int[][] computeHitHistogram(Iterable<double[]> data, NeuronSquareMesh2D map, DistanceMeasure distance) {\n    final HashMap<Neuron, Integer> hit = new HashMap<Neuron, Integer>();\n    final Network net = map.getNetwork();\n    for (double[] f : data) {\n        final Neuron best = findBest(f, net, distance);\n        final Integer count = hit.get(best);\n        if (count == null) {\n            hit.put(best, 1);\n        } else {\n            hit.put(best, count + 1);\n        }\n    }\n    // Copy the histogram data into a 2D map.\n    final int numRows = map.getNumberOfRows();\n    final int numCols = map.getNumberOfColumns();\n    final int[][] histo = new int[numRows][numCols];\n    for (int i = 0; i < numRows; i++) {\n        for (int j = 0; j < numCols; j++) {\n            final Neuron neuron = map.getNeuron(i, j);\n            final Integer count = hit.get(neuron);\n            if (count == null) {\n                histo[i][j] = 0;\n            } else {\n                histo[i][j] = count;\n            }\n        }\n    }\n    return histo;\n}"
            ],
            [
                "computeQuantizationError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the quantization error.\n * The quantization error is the average distance between a feature vector\n * and its \"best matching unit\" (closest neuron).\n *\n * @param data Feature vectors.\n * @param neurons List of neurons to scan.\n * @param distance Distance function.\n * @return the error.\n * @throws NoDataException if {@code data} is empty.\n */\npublic static double computeQuantizationError(Iterable<double[]> data, Iterable<Neuron> neurons, DistanceMeasure distance) {\n    double d = 0;\n    int count = 0;\n    for (double[] f : data) {\n        ++count;\n        d += distance.compute(f, findBest(f, neurons, distance).getFeatures());\n    }\n    if (count == 0) {\n        throw new NoDataException();\n    }\n    return d / count;\n}"
            ],
            [
                "computeTopographicError",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Computes the topographic error.\n * The topographic error is the proportion of data for which first and\n * second best matching units are not adjacent in the map.\n *\n * @param data Feature vectors.\n * @param net Network.\n * @param distance Distance function.\n * @return the error.\n * @throws NoDataException if {@code data} is empty.\n */\npublic static double computeTopographicError(Iterable<double[]> data, Network net, DistanceMeasure distance) {\n    int notAdjacentCount = 0;\n    int count = 0;\n    for (double[] f : data) {\n        ++count;\n        final Pair<Neuron, Neuron> p = findBestAndSecondBest(f, net, distance);\n        if (!net.getNeighbours(p.getFirst()).contains(p.getSecond())) {\n            // Increment count if first and second best matching units\n            // are not neighbours.\n            ++notAdjacentCount;\n        }\n    }\n    if (count == 0) {\n        throw new NoDataException();\n    }\n    return ((double) notAdjacentCount) / count;\n}"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Uniform sampling of the given range.\n *\n * @param min Lower bound of the range.\n * @param max Upper bound of the range.\n * @param rng Random number generator used to draw samples from a\n * uniform distribution.\n * @return an initializer such that the features will be initialized with\n * values within the given range.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code min >= max}.\n */\npublic static FeatureInitializer uniform(final RandomGenerator rng, final double min, final double max) {\n    return randomize(new UniformRealDistribution(rng, min, max), function(new Constant(0), 0, 0));\n}"
            ],
            [
                "uniform",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Uniform sampling of the given range.\n *\n * @param min Lower bound of the range.\n * @param max Upper bound of the range.\n * @return an initializer such that the features will be initialized with\n * values within the given range.\n * @throws org.apache.commons.math3.exception.NumberIsTooLargeException\n * if {@code min >= max}.\n */\npublic static FeatureInitializer uniform(final double min, final double max) {\n    return randomize(new UniformRealDistribution(min, max), function(new Constant(0), 0, 0));\n}"
            ],
            [
                "function",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Creates an initializer from a univariate function {@code f(x)}.\n * The argument {@code x} is set to {@code init} at the first call\n * and will be incremented at each call.\n *\n * @param f Function.\n * @param init Initial value.\n * @param inc Increment\n * @return the initializer.\n */\npublic static FeatureInitializer function(final UnivariateFunction f, final double init, final double inc) {\n    return new FeatureInitializer() {\n\n        /**\n         * Argument.\n         */\n        private double arg = init;\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value() {\n            final double result = f.value(arg);\n            arg += inc;\n            return result;\n        }\n    };\n}"
            ],
            [
                "randomize",
                "org.apache.commons.math3.ml.neuralnet",
                "FeatureInitializerFactory",
                "/**\n * Adds some amount of random data to the given initializer.\n *\n * @param random Random variable distribution.\n * @param orig Original initializer.\n * @return an initializer whose {@link FeatureInitializer#value() value}\n * method will return {@code orig.value() + random.sample()}.\n */\npublic static FeatureInitializer randomize(final RealDistribution random, final FeatureInitializer orig) {\n    return new FeatureInitializer() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public double value() {\n            return orig.value() + random.sample();\n        }\n    };\n}"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Breaks a string representation up into two dfp's.\n * <p>The two dfp are such that the sum of them is equivalent\n * to the input string, but has higher precision than using a\n * single dfp. This is useful for improving accuracy of\n * exponentiation and critical multiplies.\n * @param field field to which the Dfp must belong\n * @param a string representation to split\n * @return an array of two {@link Dfp} which sum is a\n */\nprotected static Dfp[] split(final DfpField field, final String a) {\n    Dfp[] result = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n    buf = new char[a.length()];\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n        if (sig == (field.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig++;\n        }\n    }\n    result[0] = field.newDfp(new String(buf, 0, sp));\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n    result[1] = field.newDfp(new String(buf));\n    return result;\n}"
            ],
            [
                "split",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Splits a {@link Dfp} into 2 {@link Dfp}'s such that their sum is equal to the input {@link Dfp}.\n * @param a number to split\n * @return two elements array containing the split number\n */\nprotected static Dfp[] split(final Dfp a) {\n    final Dfp[] result = new Dfp[2];\n    final Dfp shift = a.multiply(a.power10K(a.getRadixDigits() / 2));\n    result[0] = a.add(shift).subtract(shift);\n    result[1] = a.subtract(result[0]);\n    return result;\n}"
            ],
            [
                "splitMult",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Multiply two numbers that are split in to two pieces that are\n *  meant to be added together.\n *  Use binomial multiplication so ab = a0 b0 + a0 b1 + a1 b0 + a1 b1\n *  Store the first term in result0, the rest in result1\n *  @param a first factor of the multiplication, in split form\n *  @param b second factor of the multiplication, in split form\n *  @return a &times; b, in split form\n */\nprotected static Dfp[] splitMult(final Dfp[] a, final Dfp[] b) {\n    final Dfp[] result = new Dfp[2];\n    result[1] = a[0].getZero();\n    result[0] = a[0].multiply(b[0]);\n    /* If result[0] is infinite or zero, don't compute result[1].\n         * Attempting to do so may produce NaNs.\n         */\n    if (result[0].classify() == Dfp.INFINITE || result[0].equals(result[1])) {\n        return result;\n    }\n    result[1] = a[0].multiply(b[1]).add(a[1].multiply(b[0])).add(a[1].multiply(b[1]));\n    return result;\n}"
            ],
            [
                "splitDiv",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Divide two numbers that are split in to two pieces that are meant to be added together.\n * Inverse of split multiply above:\n *  (a+b) / (c+d) = (a/c) + ( (bc-ad)/(c**2+cd) )\n *  @param a dividend, in split form\n *  @param b divisor, in split form\n *  @return a / b, in split form\n */\nprotected static Dfp[] splitDiv(final Dfp[] a, final Dfp[] b) {\n    final Dfp[] result;\n    result = new Dfp[2];\n    result[0] = a[0].divide(b[0]);\n    result[1] = a[1].multiply(b[0]).subtract(a[0].multiply(b[1]));\n    result[1] = result[1].divide(b[0].multiply(b[0]).add(b[0].multiply(b[1])));\n    return result;\n}"
            ],
            [
                "splitPow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Raise a split base to the a power.\n * @param base number to raise\n * @param a power\n * @return base<sup>a</sup>\n */\nprotected static Dfp splitPow(final Dfp[] base, int a) {\n    boolean invert = false;\n    Dfp[] r = new Dfp[2];\n    Dfp[] result = new Dfp[2];\n    result[0] = base[0].getOne();\n    result[1] = base[0].getZero();\n    if (a == 0) {\n        // Special case a = 0\n        return result[0].add(result[1]);\n    }\n    if (a < 0) {\n        // If a is less than zero\n        invert = true;\n        a = -a;\n    }\n    // Exponentiate by successive squaring\n    do {\n        r[0] = new Dfp(base[0]);\n        r[1] = new Dfp(base[1]);\n        int trial = 1;\n        int prevtrial;\n        while (true) {\n            prevtrial = trial;\n            trial *= 2;\n            if (trial > a) {\n                break;\n            }\n            r = splitMult(r, r);\n        }\n        trial = prevtrial;\n        a -= trial;\n        result = splitMult(result, r);\n    } while (a >= 1);\n    result[0] = result[0].add(result[1]);\n    if (invert) {\n        result[0] = base[0].getOne().divide(result[0]);\n    }\n    return result[0];\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Raises base to the power a by successive squaring.\n * @param base number to raise\n * @param a power\n * @return base<sup>a</sup>\n */\npublic static Dfp pow(Dfp base, int a) {\n    boolean invert = false;\n    Dfp result = base.getOne();\n    if (a == 0) {\n        // Special case\n        return result;\n    }\n    if (a < 0) {\n        invert = true;\n        a = -a;\n    }\n    // Exponentiate by successive squaring\n    do {\n        Dfp r = new Dfp(base);\n        Dfp prevr;\n        int trial = 1;\n        int prevtrial;\n        do {\n            prevr = new Dfp(r);\n            prevtrial = trial;\n            r = r.multiply(r);\n            trial *= 2;\n        } while (a > trial);\n        r = prevr;\n        trial = prevtrial;\n        a -= trial;\n        result = result.multiply(r);\n    } while (a >= 1);\n    if (invert) {\n        result = base.getOne().divide(result);\n    }\n    return base.newInstance(result);\n}"
            ],
            [
                "exp",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes e to the given power.\n * a is broken into two parts, such that a = n+m  where n is an integer.\n * We use pow() to compute e<sup>n</sup> and a Taylor series to compute\n * e<sup>m</sup>.  We return e*<sup>n</sup> &times; e<sup>m</sup>\n * @param a power at which e should be raised\n * @return e<sup>a</sup>\n */\npublic static Dfp exp(final Dfp a) {\n    final Dfp inta = a.rint();\n    final Dfp fraca = a.subtract(inta);\n    final int ia = inta.intValue();\n    if (ia > 2147483646) {\n        // return +Infinity\n        return a.newInstance((byte) 1, Dfp.INFINITE);\n    }\n    if (ia < -2147483646) {\n        // return 0;\n        return a.newInstance();\n    }\n    final Dfp einta = splitPow(a.getField().getESplit(), ia);\n    final Dfp efraca = expInternal(fraca);\n    return einta.multiply(efraca);\n}"
            ],
            [
                "expInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes e to the given power.\n * Where -1 < a < 1.  Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...\n * @param a power at which e should be raised\n * @return e<sup>a</sup>\n */\nprotected static Dfp expInternal(final Dfp a) {\n    Dfp y = a.getOne();\n    Dfp x = a.getOne();\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n    for (int i = 1; i < 90; i++) {\n        x = x.multiply(a);\n        fact = fact.divide(i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "log",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Returns the natural logarithm of a.\n * a is first split into three parts such that  a = (10000^h)(2^j)k.\n * ln(a) is computed by ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k)\n * k is in the range 2/3 < k <4/3 and is passed on to a series expansion.\n * @param a number from which logarithm is requested\n * @return log(a)\n */\npublic static Dfp log(Dfp a) {\n    int lr;\n    Dfp x;\n    int ix;\n    int p2 = 0;\n    // Check the arguments somewhat here\n    if (a.equals(a.getZero()) || a.lessThan(a.getZero()) || a.isNaN()) {\n        // negative, zero or NaN\n        a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return a.dotrap(DfpField.FLAG_INVALID, \"ln\", a, a.newInstance((byte) 1, Dfp.QNAN));\n    }\n    if (a.classify() == Dfp.INFINITE) {\n        return a;\n    }\n    x = new Dfp(a);\n    lr = x.log10K();\n    x = x.divide(pow(a.newInstance(10000), lr));\n    /* This puts x in the range 0-10000 */\n    ix = x.floor().intValue();\n    while (ix > 2) {\n        ix >>= 1;\n        p2++;\n    }\n    Dfp[] spx = split(x);\n    Dfp[] spy = new Dfp[2];\n    // use spy[0] temporarily as a divisor\n    spy[0] = pow(a.getTwo(), p2);\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n    // Use spy[0] for comparison\n    spy[0] = a.newInstance(\"1.33333\");\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n        p2++;\n    }\n    // X is now in the range of 2/3 < x < 4/3\n    Dfp[] spz = logInternal(spx);\n    spx[0] = a.newInstance(new StringBuilder().append(p2 + 4 * lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn2Split(), spx);\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n    spx[0] = a.newInstance(new StringBuilder().append(4 * lr).toString());\n    spx[1] = a.getZero();\n    spy = splitMult(a.getField().getLn5Split(), spx);\n    spz[0] = spz[0].add(spy[0]);\n    spz[1] = spz[1].add(spy[1]);\n    return a.newInstance(spz[0].add(spz[1]));\n}"
            ],
            [
                "logInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes the natural log of a number between 0 and 2.\n *  Let f(x) = ln(x),\n *\n *  We know that f'(x) = 1/x, thus from Taylor's theorum we have:\n *\n *           -----          n+1         n\n *  f(x) =   \\           (-1)    (x - 1)\n *           /          ----------------    for 1 <= n <= infinity\n *           -----             n\n *\n *  or\n *                       2        3       4\n *                   (x-1)   (x-1)    (x-1)\n *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n *                     2       3        4\n *\n *  alternatively,\n *\n *                  2    3   4\n *                 x    x   x\n *  ln(x+1) =  x - -  + - - - + ...\n *                 2    3   4\n *\n *  This series can be used to compute ln(x), but it converges too slowly.\n *\n *  If we substitute -x for x above, we get\n *\n *                   2    3    4\n *                  x    x    x\n *  ln(1-x) =  -x - -  - -  - - + ...\n *                  2    3    4\n *\n *  Note that all terms are now negative.  Because the even powered ones\n *  absorbed the sign.  Now, subtract the series above from the previous\n *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n *  only the odd ones\n *\n *                             3     5      7\n *                           2x    2x     2x\n *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n *                            3     5      7\n *\n *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n *\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      x-1           \\          3        5        7          /\n *\n *  But now we want to find ln(a), so we need to find the value of x\n *  such that a = (x+1)/(x-1).   This is easily solved to find that\n *  x = (a-1)/(a+1).\n * @param a number from which logarithm is requested, in split form\n * @return log(a)\n */\nprotected static Dfp[] logInternal(final Dfp[] a) {\n    /* Now we want to compute x = (a-1)/(a+1) but this is prone to\n         * loss of precision.  So instead, compute x = (a/4 - 1/4) / (a/4 + 1/4)\n         */\n    Dfp t = a[0].divide(4).add(a[1].divide(4));\n    Dfp x = t.add(a[0].newInstance(\"-0.25\")).divide(t.add(a[0].newInstance(\"0.25\")));\n    Dfp y = new Dfp(x);\n    Dfp num = new Dfp(x);\n    Dfp py = new Dfp(y);\n    int den = 1;\n    for (int i = 0; i < 10000; i++) {\n        num = num.multiply(x);\n        num = num.multiply(x);\n        den += 2;\n        t = num.divide(den);\n        y = y.add(t);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    y = y.multiply(a[0].getTwo());\n    return split(y);\n}"
            ],
            [
                "pow",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes x to the y power.<p>\n *\n *  Uses the following method:<p>\n *\n *  <ol>\n *  <li> Set u = rint(y), v = y-u\n *  <li> Compute a = v * ln(x)\n *  <li> Compute b = rint( a/ln(2) )\n *  <li> Compute c = a - b*ln(2)\n *  <li> x<sup>y</sup> = x<sup>u</sup>  *   2<sup>b</sup> * e<sup>c</sup>\n *  </ol>\n *  if |y| > 1e8, then we compute by exp(y*ln(x))   <p>\n *\n *  <b>Special Cases</b><p>\n *  <ul>\n *  <li>  if y is 0.0 or -0.0 then result is 1.0\n *  <li>  if y is 1.0 then result is x\n *  <li>  if y is NaN then result is NaN\n *  <li>  if x is NaN and y is not zero then result is NaN\n *  <li>  if |x| > 1.0 and y is +Infinity then result is +Infinity\n *  <li>  if |x| < 1.0 and y is -Infinity then result is +Infinity\n *  <li>  if |x| > 1.0 and y is -Infinity then result is +0\n *  <li>  if |x| < 1.0 and y is +Infinity then result is +0\n *  <li>  if |x| = 1.0 and y is +/-Infinity then result is NaN\n *  <li>  if x = +0 and y > 0 then result is +0\n *  <li>  if x = +Inf and y < 0 then result is +0\n *  <li>  if x = +0 and y < 0 then result is +Inf\n *  <li>  if x = +Inf and y > 0 then result is +Inf\n *  <li>  if x = -0 and y > 0, finite, not odd integer then result is +0\n *  <li>  if x = -0 and y < 0, finite, and odd integer then result is -Inf\n *  <li>  if x = -Inf and y > 0, finite, and odd integer then result is -Inf\n *  <li>  if x = -0 and y < 0, not finite odd integer then result is +Inf\n *  <li>  if x = -Inf and y > 0, not finite odd integer then result is +Inf\n *  <li>  if x < 0 and y > 0, finite, and odd integer then result is -(|x|<sup>y</sup>)\n *  <li>  if x < 0 and y > 0, finite, and not integer then result is NaN\n *  </ul>\n *  @param x base to be raised\n *  @param y power to which base should be raised\n *  @return x<sup>y</sup>\n */\npublic static Dfp pow(Dfp x, final Dfp y) {\n    // make sure we don't mix number with different precision\n    if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        final Dfp result = x.newInstance(x.getZero());\n        result.nans = Dfp.QNAN;\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result);\n    }\n    final Dfp zero = x.getZero();\n    final Dfp one = x.getOne();\n    final Dfp two = x.getTwo();\n    boolean invert = false;\n    int ui;\n    /* Check for special cases */\n    if (y.equals(zero)) {\n        return x.newInstance(one);\n    }\n    if (y.equals(one)) {\n        if (x.isNaN()) {\n            // Test for NaNs\n            x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x);\n        }\n        return x;\n    }\n    if (x.isNaN() || y.isNaN()) {\n        // Test for NaNs\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    // X == 0\n    if (x.equals(zero)) {\n        if (Dfp.copysign(one, x).greaterThan(zero)) {\n            // X == +0\n            if (y.greaterThan(zero)) {\n                return x.newInstance(zero);\n            } else {\n                return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n            }\n        } else {\n            // X == -0\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero.negate());\n                } else {\n                    return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE));\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(zero);\n                } else {\n                    return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n                }\n            }\n        }\n    }\n    if (x.lessThan(zero)) {\n        // Make x positive, but keep track of it\n        x = x.negate();\n        invert = true;\n    }\n    if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return y;\n        } else {\n            return x.newInstance(zero);\n        }\n    }\n    if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {\n        if (y.greaterThan(zero)) {\n            return x.newInstance(zero);\n        } else {\n            return x.newInstance(Dfp.copysign(y, one));\n        }\n    }\n    if (x.equals(one) && y.classify() == Dfp.INFINITE) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    if (x.classify() == Dfp.INFINITE) {\n        // x = +/- inf\n        if (invert) {\n            // negative infinity\n            if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n                // If y is odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero.negate());\n                }\n            } else {\n                // Y is not odd integer\n                if (y.greaterThan(zero)) {\n                    return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE));\n                } else {\n                    return x.newInstance(zero);\n                }\n            }\n        } else {\n            // positive infinity\n            if (y.greaterThan(zero)) {\n                return x;\n            } else {\n                return x.newInstance(zero);\n            }\n        }\n    }\n    if (invert && !y.rint().equals(y)) {\n        x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN));\n    }\n    // End special cases\n    Dfp r;\n    if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) {\n        final Dfp u = y.rint();\n        ui = u.intValue();\n        final Dfp v = y.subtract(u);\n        if (v.unequal(zero)) {\n            final Dfp a = v.multiply(log(x));\n            final Dfp b = a.divide(x.getField().getLn2()).rint();\n            final Dfp c = a.subtract(b.multiply(x.getField().getLn2()));\n            r = splitPow(split(x), ui);\n            r = r.multiply(pow(two, b.intValue()));\n            r = r.multiply(exp(c));\n        } else {\n            r = splitPow(split(x), ui);\n        }\n    } else {\n        // very large exponent.  |y| > 1e8\n        r = exp(log(x).multiply(y));\n    }\n    if (invert && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n        // if y is odd integer\n        r = r.negate();\n    }\n    return x.newInstance(r);\n}"
            ],
            [
                "sinInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes sin(a)  Used when 0 < a < pi/4.\n * Uses the classic Taylor series.  x - x**3/3! + x**5/5!  ...\n * @param a number from which sine is desired, in split form\n * @return sin(a)\n */\nprotected static Dfp sinInternal(Dfp[] a) {\n    Dfp c = a[0].add(a[1]);\n    Dfp y = c;\n    c = c.multiply(c);\n    Dfp x = y;\n    Dfp fact = a[0].getOne();\n    Dfp py = new Dfp(y);\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n        // 1 over fact\n        fact = fact.divide((i - 1) * i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "cosInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * Computes cos(a)  Used when 0 < a < pi/4.\n * Uses the classic Taylor series for cosine.  1 - x**2/2! + x**4/4!  ...\n * @param a number from which cosine is desired, in split form\n * @return cos(a)\n */\nprotected static Dfp cosInternal(Dfp[] a) {\n    final Dfp one = a[0].getOne();\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a[0].add(a[1]);\n    c = c.multiply(c);\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n        // 1 over fact\n        fact = fact.divide((i - 1) * i);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "sin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the sine of the argument.\n * @param a number from which sine is desired\n * @return sin(a)\n */\npublic static Dfp sin(final Dfp a) {\n    final Dfp pi = a.getField().getPi();\n    final Dfp zero = a.getField().getZero();\n    boolean neg = false;\n    /* First reduce the argument to the range of +/- PI */\n    Dfp x = a.remainder(pi.multiply(2));\n    /* if x < 0 then apply identity sin(-x) = -sin(x) */\n    /* This puts x in the range 0 < x < PI            */\n    if (x.lessThan(zero)) {\n        x = x.negate();\n        neg = true;\n    }\n    /* Since sine(x) = sine(pi - x) we can reduce the range to\n         * 0 < x < pi/2\n         */\n    if (x.greaterThan(pi.divide(2))) {\n        x = pi.subtract(x);\n    }\n    Dfp y;\n    if (x.lessThan(pi.divide(4))) {\n        y = sinInternal(split(x));\n    } else {\n        final Dfp[] c = new Dfp[2];\n        final Dfp[] piSplit = a.getField().getPiSplit();\n        c[0] = piSplit[0].divide(2).subtract(x);\n        c[1] = piSplit[1].divide(2);\n        y = cosInternal(c);\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "cos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the cosine of the argument.\n * @param a number from which cosine is desired\n * @return cos(a)\n */\npublic static Dfp cos(Dfp a) {\n    final Dfp pi = a.getField().getPi();\n    final Dfp zero = a.getField().getZero();\n    boolean neg = false;\n    /* First reduce the argument to the range of +/- PI */\n    Dfp x = a.remainder(pi.multiply(2));\n    /* if x < 0 then apply identity cos(-x) = cos(x) */\n    /* This puts x in the range 0 < x < PI           */\n    if (x.lessThan(zero)) {\n        x = x.negate();\n    }\n    /* Since cos(x) = -cos(pi - x) we can reduce the range to\n         * 0 < x < pi/2\n         */\n    if (x.greaterThan(pi.divide(2))) {\n        x = pi.subtract(x);\n        neg = true;\n    }\n    Dfp y;\n    if (x.lessThan(pi.divide(4))) {\n        Dfp[] c = new Dfp[2];\n        c[0] = x;\n        c[1] = zero;\n        y = cosInternal(c);\n    } else {\n        final Dfp[] c = new Dfp[2];\n        final Dfp[] piSplit = a.getField().getPiSplit();\n        c[0] = piSplit[0].divide(2).subtract(x);\n        c[1] = piSplit[1].divide(2);\n        y = sinInternal(c);\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "tan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the tangent of the argument.\n * @param a number from which tangent is desired\n * @return tan(a)\n */\npublic static Dfp tan(final Dfp a) {\n    return sin(a).divide(cos(a));\n}"
            ],
            [
                "atanInternal",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-tangent of the argument.\n * @param a number from which arc-tangent is desired\n * @return atan(a)\n */\nprotected static Dfp atanInternal(final Dfp a) {\n    Dfp y = new Dfp(a);\n    Dfp x = new Dfp(y);\n    Dfp py = new Dfp(y);\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(a);\n        x = x.multiply(a);\n        x = x.negate();\n        y = y.add(x.divide(i));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "atan",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc tangent of the argument\n *\n *  Uses the typical taylor series\n *\n *  but may reduce arguments using the following identity\n * tan(x+y) = (tan(x) + tan(y)) / (1 - tan(x)*tan(y))\n *\n * since tan(PI/8) = sqrt(2)-1,\n *\n * atan(x) = atan( (x - sqrt(2) + 1) / (1+x*sqrt(2) - x) + PI/8.0\n * @param a number from which arc-tangent is desired\n * @return atan(a)\n */\npublic static Dfp atan(final Dfp a) {\n    final Dfp zero = a.getField().getZero();\n    final Dfp one = a.getField().getOne();\n    final Dfp[] sqr2Split = a.getField().getSqr2Split();\n    final Dfp[] piSplit = a.getField().getPiSplit();\n    boolean recp = false;\n    boolean neg = false;\n    boolean sub = false;\n    final Dfp ty = sqr2Split[0].subtract(one).add(sqr2Split[1]);\n    Dfp x = new Dfp(a);\n    if (x.lessThan(zero)) {\n        neg = true;\n        x = x.negate();\n    }\n    if (x.greaterThan(one)) {\n        recp = true;\n        x = one.divide(x);\n    }\n    if (x.greaterThan(ty)) {\n        Dfp[] sty = new Dfp[2];\n        sub = true;\n        sty[0] = sqr2Split[0].subtract(one);\n        sty[1] = sqr2Split[1];\n        Dfp[] xs = split(x);\n        Dfp[] ds = splitMult(xs, sty);\n        ds[0] = ds[0].add(one);\n        xs[0] = xs[0].subtract(sty[0]);\n        xs[1] = xs[1].subtract(sty[1]);\n        xs = splitDiv(xs, ds);\n        x = xs[0].add(xs[1]);\n        //x = x.subtract(ty).divide(dfp.one.add(x.multiply(ty)));\n    }\n    Dfp y = atanInternal(x);\n    if (sub) {\n        y = y.add(piSplit[0].divide(8)).add(piSplit[1].divide(8));\n    }\n    if (recp) {\n        y = piSplit[0].divide(2).subtract(y).add(piSplit[1].divide(2));\n    }\n    if (neg) {\n        y = y.negate();\n    }\n    return a.newInstance(y);\n}"
            ],
            [
                "asin",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-sine of the argument.\n * @param a number from which arc-sine is desired\n * @return asin(a)\n */\npublic static Dfp asin(final Dfp a) {\n    return atan(a.divide(a.getOne().subtract(a.multiply(a)).sqrt()));\n}"
            ],
            [
                "acos",
                "org.apache.commons.math3.dfp",
                "DfpMath",
                "/**\n * computes the arc-cosine of the argument.\n * @param a number from which arc-cosine is desired\n * @return acos(a)\n */\npublic static Dfp acos(Dfp a) {\n    Dfp result;\n    boolean negative = false;\n    if (a.lessThan(a.getZero())) {\n        negative = true;\n    }\n    // absolute value\n    a = Dfp.copysign(a, a.getOne());\n    result = atan(a.getOne().subtract(a.multiply(a)).sqrt().divide(a));\n    if (negative) {\n        result = a.getField().getPi().subtract(result);\n    }\n    return a.newInstance(result);\n}"
            ],
            [
                "copysign",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Creates an instance that is the same as x except that it has the sign of y.\n * abs(x) = dfp.copysign(x, dfp.one)\n * @param x number to get the value from\n * @param y number to get the sign from\n * @return a number with the value of x and the sign of y\n */\npublic static Dfp copysign(final Dfp x, final Dfp y) {\n    Dfp result = x.newInstance(x);\n    result.sign = y.sign;\n    return result;\n}"
            ],
            [
                "computeExp",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * Compute exp(a).\n * @param a number for which we want the exponential\n * @param one constant with value 1 at desired precision\n * @return exp(a)\n */\npublic static Dfp computeExp(final Dfp a, final Dfp one) {\n    Dfp y = new Dfp(one);\n    Dfp py = new Dfp(one);\n    Dfp f = new Dfp(one);\n    Dfp fi = new Dfp(one);\n    Dfp x = new Dfp(one);\n    for (int i = 0; i < 10000; i++) {\n        x = x.multiply(a);\n        y = y.add(x.divide(f));\n        fi = fi.add(one);\n        f = f.multiply(fi);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y;\n}"
            ],
            [
                "computeLn",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * Compute ln(a).\n *\n *  Let f(x) = ln(x),\n *\n *  We know that f'(x) = 1/x, thus from Taylor's theorem we have:\n *\n *           -----          n+1         n\n *  f(x) =   \\           (-1)    (x - 1)\n *           /          ----------------    for 1 <= n <= infinity\n *           -----             n\n *\n *  or\n *                       2        3       4\n *                   (x-1)   (x-1)    (x-1)\n *  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n *                     2       3        4\n *\n *  alternatively,\n *\n *                  2    3   4\n *                 x    x   x\n *  ln(x+1) =  x - -  + - - - + ...\n *                 2    3   4\n *\n *  This series can be used to compute ln(x), but it converges too slowly.\n *\n *  If we substitute -x for x above, we get\n *\n *                   2    3    4\n *                  x    x    x\n *  ln(1-x) =  -x - -  - -  - - + ...\n *                  2    3    4\n *\n *  Note that all terms are now negative.  Because the even powered ones\n *  absorbed the sign.  Now, subtract the series above from the previous\n *  one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n *  only the odd ones\n *\n *                             3     5      7\n *                           2x    2x     2x\n *  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n *                            3     5      7\n *\n *  By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n *\n *                                3        5        7\n *      x+1           /          x        x        x          \\\n *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n *      x-1           \\          3        5        7          /\n *\n *  But now we want to find ln(a), so we need to find the value of x\n *  such that a = (x+1)/(x-1).   This is easily solved to find that\n *  x = (a-1)/(a+1).\n * @param a number for which we want the exponential\n * @param one constant with value 1 at desired precision\n * @param two constant with value 2 at desired precision\n * @return ln(a)\n */\npublic static Dfp computeLn(final Dfp a, final Dfp one, final Dfp two) {\n    int den = 1;\n    Dfp x = a.add(new Dfp(a.getField(), -1)).divide(a.add(one));\n    Dfp y = new Dfp(x);\n    Dfp num = new Dfp(x);\n    Dfp py = new Dfp(y);\n    for (int i = 0; i < 10000; i++) {\n        num = num.multiply(x);\n        num = num.multiply(x);\n        den += 2;\n        Dfp t = num.divide(den);\n        y = y.add(t);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return y.multiply(two);\n}"
            ],
            [
                "getRandomGenerator",
                "org.apache.commons.math3.genetics",
                "GeneticAlgorithm",
                "/**\n * Returns the (static) random generator.\n *\n * @return the static random generator shared by GA implementation classes\n */\npublic static synchronized RandomGenerator getRandomGenerator() {\n    return randomGenerator;\n}"
            ],
            [
                "randomPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation corresponding to a random permutation of\n * length l which can be passed to the RandomKey constructor.\n *\n * @param l length of the permutation\n * @return representation of a random permutation\n */\npublic static final List<Double> randomPermutation(final int l) {\n    List<Double> repr = new ArrayList<Double>(l);\n    for (int i = 0; i < l; i++) {\n        repr.add(GeneticAlgorithm.getRandomGenerator().nextDouble());\n    }\n    return repr;\n}"
            ],
            [
                "identityPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation corresponding to an identity permutation of\n * length l which can be passed to the RandomKey constructor.\n *\n * @param l length of the permutation\n * @return representation of an identity permutation\n */\npublic static final List<Double> identityPermutation(final int l) {\n    List<Double> repr = new ArrayList<Double>(l);\n    for (int i = 0; i < l; i++) {\n        repr.add((double) i / l);\n    }\n    return repr;\n}"
            ],
            [
                "comparatorPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation of a permutation corresponding to the\n * <code>data</code> sorted by <code>comparator</code>. The\n * <code>data</code> is not modified during the process.\n *\n * This is useful if you want to inject some permutations to the initial\n * population.\n *\n * @param <S> type of the data\n * @param data list of data determining the order\n * @param comparator how the data will be compared\n * @return list representation of the permutation corresponding to the parameters\n */\npublic static <S> List<Double> comparatorPermutation(final List<S> data, final Comparator<S> comparator) {\n    List<S> sortedData = new ArrayList<S>(data);\n    Collections.sort(sortedData, comparator);\n    return inducedPermutation(data, sortedData);\n}"
            ],
            [
                "inducedPermutation",
                "org.apache.commons.math3.genetics",
                "RandomKey",
                "/**\n * Generates a representation of a permutation corresponding to a\n * permutation which yields <code>permutedData</code> when applied to\n * <code>originalData</code>.\n *\n * This method can be viewed as an inverse to {@link #decode(List)}.\n *\n * @param <S> type of the data\n * @param originalData the original, unpermuted data\n * @param permutedData the data, somehow permuted\n * @return representation of a permutation corresponding to the permutation\n *   <code>originalData -> permutedData</code>\n * @throws DimensionMismatchException iff the length of <code>originalData</code>\n *   and <code>permutedData</code> lists are not equal\n * @throws MathIllegalArgumentException iff the <code>permutedData</code> and\n *   <code>originalData</code> lists contain different data\n */\npublic static <S> List<Double> inducedPermutation(final List<S> originalData, final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException {\n    if (originalData.size() != permutedData.size()) {\n        throw new DimensionMismatchException(permutedData.size(), originalData.size());\n    }\n    int l = originalData.size();\n    List<S> origDataCopy = new ArrayList<S>(originalData);\n    Double[] res = new Double[l];\n    for (int i = 0; i < l; i++) {\n        int index = origDataCopy.indexOf(permutedData.get(i));\n        if (index == -1) {\n            throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_ORIG_AND_PERMUTED_DATA);\n        }\n        res[index] = (double) i / l;\n        origDataCopy.set(index, null);\n    }\n    return Arrays.asList(res);\n}"
            ],
            [
                "randomBinaryRepresentation",
                "org.apache.commons.math3.genetics",
                "BinaryChromosome",
                "/**\n * Returns a representation of a random binary array of length <code>length</code>.\n * @param length length of the array\n * @return a random binary array of length <code>length</code>\n */\npublic static List<Integer> randomBinaryRepresentation(int length) {\n    // random binary list\n    List<Integer> rList = new ArrayList<Integer>(length);\n    for (int j = 0; j < length; j++) {\n        rList.add(GeneticAlgorithm.getRandomGenerator().nextInt(2));\n    }\n    return rList;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * Get the set of locales for which point/vector formats are available.\n * <p>This is the same set as the {@link NumberFormat} set.</p>\n * @return available point/vector format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "/**\n * Returns the default 3D vector format for the current locale.\n * @return the default 3D vector format.\n */\npublic static Vector3DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3DFormat",
                "/**\n * Returns the default 3D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 3D vector format specific to the given locale.\n */\npublic static Vector3DFormat getInstance(final Locale locale) {\n    return new Vector3DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final FieldVector3D<T> v2) throws MathArithmeticException {\n    final T normProduct = v1.getNorm().multiply(v2.getNorm());\n    if (normProduct.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    final T dot = dotProduct(v1, v2);\n    final double threshold = normProduct.getReal() * 0.9999;\n    if ((dot.getReal() < -threshold) || (dot.getReal() > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        FieldVector3D<T> v3 = crossProduct(v1, v2);\n        if (dot.getReal() >= 0) {\n            return v3.getNorm().divide(normProduct).asin();\n        }\n        return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return dot.divide(normProduct).acos();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final FieldVector3D<T> v1, final Vector3D v2) throws MathArithmeticException {\n    final T normProduct = v1.getNorm().multiply(v2.getNorm());\n    if (normProduct.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    final T dot = dotProduct(v1, v2);\n    final double threshold = normProduct.getReal() * 0.9999;\n    if ((dot.getReal() < -threshold) || (dot.getReal() > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        FieldVector3D<T> v3 = crossProduct(v1, v2);\n        if (dot.getReal() >= 0) {\n            return v3.getNorm().divide(normProduct).asin();\n        }\n        return v3.getNorm().divide(normProduct).asin().subtract(FastMath.PI).negate();\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return dot.divide(normProduct).acos();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static <T extends RealFieldElement<T>> T angle(final Vector3D v1, final FieldVector3D<T> v2) throws MathArithmeticException {\n    return angle(v2, v1);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the dot product v1.v2\n */\npublic static <T extends RealFieldElement<T>> T dotProduct(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.dotProduct(v1);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> crossProduct(final Vector3D v1, final FieldVector3D<T> v2) {\n    return new FieldVector3D<T>(v2.x.linearCombination(v1.getY(), v2.z, -v1.getZ(), v2.y), v2.y.linearCombination(v1.getZ(), v2.x, -v1.getX(), v2.z), v2.z.linearCombination(v1.getX(), v2.y, -v1.getY(), v2.x));\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance1(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distance1(v1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distance(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distance(v1);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static <T extends RealFieldElement<T>> T distanceInf(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distanceInf(v1);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final FieldVector3D<T> v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final FieldVector3D<T> v1, final Vector3D v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldVector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @param <T> the type of the field elements\n * @return the square of the distance between v1 and v2\n */\npublic static <T extends RealFieldElement<T>> T distanceSq(final Vector3D v1, final FieldVector3D<T> v2) {\n    return v2.distanceSq(v1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "/**\n * Compute the <i>distance</i> between two rotations.\n * <p>The <i>distance</i> is intended here as a way to check if two\n * rotations are almost similar (i.e. they transform vectors the same way)\n * or very different. It is mathematically defined as the angle of\n * the rotation r that prepended to one of the rotations gives the other\n * one:</p>\n * <pre>\n *        r<sub>1</sub>(r) = r<sub>2</sub>\n * </pre>\n * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n * reached for some v. The distance is equal to 0 if and only if the two\n * rotations are identical.</p>\n * <p>Comparing two rotations should always be done using this value rather\n * than for example comparing the components of the quaternions. It is much\n * more stable, and has a geometric meaning. Also comparing quaternions\n * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n * their components are different (they are exact opposites).</p>\n * @param r1 first rotation\n * @param r2 second rotation\n * @return <i>distance</i> between r1 and r2\n */\npublic static double distance(Rotation r1, Rotation r2) {\n    return r1.composeInverseInternal(r2).getAngle();\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Euclidean3D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean3D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply a rotation to a vector.\n * @param r rotation to apply\n * @param u vector to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new vector which is the image of u by the rotation\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> applyTo(final Rotation r, final FieldVector3D<T> u) {\n    final T x = u.getX();\n    final T y = u.getY();\n    final T z = u.getZ();\n    final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n    return new FieldVector3D<T>(x.multiply(r.getQ0()).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(r.getQ0()).add(s.multiply(r.getQ1())).multiply(2).subtract(x), y.multiply(r.getQ0()).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(r.getQ0()).add(s.multiply(r.getQ2())).multiply(2).subtract(y), z.multiply(r.getQ0()).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(r.getQ0()).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n}"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply the inverse of a rotation to a vector.\n * @param r rotation to apply\n * @param u vector to apply the inverse of the rotation to\n * @param <T> the type of the field elements\n * @return a new vector which such that u is its image by the rotation\n */\npublic static <T extends RealFieldElement<T>> FieldVector3D<T> applyInverseTo(final Rotation r, final FieldVector3D<T> u) {\n    final T x = u.getX();\n    final T y = u.getY();\n    final T z = u.getZ();\n    final T s = x.multiply(r.getQ1()).add(y.multiply(r.getQ2())).add(z.multiply(r.getQ3()));\n    final double m0 = -r.getQ0();\n    return new FieldVector3D<T>(x.multiply(m0).subtract(z.multiply(r.getQ2()).subtract(y.multiply(r.getQ3()))).multiply(m0).add(s.multiply(r.getQ1())).multiply(2).subtract(x), y.multiply(m0).subtract(x.multiply(r.getQ3()).subtract(z.multiply(r.getQ1()))).multiply(m0).add(s.multiply(r.getQ2())).multiply(2).subtract(y), z.multiply(m0).subtract(y.multiply(r.getQ1()).subtract(x.multiply(r.getQ2()))).multiply(m0).add(s.multiply(r.getQ3())).multiply(2).subtract(z));\n}"
            ],
            [
                "applyTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply a rotation to another rotation.\n * Applying a rotation to another rotation is computing the composition\n * in an order compliant with the following rule : let u be any\n * vector and v its image by rInner (i.e. rInner.applyTo(u) = v), let w be the image\n * of v by rOuter (i.e. rOuter.applyTo(v) = w), then w = comp.applyTo(u),\n * where comp = applyTo(rOuter, rInner).\n * @param r1 rotation to apply\n * @param rInner rotation to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new rotation which is the composition of r by the instance\n */\npublic static <T extends RealFieldElement<T>> FieldRotation<T> applyTo(final Rotation r1, final FieldRotation<T> rInner) {\n    return new FieldRotation<T>(rInner.q0.multiply(r1.getQ0()).subtract(rInner.q1.multiply(r1.getQ1()).add(rInner.q2.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ3()))), rInner.q1.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ1())).add(rInner.q2.multiply(r1.getQ3()).subtract(rInner.q3.multiply(r1.getQ2()))), rInner.q2.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ2())).add(rInner.q3.multiply(r1.getQ1()).subtract(rInner.q1.multiply(r1.getQ3()))), rInner.q3.multiply(r1.getQ0()).add(rInner.q0.multiply(r1.getQ3())).add(rInner.q1.multiply(r1.getQ2()).subtract(rInner.q2.multiply(r1.getQ1()))), false);\n}"
            ],
            [
                "applyInverseTo",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Apply the inverse of a rotation to another rotation.\n * Applying the inverse of a rotation to another rotation is computing\n * the composition in an order compliant with the following rule :\n * let u be any vector and v its image by rInner (i.e. rInner.applyTo(u) = v),\n * let w be the inverse image of v by rOuter\n * (i.e. rOuter.applyInverseTo(v) = w), then w = comp.applyTo(u), where\n * comp = applyInverseTo(rOuter, rInner).\n * @param rOuter rotation to apply the rotation to\n * @param rInner rotation to apply the rotation to\n * @param <T> the type of the field elements\n * @return a new rotation which is the composition of r by the inverse\n * of the instance\n */\npublic static <T extends RealFieldElement<T>> FieldRotation<T> applyInverseTo(final Rotation rOuter, final FieldRotation<T> rInner) {\n    return new FieldRotation<T>(rInner.q0.multiply(rOuter.getQ0()).add(rInner.q1.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ2())).add(rInner.q3.multiply(rOuter.getQ3()))).negate(), rInner.q0.multiply(rOuter.getQ1()).add(rInner.q2.multiply(rOuter.getQ3()).subtract(rInner.q3.multiply(rOuter.getQ2()))).subtract(rInner.q1.multiply(rOuter.getQ0())), rInner.q0.multiply(rOuter.getQ2()).add(rInner.q3.multiply(rOuter.getQ1()).subtract(rInner.q1.multiply(rOuter.getQ3()))).subtract(rInner.q2.multiply(rOuter.getQ0())), rInner.q0.multiply(rOuter.getQ3()).add(rInner.q1.multiply(rOuter.getQ2()).subtract(rInner.q2.multiply(rOuter.getQ1()))).subtract(rInner.q3.multiply(rOuter.getQ0())), false);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "FieldRotation",
                "/**\n * Compute the <i>distance</i> between two rotations.\n * <p>The <i>distance</i> is intended here as a way to check if two\n * rotations are almost similar (i.e. they transform vectors the same way)\n * or very different. It is mathematically defined as the angle of\n * the rotation r that prepended to one of the rotations gives the other\n * one:</p>\n * <pre>\n *        r<sub>1</sub>(r) = r<sub>2</sub>\n * </pre>\n * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n * reached for some v. The distance is equal to 0 if and only if the two\n * rotations are identical.</p>\n * <p>Comparing two rotations should always be done using this value rather\n * than for example comparing the components of the quaternions. It is much\n * more stable, and has a geometric meaning. Also comparing quaternions\n * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n * their components are different (they are exact opposites).</p>\n * @param r1 first rotation\n * @param r2 second rotation\n * @param <T> the type of the field elements\n * @return <i>distance</i> between r1 and r2\n */\npublic static <T extends RealFieldElement<T>> T distance(final FieldRotation<T> r1, final FieldRotation<T> r2) {\n    return r1.composeInverseInternal(r2).getAngle();\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static double angle(Vector3D v1, Vector3D v2) throws MathArithmeticException {\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    double dot = v1.dotProduct(v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        Vector3D v3 = crossProduct(v1, v2);\n        if (dot >= 0) {\n            return FastMath.asin(v3.getNorm() / normProduct);\n        }\n        return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return FastMath.acos(dot / normProduct);\n}"
            ],
            [
                "dotProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the dot product v1.v2\n */\npublic static double dotProduct(Vector3D v1, Vector3D v2) {\n    return v1.dotProduct(v2);\n}"
            ],
            [
                "crossProduct",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\npublic static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n    return v1.crossProduct(v2);\n}"
            ],
            [
                "distance1",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>1</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n */\npublic static double distance1(Vector3D v1, Vector3D v2) {\n    return v1.distance1(v2);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector3D v1, Vector3D v2) {\n    return v1.distance(v2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector3D v1, Vector3D v2) {\n    return v1.distanceInf(v2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return the square of the distance between v1 and v2\n */\npublic static double distanceSq(Vector3D v1, Vector3D v2) {\n    return v1.distanceSq(v2);\n}"
            ],
            [
                "intersection",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Plane",
                "/**\n * Get the intersection point of three planes.\n * @param plane1 first plane1\n * @param plane2 second plane2\n * @param plane3 third plane2\n * @return intersection point of three planes, null if some planes are parallel\n */\npublic static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3) {\n    // coefficients of the three planes linear equations\n    final double a1 = plane1.w.getX();\n    final double b1 = plane1.w.getY();\n    final double c1 = plane1.w.getZ();\n    final double d1 = plane1.originOffset;\n    final double a2 = plane2.w.getX();\n    final double b2 = plane2.w.getY();\n    final double c2 = plane2.w.getZ();\n    final double d2 = plane2.originOffset;\n    final double a3 = plane3.w.getX();\n    final double b3 = plane3.w.getY();\n    final double c3 = plane3.w.getZ();\n    final double d3 = plane3.originOffset;\n    // direct Cramer resolution of the linear system\n    // (this is still feasible for a 3x3 system)\n    final double a23 = b2 * c3 - b3 * c2;\n    final double b23 = c2 * a3 - c3 * a2;\n    final double c23 = a2 * b3 - a3 * b2;\n    final double determinant = a1 * a23 + b1 * b23 + c1 * c23;\n    if (FastMath.abs(determinant) < 1.0e-10) {\n        return null;\n    }\n    final double r = 1.0 / determinant;\n    return new Vector3D((-a23 * d1 - (c1 * b3 - c3 * b1) * d2 - (c2 * b1 - c1 * b2) * d3) * r, (-b23 * d1 - (c3 * a1 - c1 * a3) * d2 - (c1 * a2 - c2 * a1) * d3) * r, (-c23 * d1 - (b1 * a3 - b3 * a1) * d2 - (b2 * a1 - b1 * a2) * d3) * r);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Euclidean1D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean1D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "/**\n * Returns the default 1D vector format for the current locale.\n * @return the default 1D vector format.\n */\npublic static Vector1DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1DFormat",
                "/**\n * Returns the default 1D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 1D vector format specific to the given locale.\n */\npublic static Vector1DFormat getInstance(final Locale locale) {\n    return new Vector1DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector1D p1, Vector1D p2) {\n    return p1.distance(p2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector1D p1, Vector1D p2) {\n    return p1.distanceInf(p2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\npublic static double distanceSq(Vector1D p1, Vector1D p2) {\n    return p1.distanceSq(p2);\n}"
            ],
            [
                "reducePoints",
                "org.apache.commons.math3.geometry.euclidean.twod.hull",
                "AklToussaintHeuristic",
                "/**\n * Returns a point set that is reduced by all points for which it is safe to assume\n * that they are not part of the convex hull.\n *\n * @param points the original point set\n * @return a reduced point set, useful as input for convex hull algorithms\n */\npublic static Collection<Vector2D> reducePoints(final Collection<Vector2D> points) {\n    // find the leftmost point\n    int size = 0;\n    Vector2D minX = null;\n    Vector2D maxX = null;\n    Vector2D minY = null;\n    Vector2D maxY = null;\n    for (Vector2D p : points) {\n        if (minX == null || p.getX() < minX.getX()) {\n            minX = p;\n        }\n        if (maxX == null || p.getX() > maxX.getX()) {\n            maxX = p;\n        }\n        if (minY == null || p.getY() < minY.getY()) {\n            minY = p;\n        }\n        if (maxY == null || p.getY() > maxY.getY()) {\n            maxY = p;\n        }\n        size++;\n    }\n    if (size < 4) {\n        return points;\n    }\n    final List<Vector2D> quadrilateral = buildQuadrilateral(minY, maxX, maxY, minX);\n    // if the quadrilateral is not well formed, e.g. only 2 points, do not attempt to reduce\n    if (quadrilateral.size() < 3) {\n        return points;\n    }\n    final List<Vector2D> reducedPoints = new ArrayList<Vector2D>(quadrilateral);\n    for (final Vector2D p : points) {\n        // check all points if they are within the quadrilateral\n        // in which case they can not be part of the convex hull\n        if (!insideQuadrilateral(p, quadrilateral)) {\n            reducedPoints.add(p);\n        }\n    }\n    return reducedPoints;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "/**\n * Returns the default 2D vector format for the current locale.\n * @return the default 2D vector format.\n */\npublic static Vector2DFormat getInstance() {\n    return getInstance(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2DFormat",
                "/**\n * Returns the default 2D vector format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the 2D vector format specific to the given locale.\n */\npublic static Vector2DFormat getInstance(final Locale locale) {\n    return new Vector2DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n}"
            ],
            [
                "angle",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the angular separation between two vectors.\n * <p>This method computes the angular separation between two\n * vectors using the dot product for well separated vectors and the\n * cross product for almost aligned vectors. This allows to have a\n * good accuracy in all cases, even for vectors very close to each\n * other.</p>\n * @param v1 first vector\n * @param v2 second vector\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\npublic static double angle(Vector2D v1, Vector2D v2) throws MathArithmeticException {\n    double normProduct = v1.getNorm() * v2.getNorm();\n    if (normProduct == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    double dot = v1.dotProduct(v2);\n    double threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n        // the vectors are almost aligned, compute using the sine\n        final double n = FastMath.abs(MathArrays.linearCombination(v1.x, v2.y, -v1.y, v2.x));\n        if (dot >= 0) {\n            return FastMath.asin(n / normProduct);\n        }\n        return FastMath.PI - FastMath.asin(n / normProduct);\n    }\n    // the vectors are sufficiently separated to use the cosine\n    return FastMath.acos(dot / normProduct);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the distance between two vectors according to the L<sub>2</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNorm()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>2</sub> norm\n */\npublic static double distance(Vector2D p1, Vector2D p2) {\n    return p1.distance(p2);\n}"
            ],
            [
                "distanceInf",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormInf()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm\n */\npublic static double distanceInf(Vector2D p1, Vector2D p2) {\n    return p1.distanceInf(p2);\n}"
            ],
            [
                "distanceSq",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Compute the square of the distance between two vectors.\n * <p>Calling this method is equivalent to calling:\n * <code>p1.subtract(p2).getNormSq()</code> except that no intermediate\n * vector is built</p>\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\npublic static double distanceSq(Vector2D p1, Vector2D p2) {\n    return p1.distanceSq(p2);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Euclidean2D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Euclidean2D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding an affine transform.\n * @param transform affine transform to embed (must be inversible\n * otherwise the {@link\n * org.apache.commons.math3.geometry.partitioning.Transform#apply(Hyperplane)\n * apply(Hyperplane)} method would work only for some lines, and\n * fail for other ones)\n * @return a new transform that can be applied to either {@link\n * Vector2D Vector2D}, {@link Line Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n * @exception MathIllegalArgumentException if the transform is non invertible\n * @deprecated as of 3.6, replaced with {@link #getTransform(double, double, double, double, double, double)}\n */\n@Deprecated\npublic static Transform<Euclidean2D, Euclidean1D> getTransform(final AffineTransform transform) throws MathIllegalArgumentException {\n    final double[] m = new double[6];\n    transform.getMatrix(m);\n    return new LineTransform(m[0], m[1], m[2], m[3], m[4], m[5]);\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Line",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding an affine transform.\n * @param cXX transform factor between input abscissa and output abscissa\n * @param cYX transform factor between input abscissa and output ordinate\n * @param cXY transform factor between input ordinate and output abscissa\n * @param cYY transform factor between input ordinate and output ordinate\n * @param cX1 transform addendum for output abscissa\n * @param cY1 transform addendum for output ordinate\n * @return a new transform that can be applied to either {@link\n * Vector2D Vector2D}, {@link Line Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n * @exception MathIllegalArgumentException if the transform is non invertible\n * @since 3.6\n */\npublic static Transform<Euclidean2D, Euclidean1D> getTransform(final double cXX, final double cYX, final double cXY, final double cYY, final double cX1, final double cY1) throws MathIllegalArgumentException {\n    return new LineTransform(cXX, cYX, cXY, cYY, cX1, cY1);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "/**\n * Compute the distance (angular separation) between two points.\n * @param p1 first vector\n * @param p2 second vector\n * @return the angular separation between p1 and p2\n */\npublic static double distance(S1Point p1, S1Point p2) {\n    return Vector2D.angle(p1.vector, p2.vector);\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.oned",
                "Sphere1D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Sphere1D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Sphere2D",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static Sphere2D getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getTransform",
                "org.apache.commons.math3.geometry.spherical.twod",
                "Circle",
                "/**\n * Get a {@link org.apache.commons.math3.geometry.partitioning.Transform\n * Transform} embedding a 3D rotation.\n * @param rotation rotation to use\n * @return a new transform that can be applied to either {@link\n * Point Point}, {@link Circle Line} or {@link\n * org.apache.commons.math3.geometry.partitioning.SubHyperplane\n * SubHyperplane} instances\n */\npublic static Transform<Sphere2D, Sphere1D> getTransform(final Rotation rotation) {\n    return new CircleTransform(rotation);\n}"
            ],
            [
                "distance",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * Compute the distance (angular separation) between two points.\n * @param p1 first vector\n * @param p2 second vector\n * @return the angular separation between p1 and p2\n */\npublic static double distance(S2Point p1, S2Point p2) {\n    return Vector3D.angle(p1.vector, p2.vector);\n}"
            ],
            [
                "createAdaptor",
                "org.apache.commons.math3.random",
                "RandomAdaptor",
                "/**\n * Factory method to create a <code>Random</code> using the supplied\n * <code>RandomGenerator</code>.\n *\n * @param randomGenerator  wrapped RandomGenerator instance\n * @return a Random instance wrapping the RandomGenerator\n */\npublic static Random createAdaptor(RandomGenerator randomGenerator) {\n    return new RandomAdaptor(randomGenerator);\n}"
            ],
            [
                "createRandomGenerator",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "/**\n * Creates a {@link RandomDataGenerator} instance that wraps a\n * {@link Random} instance.\n *\n * @param rng JDK {@link Random} instance that will generate the\n * the random data.\n * @return the given RNG, wrapped in a {@link RandomGenerator}.\n */\npublic static RandomGenerator createRandomGenerator(final Random rng) {\n    return new RandomGenerator() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(int seed) {\n            rng.setSeed((long) seed);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(int[] seed) {\n            rng.setSeed(convertToLong(seed));\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void setSeed(long seed) {\n            rng.setSeed(seed);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void nextBytes(byte[] bytes) {\n            rng.nextBytes(bytes);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int nextInt() {\n            return rng.nextInt();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public int nextInt(int n) {\n            if (n <= 0) {\n                throw new NotStrictlyPositiveException(n);\n            }\n            return rng.nextInt(n);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public long nextLong() {\n            return rng.nextLong();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public boolean nextBoolean() {\n            return rng.nextBoolean();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public float nextFloat() {\n            return rng.nextFloat();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public double nextDouble() {\n            return rng.nextDouble();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public double nextGaussian() {\n            return rng.nextGaussian();\n        }\n    };\n}"
            ],
            [
                "convertToLong",
                "org.apache.commons.math3.random",
                "RandomGeneratorFactory",
                "/**\n * Converts seed from one representation to another.\n *\n * @param seed Original seed.\n * @return the converted seed.\n */\npublic static long convertToLong(int[] seed) {\n    // The following number is the largest prime that fits\n    // in 32 bits (i.e. 2^32 - 5).\n    final long prime = 4294967291l;\n    long combined = 0l;\n    for (int s : seed) {\n        combined = combined * prime + s;\n    }\n    return combined;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Get the set of locales for which complex formats are available.  This\n * is the same set as the {@link NumberFormat} set.\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "formatBigFraction",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * This static method calls formatBigFraction() on a default instance of\n * BigFractionFormat.\n *\n * @param f BigFraction object to format\n * @return A formatted BigFraction in proper form.\n */\npublic static String formatBigFraction(final BigFraction f) {\n    return getImproperInstance().format(f);\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static BigFractionFormat getImproperInstance() {\n    return getImproperInstance(Locale.getDefault());\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static BigFractionFormat getImproperInstance(final Locale locale) {\n    return new BigFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static BigFractionFormat getProperInstance() {\n    return getProperInstance(Locale.getDefault());\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static BigFractionFormat getProperInstance(final Locale locale) {\n    return new ProperBigFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * <p>Creates a {@code Fraction} instance with the 2 parts\n * of a fraction Y/Z.</p>\n *\n * <p>Any negative signs are resolved to be on the numerator.</p>\n *\n * @param numerator  the numerator, for example the three in 'three sevenths'\n * @param denominator  the denominator, for example the seven in 'three sevenths'\n * @return a new fraction instance, with the numerator and denominator reduced\n * @throws MathArithmeticException if the denominator is {@code zero}\n */\npublic static Fraction getReducedFraction(int numerator, int denominator) {\n    if (denominator == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION, numerator, denominator);\n    }\n    if (numerator == 0) {\n        // normalize zero.\n        return ZERO;\n    }\n    // allow 2^k/-2^31 as a valid fraction (where k>0)\n    if (denominator == Integer.MIN_VALUE && (numerator & 1) == 0) {\n        numerator /= 2;\n        denominator /= 2;\n    }\n    if (denominator < 0) {\n        if (numerator == Integer.MIN_VALUE || denominator == Integer.MIN_VALUE) {\n            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION, numerator, denominator);\n        }\n        numerator = -numerator;\n        denominator = -denominator;\n    }\n    // simplify fraction.\n    int gcd = ArithmeticUtils.gcd(numerator, denominator);\n    numerator /= gcd;\n    denominator /= gcd;\n    return new Fraction(numerator, denominator);\n}"
            ],
            [
                "getReducedFraction",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * <p>\n * Creates a <code>BigFraction</code> instance with the 2 parts of a fraction\n * Y/Z.\n * </p>\n *\n * <p>\n * Any negative signs are resolved to be on the numerator.\n * </p>\n *\n * @param numerator\n *            the numerator, for example the three in 'three sevenths'.\n * @param denominator\n *            the denominator, for example the seven in 'three sevenths'.\n * @return a new fraction instance, with the numerator and denominator\n *         reduced.\n * @throws ArithmeticException\n *             if the denominator is <code>zero</code>.\n */\npublic static BigFraction getReducedFraction(final int numerator, final int denominator) {\n    if (numerator == 0) {\n        // normalize zero.\n        return ZERO;\n    }\n    return new BigFraction(numerator, denominator);\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)}. The only\n * customization is the maximum number of BigFraction digits, which is set to 0.\n * @return the default number format.\n */\nprotected static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)}. The only\n * customization is the maximum number of BigFraction digits, which is set to 0.\n * @param locale the specific locale used by the format.\n * @return the default number format specific to the given locale.\n */\nprotected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n    final NumberFormat nf = NumberFormat.getNumberInstance(locale);\n    nf.setMaximumFractionDigits(0);\n    nf.setParseIntegerOnly(true);\n    return nf;\n}"
            ],
            [
                "parseNextCharacter",
                "org.apache.commons.math3.fraction",
                "AbstractFormat",
                "/**\n * Parses <code>source</code> until a non-whitespace character is found.\n * @param source the string to parse\n * @param pos input/output parsing parameter.\n * @return the first non-whitespace character.\n */\nprotected static char parseNextCharacter(final String source, final ParsePosition pos) {\n    int index = pos.getIndex();\n    final int n = source.length();\n    char ret = 0;\n    if (index < n) {\n        char c;\n        do {\n            c = source.charAt(index++);\n        } while (Character.isWhitespace(c) && index < n);\n        pos.setIndex(index);\n        if (index < n) {\n            ret = c;\n        }\n    }\n    return ret;\n}"
            ],
            [
                "getAvailableLocales",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Get the set of locales for which complex formats are available.  This\n * is the same set as the {@link NumberFormat} set.\n * @return available complex format locales.\n */\npublic static Locale[] getAvailableLocales() {\n    return NumberFormat.getAvailableLocales();\n}"
            ],
            [
                "formatFraction",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * This static method calls formatFraction() on a default instance of\n * FractionFormat.\n *\n * @param f Fraction object to format\n * @return a formatted fraction in proper form.\n */\npublic static String formatFraction(Fraction f) {\n    return getImproperInstance().format(f);\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static FractionFormat getImproperInstance() {\n    return getImproperInstance(Locale.getDefault());\n}"
            ],
            [
                "getImproperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static FractionFormat getImproperInstance(final Locale locale) {\n    return new FractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the current locale.\n * @return the default complex format.\n */\npublic static FractionFormat getProperInstance() {\n    return getProperInstance(Locale.getDefault());\n}"
            ],
            [
                "getProperInstance",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Returns the default complex format for the given locale.\n * @param locale the specific locale used by the format.\n * @return the complex format specific to the given locale.\n */\npublic static FractionFormat getProperInstance(final Locale locale) {\n    return new ProperFractionFormat(getDefaultNumberFormat(locale));\n}"
            ],
            [
                "getDefaultNumberFormat",
                "org.apache.commons.math3.fraction",
                "FractionFormat",
                "/**\n * Create a default number format.  The default number format is based on\n * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n * customizing is the maximum number of fraction digits, which is set to 0.\n * @return the default number format.\n */\nprotected static NumberFormat getDefaultNumberFormat() {\n    return getDefaultNumberFormat(Locale.getDefault());\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "FractionField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static FractionField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "getInstance",
                "org.apache.commons.math3.fraction",
                "BigFractionField",
                "/**\n * Get the unique instance.\n * @return the unique instance\n */\npublic static BigFractionField getInstance() {\n    return LazyHolder.INSTANCE;\n}"
            ],
            [
                "flatten",
                "org.apache.commons.math3.exception.util",
                "ArgUtils",
                "/**\n * Transform a multidimensional array into a one-dimensional list.\n *\n * @param array Array (possibly multidimensional).\n * @return a list of all the {@code Object} instances contained in\n * {@code array}.\n */\npublic static Object[] flatten(Object[] array) {\n    final List<Object> list = new ArrayList<Object>();\n    if (array != null) {\n        for (Object o : array) {\n            if (o instanceof Object[]) {\n                for (Object oR : flatten((Object[]) o)) {\n                    list.add(oR);\n                }\n            } else {\n                list.add(o);\n            }\n        }\n    }\n    return list.toArray();\n}"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Multiply every component in the given real array by the\n * given real number. The change is made in place.\n *\n * @param f the real array to be scaled\n * @param d the real scaling coefficient\n * @return a reference to the scaled array\n */\npublic static double[] scaleArray(double[] f, double d) {\n    for (int i = 0; i < f.length; i++) {\n        f[i] *= d;\n    }\n    return f;\n}"
            ],
            [
                "scaleArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Multiply every component in the given complex array by the\n * given real number. The change is made in place.\n *\n * @param f the complex array to be scaled\n * @param d the real scaling coefficient\n * @return a reference to the scaled array\n */\npublic static Complex[] scaleArray(Complex[] f, double d) {\n    for (int i = 0; i < f.length; i++) {\n        f[i] = new Complex(d * f[i].getReal(), d * f[i].getImaginary());\n    }\n    return f;\n}"
            ],
            [
                "createRealImaginaryArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Builds a new two dimensional array of {@code double} filled with the real\n * and imaginary parts of the specified {@link Complex} numbers. In the\n * returned array {@code dataRI}, the data is laid out as follows\n * <ul>\n * <li>{@code dataRI[0][i] = dataC[i].getReal()},</li>\n * <li>{@code dataRI[1][i] = dataC[i].getImaginary()}.</li>\n * </ul>\n *\n * @param dataC the array of {@link Complex} data to be transformed\n * @return a two dimensional array filled with the real and imaginary parts\n *   of the specified complex input\n */\npublic static double[][] createRealImaginaryArray(final Complex[] dataC) {\n    final double[][] dataRI = new double[2][dataC.length];\n    final double[] dataR = dataRI[0];\n    final double[] dataI = dataRI[1];\n    for (int i = 0; i < dataC.length; i++) {\n        final Complex c = dataC[i];\n        dataR[i] = c.getReal();\n        dataI[i] = c.getImaginary();\n    }\n    return dataRI;\n}"
            ],
            [
                "createComplexArray",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Builds a new array of {@link Complex} from the specified two dimensional\n * array of real and imaginary parts. In the returned array {@code dataC},\n * the data is laid out as follows\n * <ul>\n * <li>{@code dataC[i].getReal() = dataRI[0][i]},</li>\n * <li>{@code dataC[i].getImaginary() = dataRI[1][i]}.</li>\n * </ul>\n *\n * @param dataRI the array of real and imaginary parts to be transformed\n * @return an array of {@link Complex} with specified real and imaginary parts.\n * @throws DimensionMismatchException if the number of rows of the specified\n *   array is not two, or the array is not rectangular\n */\npublic static Complex[] createComplexArray(final double[][] dataRI) throws DimensionMismatchException {\n    if (dataRI.length != 2) {\n        throw new DimensionMismatchException(dataRI.length, 2);\n    }\n    final double[] dataR = dataRI[0];\n    final double[] dataI = dataRI[1];\n    if (dataR.length != dataI.length) {\n        throw new DimensionMismatchException(dataI.length, dataR.length);\n    }\n    final int n = dataR.length;\n    final Complex[] c = new Complex[n];\n    for (int i = 0; i < n; i++) {\n        c[i] = new Complex(dataR[i], dataI[i]);\n    }\n    return c;\n}"
            ],
            [
                "exactLog2",
                "org.apache.commons.math3.transform",
                "TransformUtils",
                "/**\n * Returns the base-2 logarithm of the specified {@code int}. Throws an\n * exception if {@code n} is not a power of two.\n *\n * @param n the {@code int} whose base-2 logarithm is to be evaluated\n * @return the base-2 logarithm of {@code n}\n * @throws MathIllegalArgumentException if {@code n} is not a power of two\n */\npublic static int exactLog2(final int n) throws MathIllegalArgumentException {\n    int index = Arrays.binarySearch(TransformUtils.POWERS_OF_TWO, n);\n    if (index < 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING, Integer.valueOf(n));\n    }\n    return index;\n}"
            ]
        ],
        "tokensProjectClassesNonPrivateStaticAttributes": [
            [
                "PRIMES",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * The first 512 prime numbers.\n * <p>\n * It contains all primes smaller or equal to the cubic square of Integer.MAX_VALUE.\n * As a result, <code>int</code> numbers which are not reduced by those primes are guaranteed\n * to be either prime or semi prime.\n */\npublic static final int[] PRIMES = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671 };"
            ],
            [
                "PRIMES_LAST",
                "org.apache.commons.math3.primes",
                "SmallPrimes",
                "/**\n * The last number in PRIMES.\n */\npublic static final int PRIMES_LAST = PRIMES[PRIMES.length - 1];"
            ],
            [
                "MIDPOINT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "MidPointIntegrator",
                "/**\n * Maximum number of iterations for midpoint.\n */\npublic static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "ROMBERG_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "RombergIntegrator",
                "/**\n * Maximal number of iterations for Romberg.\n */\npublic static final int ROMBERG_MAX_ITERATIONS_COUNT = 32;"
            ],
            [
                "SIMPSON_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "SimpsonIntegrator",
                "/**\n * Maximal number of iterations for Simpson.\n */\npublic static final int SIMPSON_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default absolute accuracy.\n */\npublic static final double DEFAULT_ABSOLUTE_ACCURACY = 1.0e-15;"
            ],
            [
                "DEFAULT_RELATIVE_ACCURACY",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default relative accuracy.\n */\npublic static final double DEFAULT_RELATIVE_ACCURACY = 1.0e-6;"
            ],
            [
                "DEFAULT_MIN_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default minimal iteration count.\n */\npublic static final int DEFAULT_MIN_ITERATIONS_COUNT = 3;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "BaseAbstractUnivariateIntegrator",
                "/**\n * Default maximal iteration count.\n */\npublic static final int DEFAULT_MAX_ITERATIONS_COUNT = Integer.MAX_VALUE;"
            ],
            [
                "TRAPEZOID_MAX_ITERATIONS_COUNT",
                "org.apache.commons.math3.analysis.integration",
                "TrapezoidIntegrator",
                "/**\n * Maximum number of iterations for trapezoid.\n */\npublic static final int TRAPEZOID_MAX_ITERATIONS_COUNT = 64;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "BaseSecantSolver",
                "/**\n * Default absolute accuracy.\n */\nprotected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.analysis.solvers",
                "SecantSolver",
                "/**\n * Default absolute accuracy.\n */\nprotected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_BANDWIDTH",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value of the bandwidth parameter.\n */\npublic static final double DEFAULT_BANDWIDTH = 0.3;"
            ],
            [
                "DEFAULT_ROBUSTNESS_ITERS",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value of the number of robustness iterations.\n */\npublic static final int DEFAULT_ROBUSTNESS_ITERS = 2;"
            ],
            [
                "DEFAULT_ACCURACY",
                "org.apache.commons.math3.analysis.interpolation",
                "LoessInterpolator",
                "/**\n * Default value for accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_ACCURACY = 1e-12;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.analysis.interpolation",
                "NevilleInterpolator",
                "/**\n * serializable version identifier\n */\nstatic final long serialVersionUID = 3003707660147873733L;"
            ],
            [
                "DEFAULT_EXTEND",
                "org.apache.commons.math3.analysis.interpolation",
                "UnivariatePeriodicInterpolator",
                "/**\n * Default number of extension points of the samples array.\n */\npublic static final int DEFAULT_EXTEND = 5;"
            ],
            [
                "DEFAULT_MICROSPHERE_ELEMENTS",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "/**\n * Default number of surface elements that composes the microsphere.\n */\npublic static final int DEFAULT_MICROSPHERE_ELEMENTS = 2000;"
            ],
            [
                "DEFAULT_BRIGHTNESS_EXPONENT",
                "org.apache.commons.math3.analysis.interpolation",
                "MicrosphereInterpolator",
                "/**\n * Default exponent used the weights calculation.\n */\npublic static final int DEFAULT_BRIGHTNESS_EXPONENT = 2;"
            ],
            [
                "EPSILON",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * <p>\n * Largest double-precision floating-point number such that\n * {@code 1 + EPSILON} is numerically equal to 1. This value is an upper\n * bound on the relative error due to rounding real numbers to double\n * precision floating-point numbers.\n * </p>\n * <p>\n * In IEEE 754 arithmetic, this is 2<sup>-53</sup>.\n * </p>\n *\n * @see <a href=\"http://en.wikipedia.org/wiki/Machine_epsilon\">Machine epsilon</a>\n */\npublic static final double EPSILON;"
            ],
            [
                "SAFE_MIN",
                "org.apache.commons.math3.util",
                "Precision",
                "/**\n * Safe minimum, such that {@code 1 / SAFE_MIN} does not overflow.\n * <br/>\n * In IEEE 754 arithmetic, this is also the smallest normalized\n * number 2<sup>-1022</sup>.\n */\npublic static final double SAFE_MIN;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToDoubleHashMap",
                "/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;"
            ],
            [
                "FREE",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;"
            ],
            [
                "FULL",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;"
            ],
            [
                "REMOVED",
                "org.apache.commons.math3.util",
                "OpenIntToFieldHashMap",
                "/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;"
            ],
            [
                "PI",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Archimede's constant PI, ratio of circle circumference to diameter.\n */\npublic static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;"
            ],
            [
                "E",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Napier's constant e, base of the natural logarithm.\n */\npublic static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;"
            ],
            [
                "EXP_INT_TABLE_MAX_INDEX",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Index of exp(0) in the array of integer exponentials.\n */\nstatic final int EXP_INT_TABLE_MAX_INDEX = 750;"
            ],
            [
                "EXP_INT_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Length of the array of integer exponentials.\n */\nstatic final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;"
            ],
            [
                "LN_MANT_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Logarithm table length.\n */\nstatic final int LN_MANT_LEN = 1024;"
            ],
            [
                "EXP_FRAC_TABLE_LEN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Exponential fractions table length.\n */\n// 0, 1/1024, ... 1024/1024\nstatic final int EXP_FRAC_TABLE_LEN = 1025;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of NaN.\n */\npublic static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of positive infinity.\n */\npublic static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "FastMath",
                "/**\n * Split version of negative infinity.\n */\npublic static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of NaN.\n */\npublic static final Split NAN = new Split(Double.NaN, 0);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of positive infinity.\n */\npublic static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Split",
                "/**\n * Split version of negative infinity.\n */\npublic static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);"
            ],
            [
                "ADDITIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "/**\n * Additive expansion mode.\n * @deprecated As of 3.1. Please use {@link ExpansionMode#ADDITIVE} instead.\n */\n@Deprecated\npublic static final int ADDITIVE_MODE = 1;"
            ],
            [
                "MULTIPLICATIVE_MODE",
                "org.apache.commons.math3.util",
                "ResizableDoubleArray",
                "/**\n * Multiplicative expansion mode.\n * @deprecated As of 3.1. Please use {@link ExpansionMode#MULTIPLICATIVE} instead.\n */\n@Deprecated\npublic static final int MULTIPLICATIVE_MODE = 0;"
            ],
            [
                "TWO_PI",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * \\(2\\pi\\)\n * @since 2.1\n */\npublic static final double TWO_PI = 2 * FastMath.PI;"
            ],
            [
                "PI_SQUARED",
                "org.apache.commons.math3.util",
                "MathUtils",
                "/**\n * \\(\\pi^2\\)\n * @since 3.4\n */\npublic static final double PI_SQUARED = FastMath.PI * FastMath.PI;"
            ],
            [
                "FACTORIALS",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * All long-representable factorials\n */\nstatic final long[] FACTORIALS = new long[] { 1l, 1l, 2l, 6l, 24l, 120l, 720l, 5040l, 40320l, 362880l, 3628800l, 39916800l, 479001600l, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l, 355687428096000l, 6402373705728000l, 121645100408832000l, 2432902008176640000l };"
            ],
            [
                "STIRLING_S2",
                "org.apache.commons.math3.util",
                "CombinatoricsUtils",
                "/**\n * Stirling numbers of the second kind.\n */\nstatic final AtomicReference<long[][]> STIRLING_S2 = new AtomicReference<long[][]>(null);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@code 0d} as a {@code Decimal64}.\n */\npublic static final Decimal64 ZERO;"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@code 1d} as a {@code Decimal64}.\n */\npublic static final Decimal64 ONE;"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#NEGATIVE_INFINITY} as a\n * {@code Decimal64}.\n */\npublic static final Decimal64 NEGATIVE_INFINITY;"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#POSITIVE_INFINITY} as a\n * {@code Decimal64}.\n */\npublic static final Decimal64 POSITIVE_INFINITY;"
            ],
            [
                "NAN",
                "org.apache.commons.math3.util",
                "Decimal64",
                "/**\n * The constant value of {@link Double#NaN} as a {@code Decimal64}.\n */\npublic static final Decimal64 NAN;"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.util",
                "BigReal",
                "/**\n * A big real representing 0.\n */\npublic static final BigReal ZERO = new BigReal(BigDecimal.ZERO);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.util",
                "BigReal",
                "/**\n * A big real representing 1.\n */\npublic static final BigReal ONE = new BigReal(BigDecimal.ONE);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Identity quaternion.\n */\npublic static final Quaternion IDENTITY = new Quaternion(1, 0, 0, 0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * Zero quaternion.\n */\npublic static final Quaternion ZERO = new Quaternion(0, 0, 0, 0);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * i\n */\npublic static final Quaternion I = new Quaternion(0, 1, 0, 0);"
            ],
            [
                "J",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * j\n */\npublic static final Quaternion J = new Quaternion(0, 0, 1, 0);"
            ],
            [
                "K",
                "org.apache.commons.math3.complex",
                "Quaternion",
                "/**\n * k\n */\npublic static final Quaternion K = new Quaternion(0, 0, 0, 1);"
            ],
            [
                "I",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * The square root of -1. A number representing \"0.0 + 1.0i\"\n */\npublic static final Complex I = new Complex(0.0, 1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.complex",
                "Complex",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A complex number representing \"NaN + NaNi\"\n */\npublic static final Complex NaN = new Complex(Double.NaN, Double.NaN);"
            ],
            [
                "INF",
                "org.apache.commons.math3.complex",
                "Complex",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A complex number representing \"+INF + INFi\"\n */\npublic static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * A complex number representing \"1.0 + 0.0i\"\n */\npublic static final Complex ONE = new Complex(1.0, 0.0);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.complex",
                "Complex",
                "/**\n * A complex number representing \"0.0 + 0.0i\"\n */\npublic static final Complex ZERO = new Complex(0.0, 0.0);"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Minimum dimension of the problem: {@value}\n */\npublic static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #initialTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optimization.direct",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #stoppingTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "DEFAULT_CHECKFEASABLECOUNT",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #checkFeasableCount}: {@value}.\n */\npublic static final int DEFAULT_CHECKFEASABLECOUNT = 0;"
            ],
            [
                "DEFAULT_STOPFITNESS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #stopFitness}: {@value}.\n */\npublic static final double DEFAULT_STOPFITNESS = 0;"
            ],
            [
                "DEFAULT_ISACTIVECMA",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #isActiveCMA}: {@value}.\n */\npublic static final boolean DEFAULT_ISACTIVECMA = true;"
            ],
            [
                "DEFAULT_MAXITERATIONS",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #maxIterations}: {@value}.\n */\npublic static final int DEFAULT_MAXITERATIONS = 30000;"
            ],
            [
                "DEFAULT_DIAGONALONLY",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #diagonalOnly}: {@value}.\n */\npublic static final int DEFAULT_DIAGONALONLY = 0;"
            ],
            [
                "DEFAULT_RANDOMGENERATOR",
                "org.apache.commons.math3.optimization.direct",
                "CMAESOptimizer",
                "/**\n * Default value for {@link #random}.\n */\npublic static final RandomGenerator DEFAULT_RANDOMGENERATOR = new MersenneTwister();"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.optimization.linear",
                "AbstractLinearOptimizer",
                "/**\n * Default maximal number of iterations allowed.\n */\npublic static final int DEFAULT_MAX_ITERATIONS = 100;"
            ],
            [
                "DEFAULT_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * The default format for {@link RealMatrix} objects.\n * @since 3.1\n */\npublic static final RealMatrixFormat DEFAULT_FORMAT = RealMatrixFormat.getInstance();"
            ],
            [
                "OCTAVE_FORMAT",
                "org.apache.commons.math3.linear",
                "MatrixUtils",
                "/**\n * A format for {@link RealMatrix} objects compatible with octave.\n * @since 3.1\n */\npublic static final RealMatrixFormat OCTAVE_FORMAT = new RealMatrixFormat(\"[\", \"]\", \"\", \"\", \"; \", \", \");"
            ],
            [
                "DEFAULT_ZERO_TOLERANCE",
                "org.apache.commons.math3.linear",
                "OpenMapRealVector",
                "/**\n * Default Tolerance for having a value considered zero.\n */\npublic static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockFieldMatrix",
                "/**\n * Block size.\n */\npublic static final int BLOCK_SIZE = 36;"
            ],
            [
                "OPERATOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "/**\n * Key for the <a href=\"#context\">exception context</a>.\n */\npublic static final String OPERATOR = \"operator\";"
            ],
            [
                "VECTOR",
                "org.apache.commons.math3.linear",
                "ConjugateGradient",
                "/**\n * Key for the <a href=\"#context\">exception context</a>.\n */\npublic static final String VECTOR = \"vector\";"
            ],
            [
                "DEFAULT_RELATIVE_SYMMETRY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "/**\n * Default threshold above which off-diagonal elements are considered too different\n * and matrix not symmetric.\n */\npublic static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;"
            ],
            [
                "DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD",
                "org.apache.commons.math3.linear",
                "CholeskyDecomposition",
                "/**\n * Default threshold below which diagonal elements are considered null\n * and matrix not positive definite.\n */\npublic static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;"
            ],
            [
                "BLOCK_SIZE",
                "org.apache.commons.math3.linear",
                "BlockRealMatrix",
                "/**\n * Block size.\n */\npublic static final int BLOCK_SIZE = 52;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "/**\n * The cubic root of {@link #MACH_PREC}.\n */\nstatic final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "SymmLQ",
                "/**\n * The machine precision.\n */\nstatic final double MACH_PREC;"
            ],
            [
                "CBRT_MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "/**\n * The cubic root of {@link #MACH_PREC}.\n */\nstatic final double CBRT_MACH_PREC;"
            ],
            [
                "MACH_PREC",
                "org.apache.commons.math3.linear",
                "State",
                "/**\n * The machine precision.\n */\nstatic final double MACH_PREC;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "CauchyDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "SOLVER_DEFAULT_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "AbstractRealDistribution",
                "/**\n * Default accuracy.\n */\npublic static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "TDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ChiSquaredDistribution",
                "/**\n * Default inverse cumulative probability accuracy\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "BetaDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NormalDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "UniformRealDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @deprecated as of 3.2 not used anymore, will be removed in 4.0\n */\n@Deprecated\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "WeibullDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "NakagamiDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ExponentialDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "LogNormalDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "ParetoDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "FDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_MAX_ITERATIONS",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "/**\n * Default maximum number of iterations for cumulative probability calculations.\n * @since 2.1\n */\npublic static final int DEFAULT_MAX_ITERATIONS = 10000000;"
            ],
            [
                "DEFAULT_EPSILON",
                "org.apache.commons.math3.distribution",
                "PoissonDistribution",
                "/**\n * Default convergence criterion.\n * @since 2.1\n */\npublic static final double DEFAULT_EPSILON = 1e-12;"
            ],
            [
                "DEFAULT_INVERSE_ABSOLUTE_ACCURACY",
                "org.apache.commons.math3.distribution",
                "GammaDistribution",
                "/**\n * Default inverse cumulative probability accuracy.\n * @since 2.1\n */\npublic static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;"
            ],
            [
                "DEFAULT_ULPS",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "/**\n * Default amount of error to accept in floating point comparisons (as ulps).\n */\nstatic final int DEFAULT_ULPS = 10;"
            ],
            [
                "DEFAULT_CUT_OFF",
                "org.apache.commons.math3.optim.linear",
                "SimplexSolver",
                "/**\n * Default cut-off value.\n */\nstatic final double DEFAULT_CUT_OFF = 1e-10;"
            ],
            [
                "MINIMUM_PROBLEM_DIMENSION",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Minimum dimension of the problem: {@value}\n */\npublic static final int MINIMUM_PROBLEM_DIMENSION = 2;"
            ],
            [
                "DEFAULT_INITIAL_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #initialTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_INITIAL_RADIUS = 10.0;"
            ],
            [
                "DEFAULT_STOPPING_RADIUS",
                "org.apache.commons.math3.optim.nonlinear.scalar.noderiv",
                "BOBYQAOptimizer",
                "/**\n * Default value for {@link #stoppingTrustRegionRadius}: {@value} .\n */\npublic static final double DEFAULT_STOPPING_RADIUS = 1E-8;"
            ],
            [
                "GAMMA",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * <a href=\"http://en.wikipedia.org/wiki/Euler-Mascheroni_constant\">Euler-Mascheroni constant</a>\n * @since 2.0\n */\npublic static final double GAMMA = 0.577215664901532860606512090082;"
            ],
            [
                "LANCZOS_G",
                "org.apache.commons.math3.special",
                "Gamma",
                "/**\n * The value of the {@code g} constant in the Lanczos approximation, see\n * {@link #lanczos(double)}.\n * @since 3.1\n */\npublic static final double LANCZOS_G = 607.0 / 128.0;"
            ],
            [
                "DEFAULT_NAN_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "/**\n * default NaN strategy\n */\npublic static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.FAILED;"
            ],
            [
                "DEFAULT_TIES_STRATEGY",
                "org.apache.commons.math3.stat.ranking",
                "NaturalRanking",
                "/**\n * default ties strategy\n */\npublic static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;"
            ],
            [
                "MAXIMUM_PARTIAL_SUM_COUNT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Bound on the number of partial sums in {@link #ksSum(double, double, int)}\n */\nprotected static final int MAXIMUM_PARTIAL_SUM_COUNT = 100000;"
            ],
            [
                "KS_SUM_CAUCHY_CRITERION",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Convergence criterion for {@link #ksSum(double, double, int)}\n */\nprotected static final double KS_SUM_CAUCHY_CRITERION = 1E-20;"
            ],
            [
                "PG_SUM_RELATIVE_ERROR",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Convergence criterion for the sums in #pelzGood(double, double, int)}\n */\nprotected static final double PG_SUM_RELATIVE_ERROR = 1.0e-10;"
            ],
            [
                "SMALL_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * No longer used.\n */\n@Deprecated\nprotected static final int SMALL_SAMPLE_PRODUCT = 200;"
            ],
            [
                "LARGE_SAMPLE_PRODUCT",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * When product of sample sizes exceeds this value, 2-sample K-S test uses asymptotic\n * distribution to compute the p-value.\n */\nprotected static final int LARGE_SAMPLE_PRODUCT = 10000;"
            ],
            [
                "MONTE_CARLO_ITERATIONS",
                "org.apache.commons.math3.stat.inference",
                "KolmogorovSmirnovTest",
                "/**\n * Default number of iterations used by {@link #monteCarloP(double, int, int, boolean, int)}.\n *  Deprecated as of version 3.6, as this method is no longer needed.\n */\n@Deprecated\nprotected static final int MONTE_CARLO_ITERATIONS = 1000000;"
            ],
            [
                "INFINITE_WINDOW",
                "org.apache.commons.math3.stat.descriptive",
                "DescriptiveStatistics",
                "/**\n * Represents an infinite window size.  When the {@link #getWindowSize()}\n * returns this value, there is no limit to the number of data values\n * that can be stored in the dataset.\n */\npublic static final int INFINITE_WINDOW = -1;"
            ],
            [
                "UPSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "/**\n * The UPSIDE Direction is used to specify that the observations above the\n * cutoff point will be used to calculate SemiVariance.\n */\npublic static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;"
            ],
            [
                "DOWNSIDE_VARIANCE",
                "org.apache.commons.math3.stat.descriptive.moment",
                "SemiVariance",
                "/**\n * The DOWNSIDE Direction is used to specify that the observations below\n * the cutoff point will be used to calculate SemiVariance\n */\npublic static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "MapUtils",
                "/**\n * Comparator.\n */\nstatic final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "COMPARATOR",
                "org.apache.commons.math3.ml.neuralnet",
                "PairNeuronDouble",
                "/**\n * Comparator.\n */\nstatic final Comparator<PairNeuronDouble> COMPARATOR = new Comparator<PairNeuronDouble>() {\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(PairNeuronDouble o1, PairNeuronDouble o2) {\n        return Double.compare(o1.value, o2.value);\n    }\n};"
            ],
            [
                "RADIX",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The radix, or base of this system.  Set to 10000\n */\npublic static final int RADIX = 10000;"
            ],
            [
                "MIN_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The minimum exponent before underflow is signaled.  Flush to zero\n *  occurs at minExp-DIGITS\n */\npublic static final int MIN_EXP = -32767;"
            ],
            [
                "MAX_EXP",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The maximum exponent before overflow is signaled and results flushed\n *  to infinity\n */\npublic static final int MAX_EXP = 32768;"
            ],
            [
                "ERR_SCALE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * The amount under/overflows are scaled by before going to trap handler\n */\npublic static final int ERR_SCALE = 32760;"
            ],
            [
                "FINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for normal finite numbers.\n */\npublic static final byte FINITE = 0;"
            ],
            [
                "INFINITE",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for Infinity.\n */\npublic static final byte INFINITE = 1;"
            ],
            [
                "SNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for signaling NaN.\n */\npublic static final byte SNAN = 2;"
            ],
            [
                "QNAN",
                "org.apache.commons.math3.dfp",
                "Dfp",
                "/**\n * Indicator value for quiet NaN.\n */\npublic static final byte QNAN = 3;"
            ],
            [
                "FLAG_INVALID",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for invalid operation.\n */\npublic static final int FLAG_INVALID = 1;"
            ],
            [
                "FLAG_DIV_ZERO",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for division by zero.\n */\npublic static final int FLAG_DIV_ZERO = 2;"
            ],
            [
                "FLAG_OVERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for overflow.\n */\npublic static final int FLAG_OVERFLOW = 4;"
            ],
            [
                "FLAG_UNDERFLOW",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for underflow.\n */\npublic static final int FLAG_UNDERFLOW = 8;"
            ],
            [
                "FLAG_INEXACT",
                "org.apache.commons.math3.dfp",
                "DfpField",
                "/**\n * IEEE 854-1987 flag for inexact result.\n */\npublic static final int FLAG_INEXACT = 16;"
            ],
            [
                "DEFAULT_PREFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default prefix: \"{\".\n */\npublic static final String DEFAULT_PREFIX = \"{\";"
            ],
            [
                "DEFAULT_SUFFIX",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default suffix: \"}\".\n */\npublic static final String DEFAULT_SUFFIX = \"}\";"
            ],
            [
                "DEFAULT_SEPARATOR",
                "org.apache.commons.math3.geometry",
                "VectorFormat",
                "/**\n * The default separator: \", \".\n */\npublic static final String DEFAULT_SEPARATOR = \"; \";"
            ],
            [
                "XYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around X, then around Y, then\n * around Z\n */\npublic static final RotationOrder XYZ = new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "XZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around X, then around Z, then\n * around Y\n */\npublic static final RotationOrder XZY = new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "YXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Y, then around X, then\n * around Z\n */\npublic static final RotationOrder YXZ = new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "YZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Y, then around Z, then\n * around X\n */\npublic static final RotationOrder YZX = new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "ZXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Z, then around X, then\n * around Y\n */\npublic static final RotationOrder ZXY = new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "ZYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Cardan angles.\n * this ordered set of rotations is around Z, then around Y, then\n * around X\n */\npublic static final RotationOrder ZYX = new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XYX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around X, then around Y, then\n * around X\n */\npublic static final RotationOrder XYX = new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);"
            ],
            [
                "XZX",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around X, then around Z, then\n * around X\n */\npublic static final RotationOrder XZX = new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);"
            ],
            [
                "YXY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Y, then around X, then\n * around Y\n */\npublic static final RotationOrder YXY = new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);"
            ],
            [
                "YZY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Y, then around Z, then\n * around Y\n */\npublic static final RotationOrder YZY = new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);"
            ],
            [
                "ZXZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Z, then around X, then\n * around Z\n */\npublic static final RotationOrder ZXZ = new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);"
            ],
            [
                "ZYZ",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "RotationOrder",
                "/**\n * Set of Euler angles.\n * this ordered set of rotations is around Z, then around Y, then\n * around Z\n */\npublic static final RotationOrder ZYZ = new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);"
            ],
            [
                "IDENTITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Rotation",
                "/**\n * Identity rotation.\n */\npublic static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Null vector (coordinates: 0, 0, 0).\n */\npublic static final Vector3D ZERO = new Vector3D(0, 0, 0);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * First canonical vector (coordinates: 1, 0, 0).\n */\npublic static final Vector3D PLUS_I = new Vector3D(1, 0, 0);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the first canonical vector (coordinates: -1, 0, 0).\n */\npublic static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Second canonical vector (coordinates: 0, 1, 0).\n */\npublic static final Vector3D PLUS_J = new Vector3D(0, 1, 0);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the second canonical vector (coordinates: 0, -1, 0).\n */\npublic static final Vector3D MINUS_J = new Vector3D(0, -1, 0);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Third canonical vector (coordinates: 0, 0, 1).\n */\npublic static final Vector3D PLUS_K = new Vector3D(0, 0, 1);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * Opposite of the third canonical vector (coordinates: 0, 0, -1).\n */\npublic static final Vector3D MINUS_K = new Vector3D(0, 0, -1);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector3D POSITIVE_INFINITY = new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.threed",
                "Vector3D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector3D NEGATIVE_INFINITY = new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Origin (coordinates: 0).\n */\npublic static final Vector1D ZERO = new Vector1D(0.0);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * Unit (coordinates: 1).\n */\npublic static final Vector1D ONE = new Vector1D(1.0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector1D NaN = new Vector1D(Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector1D POSITIVE_INFINITY = new Vector1D(Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.oned",
                "Vector1D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector1D NEGATIVE_INFINITY = new Vector1D(Double.NEGATIVE_INFINITY);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * Origin (coordinates: 0, 0).\n */\npublic static final Vector2D ZERO = new Vector2D(0, 0);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);"
            ],
            [
                "POSITIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "// CHECKSTYLE: resume ConstantName\n/**\n * A vector with all coordinates set to positive infinity.\n */\npublic static final Vector2D POSITIVE_INFINITY = new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);"
            ],
            [
                "NEGATIVE_INFINITY",
                "org.apache.commons.math3.geometry.euclidean.twod",
                "Vector2D",
                "/**\n * A vector with all coordinates set to negative infinity.\n */\npublic static final Vector2D NEGATIVE_INFINITY = new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.oned",
                "S1Point",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final S1Point NaN = new S1Point(Double.NaN, Vector2D.NaN);"
            ],
            [
                "PLUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +I (coordinates: \\( \\theta = 0, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point PLUS_I = new S2Point(0, 0.5 * FastMath.PI, Vector3D.PLUS_I);"
            ],
            [
                "PLUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +J (coordinates: \\( \\theta = \\pi/2, \\varphi = \\pi/2 \\))).\n */\npublic static final S2Point PLUS_J = new S2Point(0.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.PLUS_J);"
            ],
            [
                "PLUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * +K (coordinates: \\( \\theta = any angle, \\varphi = 0 \\)).\n */\npublic static final S2Point PLUS_K = new S2Point(0, 0, Vector3D.PLUS_K);"
            ],
            [
                "MINUS_I",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -I (coordinates: \\( \\theta = \\pi, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point MINUS_I = new S2Point(FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_I);"
            ],
            [
                "MINUS_J",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -J (coordinates: \\( \\theta = 3\\pi/2, \\varphi = \\pi/2 \\)).\n */\npublic static final S2Point MINUS_J = new S2Point(1.5 * FastMath.PI, 0.5 * FastMath.PI, Vector3D.MINUS_J);"
            ],
            [
                "MINUS_K",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "/**\n * -K (coordinates: \\( \\theta = any angle, \\varphi = \\pi \\)).\n */\npublic static final S2Point MINUS_K = new S2Point(0, FastMath.PI, Vector3D.MINUS_K);"
            ],
            [
                "NaN",
                "org.apache.commons.math3.geometry.spherical.twod",
                "S2Point",
                "// CHECKSTYLE: stop ConstantName\n/**\n * A vector with all coordinates set to NaN.\n */\npublic static final S2Point NaN = new S2Point(Double.NaN, Double.NaN, Vector3D.NaN);"
            ],
            [
                "DIGEST_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Use empirical distribution.\n */\npublic static final int DIGEST_MODE = 0;"
            ],
            [
                "REPLAY_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Replay data from valuesFilePath.\n */\npublic static final int REPLAY_MODE = 1;"
            ],
            [
                "UNIFORM_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Uniform random deviates with mean = &mu;.\n */\npublic static final int UNIFORM_MODE = 2;"
            ],
            [
                "EXPONENTIAL_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Exponential random deviates with mean = &mu;.\n */\npublic static final int EXPONENTIAL_MODE = 3;"
            ],
            [
                "GAUSSIAN_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Gaussian random deviates with mean = &mu;, std dev = &sigma;.\n */\npublic static final int GAUSSIAN_MODE = 4;"
            ],
            [
                "CONSTANT_MODE",
                "org.apache.commons.math3.random",
                "ValueServer",
                "/**\n * Always return mu\n */\npublic static final int CONSTANT_MODE = 5;"
            ],
            [
                "DEFAULT_BIN_COUNT",
                "org.apache.commons.math3.random",
                "EmpiricalDistribution",
                "/**\n * Default bin count\n */\npublic static final int DEFAULT_BIN_COUNT = 1000;"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2 / 1\".\n */\npublic static final Fraction TWO = new Fraction(2, 1);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1\".\n */\npublic static final Fraction ONE = new Fraction(1, 1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"0\".\n */\npublic static final Fraction ZERO = new Fraction(0, 1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"4/5\".\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/5\".\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/2\".\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/4\".\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"1/3\".\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"3/5\".\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"3/4\".\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/5\".\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/4\".\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"2/3\".\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "Fraction",
                "/**\n * A fraction representing \"-1 / 1\".\n */\npublic static final Fraction MINUS_ONE = new Fraction(-1, 1);"
            ],
            [
                "TWO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2 / 1\".\n */\npublic static final BigFraction TWO = new BigFraction(2);"
            ],
            [
                "ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1\".\n */\npublic static final BigFraction ONE = new BigFraction(1);"
            ],
            [
                "ZERO",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"0\".\n */\npublic static final BigFraction ZERO = new BigFraction(0);"
            ],
            [
                "MINUS_ONE",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"-1 / 1\".\n */\npublic static final BigFraction MINUS_ONE = new BigFraction(-1);"
            ],
            [
                "FOUR_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"4/5\".\n */\npublic static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);"
            ],
            [
                "ONE_FIFTH",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/5\".\n */\npublic static final BigFraction ONE_FIFTH = new BigFraction(1, 5);"
            ],
            [
                "ONE_HALF",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/2\".\n */\npublic static final BigFraction ONE_HALF = new BigFraction(1, 2);"
            ],
            [
                "ONE_QUARTER",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/4\".\n */\npublic static final BigFraction ONE_QUARTER = new BigFraction(1, 4);"
            ],
            [
                "ONE_THIRD",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"1/3\".\n */\npublic static final BigFraction ONE_THIRD = new BigFraction(1, 3);"
            ],
            [
                "THREE_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"3/5\".\n */\npublic static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);"
            ],
            [
                "THREE_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"3/4\".\n */\npublic static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);"
            ],
            [
                "TWO_FIFTHS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/5\".\n */\npublic static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);"
            ],
            [
                "TWO_QUARTERS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/4\".\n */\npublic static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);"
            ],
            [
                "TWO_THIRDS",
                "org.apache.commons.math3.fraction",
                "BigFraction",
                "/**\n * A fraction representing \"2/3\".\n */\npublic static final BigFraction TWO_THIRDS = new BigFraction(2, 3);"
            ],
            [
                "INTEGER_ZERO",
                "org.apache.commons.math3.exception",
                "MathIllegalNumberException",
                "/**\n * Helper to avoid boxing warnings. @since 3.3\n */\nprotected static final Integer INTEGER_ZERO = Integer.valueOf(0);"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastSineTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120211L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastFourierTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120210L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastCosineTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120212L;"
            ],
            [
                "serialVersionUID",
                "org.apache.commons.math3.transform",
                "FastHadamardTransformer",
                "/**\n * Serializable version identifier.\n */\nstatic final long serialVersionUID = 20120211L;"
            ]
        ],
        "tokensMethodJavadocValues": [
            [
                "1.0",
                "double"
            ]
        ],
        "tokensMethodArguments": [
            [
                "x",
                "",
                "double"
            ],
            [
                "y",
                "",
                "double"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticNonVoidMethods": [
            [
                "getObservations",
                "org.apache.commons.math3.optimization.fitting",
                "CurveFitter",
                "/**\n * Get the observed points.\n * @return observed points\n * @see #addObservedPoint(double, double)\n * @see #addObservedPoint(double, double, double)\n * @see #addObservedPoint(WeightedObservedPoint)\n */\npublic WeightedObservedPoint[] getObservations() {\n    return observations.toArray(new WeightedObservedPoint[observations.size()]);\n}"
            ],
            [
                "clone",
                "java.lang",
                "Object",
                "protected native Object clone() throws CloneNotSupportedException"
            ],
            [
                "fit",
                "org.apache.commons.math3.optimization.fitting",
                "CurveFitter",
                "/**\n * Fit a curve.\n * This method compute the coefficients of the curve that best\n * fit the sample of observed points previously given through calls\n * to the {@link #addObservedPoint(WeightedObservedPoint)\n * addObservedPoint} method.\n *\n * @param f parametric function to fit.\n * @param initialGuess first guess of the function parameters.\n * @param maxEval Maximum number of function evaluations.\n * @return the fitted parameters.\n * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n * if the number of allowed evaluations is exceeded.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the start point dimension is wrong.\n * @since 3.0\n */\npublic double[] fit(int maxEval, T f, final double[] initialGuess) {\n    // prepare least squares problem\n    double[] target = new double[observations.size()];\n    double[] weights = new double[observations.size()];\n    int i = 0;\n    for (WeightedObservedPoint point : observations) {\n        target[i] = point.getY();\n        weights[i] = point.getWeight();\n        ++i;\n    }\n    // perform the fit\n    final PointVectorValuePair optimum;\n    if (optimizer == null) {\n        // to be removed in 4.0\n        optimum = oldOptimizer.optimize(maxEval, new OldTheoreticalValuesFunction(f), target, weights, initialGuess);\n    } else {\n        optimum = optimizer.optimize(maxEval, new TheoreticalValuesFunction(f), target, weights, initialGuess);\n    }\n    // extract the coefficients\n    return optimum.getPointRef();\n}"
            ],
            [
                "equals",
                "java.lang",
                "Object",
                "public boolean equals(Object arg0)"
            ],
            [
                "fit",
                "org.apache.commons.math3.optimization.fitting",
                "CurveFitter",
                "/**\n * Fit a curve.\n * This method compute the coefficients of the curve that best\n * fit the sample of observed points previously given through calls\n * to the {@link #addObservedPoint(WeightedObservedPoint)\n * addObservedPoint} method.\n *\n * @param f parametric function to fit.\n * @param initialGuess first guess of the function parameters.\n * @return the fitted parameters.\n * @throws org.apache.commons.math3.exception.DimensionMismatchException\n * if the start point dimension is wrong.\n */\npublic double[] fit(T f, final double[] initialGuess) {\n    return fit(Integer.MAX_VALUE, f, initialGuess);\n}"
            ],
            [
                "getClass",
                "java.lang",
                "Object",
                "public final native Class<? extends Object> getClass()"
            ],
            [
                "toString",
                "java.lang",
                "Object",
                "public String toString()"
            ],
            [
                "hashCode",
                "java.lang",
                "Object",
                "public native int hashCode()"
            ]
        ],
        "tokensMethodVariablesNonPrivateNonStaticAttributes": [],
        "tokensOracleVariablesNonPrivateNonStaticNonVoidMethods": [],
        "tokensOracleVariablesNonPrivateNonStaticAttributes": []
    }
]